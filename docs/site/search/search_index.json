{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Swarms Docs Home","text":""},{"location":"#what-is-swarms","title":"What is Swarms?","text":"<p>Swarms is the first and most reliable multi-agent production-grade framework designed to orchestrate intelligent AI agents at scale. Built for enterprise applications, Swarms enables you to create sophisticated multi-agent systems that can handle complex tasks through collaboration, parallel processing, and intelligent task distribution.</p>"},{"location":"#key-capabilities","title":"Key Capabilities","text":"<ul> <li>\ud83c\udfe2 Production-Ready: Enterprise-grade infrastructure with high reliability, comprehensive logging, and robust error handling</li> <li>\ud83e\udd16 Multi-Agent Orchestration: Support for hierarchical swarms, parallel processing, sequential workflows, and dynamic agent rearrangement</li> <li>\ud83d\udd04 Flexible Integration: Multi-model support, custom agent creation, extensive tool library, and multiple memory systems</li> <li>\ud83d\udcc8 Scalable Architecture: Concurrent processing, resource management, load balancing, and horizontal scaling capabilities</li> <li>\ud83d\udee0\ufe0f Developer-Friendly: Simple API, extensive documentation, active community, and CLI tools for rapid development</li> <li>\ud83d\udd10 Enterprise Security: Built-in error handling, rate limiting, monitoring integration, and audit logging</li> </ul>"},{"location":"#why-choose-swarms","title":"Why Choose Swarms?","text":"<p>Swarms stands out as the most reliable multi-agent framework because it was built from the ground up for production environments. Unlike other frameworks that focus on research or simple demos, Swarms provides the infrastructure, tooling, and best practices needed to deploy multi-agent systems in real-world applications.</p> <p>Whether you're building financial analysis systems, healthcare diagnostics, manufacturing optimization, or any other complex multi-agent application, Swarms provides the foundation you need to succeed.</p>"},{"location":"#swarms-installation","title":"Swarms Installation","text":"<pre><code>pip3 install swarms\n</code></pre>"},{"location":"#update-swarms","title":"Update Swarms","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"#get-started-building-production-grade-multi-agent-applications","title":"Get Started Building Production-Grade Multi-Agent Applications","text":""},{"location":"#onboarding","title":"Onboarding","text":"Section Links Installation Installation Quickstart Get Started Environment Setup Environment Configuration Environment Variables Environment Variables Swarms CLI CLI Documentation Agent Internal Mechanisms Agent Architecture Agent API Agent API Managing Prompts in Production Prompts Management Integrating External Agents External Agents Integration Creating Agents from YAML YAML Agent Creation Why You Need Swarms Why MultiAgent Collaboration Swarm Architectures Analysis Swarm Architectures Choosing the Right Swarm How to Choose Swarms Full API Reference API Reference AgentRearrange Docs AgentRearrange"},{"location":"#ecosystem","title":"Ecosystem","text":"<p>Here you'll find references about the Swarms framework, marketplace, community, and more to enable you to build your multi-agent applications.</p> Section Links Swarms Python Framework Docs Framework Docs Swarms Cloud API Cloud API Swarms Marketplace API Marketplace API Swarms Memory Systems Memory Systems Available Models Models Overview Swarms Tools Tools Overview Example Applications Examples Swarms Corp Github Swarms Corp GitHub"},{"location":"#join-the-swarms-community","title":"Join the Swarms Community","text":"Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"#get-support","title":"Get Support","text":"<p>Want to get in touch with the Swarms team? Open an issue on GitHub or reach out to us via email. We're here to help!</p>"},{"location":"docs_structure/","title":"Class/function","text":"<p>Brief description \u2193</p> <p>\u2193  </p>"},{"location":"docs_structure/#overview","title":"Overview","text":"<p>\u2193</p>"},{"location":"docs_structure/#architecture-mermaid-diagram","title":"Architecture (Mermaid diagram)","text":"<p>\u2193</p>"},{"location":"docs_structure/#class-reference-constructor-methods","title":"Class Reference (Constructor + Methods)","text":"<p>\u2193</p>"},{"location":"docs_structure/#examples","title":"Examples","text":"<p>\u2193</p>"},{"location":"docs_structure/#conclusion","title":"Conclusion","text":"<p>Benefits of class/structure, and more</p>"},{"location":"quickstart/","title":"Welcome to Swarms Docs Home","text":""},{"location":"quickstart/#what-is-swarms","title":"What is Swarms?","text":"<p>Swarms is the first and most reliable multi-agent production-grade framework designed to orchestrate intelligent AI agents at scale. Built for enterprise applications, Swarms enables you to create sophisticated multi-agent systems that can handle complex tasks through collaboration, parallel processing, and intelligent task distribution.</p>"},{"location":"quickstart/#key-capabilities","title":"Key Capabilities","text":"<ul> <li>\ud83c\udfe2 Production-Ready: Enterprise-grade infrastructure with high reliability, comprehensive logging, and robust error handling</li> <li>\ud83e\udd16 Multi-Agent Orchestration: Support for hierarchical swarms, parallel processing, sequential workflows, and dynamic agent rearrangement</li> <li>\ud83d\udd04 Flexible Integration: Multi-model support, custom agent creation, extensive tool library, and multiple memory systems</li> <li>\ud83d\udcc8 Scalable Architecture: Concurrent processing, resource management, load balancing, and horizontal scaling capabilities</li> <li>\ud83d\udee0\ufe0f Developer-Friendly: Simple API, extensive documentation, active community, and CLI tools for rapid development</li> <li>\ud83d\udd10 Enterprise Security: Built-in error handling, rate limiting, monitoring integration, and audit logging</li> </ul>"},{"location":"quickstart/#why-choose-swarms","title":"Why Choose Swarms?","text":"<p>Swarms stands out as the most reliable multi-agent framework because it was built from the ground up for production environments. Unlike other frameworks that focus on research or simple demos, Swarms provides the infrastructure, tooling, and best practices needed to deploy multi-agent systems in real-world applications.</p> <p>Whether you're building financial analysis systems, healthcare diagnostics, manufacturing optimization, or any other complex multi-agent application, Swarms provides the foundation you need to succeed.</p> <p>Get started learning swarms with the following examples and more.  </p>"},{"location":"quickstart/#install","title":"Install \ud83d\udcbb","text":"<pre><code>$ pip3 install -U swarms\n</code></pre>"},{"location":"quickstart/#using-uv-recommended","title":"Using uv (Recommended)","text":"<p>uv is a fast Python package installer and resolver, written in Rust.</p> <pre><code># Install uv\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install swarms using uv\n$ uv pip install swarms\n</code></pre>"},{"location":"quickstart/#using-poetry","title":"Using poetry","text":"<pre><code># Install poetry if you haven't already\n$ curl -sSL https://install.python-poetry.org | python3 -\n\n# Add swarms to your project\n$ poetry add swarms\n</code></pre>"},{"location":"quickstart/#from-source","title":"From source","text":"<pre><code># Clone the repository\n$ git clone https://github.com/kyegomez/swarms.git\n$ cd swarms\n\n# Install with pip\n$ pip install -e .\n</code></pre>"},{"location":"quickstart/#environment-configuration","title":"Environment Configuration","text":"<p>Learn more about the environment configuration here</p> <pre><code>OPENAI_API_KEY=\"\"\nWORKSPACE_DIR=\"agent_workspace\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\n</code></pre>"},{"location":"quickstart/#your-first-agent","title":"\ud83e\udd16 Your First Agent","text":"<p>An Agent is the fundamental building block of a swarm\u2014an autonomous entity powered by an LLM + Tools + Memory. Learn more Here</p> <pre><code>from swarms import Agent\n\n# Initialize a new agent\nagent = Agent(\n    model_name=\"gpt-4o-mini\", # Specify the LLM\n    max_loops=1,              # Set the number of interactions\n    interactive=True,         # Enable interactive mode for real-time feedback\n)\n\n# Run the agent with a task\nagent.run(\"What are the key benefits of using a multi-agent system?\")\n</code></pre>"},{"location":"quickstart/#your-first-swarm-multi-agent-collaboration","title":"\ud83e\udd1d Your First Swarm: Multi-Agent Collaboration","text":"<p>A Swarm consists of multiple agents working together. This simple example creates a two-agent workflow for researching and writing a blog post. Learn More About SequentialWorkflow</p> <pre><code>from swarms import Agent, SequentialWorkflow\n\n# Agent 1: The Researcher\nresearcher = Agent(\n    agent_name=\"Researcher\",\n    system_prompt=\"Your job is to research the provided topic and provide a detailed summary.\",\n    model_name=\"gpt-4o-mini\",\n)\n\n# Agent 2: The Writer\nwriter = Agent(\n    agent_name=\"Writer\",\n    system_prompt=\"Your job is to take the research summary and write a beautiful, engaging blog post about it.\",\n    model_name=\"gpt-4o-mini\",\n)\n\n# Create a sequential workflow where the researcher's output feeds into the writer's input\nworkflow = SequentialWorkflow(agents=[researcher, writer])\n\n# Run the workflow on a task\nfinal_post = workflow.run(\"The history and future of artificial intelligence\")\nprint(final_post)\n</code></pre>"},{"location":"quickstart/#multi-agent-architectures-for-production-deployments","title":"\ud83c\udfd7\ufe0f Multi-Agent Architectures For Production Deployments","text":"<p><code>swarms</code> provides a variety of powerful, pre-built multi-agent architectures enabling you to orchestrate agents in various ways. Choose the right structure for your specific problem to build efficient and reliable production systems.</p> Architecture Description Best For SequentialWorkflow Agents execute tasks in a linear chain; one agent's output is the next one's input. Step-by-step processes like data transformation pipelines, report generation. ConcurrentWorkflow Agents run tasks simultaneously for maximum efficiency. High-throughput tasks like batch processing, parallel data analysis. AgentRearrange Dynamically maps complex relationships (e.g., <code>a -&gt; b, c</code>) between agents. Flexible and adaptive workflows, task distribution, dynamic routing. GraphWorkflow Orchestrates agents as nodes in a Directed Acyclic Graph (DAG). Complex projects with intricate dependencies, like software builds. MixtureOfAgents (MoA) Utilizes multiple expert agents in parallel and synthesizes their outputs. Complex problem-solving, achieving state-of-the-art performance through collaboration. GroupChat Agents collaborate and make decisions through a conversational interface. Real-time collaborative decision-making, negotiations, brainstorming. ForestSwarm Dynamically selects the most suitable agent or tree of agents for a given task. Task routing, optimizing for expertise, complex decision-making trees. SpreadSheetSwarm Manages thousands of agents concurrently, tracking tasks and outputs in a structured format. Massive-scale parallel operations, large-scale data generation and analysis. SwarmRouter Universal orchestrator that provides a single interface to run any type of swarm with dynamic selection. Simplifying complex workflows, switching between swarm strategies, unified multi-agent management."},{"location":"quickstart/#sequentialworkflow","title":"SequentialWorkflow","text":"<p>A <code>SequentialWorkflow</code> executes tasks in a strict order, forming a pipeline where each agent builds upon the work of the previous one. <code>SequentialWorkflow</code> is Ideal for processes that have clear, ordered steps. This ensures that tasks with dependencies are handled correctly.</p> <pre><code>from swarms import Agent, SequentialWorkflow\n\n# Initialize agents for a 3-step process\n# 1. Generate an idea\nidea_generator = Agent(agent_name=\"IdeaGenerator\", system_prompt=\"Generate a unique startup idea.\", model_name=\"gpt-4o-mini\")\n# 2. Validate the idea\nvalidator = Agent(agent_name=\"Validator\", system_prompt=\"Take this startup idea and analyze its market viability.\", model_name=\"gpt-4o-mini\")\n# 3. Create a pitch\npitch_creator = Agent(agent_name=\"PitchCreator\", system_prompt=\"Write a 3-sentence elevator pitch for this validated startup idea.\", model_name=\"gpt-4o-mini\")\n\n# Create the sequential workflow\nworkflow = SequentialWorkflow(agents=[idea_generator, validator, pitch_creator])\n\n# Run the workflow\nelevator_pitch = workflow.run()\nprint(elevator_pitch)\n</code></pre>"},{"location":"quickstart/#concurrentworkflow-with-spreadsheetswarm","title":"ConcurrentWorkflow (with <code>SpreadSheetSwarm</code>)","text":"<p>A concurrent workflow runs multiple agents simultaneously. <code>SpreadSheetSwarm</code> is a powerful implementation that can manage thousands of concurrent agents and log their outputs to a CSV file. Use this architecture for high-throughput tasks that can be performed in parallel, drastically reducing execution time.</p> <pre><code>from swarms import Agent, SpreadSheetSwarm\n\n# Define a list of tasks (e.g., social media posts to generate)\nplatforms = [\"Twitter\", \"LinkedIn\", \"Instagram\"]\n\n# Create an agent for each task\nagents = [\n    Agent(\n        agent_name=f\"{platform}-Marketer\",\n        system_prompt=f\"Generate a real estate marketing post for {platform}.\",\n        model_name=\"gpt-4o-mini\",\n    )\n    for platform in platforms\n]\n\n# Initialize the swarm to run these agents concurrently\nswarm = SpreadSheetSwarm(\n    agents=agents,\n    autosave_on=True,\n    save_file_path=\"marketing_posts.csv\",\n)\n\n# Run the swarm with a single, shared task description\nproperty_description = \"A beautiful 3-bedroom house in sunny California.\"\nswarm.run(task=f\"Generate a post about: {property_description}\")\n# Check marketing_posts.csv for the results!\n</code></pre>"},{"location":"quickstart/#agentrearrange","title":"AgentRearrange","text":"<p>Inspired by <code>einsum</code>, <code>AgentRearrange</code> lets you define complex, non-linear relationships between agents using a simple string-based syntax. Learn more. This architecture is Perfect for orchestrating dynamic workflows where agents might work in parallel, sequence, or a combination of both.</p> <pre><code>from swarms import Agent, AgentRearrange\n\n# Define agents\nresearcher = Agent(agent_name=\"researcher\", model_name=\"gpt-4o-mini\")\nwriter = Agent(agent_name=\"writer\", model_name=\"gpt-4o-mini\")\neditor = Agent(agent_name=\"editor\", model_name=\"gpt-4o-mini\")\n\n# Define a flow: researcher sends work to both writer and editor simultaneously\n# This is a one-to-many relationship\nflow = \"researcher -&gt; writer, editor\"\n\n# Create the rearrangement system\nrearrange_system = AgentRearrange(\n    agents=[researcher, writer, editor],\n    flow=flow,\n)\n\n# Run the system\n# The researcher will generate content, and then both the writer and editor\n# will process that content in parallel.\noutputs = rearrange_system.run(\"Analyze the impact of AI on modern cinema.\")\nprint(outputs)\n</code></pre> <p>&lt;!-- </p>"},{"location":"quickstart/#graphworkflow","title":"GraphWorkflow","text":"<p><code>GraphWorkflow</code> orchestrates tasks using a Directed Acyclic Graph (DAG), allowing you to manage complex dependencies where some tasks must wait for others to complete.</p> <p>Description: Essential for building sophisticated pipelines, like in software development or complex project management, where task order and dependencies are critical.</p> <pre><code>from swarms import Agent, GraphWorkflow, Node, Edge, NodeType\n\n# Define agents and a simple python function as nodes\ncode_generator = Agent(agent_name=\"CodeGenerator\", system_prompt=\"Write Python code for the given task.\", model_name=\"gpt-4o-mini\")\ncode_tester = Agent(agent_name=\"CodeTester\", system_prompt=\"Test the given Python code and find bugs.\", model_name=\"gpt-4o-mini\")\n\n# Create nodes for the graph\nnode1 = Node(id=\"generator\", agent=code_generator)\nnode2 = Node(id=\"tester\", agent=code_tester)\n\n# Create the graph and define the dependency\ngraph = GraphWorkflow()\ngraph.add_nodes([node1, node2])\ngraph.add_edge(Edge(source=\"generator\", target=\"tester\")) # Tester runs after generator\n\n# Set entry and end points\ngraph.set_entry_points([\"generator\"])\ngraph.set_end_points([\"tester\"])\n\n# Run the graph workflow\nresults = graph.run(\"Create a function that calculates the factorial of a number.\")\nprint(results)\n``` --&gt;\n\n----\n\n### SwarmRouter: The Universal Swarm Orchestrator\n\nThe `SwarmRouter` simplifies building complex workflows by providing a single interface to run any type of swarm. Instead of importing and managing different swarm classes, you can dynamically select the one you need just by changing the `swarm_type` parameter. [Read the full documentation](https://docs.swarms.world/en/latest/swarms/structs/swarm_router/)\n\nThis makes your code cleaner and more flexible, allowing you to switch between different multi-agent strategies with ease. Here's a complete example that shows how to define agents and then use `SwarmRouter` to execute the same task using different collaborative strategies.\n\n```python\nfrom swarms import Agent\nfrom swarms.structs.swarm_router import SwarmRouter, SwarmType\n\n# Define a few generic agents\nwriter = Agent(agent_name=\"Writer\", system_prompt=\"You are a creative writer.\", model_name=\"gpt-4o-mini\")\neditor = Agent(agent_name=\"Editor\", system_prompt=\"You are an expert editor for stories.\", model_name=\"gpt-4o-mini\")\nreviewer = Agent(agent_name=\"Reviewer\", system_prompt=\"You are a final reviewer who gives a score.\", model_name=\"gpt-4o-mini\")\n\n# The agents and task will be the same for all examples\nagents = [writer, editor, reviewer]\ntask = \"Write a short story about a robot who discovers music.\"\n\n# --- Example 1: SequentialWorkflow ---\n# Agents run one after another in a chain: Writer -&gt; Editor -&gt; Reviewer.\nprint(\"Running a Sequential Workflow...\")\nsequential_router = SwarmRouter(swarm_type=SwarmType.SequentialWorkflow, agents=agents)\nsequential_output = sequential_router.run(task)\nprint(f\"Final Sequential Output:\\n{sequential_output}\\n\")\n\n# --- Example 2: ConcurrentWorkflow ---\n# All agents receive the same initial task and run at the same time.\nprint(\"Running a Concurrent Workflow...\")\nconcurrent_router = SwarmRouter(swarm_type=SwarmType.ConcurrentWorkflow, agents=agents)\nconcurrent_outputs = concurrent_router.run(task)\n# This returns a dictionary of each agent's output\nfor agent_name, output in concurrent_outputs.items():\n    print(f\"Output from {agent_name}:\\n{output}\\n\")\n\n# --- Example 3: MixtureOfAgents ---\n# All agents run in parallel, and a special 'aggregator' agent synthesizes their outputs.\nprint(\"Running a Mixture of Agents Workflow...\")\naggregator = Agent(\n    agent_name=\"Aggregator\",\n    system_prompt=\"Combine the story, edits, and review into a final document.\",\n    model_name=\"gpt-4o-mini\"\n)\nmoa_router = SwarmRouter(\n    swarm_type=SwarmType.MixtureOfAgents,\n    agents=agents,\n    aggregator_agent=aggregator, # MoA requires an aggregator\n)\naggregated_output = moa_router.run(task)\nprint(f\"Final Aggregated Output:\\n{aggregated_output}\\n\")\n</code></pre> <p>The <code>SwarmRouter</code> is a powerful tool for simplifying multi-agent orchestration. It provides a consistent and flexible way to deploy different collaborative strategies, allowing you to build more sophisticated applications with less code.</p>"},{"location":"quickstart/#mixtureofagents-moa","title":"MixtureOfAgents (MoA)","text":"<p>The <code>MixtureOfAgents</code> architecture processes tasks by feeding them to multiple \"expert\" agents in parallel. Their diverse outputs are then synthesized by an aggregator agent to produce a final, high-quality result. Learn more here</p> <pre><code>from swarms import Agent, MixtureOfAgents\n\n# Define expert agents\nfinancial_analyst = Agent(agent_name=\"FinancialAnalyst\", system_prompt=\"Analyze financial data.\", model_name=\"gpt-4o-mini\")\nmarket_analyst = Agent(agent_name=\"MarketAnalyst\", system_prompt=\"Analyze market trends.\", model_name=\"gpt-4o-mini\")\nrisk_analyst = Agent(agent_name=\"RiskAnalyst\", system_prompt=\"Analyze investment risks.\", model_name=\"gpt-4o-mini\")\n\n# Define the aggregator agent\naggregator = Agent(\n    agent_name=\"InvestmentAdvisor\",\n    system_prompt=\"Synthesize the financial, market, and risk analyses to provide a final investment recommendation.\",\n    model_name=\"gpt-4o-mini\"\n)\n\n# Create the MoA swarm\nmoa_swarm = MixtureOfAgents(\n    agents=[financial_analyst, market_analyst, risk_analyst],\n    aggregator_agent=aggregator,\n)\n\n# Run the swarm\nrecommendation = moa_swarm.run(\"Should we invest in NVIDIA stock right now?\")\nprint(recommendation)\n</code></pre>"},{"location":"quickstart/#groupchat","title":"GroupChat","text":"<p><code>GroupChat</code> creates a conversational environment where multiple agents can interact, discuss, and collaboratively solve a problem. You can define the speaking order or let it be determined dynamically. This architecture is ideal for tasks that benefit from debate and multi-perspective reasoning, such as contract negotiation, brainstorming, or complex decision-making.</p> <pre><code>from swarms import Agent, GroupChat\n\n# Define agents for a debate\ntech_optimist = Agent(agent_name=\"TechOptimist\", system_prompt=\"Argue for the benefits of AI in society.\", model_name=\"gpt-4o-mini\")\ntech_critic = Agent(agent_name=\"TechCritic\", system_prompt=\"Argue against the unchecked advancement of AI.\", model_name=\"gpt-4o-mini\")\n\n# Create the group chat\nchat = GroupChat(\n    agents=[tech_optimist, tech_critic],\n    max_loops=4, # Limit the number of turns in the conversation\n)\n\n# Run the chat with an initial topic\nconversation_history = chat.run(\n    \"Let's discuss the societal impact of artificial intelligence.\"\n)\n\n# Print the full conversation\nfor message in conversation_history:\n    print(f\"[{message['agent_name']}]: {message['content']}\")\n</code></pre>"},{"location":"applications/azure_openai/","title":"Deploying Azure OpenAI in Production: A Comprehensive Guide","text":"<p>In today's fast-paced digital landscape, leveraging cutting-edge technologies has become essential for businesses to stay competitive and provide exceptional services to their customers. One such technology that has gained significant traction is Azure OpenAI, a powerful platform that allows developers to integrate advanced natural language processing (NLP) capabilities into their applications. Whether you're building a chatbot, a content generation system, or any other AI-powered solution, Azure OpenAI offers a robust and scalable solution for production-grade deployment.</p> <p>In this comprehensive guide, we'll walk through the process of setting up and deploying Azure OpenAI in a production environment. We'll dive deep into the code, provide clear explanations, and share best practices to ensure a smooth and successful implementation.</p>"},{"location":"applications/azure_openai/#prerequisites","title":"Prerequisites:","text":"<p>Before we begin, it's essential to have the following prerequisites in place:</p> <ol> <li>Python: You'll need to have Python installed on your system. This guide assumes you're using Python 3.6 or later.</li> <li>Azure Subscription: You'll need an active Azure subscription to access Azure OpenAI services.</li> <li>Azure OpenAI Resource: Create an Azure OpenAI resource in your Azure subscription.</li> <li>Python Packages: Install the required Python packages, including <code>python-dotenv</code> and <code>swarms</code>.</li> </ol>"},{"location":"applications/azure_openai/#setting-up-the-environment","title":"Setting up the Environment:","text":"<p>To kick things off, we'll set up our development environment and install the necessary dependencies.</p> <ol> <li>Create a Virtual Environment: It's a best practice to create a virtual environment to isolate your project dependencies from the rest of your system. You can create a virtual environment using <code>venv</code> or any other virtual environment management tool of your choice.</li> </ol> <pre><code>python -m venv myenv\n</code></pre> <ol> <li>Activate the Virtual Environment: Activate the virtual environment to ensure that any packages you install are isolated within the environment.</li> </ol> <pre><code>source myenv/bin/activate  # On Windows, use `myenv\\Scripts\\activate`\n</code></pre> <ol> <li>Install Required Packages: Install the <code>python-dotenv</code> and <code>swarms</code> packages using pip.</li> </ol> <pre><code>pip install python-dotenv swarms\n</code></pre> <ol> <li>Create a <code>.env</code> File: In the root directory of your project, create a new file called <code>.env</code>. This file will store your Azure OpenAI credentials and configuration settings.</li> </ol> <pre><code>AZURE_OPENAI_ENDPOINT=&lt;your_azure_openai_endpoint&gt;\nAZURE_OPENAI_DEPLOYMENT=&lt;your_azure_openai_deployment_name&gt;\nOPENAI_API_VERSION=&lt;your_openai_api_version&gt;\nAZURE_OPENAI_API_KEY=&lt;your_azure_openai_api_key&gt;\nAZURE_OPENAI_AD_TOKEN=&lt;your_azure_openai_ad_token&gt;\n</code></pre> <p>Replace the placeholders with your actual Azure OpenAI credentials and configuration settings.</p>"},{"location":"applications/azure_openai/#connecting-to-azure-openai","title":"Connecting to Azure OpenAI:","text":"<p>Now that we've set up our environment, let's dive into the code that connects to Azure OpenAI and interacts with the language model.</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import AzureOpenAI\n\n# Load the environment variables\nload_dotenv()\n\n# Create an instance of the AzureOpenAI class\nmodel = AzureOpenAI(\n    azure_endpoint=os.getenv(\"AZURE_OPENAI_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_OPENAI_DEPLOYMENT\"),\n    openai_api_version=os.getenv(\"OPENAI_API_VERSION\"),\n    openai_api_key=os.getenv(\"AZURE_OPENAI_API_KEY\"),\n    azure_ad_token=os.getenv(\"AZURE_OPENAI_AD_TOKEN\")\n)\n</code></pre>"},{"location":"applications/azure_openai/#lets-break-down-this-code","title":"Let's break down this code:","text":"<ol> <li> <p>Import Statements: We import the necessary modules, including <code>os</code> for interacting with the operating system, <code>load_dotenv</code> from <code>python-dotenv</code> to load environment variables, and <code>AzureOpenAI</code> from <code>swarms</code> to interact with the Azure OpenAI service.</p> </li> <li> <p>Load Environment Variables: We use <code>load_dotenv()</code> to load the environment variables stored in the <code>.env</code> file we created earlier.</p> </li> <li> <p>Create AzureOpenAI Instance: We create an instance of the <code>AzureOpenAI</code> class by passing in the required configuration parameters:</p> </li> <li><code>azure_endpoint</code>: The endpoint URL for your Azure OpenAI resource.</li> <li><code>deployment_name</code>: The name of the deployment you want to use.</li> <li><code>openai_api_version</code>: The version of the OpenAI API you want to use.</li> <li><code>openai_api_key</code>: Your Azure OpenAI API key, which authenticates your requests.</li> <li><code>azure_ad_token</code>: An optional Azure Active Directory (AAD) token for additional security.</li> </ol> <p>Querying the Language Model: With our connection to Azure OpenAI established, we can now query the language model and receive responses.</p> <pre><code># Define the prompt\nprompt = \"Analyze this load document and assess it for any risks and create a table in markdwon format.\"\n\n# Generate a response\nresponse = model(prompt)\nprint(response)\n</code></pre>"},{"location":"applications/azure_openai/#heres-whats-happening","title":"Here's what's happening:","text":"<ol> <li> <p>Define the Prompt: We define a prompt, which is the input text or question we want to feed into the language model.</p> </li> <li> <p>Generate a Response: We call the <code>model</code> instance with the <code>prompt</code> as an argument. This triggers the Azure OpenAI service to process the prompt and generate a response.</p> </li> <li> <p>Print the Response: Finally, we print the response received from the language model.</p> </li> </ol> <p>Running the Code: To run the code, save it in a Python file (e.g., <code>main.py</code>) and execute it from the command line:</p> <pre><code>python main.py\n</code></pre>"},{"location":"applications/azure_openai/#best-practices-for-production-deployment","title":"Best Practices for Production Deployment:","text":"<p>While the provided code serves as a basic example, there are several best practices to consider when deploying Azure OpenAI in a production environment:</p> <ol> <li> <p>Secure Credentials Management: Instead of storing sensitive credentials like API keys in your codebase, consider using secure storage solutions like Azure Key Vault or environment variables managed by your cloud provider.</p> </li> <li> <p>Error Handling and Retries: Implement robust error handling and retry mechanisms to handle potential failures or rate-limiting scenarios.</p> </li> <li> <p>Logging and Monitoring: Implement comprehensive logging and monitoring strategies to track application performance, identify issues, and gather insights for optimization.</p> </li> <li> <p>Scalability and Load Testing: Conduct load testing to ensure your application can handle anticipated traffic volumes and scale appropriately based on demand.</p> </li> <li> <p>Caching and Optimization: Explore caching strategies and performance optimizations to improve response times and reduce the load on the Azure OpenAI service.</p> </li> <li> <p>Integration with Other Services: Depending on your use case, you may need to integrate Azure OpenAI with other Azure services or third-party tools for tasks like data processing, storage, or analysis.</p> </li> <li> <p>Compliance and Security: Ensure your application adheres to relevant compliance standards and security best practices, especially when handling sensitive data.</p> </li> </ol>"},{"location":"applications/azure_openai/#conclusion","title":"Conclusion:","text":"<p>Azure OpenAI is a powerful platform that enables developers to integrate advanced natural language processing capabilities into their applications. By following the steps outlined in this guide, you can set up a production-ready environment for deploying Azure OpenAI and start leveraging its capabilities in your projects.</p> <p>Remember, this guide serves as a starting point, and there are numerous additional features and capabilities within Azure OpenAI that you can explore to enhance your applications further. As with any production deployment, it's crucial to follow best practices, conduct thorough testing, and implement robust monitoring and security measures.</p> <p>With the right approach and careful planning, you can successfully deploy Azure OpenAI in a production environment and unlock the power of cutting-edge language models to drive innovation and provide exceptional experiences for your users.</p>"},{"location":"applications/blog/","title":"The Future of Manufacturing: Leveraging Autonomous LLM Agents for Cost Reduction and Revenue Growth","text":""},{"location":"applications/blog/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Understanding Autonomous LLM Agents</li> <li>RAG Embedding Databases: The Knowledge Foundation</li> <li>Function Calling and External Tools: Enhancing Capabilities</li> <li>Cost Reduction Strategies    5.1. Optimizing Supply Chain Management    5.2. Enhancing Quality Control    5.3. Streamlining Maintenance and Repairs    5.4. Improving Energy Efficiency</li> <li>Revenue Growth Opportunities    6.1. Product Innovation and Development    6.2. Personalized Customer Experiences    6.3. Market Analysis and Trend Prediction    6.4. Optimizing Pricing Strategies</li> <li>Implementation Strategies</li> <li>Overcoming Challenges and Risks</li> <li>Case Studies</li> <li>Future Outlook</li> <li>Conclusion</li> </ol>"},{"location":"applications/blog/#1-introduction","title":"1. Introduction","text":"<p>In today's rapidly evolving manufacturing landscape, executives and CEOs face unprecedented challenges and opportunities. The key to maintaining a competitive edge lies in embracing cutting-edge technologies that can revolutionize operations, reduce costs, and drive revenue growth. One such transformative technology is the integration of autonomous Large Language Model (LLM) agents equipped with Retrieval-Augmented Generation (RAG) embedding databases, function calling capabilities, and access to external tools.</p> <p>This comprehensive blog post aims to explore how these advanced AI systems can be leveraged to address the most pressing issues in manufacturing enterprises. We will delve into the intricacies of these technologies, provide concrete examples of their applications, and offer insights into implementation strategies. By the end of this article, you will have a clear understanding of how autonomous LLM agents can become a cornerstone of your manufacturing business's digital transformation journey.</p>"},{"location":"applications/blog/#2-understanding-autonomous-llm-agents","title":"2. Understanding Autonomous LLM Agents","text":"<p>Autonomous LLM agents represent the cutting edge of artificial intelligence in the manufacturing sector. These sophisticated systems are built upon large language models, which are neural networks trained on vast amounts of text data. What sets them apart is their ability to operate autonomously, making decisions and taking actions with minimal human intervention.</p> <p>Key features of autonomous LLM agents include:</p> <ol> <li> <p>Natural Language Processing (NLP): They can understand and generate human-like text, enabling seamless communication with employees across all levels of the organization.</p> </li> <li> <p>Contextual Understanding: These agents can grasp complex scenarios and nuanced information, making them ideal for handling intricate manufacturing processes.</p> </li> <li> <p>Adaptive Learning: Through continuous interaction and feedback, they can improve their performance over time, becoming more efficient and accurate.</p> </li> <li> <p>Multi-modal Input Processing: Advanced agents can process not only text but also images, audio, and sensor data, providing a holistic view of manufacturing operations.</p> </li> <li> <p>Task Automation: They can automate a wide range of tasks, from data analysis to decision-making, freeing up human resources for more strategic activities.</p> </li> </ol> <p>The integration of autonomous LLM agents in manufacturing environments opens up new possibilities for optimization, innovation, and growth. As we explore their applications throughout this blog, it's crucial to understand that these agents are not meant to replace human workers but to augment their capabilities and drive overall productivity.</p>"},{"location":"applications/blog/#3-rag-embedding-databases-the-knowledge-foundation","title":"3. RAG Embedding Databases: The Knowledge Foundation","text":"<p>At the heart of effective autonomous LLM agents lies the Retrieval-Augmented Generation (RAG) embedding database. This technology serves as the knowledge foundation, enabling agents to access and utilize vast amounts of relevant information quickly and accurately.</p> <p>RAG embedding databases work by:</p> <ol> <li> <p>Vectorizing Information: Converting textual data into high-dimensional vectors that capture semantic meaning.</p> </li> <li> <p>Efficient Storage: Organizing these vectors in a way that allows for rapid retrieval of relevant information.</p> </li> <li> <p>Contextual Retrieval: Enabling the agent to pull relevant information based on the current context or query.</p> </li> <li> <p>Dynamic Updates: Allowing for continuous updates to the knowledge base, ensuring the agent always has access to the most current information.</p> </li> </ol> <p>In the manufacturing context, RAG embedding databases can store a wealth of information, including:</p> <ul> <li>Technical specifications of machinery and products</li> <li>Historical production data and performance metrics</li> <li>Quality control guidelines and standards</li> <li>Supplier information and supply chain data</li> <li>Market trends and customer feedback</li> </ul> <p>By leveraging RAG embedding databases, autonomous LLM agents can make informed decisions based on a comprehensive understanding of the manufacturing ecosystem. This leads to more accurate predictions, better problem-solving capabilities, and the ability to generate innovative solutions.</p> <p>For example, when faced with a production bottleneck, an agent can quickly retrieve relevant historical data, equipment specifications, and best practices to propose an optimal solution. This rapid access to contextual information significantly reduces decision-making time and improves the quality of outcomes.</p>"},{"location":"applications/blog/#4-function-calling-and-external-tools-enhancing-capabilities","title":"4. Function Calling and External Tools: Enhancing Capabilities","text":"<p>The true power of autonomous LLM agents in manufacturing environments is realized through their ability to interact with external systems and tools. This is achieved through function calling and integration with specialized external tools.</p> <p>Function calling allows the agent to:</p> <ol> <li> <p>Execute Specific Tasks: Trigger predefined functions to perform complex operations or calculations.</p> </li> <li> <p>Interact with Databases: Query and update various databases within the manufacturing ecosystem.</p> </li> <li> <p>Control Equipment: Send commands to machinery or robotic systems on the production floor.</p> </li> <li> <p>Generate Reports: Automatically compile and format data into meaningful reports for different stakeholders.</p> </li> </ol> <p>External tools that can be integrated include:</p> <ul> <li>Predictive Maintenance Software: To schedule and optimize equipment maintenance.</li> <li>Supply Chain Management Systems: For real-time tracking and optimization of inventory and logistics.</li> <li>Quality Control Systems: To monitor and analyze product quality metrics.</li> <li>Energy Management Tools: For monitoring and optimizing energy consumption across the facility.</li> <li>Customer Relationship Management (CRM) Software: To analyze customer data and improve service.</li> </ul> <p>By combining the cognitive abilities of LLM agents with the specialized functionalities of external tools, manufacturing enterprises can create a powerful ecosystem that drives efficiency and innovation.</p> <p>For instance, an autonomous agent could:</p> <ol> <li>Detect an anomaly in production quality through data analysis.</li> <li>Use function calling to query the maintenance database for equipment history.</li> <li>Leverage an external predictive maintenance tool to assess the risk of equipment failure.</li> <li>Automatically schedule maintenance and adjust production schedules to minimize downtime.</li> <li>Generate a comprehensive report for management, detailing the issue, actions taken, and impact on production.</li> </ol> <p>This level of integration and automation can lead to significant improvements in operational efficiency, cost reduction, and overall productivity.</p>"},{"location":"applications/blog/#5-cost-reduction-strategies","title":"5. Cost Reduction Strategies","text":"<p>One of the primary benefits of implementing autonomous LLM agents in manufacturing is the potential for substantial cost reductions across various aspects of operations. Let's explore some key areas where these agents can drive down expenses:</p>"},{"location":"applications/blog/#51-optimizing-supply-chain-management","title":"5.1. Optimizing Supply Chain Management","text":"<p>Autonomous LLM agents can revolutionize supply chain management by:</p> <ul> <li> <p>Predictive Inventory Management: Analyzing historical data, market trends, and production schedules to optimize inventory levels, reducing carrying costs and minimizing stockouts.</p> </li> <li> <p>Supplier Selection and Negotiation: Evaluating supplier performance, market conditions, and contract terms to recommend the most cost-effective suppliers and negotiate better deals.</p> </li> <li> <p>Logistics Optimization: Analyzing transportation routes, warehouse locations, and delivery schedules to minimize logistics costs and improve delivery times.</p> </li> </ul> <p>Example: A large automotive manufacturer implemented an autonomous LLM agent to optimize its global supply chain. The agent analyzed data from multiple sources, including production schedules, supplier performance metrics, and global shipping trends. By optimizing inventory levels and renegotiating supplier contracts, the company reduced supply chain costs by 15% in the first year, resulting in savings of over $100 million.</p>"},{"location":"applications/blog/#52-enhancing-quality-control","title":"5.2. Enhancing Quality Control","text":"<p>Quality control is a critical aspect of manufacturing that directly impacts costs. Autonomous LLM agents can significantly improve quality control processes by:</p> <ul> <li> <p>Real-time Defect Detection: Integrating with computer vision systems to identify and classify defects in real-time, reducing waste and rework.</p> </li> <li> <p>Root Cause Analysis: Analyzing production data to identify the root causes of quality issues and recommending corrective actions.</p> </li> <li> <p>Predictive Quality Management: Leveraging historical data and machine learning models to predict potential quality issues before they occur.</p> </li> </ul> <p>Example: A semiconductor manufacturer deployed an autonomous LLM agent to enhance its quality control processes. The agent analyzed data from multiple sensors on the production line, historical quality records, and equipment maintenance logs. By identifying subtle patterns that led to defects, the agent helped reduce scrap rates by 30% and improved overall yield by 5%, resulting in annual savings of $50 million.</p>"},{"location":"applications/blog/#53-streamlining-maintenance-and-repairs","title":"5.3. Streamlining Maintenance and Repairs","text":"<p>Effective maintenance is crucial for minimizing downtime and extending the lifespan of expensive manufacturing equipment. Autonomous LLM agents can optimize maintenance processes by:</p> <ul> <li> <p>Predictive Maintenance: Analyzing equipment sensor data, maintenance history, and production schedules to predict when maintenance is needed, reducing unplanned downtime.</p> </li> <li> <p>Maintenance Scheduling Optimization: Balancing maintenance needs with production schedules to minimize disruptions and maximize equipment availability.</p> </li> <li> <p>Repair Knowledge Management: Creating and maintaining a comprehensive knowledge base of repair procedures, making it easier for technicians to quickly address issues.</p> </li> </ul> <p>Example: A paper mill implemented an autonomous LLM agent to manage its maintenance operations. The agent analyzed vibration data from critical equipment, historical maintenance records, and production schedules. By implementing a predictive maintenance strategy, the mill reduced unplanned downtime by 40% and extended the lifespan of key equipment by 25%, resulting in annual savings of $15 million in maintenance costs and lost production time.</p>"},{"location":"applications/blog/#54-improving-energy-efficiency","title":"5.4. Improving Energy Efficiency","text":"<p>Energy consumption is a significant cost factor in manufacturing. Autonomous LLM agents can help reduce energy costs by:</p> <ul> <li> <p>Real-time Energy Monitoring: Analyzing energy consumption data across the facility to identify inefficiencies and anomalies.</p> </li> <li> <p>Process Optimization for Energy Efficiency: Recommending changes to production processes to reduce energy consumption without impacting output.</p> </li> <li> <p>Demand Response Management: Integrating with smart grid systems to optimize energy usage based on variable electricity prices and demand.</p> </li> </ul> <p>Example: A large chemical manufacturing plant deployed an autonomous LLM agent to optimize its energy consumption. The agent analyzed data from thousands of sensors across the facility, weather forecasts, and electricity price fluctuations. By optimizing process parameters and scheduling energy-intensive operations during off-peak hours, the plant reduced its energy costs by 18%, saving $10 million annually.</p>"},{"location":"applications/blog/#6-revenue-growth-opportunities","title":"6. Revenue Growth Opportunities","text":"<p>While cost reduction is crucial, autonomous LLM agents also present significant opportunities for revenue growth in manufacturing enterprises. Let's explore how these advanced AI systems can drive top-line growth:</p>"},{"location":"applications/blog/#61-product-innovation-and-development","title":"6.1. Product Innovation and Development","text":"<p>Autonomous LLM agents can accelerate and enhance the product innovation process by:</p> <ul> <li> <p>Market Trend Analysis: Analyzing vast amounts of market data, customer feedback, and industry reports to identify emerging trends and unmet needs.</p> </li> <li> <p>Design Optimization: Leveraging generative design techniques and historical performance data to suggest optimal product designs that balance functionality, manufacturability, and cost.</p> </li> <li> <p>Rapid Prototyping Assistance: Guiding engineers through the prototyping process, suggesting materials and manufacturing techniques based on design requirements and cost constraints.</p> </li> </ul> <p>Example: A consumer electronics manufacturer utilized an autonomous LLM agent to enhance its product development process. The agent analyzed social media trends, customer support tickets, and competitor product features to identify key areas for innovation. By suggesting novel features and optimizing designs for manufacturability, the company reduced time-to-market for new products by 30% and increased the success rate of new product launches by 25%, resulting in a 15% increase in annual revenue.</p>"},{"location":"applications/blog/#62-personalized-customer-experiences","title":"6.2. Personalized Customer Experiences","text":"<p>In the age of mass customization, providing personalized experiences can significantly boost customer satisfaction and revenue. Autonomous LLM agents can facilitate this by:</p> <ul> <li> <p>Customer Preference Analysis: Analyzing historical purchase data, customer interactions, and market trends to predict individual customer preferences.</p> </li> <li> <p>Dynamic Product Configuration: Enabling real-time product customization based on customer inputs and preferences, while ensuring manufacturability.</p> </li> <li> <p>Personalized Marketing and Sales Support: Generating tailored marketing content and sales recommendations for each customer or market segment.</p> </li> </ul> <p>Example: A high-end furniture manufacturer implemented an autonomous LLM agent to power its online customization platform. The agent analyzed customer behavior, design trends, and production capabilities to offer personalized product recommendations and customization options. This led to a 40% increase in online sales and a 20% increase in average order value, driving significant revenue growth.</p>"},{"location":"applications/blog/#63-market-analysis-and-trend-prediction","title":"6.3. Market Analysis and Trend Prediction","text":"<p>Staying ahead of market trends is crucial for maintaining a competitive edge. Autonomous LLM agents can provide valuable insights by:</p> <ul> <li> <p>Competitive Intelligence: Analyzing competitor activities, product launches, and market positioning to identify threats and opportunities.</p> </li> <li> <p>Demand Forecasting: Combining historical sales data, economic indicators, and market trends to predict future demand more accurately.</p> </li> <li> <p>Emerging Market Identification: Analyzing global economic data, demographic trends, and industry reports to identify promising new markets for expansion.</p> </li> </ul> <p>Example: A global automotive parts manufacturer employed an autonomous LLM agent to enhance its market intelligence capabilities. The agent analyzed data from industry reports, social media, patent filings, and economic indicators to predict the growth of electric vehicle adoption in different regions. This insight allowed the company to strategically invest in EV component manufacturing, resulting in a 30% year-over-year growth in this high-margin segment.</p>"},{"location":"applications/blog/#64-optimizing-pricing-strategies","title":"6.4. Optimizing Pricing Strategies","text":"<p>Pricing is a critical lever for revenue growth. Autonomous LLM agents can optimize pricing strategies by:</p> <ul> <li> <p>Dynamic Pricing Models: Analyzing market conditions, competitor pricing, and demand fluctuations to suggest optimal pricing in real-time.</p> </li> <li> <p>Value-based Pricing Analysis: Assessing customer perceived value through sentiment analysis and willingness-to-pay studies to maximize revenue.</p> </li> <li> <p>Bundle and Discount Optimization: Recommending product bundles and discount structures that maximize overall revenue and profitability.</p> </li> </ul> <p>Example: A industrial equipment manufacturer implemented an autonomous LLM agent to optimize its pricing strategy. The agent analyzed historical sales data, competitor pricing, economic indicators, and customer sentiment to recommend dynamic pricing models for different product lines and markets. This resulted in a 10% increase in profit margins and a 7% boost in overall revenue within the first year of implementation.</p>"},{"location":"applications/blog/#7-implementation-strategies","title":"7. Implementation Strategies","text":"<p>Successfully implementing autonomous LLM agents in a manufacturing environment requires a strategic approach. Here are key steps and considerations for executives and CEOs:</p> <ol> <li>Start with a Clear Vision and Objectives:</li> <li>Define specific goals for cost reduction and revenue growth.</li> <li> <p>Identify key performance indicators (KPIs) to measure success.</p> </li> <li> <p>Conduct a Comprehensive Readiness Assessment:</p> </li> <li>Evaluate existing IT infrastructure and data management systems.</li> <li>Assess the quality and accessibility of historical data.</li> <li> <p>Identify potential integration points with existing systems and processes.</p> </li> <li> <p>Build a Cross-functional Implementation Team:</p> </li> <li>Include representatives from IT, operations, engineering, and business strategy.</li> <li> <p>Consider partnering with external AI and manufacturing technology experts.</p> </li> <li> <p>Develop a Phased Implementation Plan:</p> </li> <li>Start with pilot projects in specific areas (e.g., predictive maintenance or supply chain optimization).</li> <li> <p>Scale successful pilots across the organization.</p> </li> <li> <p>Invest in Data Infrastructure and Quality:</p> </li> <li>Ensure robust data collection and storage systems are in place.</li> <li> <p>Implement data cleaning and standardization processes.</p> </li> <li> <p>Choose the Right LLM and RAG Technologies:</p> </li> <li>Evaluate different LLM options based on performance, cost, and specific manufacturing requirements.</li> <li> <p>Select RAG embedding databases that can efficiently handle the scale and complexity of manufacturing data.</p> </li> <li> <p>Develop a Robust Integration Strategy:</p> </li> <li>Plan for seamless integration with existing ERP, MES, and other critical systems.</li> <li> <p>Ensure proper API development and management for connecting with external tools and databases.</p> </li> <li> <p>Prioritize Security and Compliance:</p> </li> <li>Implement strong data encryption and access control measures.</li> <li> <p>Ensure compliance with industry regulations and data privacy laws.</p> </li> <li> <p>Invest in Change Management and Training:</p> </li> <li>Develop comprehensive training programs for employees at all levels.</li> <li> <p>Communicate the benefits and address concerns about AI implementation.</p> </li> <li> <p>Establish Governance and Oversight:</p> <ul> <li>Create a governance structure to oversee the use and development of AI systems.</li> <li>Implement ethical guidelines for AI decision-making.</li> </ul> </li> <li> <p>Plan for Continuous Improvement:</p> <ul> <li>Set up feedback loops to continuously refine and improve the AI systems.</li> <li>Stay updated on advancements in LLM and RAG technologies.</li> </ul> </li> </ol> <p>Example: A leading automotive manufacturer implemented autonomous LLM agents across its global operations using a phased approach. They started with a pilot project in predictive maintenance at a single plant, which reduced downtime by 25%. Building on this success, they expanded to supply chain optimization and quality control. Within three years, the company had deployed AI agents across all major operations, resulting in a 12% reduction in overall production costs and a 9% increase in productivity.</p>"},{"location":"applications/blog/#8-overcoming-challenges-and-risks","title":"8. Overcoming Challenges and Risks","text":"<p>While the benefits of autonomous LLM agents in manufacturing are substantial, there are several challenges and risks that executives must address:</p>"},{"location":"applications/blog/#data-quality-and-availability","title":"Data Quality and Availability","text":"<p>Challenge: Manufacturing environments often have siloed, inconsistent, or incomplete data, which can hinder the effectiveness of AI systems.</p> <p>Solution: - Invest in data infrastructure and standardization across the organization. - Implement data governance policies to ensure consistent data collection and management. - Use data augmentation techniques to address gaps in historical data.</p>"},{"location":"applications/blog/#integration-with-legacy-systems","title":"Integration with Legacy Systems","text":"<p>Challenge: Many manufacturing facilities rely on legacy systems that may not easily integrate with modern AI technologies.</p> <p>Solution: - Develop custom APIs and middleware to facilitate communication between legacy systems and AI agents. - Consider a gradual modernization strategy, replacing legacy systems over time. - Use edge computing devices to bridge the gap between old equipment and new AI systems.</p>"},{"location":"applications/blog/#workforce-adaptation-and-resistance","title":"Workforce Adaptation and Resistance","text":"<p>Challenge: Employees may resist AI implementation due to fear of job displacement or lack of understanding.</p> <p>Solution: - Emphasize that AI is a tool to augment human capabilities, not replace workers. - Provide comprehensive training programs to upskill employees. - Involve workers in the AI implementation process to gain buy-in and valuable insights.</p>"},{"location":"applications/blog/#ethical-considerations-and-bias","title":"Ethical Considerations and Bias","text":"<p>Challenge: AI systems may inadvertently perpetuate biases present in historical data or decision-making processes.</p> <p>Solution: - Implement rigorous testing for bias in AI models and decisions. - Establish an ethics committee to oversee AI implementations. - Regularly audit AI systems for fairness and unintended consequences.</p>"},{"location":"applications/blog/#security-and-intellectual-property-protection","title":"Security and Intellectual Property Protection","text":"<p>Challenge: AI systems may be vulnerable to cyber attacks or could potentially expose sensitive manufacturing processes.</p> <p>Solution: - Implement robust cybersecurity measures, including encryption and access controls. - Develop clear policies on data handling and AI model ownership. - Regularly conduct security audits and penetration testing.</p> <p>Example: A pharmaceutical manufacturer faced challenges integrating AI agents with its highly regulated production processes. They addressed this by creating a cross-functional team of IT specialists, process engineers, and compliance officers. This team developed a custom integration layer that allowed AI agents to interact with existing systems while maintaining regulatory compliance. They also implemented a rigorous change management process, which included extensive training and a phased rollout. As a result, they successfully deployed AI agents that optimized production scheduling and quality control, leading to a 15% increase in throughput and a 30% reduction in quality-related issues.</p>"},{"location":"applications/blog/#9-case-studies","title":"9. Case Studies","text":"<p>To illustrate the transformative potential of autonomous LLM agents in manufacturing, let's examine several real-world case studies:</p>"},{"location":"applications/blog/#case-study-1-global-electronics-manufacturer","title":"Case Study 1: Global Electronics Manufacturer","text":"<p>Challenge: A leading electronics manufacturer was struggling with supply chain disruptions and rising production costs.</p> <p>Solution: They implemented an autonomous LLM agent integrated with their supply chain management system and production planning tools.</p> <p>Results: - 22% reduction in inventory carrying costs - 18% improvement in on-time deliveries - 15% decrease in production lead times - $200 million annual cost savings</p> <p>Key Factors for Success: - Comprehensive integration with existing systems - Real-time data processing capabilities - Continuous learning and optimization algorithms</p>"},{"location":"applications/blog/#case-study-2-automotive-parts-supplier","title":"Case Study 2: Automotive Parts Supplier","text":"<p>Challenge: An automotive parts supplier needed to improve quality control and reduce warranty claims.</p> <p>Solution: They deployed an AI-powered quality control system using computer vision and an autonomous LLM agent for defect analysis and prediction.</p> <p>Results: - 40% reduction in defect rates - 60% decrease in warranty claims - 25% improvement in overall equipment effectiveness (OEE) - $75 million annual savings in quality-related costs</p> <p>Key Factors for Success: - High-quality image data collection system - Integration of domain expertise into the AI model - Continuous feedback loop for model improvement</p>"},{"location":"applications/blog/#case-study-3-food-and-beverage-manufacturer","title":"Case Study 3: Food and Beverage Manufacturer","text":"<p>Challenge: A large food and beverage manufacturer wanted to optimize its energy consumption and reduce waste in its production processes.</p> <p>Solution: They implemented an autonomous LLM agent that integrated with their energy management systems and production equipment.</p> <p>Results: - 20% reduction in energy consumption - 30% decrease in production waste - 12% increase in overall production efficiency - $50 million annual cost savings - Significant progress towards sustainability goals</p> <p>Key Factors for Success: - Comprehensive sensor network for real-time data collection - Integration with smart grid systems for dynamic energy management - Collaboration with process engineers to refine AI recommendations</p>"},{"location":"applications/blog/#case-study-4-aerospace-component-manufacturer","title":"Case Study 4: Aerospace Component Manufacturer","text":"<p>Challenge: An aerospace component manufacturer needed to accelerate product development and improve first-time-right rates for new designs.</p> <p>Solution: They implemented an autonomous LLM agent to assist in the design process, leveraging historical data, simulation results, and industry standards.</p> <p>Results: - 35% reduction in design cycle time - 50% improvement in first-time-right rates for new designs - 20% increase in successful patent applications - $100 million increase in annual revenue from new products</p> <p>Key Factors for Success: - Integration of CAD systems with the AI agent - Incorporation of aerospace industry standards and regulations into the AI knowledge base - Collaborative approach between AI and human engineers</p> <p>These case studies demonstrate the wide-ranging benefits of autonomous LLM agents across various manufacturing sectors. The key takeaway is that successful implementation requires a holistic approach, combining technology integration, process redesign, and a focus on continuous improvement.</p>"},{"location":"applications/blog/#10-future-outlook","title":"10. Future Outlook","text":"<p>As we look to the future of manufacturing, the role of autonomous LLM agents is set to become even more critical. Here are some key trends and developments that executives should keep on their radar:</p>"},{"location":"applications/blog/#1-advanced-natural-language-interfaces","title":"1. Advanced Natural Language Interfaces","text":"<p>Future LLM agents will feature more sophisticated natural language interfaces, allowing workers at all levels to interact with complex manufacturing systems using conversational language. This will democratize access to AI capabilities and enhance overall operational efficiency.</p>"},{"location":"applications/blog/#2-enhanced-multi-modal-learning","title":"2. Enhanced Multi-modal Learning","text":"<p>Next-generation agents will be able to process and analyze data from a wider range of sources, including text, images, video, and sensor data. This will enable more comprehensive insights and decision-making capabilities across the manufacturing ecosystem.</p>"},{"location":"applications/blog/#3-collaborative-ai-systems","title":"3. Collaborative AI Systems","text":"<p>We'll see the emergence of AI ecosystems where multiple specialized agents collaborate to solve complex manufacturing challenges. For example, a design optimization agent might work in tandem with a supply chain agent and a quality control agent to develop new products that are optimized for both performance and manufacturability.</p>"},{"location":"applications/blog/#4-quantum-enhanced-ai","title":"4. Quantum-enhanced AI","text":"<p>As quantum computing becomes more accessible, it will significantly enhance the capabilities of LLM agents, particularly in complex optimization problems common in manufacturing. This could lead to breakthroughs in areas such as materials science and process optimization.</p>"},{"location":"applications/blog/#5-augmented-reality-integration","title":"5. Augmented Reality Integration","text":"<p>LLM agents will increasingly be integrated with augmented reality (AR) systems, providing real-time guidance and information to workers on the factory floor. This could revolutionize training, maintenance, and quality control processes.</p>"},{"location":"applications/blog/#6-autonomous-factories","title":"6. Autonomous Factories","text":"<p>The ultimate vision is the development of fully autonomous factories where LLM agents orchestrate entire production processes with minimal human intervention. While this is still on the horizon, progressive implementation of autonomous systems will steadily move the industry in this direction.</p>"},{"location":"applications/blog/#7-ethical-ai-and-explainable-decision-making","title":"7. Ethical AI and Explainable Decision-Making","text":"<p>As AI systems become more prevalent in critical manufacturing decisions, there will be an increased focus on developing ethical AI frameworks and enhancing the explainability of AI decision-making processes. This will be crucial for maintaining trust and meeting regulatory requirements.</p>"},{"location":"applications/blog/#8-circular-economy-optimization","title":"8. Circular Economy Optimization","text":"<p>Future LLM agents will play a key role in optimizing manufacturing processes for sustainability and circular economy principles. This will include enhancing recycling processes, optimizing resource use, and designing products for easy disassembly and reuse.</p> <p>To stay ahead in this rapidly evolving landscape, manufacturing executives should:</p> <ol> <li> <p>Foster a Culture of Innovation: Encourage experimentation with new AI technologies and applications.</p> </li> <li> <p>Invest in Continuous Learning: Ensure your workforce is constantly upskilling to work effectively with advanced AI systems.</p> </li> <li> <p>Collaborate with AI Research Institutions: Partner with universities and research labs to stay at the forefront of AI advancements in manufacturing.</p> </li> <li> <p>Participate in Industry Consortiums: Join manufacturing technology consortiums to share knowledge and shape industry standards for AI adoption.</p> </li> <li> <p>Develop Flexible and Scalable AI Infrastructure: Build systems that can easily incorporate new AI capabilities as they emerge.</p> </li> <li> <p>Monitor Regulatory Developments: Stay informed about evolving regulations related to AI in manufacturing to ensure compliance and competitive advantage.</p> </li> </ol> <p>By embracing these future trends and preparing their organizations accordingly, manufacturing executives can position their companies to thrive in the AI-driven future of industry.</p>"},{"location":"applications/blog/#11-conclusion","title":"11. Conclusion","text":"<p>The integration of autonomous LLM agents with RAG embedding databases, function calling, and external tools represents a paradigm shift in manufacturing. This technology has the potential to dramatically reduce costs, drive revenue growth, and revolutionize how manufacturing enterprises operate.</p> <p>Key takeaways for executives and CEOs:</p> <ol> <li> <p>Transformative Potential: Autonomous LLM agents can impact every aspect of manufacturing, from supply chain optimization to product innovation.</p> </li> <li> <p>Data-Driven Decision Making: These AI systems enable more informed, real-time decision-making based on comprehensive data analysis.</p> </li> <li> <p>Competitive Advantage: Early adopters of this technology are likely to gain significant competitive advantages in terms of efficiency, quality, and innovation.</p> </li> <li> <p>Holistic Implementation: Success requires a strategic approach that addresses technology, processes, and people.</p> </li> <li> <p>Continuous Evolution: The field of AI in manufacturing is rapidly advancing, necessitating ongoing investment and adaptation.</p> </li> <li> <p>Ethical Considerations: As AI becomes more prevalent, addressing ethical concerns and maintaining transparency will be crucial.</p> </li> <li> <p>Future Readiness: Preparing for future developments, such as quantum-enhanced AI and autonomous factories, will be key to long-term success.</p> </li> </ol> <p>The journey to implement autonomous LLM agents in manufacturing is complex but potentially transformative. It requires vision, commitment, and a willingness to reimagine traditional manufacturing processes. However, the potential rewards \u2013 in terms of cost savings, revenue growth, and competitive advantage \u2013 are substantial.</p> <p>As a manufacturing executive or CEO, your role is to lead this transformation, fostering a culture of innovation and continuous improvement. By embracing the power of autonomous LLM agents, you can position your organization at the forefront of the next industrial revolution, driving sustainable growth and success in an increasingly competitive global marketplace.</p> <p>The future of manufacturing is intelligent, autonomous, and data-driven. The time to act is now. Embrace the potential of autonomous LLM agents and lead your organization into a new era of manufacturing excellence.</p>"},{"location":"applications/business-analyst-agent/","title":"Business analyst agent","text":""},{"location":"applications/business-analyst-agent/#building-analyst-agents-with-swarms-to-write-business-reports","title":"Building Analyst Agents with Swarms to write Business Reports","text":"<p>Jupyter Notebook accompanying this post is accessible at: Business Analyst Agent Notebook</p> <p>Solving a business problem often involves preparing a Business Case Report. This report comprehensively analyzes the problem, evaluates potential solutions, and provides evidence-based recommendations and an implementation plan to effectively address the issue and drive business value. While the process of preparing one requires an experienced business analyst, the workflow can be augmented using AI agents. Two candidates stick out as areas to work on:</p> <ul> <li>Developing an outline to solve the problem</li> <li>Doing background research and gathering data </li> </ul> <p>In this post, we will explore how Swarms agents can be used to tackle a busuiness problem by outlining the solution, conducting background research and generating a preliminary report.</p> <p>Before we proceed, this blog uses 3 API tools. Please obtain the following keys and store them in a <code>.env</code> file in the same folder as this file.</p> <ul> <li>OpenAI API as <code>OPENAI_API_KEY</code></li> <li>TavilyAI API <code>TAVILY_API_KEY</code></li> <li>KayAI API as <code>KAY_API_KEY</code></li> </ul> <pre><code>import dotenv\ndotenv.load_dotenv()  # Load environment variables from .env file\n</code></pre>"},{"location":"applications/business-analyst-agent/#developing-an-outline-to-solve-the-problem","title":"Developing an Outline to solve the problem","text":"<p>Assume the business problem is: How do we improve Nike's revenue in Q3 2024? We first create a planning agent to break down the problem into dependent sub-problems.</p>"},{"location":"applications/business-analyst-agent/#step-1-defining-the-data-model-and-tool-schema","title":"Step 1. Defining the Data Model and Tool Schema","text":"<p>Using Pydantic, we define a structure to help the agent generate sub-problems. </p> <ul> <li>QueryType: Questions are either standalone or involve a combination of multiple others</li> <li>Query: Defines structure of a question.</li> <li>QueryPlan: Allows generation of a dependency graph of sub-questions</li> </ul> <pre><code>import enum\nfrom typing import List\nfrom pydantic import Field, BaseModel\n\nclass QueryType(str, enum.Enum):\n    \"\"\"Enumeration representing the types of queries that can be asked to a question answer system.\"\"\"\n\n    SINGLE_QUESTION = \"SINGLE\"\n    MERGE_MULTIPLE_RESPONSES = \"MERGE_MULTIPLE_RESPONSES\"\n\nclass Query(BaseModel):\n    \"\"\"Class representing a single question in a query plan.\"\"\"\n\n    id: int = Field(..., description=\"Unique id of the query\")\n    question: str = Field(\n        ...,\n        description=\"Question asked using a question answering system\",\n    )\n    dependencies: List[int] = Field(\n        default_factory=list,\n        description=\"List of sub questions that need to be answered before asking this question\",\n    )\n    node_type: QueryType = Field(\n        default=QueryType.SINGLE_QUESTION,\n        description=\"Type of question, either a single question or a multi-question merge\",\n    )\n\nclass QueryPlan(BaseModel):\n    \"\"\"Container class representing a tree of questions to ask a question answering system.\"\"\"\n\n    query_graph: List[Query] = Field(\n        ..., description=\"The query graph representing the plan\"\n    )\n\n    def _dependencies(self, ids: List[int]) -&gt; List[Query]:\n        \"\"\"Returns the dependencies of a query given their ids.\"\"\"\n\n        return [q for q in self.query_graph if q.id in ids]\n</code></pre> <p>Also, a <code>tool_schema</code> needs to be defined. It is an instance of <code>QueryPlan</code> and is used to initialize the agent.</p> <pre><code>tool_schema = QueryPlan(\n    query_graph = [query.dict() for query in [\n        Query(\n            id=1,\n            question=\"How do we improve Nike's revenue in Q3 2024?\",\n            dependencies=[2],\n            node_type=QueryType('SINGLE')\n        ),\n        # ... other queries ...\n    ]]\n)\n</code></pre>"},{"location":"applications/business-analyst-agent/#step-2-defining-the-planning-agent","title":"Step 2. Defining the Planning Agent","text":"<p>We specify the query, task specification and an appropriate system prompt.</p> <pre><code>from swarm_models import OpenAIChat\nfrom swarms import Agent\n\nquery = \"How do we improve Nike's revenue in Q3 2024?\"\ntask = f\"Consider: {query}. Generate just the correct query plan in JSON format.\"\nsystem_prompt = (\n        \"You are a world class query planning algorithm \" \n        \"capable of breaking apart questions into its \" \n        \"dependency queries such that the answers can be \" \n        \"used to inform the parent question. Do not answer \" \n        \"the questions, simply provide a correct compute \" \n        \"graph with good specific questions to ask and relevant \" \n        \"dependencies. Before you call the function, think \" \n        \"step-by-step to get a better understanding of the problem.\"\n    )\nllm = OpenAIChat(\n    temperature=0.0, model_name=\"gpt-4\", max_tokens=4000\n)\n</code></pre> <p>Then, we proceed with agent definition.</p> <pre><code># Initialize the agent\nagent = Agent(\n    agent_name=\"Query Planner\",\n    system_prompt=system_prompt,\n    # Set the tool schema to the JSON string -- this is the key difference\n    tool_schema=tool_schema,\n    llm=llm,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    interactive=False,\n    # Set the output type to the tool schema which is a BaseModel\n    output_type=tool_schema, # or dict, or str\n    metadata_output_type=\"json\",\n    # List of schemas that the agent can handle\n    list_base_models=[tool_schema],\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\", # or soon yaml\n)\n</code></pre>"},{"location":"applications/business-analyst-agent/#step-3-obtaining-outline-from-planning-agent","title":"Step 3. Obtaining Outline from Planning Agent","text":"<p>We now run the agent, and since its output is in JSON format, we can load it as a dictionary.</p> <pre><code>generated_data = agent.run(task)\n</code></pre> <p>At times the agent could return extra content other than JSON. Below function will filter it out.</p> <pre><code>def process_json_output(content):\n    # Find the index of the first occurrence of '```json\\n'\n    start_index = content.find('```json\\n')\n    if start_index == -1:\n        # If '```json\\n' is not found, return the original content\n        return content\n    # Return the part of the content after '```json\\n' and remove the '```' at the end\n    return content[start_index + len('```json\\n'):].rstrip('`')\n\n# Use the function to clean up the output\njson_content = process_json_output(generated_data.content)\n\nimport json\n\n# Load the JSON string into a Python object\njson_object = json.loads(json_content)\n\n# Convert the Python object back to a JSON string\njson_content = json.dumps(json_object, indent=2)\n\n# Print the JSON string\nprint(json_content)\n</code></pre> <p>Below is the output this produces</p> <pre><code>{\n  \"main_query\": \"How do we improve Nike's revenue in Q3 2024?\",\n  \"sub_queries\": [\n    {\n      \"id\": \"1\",\n      \"query\": \"What is Nike's current revenue trend?\"\n    },\n    {\n      \"id\": \"2\",\n      \"query\": \"What are the projected market trends for the sports apparel industry in 2024?\"\n    },\n    {\n      \"id\": \"3\",\n      \"query\": \"What are the current successful strategies being used by Nike's competitors?\",\n      \"dependencies\": [\n        \"2\"\n      ]\n    },\n    {\n      \"id\": \"4\",\n      \"query\": \"What are the current and projected economic conditions in Nike's major markets?\",\n      \"dependencies\": [\n        \"2\"\n      ]\n    },\n    {\n      \"id\": \"5\",\n      \"query\": \"What are the current consumer preferences in the sports apparel industry?\",\n      \"dependencies\": [\n        \"2\"\n      ]\n    },\n    {\n      \"id\": \"6\",\n      \"query\": \"What are the potential areas of improvement in Nike's current business model?\",\n      \"dependencies\": [\n        \"1\"\n      ]\n    },\n    {\n      \"id\": \"7\",\n      \"query\": \"What are the potential new markets for Nike to explore in 2024?\",\n      \"dependencies\": [\n        \"2\",\n        \"4\"\n      ]\n    },\n    {\n      \"id\": \"8\",\n      \"query\": \"What are the potential new products or services Nike could introduce in 2024?\",\n      \"dependencies\": [\n        \"5\"\n      ]\n    },\n    {\n      \"id\": \"9\",\n      \"query\": \"What are the potential marketing strategies Nike could use to increase its revenue in Q3 2024?\",\n      \"dependencies\": [\n        \"3\",\n        \"5\",\n        \"7\",\n        \"8\"\n      ]\n    },\n    {\n      \"id\": \"10\",\n      \"query\": \"What are the potential cost-saving strategies Nike could implement to increase its net revenue in Q3 2024?\",\n      \"dependencies\": [\n        \"6\"\n      ]\n    }\n  ]\n}\n</code></pre> <p>The JSON dictionary is not convenient for humans to process. We make a directed graph out of it.</p> <pre><code>import networkx as nx\nimport matplotlib.pyplot as plt\nimport textwrap\nimport random\n\n# Create a directed graph\nG = nx.DiGraph()\n\n# Define a color map\ncolor_map = {}\n\n# Add nodes and edges to the graph\nfor sub_query in json_object['sub_queries']:\n    # Check if 'dependencies' key exists in sub_query, if not, initialize it as an empty list\n    if 'dependencies' not in sub_query:\n        sub_query['dependencies'] = []\n    # Assign a random color for each node\n    color_map[sub_query['id']] = \"#{:06x}\".format(random.randint(0, 0xFFFFFF))\n    G.add_node(sub_query['id'], label=textwrap.fill(sub_query['query'], width=20))\n    for dependency in sub_query['dependencies']:\n        G.add_edge(dependency, sub_query['id'])\n\n# Draw the graph\npos = nx.spring_layout(G)\nnx.draw(G, pos, with_labels=True, node_size=800, node_color=[color_map[node] for node in G.nodes()], node_shape=\"o\", alpha=0.5, linewidths=40)\n\n# Prepare labels for legend\nlabels = nx.get_node_attributes(G, 'label')\nhandles = [plt.Line2D([0], [0], marker='o', color=color_map[node], label=f\"{node}: {label}\", markersize=10, linestyle='None') for node, label in labels.items()]\n\n# Create a legend\nplt.legend(handles=handles, title=\"Queries\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\nplt.show()\n</code></pre> <p>This produces the below diagram which makes the plan much more convenient to understand.</p> <p></p>"},{"location":"applications/business-analyst-agent/#doing-background-research-and-gathering-data","title":"Doing Background Research and Gathering Data","text":"<p>At this point, we have solved the first half of the problem. We have an outline consisting of sub-problems to to tackled to solve our business problem. This will form the overall structure of our report. We now need to research information for each sub-problem in order to write an informed report. This mechanically intensive and is the aspect that will most benefit from Agentic intervention. </p> <p>Essentially, we can spawn parallel agents to gather the data. Each agent will have 2 tools:</p> <ul> <li>Internet access</li> <li>Financial data retrieval</li> </ul> <p>As they run parallelly, they will add their knowledge into a common long-term memory. We will then spawn a separate report writing agent with access to this memory to generate our business case report.</p>"},{"location":"applications/business-analyst-agent/#step-4-defining-tools-for-worker-agents","title":"Step 4. Defining Tools for Worker Agents","text":"<p>Let us first define the 2 tools. </p> <pre><code>import os\nfrom typing import List, Dict\n\nfrom swarms import tool\n\nos.environ['TAVILY_API_KEY'] = os.getenv('TAVILY_API_KEY')\nos.environ[\"KAY_API_KEY\"] = os.getenv('KAY_API_KEY')\n\nfrom langchain_community.tools.tavily_search import TavilySearchResults\nfrom langchain_core.pydantic_v1 import BaseModel, Field\n\nfrom kay.rag.retrievers import KayRetriever\n\ndef browser(query: str) -&gt; str:\n    \"\"\"\n    Search the query in the browser with the Tavily API tool.\n    Args:\n        query (str): The query to search in the browser.\n    Returns:\n        str: The search results\n    \"\"\"\n    internet_search = TavilySearchResults()\n    results =  internet_search.invoke({\"query\": query})\n    response = '' \n    for result in results:\n        response += (result['content'] + '\\n')\n    return response\n\ndef kay_retriever(query: str) -&gt; str:\n    \"\"\"\n    Search the financial data query with the KayAI API tool.\n    Args:\n        query (str): The query to search in the KayRetriever.\n    Returns:\n        str: The first context retrieved as a string.\n    \"\"\"\n    # Initialize the retriever\n    retriever = KayRetriever(dataset_id = \"company\",  data_types=[\"10-K\", \"10-Q\", \"8-K\", \"PressRelease\"])\n    # Query the retriever\n    context = retriever.query(query=query,num_context=1)\n    return context[0]['chunk_embed_text']\n</code></pre>"},{"location":"applications/business-analyst-agent/#step-5-defining-long-term-memory","title":"Step 5. Defining Long-Term Memory","text":"<p>As mentioned previously, the worker agents running parallelly, will pool their knowledge into a common memory. Let us define that.</p> <pre><code>import logging\nimport os\nimport uuid\nfrom typing import Callable, List, Optional\n\nimport chromadb\nimport numpy as np\nfrom dotenv import load_dotenv\n\nfrom swarms.utils.data_to_text import data_to_text\nfrom swarms.utils.markdown_message import display_markdown_message\nfrom swarms_memory import  AbstractVectorDatabase\n\n\n# Results storage using local ChromaDB\nclass ChromaDB(AbstractVectorDatabase):\n    \"\"\"\n\n    ChromaDB database\n\n    Args:\n        metric (str): The similarity metric to use.\n        output (str): The name of the collection to store the results in.\n        limit_tokens (int, optional): The maximum number of tokens to use for the query. Defaults to 1000.\n        n_results (int, optional): The number of results to retrieve. Defaults to 2.\n\n    Methods:\n        add: _description_\n        query: _description_\n\n    Examples:\n        &gt;&gt;&gt; chromadb = ChromaDB(\n        &gt;&gt;&gt;     metric=\"cosine\",\n        &gt;&gt;&gt;     output=\"results\",\n        &gt;&gt;&gt;     llm=\"gpt3\",\n        &gt;&gt;&gt;     openai_api_key=OPENAI_API_KEY,\n        &gt;&gt;&gt; )\n        &gt;&gt;&gt; chromadb.add(task, result, result_id)\n    \"\"\"\n\n    def __init__(\n        self,\n        metric: str = \"cosine\",\n        output_dir: str = \"swarms\",\n        limit_tokens: Optional[int] = 1000,\n        n_results: int = 3,\n        embedding_function: Callable = None,\n        docs_folder: str = None,\n        verbose: bool = False,\n        *args,\n        **kwargs,\n    ):\n        self.metric = metric\n        self.output_dir = output_dir\n        self.limit_tokens = limit_tokens\n        self.n_results = n_results\n        self.docs_folder = docs_folder\n        self.verbose = verbose\n\n        # Disable ChromaDB logging\n        if verbose:\n            logging.getLogger(\"chromadb\").setLevel(logging.INFO)\n\n        # Create Chroma collection\n        chroma_persist_dir = \"chroma\"\n        chroma_client = chromadb.PersistentClient(\n            settings=chromadb.config.Settings(\n                persist_directory=chroma_persist_dir,\n            ),\n            *args,\n            **kwargs,\n        )\n\n        # Embedding model\n        if embedding_function:\n            self.embedding_function = embedding_function\n        else:\n            self.embedding_function = None\n\n        # Create ChromaDB client\n        self.client = chromadb.Client()\n\n        # Create Chroma collection\n        self.collection = chroma_client.get_or_create_collection(\n            name=output_dir,\n            metadata={\"hnsw:space\": metric},\n            embedding_function=self.embedding_function,\n            # data_loader=self.data_loader,\n            *args,\n            **kwargs,\n        )\n        display_markdown_message(\n            \"ChromaDB collection created:\"\n            f\" {self.collection.name} with metric: {self.metric} and\"\n            f\" output directory: {self.output_dir}\"\n        )\n\n        # If docs\n        if docs_folder:\n            display_markdown_message(\n                f\"Traversing directory: {docs_folder}\"\n            )\n            self.traverse_directory()\n\n    def add(\n        self,\n        document: str,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Add a document to the ChromaDB collection.\n\n        Args:\n            document (str): The document to be added.\n            condition (bool, optional): The condition to check before adding the document. Defaults to True.\n\n        Returns:\n            str: The ID of the added document.\n        \"\"\"\n        try:\n            doc_id = str(uuid.uuid4())\n            self.collection.add(\n                ids=[doc_id],\n                documents=[document],\n                *args,\n                **kwargs,\n            )\n            print('-----------------')\n            print(\"Document added successfully\")\n            print('-----------------')\n            return doc_id\n        except Exception as e:\n            raise Exception(f\"Failed to add document: {str(e)}\")\n\n    def query(\n        self,\n        query_text: str,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Query documents from the ChromaDB collection.\n\n        Args:\n            query (str): The query string.\n            n_docs (int, optional): The number of documents to retrieve. Defaults to 1.\n\n        Returns:\n            dict: The retrieved documents.\n        \"\"\"\n        try:\n            docs = self.collection.query(\n                query_texts=[query_text],\n                n_results=self.n_results,\n                *args,\n                **kwargs,\n            )[\"documents\"]\n            return docs[0]\n        except Exception as e:\n            raise Exception(f\"Failed to query documents: {str(e)}\")\n\n    def traverse_directory(self):\n        \"\"\"\n        Traverse through every file in the given directory and its subdirectories,\n        and return the paths of all files.\n        Parameters:\n        - directory_name (str): The name of the directory to traverse.\n        Returns:\n        - list: A list of paths to each file in the directory and its subdirectories.\n        \"\"\"\n        added_to_db = False\n\n        for root, dirs, files in os.walk(self.docs_folder):\n            for file in files:\n                file = os.path.join(self.docs_folder, file)\n                _, ext = os.path.splitext(file)\n                data = data_to_text(file)\n                added_to_db = self.add([data])\n                print(f\"{file} added to Database\")\n\n        return added_to_db\n</code></pre> <p>We can now proceed to initialize the memory.</p> <pre><code>from chromadb.utils import embedding_functions\ndefault_ef = embedding_functions.DefaultEmbeddingFunction()\n\nmemory = ChromaDB(\n    metric=\"cosine\",\n    n_results=3,\n    output_dir=\"results\",\n    embedding_function=default_ef\n)\n</code></pre>"},{"location":"applications/business-analyst-agent/#step-6-defining-worker-agents","title":"Step 6. Defining Worker Agents","text":"<p>The Worker Agent sub-classes the <code>Agent</code> class. The only different between these 2 is in how the <code>run()</code> method works. In the <code>Agent</code> class, <code>run()</code> simply returns the set of tool commands to run, but does not execute it. We, however, desire this. In addition, after we run our tools, we get the relevant information as output. We want to add this information to our memory. Hence, to incorporate these 2 changes, we define <code>WorkerAgent</code> as follows.</p> <pre><code>class WorkerAgent(Agent):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def run(self, task, *args, **kwargs):\n        response = super().run(task, *args, **kwargs)\n        print(response.content)\n\n        json_dict = json.loads(process_json_output(response.content))\n\n        #print(json.dumps(json_dict, indent=2))\n\n        if response!=None:\n            try:\n                commands = json_dict[\"commands\"]\n            except:\n                commands = [json_dict['command']]\n\n            for command in commands:\n                tool_name = command[\"name\"]\n\n                if tool_name not in ['browser', 'kay_retriever']:\n                    continue\n\n                query = command[\"args\"][\"query\"]\n\n                # Get the tool by its name\n                tool = globals()[tool_name]\n                tool_response = tool(query)\n\n                # Add tool's output to long term memory\n                self.long_term_memory.add(tool_response)\n</code></pre> <p>We can then instantiate an object of the <code>WorkerAgent</code> class.</p> <pre><code>worker_agent = WorkerAgent(\n    agent_name=\"Worker Agent\",\n    system_prompt=(\n        \"Autonomous agent that can interact with browser, \"\n        \"financial data retriever and other agents. Be Helpful \" \n        \"and Kind. Use the tools provided to assist the user. \"\n        \"Generate the plan with list of commands in JSON format.\"\n    ),\n    llm=OpenAIChat(\n    temperature=0.0, model_name=\"gpt-4\", max_tokens=4000\n),\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    interactive=True,\n    tools=[browser, kay_retriever],\n    long_term_memory=memory,\n    code_interpreter=True,\n)\n</code></pre>"},{"location":"applications/business-analyst-agent/#step-7-running-the-worker-agents","title":"Step 7. Running the Worker Agents","text":"<p>At this point, we need to setup a concurrent workflow. While the order of adding tasks to the workflow doesn't matter (since they will all run concurrently late when executed), we can take some time to define an order for these tasks. This order will come in handy later when writing the report using our Writer Agent. </p> <p>The order we will follow is Breadth First Traversal (BFT) of the sub-queries in the graph we had made earlier (shown below again for reference). BFT makes sense to be used here because we want all the dependent parent questions to be answered before answering the child question. Also, since we could have independent subgraphs, we will also perform BFT separately on each subgraph.</p> <p></p> <p>Below is the code that produces the order of processing sub-queries.</p> <pre><code>from collections import deque, defaultdict\n\n# Define the graph nodes\nnodes = json_object['sub_queries']\n\n# Create a graph from the nodes\ngraph = defaultdict(list)\nfor node in nodes:\n    for dependency in node['dependencies']:\n        graph[dependency].append(node['id'])\n\n# Find all nodes with no dependencies (potential starting points)\nstart_nodes = [node['id'] for node in nodes if not node['dependencies']]\n\n# Adjust the BFT function to handle dependencies correctly\ndef bft_corrected(start, graph, nodes_info):\n    visited = set()\n    queue = deque([start])\n    order = []\n\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            # Check if all dependencies of the current node are visited\n            node_dependencies = [n['id'] for n in nodes if n['id'] == node][0]\n            dependencies_met = all(dep in visited for dep in nodes_info[node_dependencies]['dependencies'])\n\n            if dependencies_met:\n                visited.add(node)\n                order.append(node)\n                # Add only nodes to the queue whose dependencies are fully met\n                for next_node in graph[node]:\n                    if all(dep in visited for dep in nodes_info[next_node]['dependencies']):\n                        queue.append(next_node)\n            else:\n                # Requeue the node to check dependencies later\n                queue.append(node)\n\n    return order\n\n# Dictionary to access node information quickly\nnodes_info = {node['id']: node for node in nodes}\n\n# Perform BFT for each unvisited start node using the corrected BFS function\nvisited_global = set()\nbfs_order = []\n\nfor start in start_nodes:\n    if start not in visited_global:\n        order = bft_corrected(start, graph, nodes_info)\n        bfs_order.extend(order)\n        visited_global.update(order)\n\nprint(\"BFT Order:\", bfs_order)\n</code></pre> <p>This produces the following output.</p> <pre><code>BFT Order: ['1', '6', '10', '2', '3', '4', '5', '7', '8', '9']\n</code></pre> <p>Now, let's define our <code>ConcurrentWorkflow</code> and run it.</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, ConcurrentWorkflow, OpenAIChat, Task\n\n# Create a workflow\nworkflow = ConcurrentWorkflow(max_workers=5)\ntask_list = []\n\nfor node in bfs_order:\n    sub_query =nodes_info[node]['query']\n    task = Task(worker_agent, sub_query)\n    print('-----------------')\n    print(\"Added task: \", sub_query)\n    print('-----------------')\n    task_list.append(task)\n\nworkflow.add(tasks=task_list)\n\n# Run the workflow\nworkflow.run()\n</code></pre> <p>Below is part of the output this workflow produces. We clearly see the thought process of the agent and the plan it came up to solve a particular sub-query. In addition, we see the tool-calling schema it produces in <code>\"command\"</code>.</p> <pre><code>...\n...\ncontent='\\n{\\n  \"thoughts\": {\\n    \"text\": \"To find out Nike\\'s current revenue trend, I will use the financial data retriever tool to search for \\'Nike revenue trend\\'.\",\\n    \"reasoning\": \"The financial data retriever tool allows me to search for specific financial data, so I can look up the current revenue trend of Nike.\", \\n    \"plan\": \"Use the financial data retriever tool to search for \\'Nike revenue trend\\'. Parse the result to get the current revenue trend and format that into a readable report.\"\\n  },\\n  \"command\": {\\n    \"name\": \"kay_retriever\", \\n    \"args\": {\\n      \"query\": \"Nike revenue trend\"\\n    }\\n  }\\n}\\n```' response_metadata={'token_usage': {'completion_tokens': 152, 'prompt_tokens': 1527, 'total_tokens': 1679}, 'model_name': 'gpt-4', 'system_fingerprint': None, 'finish_reason': 'stop', 'logprobs': None}\nSaved agent state to: Worker Agent_state.json\n\n{\n  \"thoughts\": {\n    \"text\": \"To find out Nike's current revenue trend, I will use the financial data retriever tool to search for 'Nike revenue trend'.\",\n    \"reasoning\": \"The financial data retriever tool allows me to search for specific financial data, so I can look up the current revenue trend of Nike.\", \n    \"plan\": \"Use the financial data retriever tool to search for 'Nike revenue trend'. Parse the result to get the current revenue trend and format that into a readable report.\"\n  },\n  \"command\": {\n    \"name\": \"kay_retriever\", \n    \"args\": {\n      \"query\": \"Nike revenue trend\"\n    }\n  }\n}\n\n-----------------\nDocument added successfully\n-----------------\n...\n...\n</code></pre> <p>Here, <code>\"name\"</code> pertains to the name of the tool to be called and <code>\"args\"</code> is the arguments to be passed to the tool call. Like mentioned before, we modify <code>Agent</code>'s default behaviour in <code>WorkerAgent</code>. Hence, the tool call is executed here and its results (information from web pages and Kay Retriever API) are added to long-term memory. We get confirmation for this from the message <code>Document added successfully</code>. </p>"},{"location":"applications/business-analyst-agent/#step-7-generating-the-report-using-writer-agent","title":"Step 7. Generating the report using Writer Agent","text":"<p>At this point, our Worker Agents have gathered all the background information required to generate the report. We have also defined a coherent structure to write the report, which is following the BFT order to answering the sub-queries. Now it's time to define a Writer Agent and call it sequentially in the order of sub-queries. </p> <pre><code>from swarms import Agent, OpenAIChat, tool\n\nagent = Agent(\n    agent_name=\"Writer Agent\",\n    agent_description=(\n        \"This agent writes reports based on information in long-term memory\"\n    ),\n    system_prompt=(\n        \"You are a world-class financial report writer. \" \n        \"Write analytical and accurate responses using memory to answer the query. \"\n        \"Do not mention use of long-term memory in the report. \"\n        \"Do not mention Writer Agent in response.\"\n        \"Return only response content in strict markdown format.\"\n    ),\n    llm=OpenAIChat(temperature=0.2, model='gpt-3.5-turbo'),\n    max_loops=1,\n    autosave=True,\n    verbose=True,\n    long_term_memory=memory,\n)\n</code></pre> <p>The report individual sections of the report will be collected in a list.</p> <pre><code>report = []\n</code></pre> <p>Let us now run the writer agent.</p> <pre><code>for node in bfs_order:\n    sub_query =nodes_info[node]['query']\n    print(\"Running task: \", sub_query)\n    out = agent.run(f\"Consider: {sub_query}. Write response in strict markdown format using long-term memory. Do not mention Writer Agent in response.\")\n    print(out)\n    try:\n        report.append(out.content)\n    except:\n        pass\n</code></pre> <p>Now, we need to clean up the repoort a bit to make it render professionally. </p> <pre><code># Remove any content before the first \"#\" as that signals start of heading\n# Anything before this usually contains filler content\nstripped_report = [entry[entry.find('#'):] if '#' in entry else entry for entry in report]\nreport = stripped_report\n\n# At times the LLM outputs \\\\n instead of \\n\ncleaned_report = [entry.replace(\"\\\\n\", \"\\n\") for entry in report]\nimport re\n\n# Function to clean up unnecessary metadata from the report entries\ndef clean_report(report):\n    cleaned_report = []\n    for entry in report:\n        # This pattern matches 'response_metadata={' followed by any characters that are not '}' (non-greedy), \n        # possibly nested inside other braces, until the closing '}'.\n        cleaned_entry = re.sub(r\"response_metadata=\\{[^{}]*(?:\\{[^{}]*\\}[^{}]*)*\\}\", \"\", entry, flags=re.DOTALL)\n        cleaned_report.append(cleaned_entry)\n    return cleaned_report\n\n# Apply the cleaning function to the markdown report\ncleaned_report = clean_report(cleaned_report)\n</code></pre> <p>After cleaning, we append parts of the report together to get out final report.</p> <pre><code>final_report = ' \\n '.join(cleaned_report)\n</code></pre> <p>In Jupyter Notebook, we can use the below code to render it in Markdown. </p> <pre><code>from IPython.display import display, Markdown\n\ndisplay(Markdown(final_report))\n</code></pre>"},{"location":"applications/business-analyst-agent/#final-generated-report","title":"Final Generated Report","text":""},{"location":"applications/business-analyst-agent/#nikes-current-revenue-trend","title":"Nike's Current Revenue Trend","text":"<p>Nike's current revenue trend has been steadily increasing over the past few years. In the most recent fiscal year, Nike reported a revenue of $37.4 billion, which was a 7% increase from the previous year. This growth can be attributed to strong sales in key markets, successful marketing campaigns, and a focus on innovation in product development. Overall, Nike continues to demonstrate strong financial performance and is well-positioned for future growth.   ### Potential Areas of Improvement in Nike's Business Model</p> <ol> <li> <p>Sustainability Practices: Nike could further enhance its sustainability efforts by reducing its carbon footprint, using more eco-friendly materials, and ensuring ethical labor practices throughout its supply chain.</p> </li> <li> <p>Diversification of Product Portfolio: While Nike is known for its athletic footwear and apparel, diversifying into new product categories or expanding into untapped markets could help drive growth and mitigate risks associated with a single product line.</p> </li> <li> <p>E-commerce Strategy: Improving the online shopping experience, investing in digital marketing, and leveraging data analytics to personalize customer interactions could boost online sales and customer loyalty.</p> </li> <li> <p>Innovation and R&amp;D: Continuously investing in research and development to stay ahead of competitors, introduce new technologies, and enhance product performance could help maintain Nike's competitive edge in the market.</p> </li> <li> <p>Brand Image and Reputation: Strengthening brand image through effective marketing campaigns, community engagement, and transparent communication with stakeholders can help build trust and loyalty among consumers.   ### Potential Cost-Saving Strategies for Nike to Increase Net Revenue in Q3 2024</p> </li> <li> <p>Supply Chain Optimization: Streamlining the supply chain, reducing transportation costs, and improving inventory management can lead to significant cost savings for Nike.</p> </li> <li> <p>Operational Efficiency: Implementing lean manufacturing practices, reducing waste, and optimizing production processes can help lower production costs and improve overall efficiency.</p> </li> <li> <p>Outsourcing Non-Core Functions: Outsourcing non-core functions such as IT services, customer support, or logistics can help reduce overhead costs and focus resources on core business activities.</p> </li> <li> <p>Energy Efficiency: Investing in energy-efficient technologies, renewable energy sources, and sustainable practices can lower utility costs and demonstrate a commitment to environmental responsibility.</p> </li> <li> <p>Negotiating Supplier Contracts: Negotiating better terms with suppliers, leveraging economies of scale, and exploring alternative sourcing options can help lower procurement costs and improve margins.</p> </li> </ol> <p>By implementing these cost-saving strategies, Nike can improve its bottom line and increase net revenue in Q3 2024.   ### Projected Market Trends for the Sports Apparel Industry in 2024</p> <ol> <li> <p>Sustainable Fashion: Consumers are increasingly demanding eco-friendly and sustainable products, leading to a rise in sustainable sportswear options in the market.</p> </li> <li> <p>Digital Transformation: The sports apparel industry is expected to continue its shift towards digital platforms, with a focus on e-commerce, personalized shopping experiences, and digital marketing strategies.</p> </li> <li> <p>Athleisure Wear: The trend of athleisure wear, which combines athletic and leisure clothing, is projected to remain popular in 2024 as consumers seek comfort and versatility in their apparel choices.</p> </li> <li> <p>Innovative Materials: Advances in technology and material science are likely to drive the development of innovative fabrics and performance-enhancing materials in sports apparel, catering to the demand for high-quality and functional products.</p> </li> <li> <p>Health and Wellness Focus: With a growing emphasis on health and wellness, sports apparel brands are expected to incorporate features that promote comfort, performance, and overall well-being in their products.</p> </li> </ol> <p>Overall, the sports apparel industry in 2024 is anticipated to be characterized by sustainability, digitalization, innovation, and a focus on consumer health and lifestyle trends.   ### Current Successful Strategies Used by Nike's Competitors</p> <ol> <li> <p>Adidas: Adidas has been successful in leveraging collaborations with celebrities and designers to create limited-edition collections that generate hype and drive sales. They have also focused on sustainability initiatives, such as using recycled materials in their products, to appeal to environmentally conscious consumers.</p> </li> <li> <p>Under Armour: Under Armour has differentiated itself by targeting performance-driven athletes and emphasizing technological innovation in their products. They have also invested heavily in digital marketing and e-commerce to reach a wider audience and enhance the customer shopping experience.</p> </li> <li> <p>Puma: Puma has successfully capitalized on the athleisure trend by offering stylish and versatile sportswear that can be worn both in and out of the gym. They have also focused on building partnerships with influencers and sponsoring high-profile athletes to increase brand visibility and credibility.</p> </li> <li> <p>Lululemon: Lululemon has excelled in creating a strong community around its brand, hosting events, classes, and collaborations to engage with customers beyond just selling products. They have also prioritized customer experience by offering personalized services and creating a seamless omnichannel shopping experience.</p> </li> <li> <p>New Balance: New Balance has carved out a niche in the market by emphasizing quality craftsmanship, heritage, and authenticity in their products. They have also focused on customization and personalization options for customers, allowing them to create unique and tailored footwear and apparel.</p> </li> </ol> <p>Overall, Nike's competitors have found success through a combination of innovative product offerings, strategic marketing initiatives, and a focus on customer engagement and experience.   ### Current and Projected Economic Conditions in Nike's Major Markets</p> <ol> <li> <p>United States: The United States, being one of Nike's largest markets, is currently experiencing moderate economic growth driven by consumer spending, low unemployment rates, and a rebound in manufacturing. However, uncertainties surrounding trade policies, inflation, and interest rates could impact consumer confidence and spending in the near future.</p> </li> <li> <p>China: China remains a key market for Nike, with a growing middle class and increasing demand for sportswear and athletic footwear. Despite recent trade tensions with the U.S., China's economy is projected to continue expanding, driven by domestic consumption, infrastructure investments, and technological advancements.</p> </li> <li> <p>Europe: Economic conditions in Europe vary across countries, with some experiencing sluggish growth due to Brexit uncertainties, political instability, and trade tensions. However, overall consumer confidence is improving, and the sports apparel market is expected to grow, driven by e-commerce and sustainability trends.</p> </li> <li> <p>Emerging Markets: Nike's presence in emerging markets such as India, Brazil, and Southeast Asia provides opportunities for growth, given the rising disposable incomes, urbanization, and increasing focus on health and fitness. However, challenges such as currency fluctuations, regulatory changes, and competition from local brands could impact Nike's performance in these markets.</p> </li> </ol> <p>Overall, Nike's major markets exhibit a mix of opportunities and challenges, with economic conditions influenced by global trends, geopolitical factors, and consumer preferences.\"  ### Current Consumer Preferences in the Sports Apparel Industry</p> <ol> <li> <p>Sustainability: Consumers are increasingly seeking eco-friendly and sustainable options in sports apparel, driving brands to focus on using recycled materials, reducing waste, and promoting ethical practices.</p> </li> <li> <p>Athleisure: The trend of athleisure wear continues to be popular, with consumers looking for versatile and comfortable clothing that can be worn both during workouts and in everyday life.</p> </li> <li> <p>Performance and Functionality: Consumers prioritize performance-enhancing features in sports apparel, such as moisture-wicking fabrics, breathable materials, and ergonomic designs that enhance comfort and mobility.</p> </li> <li> <p>Personalization: Customization options, personalized fit, and unique design elements are appealing to consumers who seek individuality and exclusivity in their sports apparel choices.</p> </li> <li> <p>Brand Transparency: Consumers value transparency in brand practices, including supply chain transparency, ethical sourcing, and clear communication on product quality and manufacturing processes.</p> </li> </ol> <p>Overall, consumer preferences in the sports apparel industry are shifting towards sustainability, versatility, performance, personalization, and transparency, influencing brand strategies and product offerings.   ### Potential New Markets for Nike to Explore in 2024</p> <ol> <li> <p>India: With a growing population, increasing disposable incomes, and a rising interest in health and fitness, India presents a significant opportunity for Nike to expand its presence and tap into a large consumer base.</p> </li> <li> <p>Africa: The African market, particularly countries with emerging economies and a young population, offers potential for Nike to introduce its products and capitalize on the growing demand for sportswear and athletic footwear.</p> </li> <li> <p>Middle East: Countries in the Middle East, known for their luxury shopping destinations and a growing interest in sports and fitness activities, could be strategic markets for Nike to target and establish a strong foothold.</p> </li> <li> <p>Latin America: Markets in Latin America, such as Brazil, Mexico, and Argentina, present opportunities for Nike to cater to a diverse consumer base and leverage the region's passion for sports and active lifestyles.</p> </li> <li> <p>Southeast Asia: Rapid urbanization, increasing urban middle-class population, and a trend towards health and wellness in countries like Indonesia, Thailand, and Vietnam make Southeast Asia an attractive region for Nike to explore and expand its market reach.</p> </li> </ol> <p>By exploring these new markets in 2024, Nike can diversify its geographical presence, reach untapped consumer segments, and drive growth in emerging economies.   ### Potential New Products or Services Nike Could Introduce in 2024</p> <ol> <li> <p>Smart Apparel: Nike could explore the integration of technology into its apparel, such as smart fabrics that monitor performance metrics, provide feedback, or enhance comfort during workouts.</p> </li> <li> <p>Athletic Accessories: Introducing a line of athletic accessories like gym bags, water bottles, or fitness trackers could complement Nike's existing product offerings and provide additional value to customers.</p> </li> <li> <p>Customization Platforms: Offering personalized design options for footwear and apparel through online customization platforms could appeal to consumers seeking unique and tailored products.</p> </li> <li> <p>Athletic Recovery Gear: Developing recovery-focused products like compression wear, recovery sandals, or massage tools could cater to athletes and fitness enthusiasts looking to enhance post-workout recovery.</p> </li> <li> <p>Sustainable Collections: Launching sustainable collections made from eco-friendly materials, recycled fabrics, or biodegradable components could align with consumer preferences for environmentally conscious products.</p> </li> </ol> <p>By introducing these new products or services in 2024, Nike can innovate its product portfolio, cater to evolving consumer needs, and differentiate itself in the competitive sports apparel market.   ### Potential Marketing Strategies for Nike to Increase Revenue in Q3 2024</p> <ol> <li> <p>Influencer Partnerships: Collaborating with popular athletes, celebrities, or social media influencers to promote Nike products can help reach a wider audience and drive sales.</p> </li> <li> <p>Interactive Campaigns: Launching interactive marketing campaigns, contests, or events that engage customers and create buzz around new product releases can generate excitement and increase brand visibility.</p> </li> <li> <p>Social Media Engagement: Leveraging social media platforms to connect with consumers, share user-generated content, and respond to feedback can build brand loyalty and encourage repeat purchases.</p> </li> <li> <p>Localized Marketing: Tailoring marketing messages, promotions, and product offerings to specific regions or target demographics can enhance relevance and appeal to diverse consumer groups.</p> </li> <li> <p>Customer Loyalty Programs: Implementing loyalty programs, exclusive offers, or rewards for repeat customers can incentivize brand loyalty, increase retention rates, and drive higher lifetime customer value.</p> </li> </ol> <p>By employing these marketing strategies in Q3 2024, Nike can enhance its brand presence, attract new customers, and ultimately boost revenue growth.</p>"},{"location":"applications/customer_support/","title":"Customer support","text":""},{"location":"applications/customer_support/#applications-of-swarms-revolutionizing-customer-support","title":"Applications of Swarms: Revolutionizing Customer Support","text":"<p>Introduction: In today's fast-paced digital world, responsive and efficient customer support is a linchpin for business success. The introduction of AI-driven swarms in the customer support domain can transform the way businesses interact with and assist their customers. By leveraging the combined power of multiple AI agents working in concert, businesses can achieve unprecedented levels of efficiency, customer satisfaction, and operational cost savings.</p>"},{"location":"applications/customer_support/#the-benefits-of-using-swarms-for-customer-support","title":"The Benefits of Using Swarms for Customer Support:","text":"<ol> <li> <p>24/7 Availability: Swarms never sleep. Customers receive instantaneous support at any hour, ensuring constant satisfaction and loyalty.</p> </li> <li> <p>Infinite Scalability: Whether it's ten inquiries or ten thousand, swarms can handle fluctuating volumes with ease, eliminating the need for vast human teams and minimizing response times.</p> </li> <li> <p>Adaptive Intelligence: Swarms learn collectively, meaning that a solution found for one customer can be instantly applied to benefit all. This leads to constantly improving support experiences, evolving with every interaction.</p> </li> </ol>"},{"location":"applications/customer_support/#features-reinventing-customer-support","title":"Features - Reinventing Customer Support:","text":"<ul> <li> <p>AI Inbox Monitor: Continuously scans email inboxes, identifying and categorizing support requests for swift responses.</p> </li> <li> <p>Intelligent Debugging: Proactively helps customers by diagnosing and troubleshooting underlying issues.</p> </li> <li> <p>Automated Refunds &amp; Coupons: Seamless integration with payment systems like Stripe allows for instant issuance of refunds or coupons if a problem remains unresolved.</p> </li> <li> <p>Full System Integration: Holistically connects with CRM, email systems, and payment portals, ensuring a cohesive and unified support experience.</p> </li> <li> <p>Conversational Excellence: With advanced LLMs (Language Model Transformers), the swarm agents can engage in natural, human-like conversations, enhancing customer comfort and trust.</p> </li> <li> <p>Rule-based Operation: By working with rule engines, swarms ensure that all actions adhere to company guidelines, ensuring consistent, error-free support.</p> </li> <li> <p>Turing Test Ready: Crafted to meet and exceed the Turing Test standards, ensuring that every customer interaction feels genuine and personal.</p> </li> </ul> <p>Conclusion: Swarms are not just another technological advancement; they represent the future of customer support. Their ability to provide round-the-clock, scalable, and continuously improving support can redefine customer experience standards. By adopting swarms, businesses can stay ahead of the curve, ensuring unparalleled customer loyalty and satisfaction.</p> <p>Experience the future of customer support. Dive into the swarm revolution.</p>"},{"location":"applications/marketing_agencies/","title":"Marketing agencies","text":""},{"location":"applications/marketing_agencies/#swarms-in-marketing-agencies-a-new-era-of-automated-media-strategy","title":"Swarms in Marketing Agencies: A New Era of Automated Media Strategy","text":""},{"location":"applications/marketing_agencies/#introduction","title":"Introduction:","text":"<ul> <li>Brief background on marketing agencies and their role in driving brand narratives and sales.</li> <li>Current challenges and pain points faced in media planning, placements, and budgeting.</li> <li>Introduction to the transformative potential of swarms in reshaping the marketing industry.</li> </ul>"},{"location":"applications/marketing_agencies/#1-fundamental-problem-media-plan-creation","title":"1. Fundamental Problem: Media Plan Creation:","text":"<ul> <li> <p>Definition: The challenge of creating an effective media plan that resonates with a target audience and aligns with brand objectives.</p> </li> <li> <p>Traditional Solutions and Their Shortcomings: Manual brainstorming sessions, over-reliance on past strategies, and long turnaround times leading to inefficiency.</p> </li> <li> <p>How Swarms Address This Problem: </p> <ul> <li>Benefit 1: Automated Media Plan Generation \u2013 Swarms ingest branding summaries, objectives, and marketing strategies to generate media plans, eliminating guesswork and human error.</li> <li>Real-world Application of Swarms: The automation of media plans based on client briefs, including platform selections, audience targeting, and creative versions.</li> </ul> </li> </ul>"},{"location":"applications/marketing_agencies/#2-fundamental-problem-media-placements","title":"2. Fundamental Problem: Media Placements:","text":"<ul> <li> <p>Definition: The tedious task of determining where ads will be placed, considering demographics, platform specifics, and more.</p> </li> <li> <p>Traditional Solutions and Their Shortcomings: Manual placement leading to possible misalignment with target audiences and brand objectives.</p> </li> <li> <p>How Swarms Address This Problem: </p> <ul> <li>Benefit 2: Precision Media Placements \u2013 Swarms analyze audience data and demographics to suggest the best placements, optimizing for conversions and brand reach.</li> <li>Real-world Application of Swarms: Automated selection of ad placements across platforms like Facebook, Google, and DSPs based on media plans.</li> </ul> </li> </ul>"},{"location":"applications/marketing_agencies/#3-fundamental-problem-budgeting","title":"3. Fundamental Problem: Budgeting:","text":"<ul> <li> <p>Definition: Efficiently allocating and managing advertising budgets across multiple campaigns, platforms, and timeframes.</p> </li> <li> <p>Traditional Solutions and Their Shortcomings: Manual budgeting using tools like Excel, prone to errors, and inefficient shifts in allocations.</p> </li> <li> <p>How Swarms Address This Problem: </p> <ul> <li>Benefit 3: Intelligent Media Budgeting \u2013 Swarms enable dynamic budget allocation based on performance analytics, maximizing ROI.</li> <li>Real-world Application of Swarms: Real-time adjustments in budget allocations based on campaign performance, eliminating long waiting periods and manual recalculations.</li> </ul> </li> </ul>"},{"location":"applications/marketing_agencies/#features","title":"Features:","text":"<ol> <li>Automated Media Plan Generator: Input your objectives and receive a comprehensive media plan.</li> <li>Precision Media Placement Tool: Ensure your ads appear in the right places to the right people.</li> <li>Dynamic Budget Allocation: Maximize ROI with real-time budget adjustments.</li> <li>Integration with Common Tools: Seamless integration with tools like Excel and APIs for exporting placements.</li> <li>Conversational Platform: A suite of tools built for modern marketing agencies, bringing all tasks under one umbrella.</li> </ol>"},{"location":"applications/marketing_agencies/#testimonials","title":"Testimonials:","text":"<ul> <li>\"Swarms have completely revolutionized our media planning process. What used to take weeks now takes mere hours.\" - Senior Media Strategist, Top-tier Marketing Agency</li> <li>\"The precision with which we can place ads now is unprecedented. It's like having a crystal ball for marketing!\" - Campaign Manager, Global Advertising Firm</li> </ul>"},{"location":"applications/marketing_agencies/#conclusion","title":"Conclusion:","text":"<ul> <li>Reiterate the immense potential of swarms in revolutionizing media planning, placements, and budgeting for marketing agencies.</li> <li>Call to action: For marketing agencies looking to step into the future and leave manual inefficiencies behind, swarms are the answer.</li> </ul>"},{"location":"concepts/limitations/","title":"Limitations of Individual Agents","text":"<p>This section explores the fundamental limitations of individual AI agents and why multi-agent systems are necessary for complex tasks. Understanding these limitations is crucial for designing effective multi-agent architectures.</p>"},{"location":"concepts/limitations/#overview","title":"Overview","text":"<pre><code>graph TD\n    A[Individual Agent Limitations] --&gt; B[Context Window Limits]\n    A --&gt; C[Hallucination]\n    A --&gt; D[Single Task Execution]\n    A --&gt; E[Lack of Collaboration]\n    A --&gt; F[Accuracy Issues]\n    A --&gt; G[Processing Speed]</code></pre>"},{"location":"concepts/limitations/#1-context-window-limits","title":"1. Context Window Limits","text":""},{"location":"concepts/limitations/#the-challenge","title":"The Challenge","text":"<p>Individual agents are constrained by fixed context windows, limiting their ability to process large amounts of information simultaneously.</p> <pre><code>graph LR\n    subgraph \"Context Window Limitation\"\n        Input[Large Document] --&gt; Truncation[Truncation]\n        Truncation --&gt; ProcessedPart[Processed Part]\n        Truncation --&gt; UnprocessedPart[Unprocessed Part]\n    end</code></pre>"},{"location":"concepts/limitations/#impact","title":"Impact","text":"<ul> <li>Limited understanding of large documents</li> <li>Fragmented processing of long conversations</li> <li>Inability to maintain extended context</li> <li>Loss of important information</li> </ul>"},{"location":"concepts/limitations/#2-hallucination","title":"2. Hallucination","text":""},{"location":"concepts/limitations/#the-challenge_1","title":"The Challenge","text":"<p>Individual agents may generate plausible-sounding but incorrect information, especially when dealing with ambiguous or incomplete data.</p> <pre><code>graph TD\n    Input[Ambiguous Input] --&gt; Agent[AI Agent]\n    Agent --&gt; Valid[Valid Output]\n    Agent --&gt; Hallucination[Hallucinated Output]\n    style Hallucination fill:#ff9999</code></pre>"},{"location":"concepts/limitations/#impact_1","title":"Impact","text":"<ul> <li>Unreliable information generation</li> <li>Reduced trust in system outputs</li> <li>Potential for misleading decisions</li> <li>Need for extensive verification</li> </ul>"},{"location":"concepts/limitations/#3-single-task-execution","title":"3. Single Task Execution","text":""},{"location":"concepts/limitations/#the-challenge_2","title":"The Challenge","text":"<p>Most individual agents are optimized for specific tasks and struggle with multi-tasking or adapting to new requirements.</p> <pre><code>graph LR\n    Task1[Task A] --&gt; Agent1[Agent A]\n    Task2[Task B] --&gt; Agent2[Agent B]\n    Task3[Task C] --&gt; Agent3[Agent C]\n    Agent1 --&gt; Output1[Output A]\n    Agent2 --&gt; Output2[Output B]\n    Agent3 --&gt; Output3[Output C]</code></pre>"},{"location":"concepts/limitations/#impact_2","title":"Impact","text":"<ul> <li>Limited flexibility</li> <li>Inefficient resource usage</li> <li>Complex integration requirements</li> <li>Reduced adaptability</li> </ul>"},{"location":"concepts/limitations/#4-lack-of-collaboration","title":"4. Lack of Collaboration","text":""},{"location":"concepts/limitations/#the-challenge_3","title":"The Challenge","text":"<p>Individual agents operate in isolation, unable to share insights or coordinate actions with other agents.</p> <pre><code>graph TD\n    A1[Agent 1] --&gt; O1[Output 1]\n    A2[Agent 2] --&gt; O2[Output 2]\n    A3[Agent 3] --&gt; O3[Output 3]\n    style A1 fill:#f9f,stroke:#333\n    style A2 fill:#f9f,stroke:#333\n    style A3 fill:#f9f,stroke:#333</code></pre>"},{"location":"concepts/limitations/#impact_3","title":"Impact","text":"<ul> <li>No knowledge sharing</li> <li>Duplicate effort</li> <li>Missed optimization opportunities</li> <li>Limited problem-solving capabilities</li> </ul>"},{"location":"concepts/limitations/#5-accuracy-issues","title":"5. Accuracy Issues","text":""},{"location":"concepts/limitations/#the-challenge_4","title":"The Challenge","text":"<p>Individual agents may produce inaccurate results due to: - Limited training data - Model biases - Lack of cross-validation - Incomplete context understanding</p> <pre><code>graph LR\n    Input[Input Data] --&gt; Processing[Processing]\n    Processing --&gt; Accurate[Accurate Output]\n    Processing --&gt; Inaccurate[Inaccurate Output]\n    style Inaccurate fill:#ff9999</code></pre>"},{"location":"concepts/limitations/#6-processing-speed-limitations","title":"6. Processing Speed Limitations","text":""},{"location":"concepts/limitations/#the-challenge_5","title":"The Challenge","text":"<p>Individual agents may experience: - Slow response times - Resource constraints - Limited parallel processing - Bottlenecks in complex tasks</p> <pre><code>graph TD\n    Input[Input] --&gt; Queue[Processing Queue]\n    Queue --&gt; Processing[Sequential Processing]\n    Processing --&gt; Delay[Processing Delay]\n    Delay --&gt; Output[Delayed Output]</code></pre>"},{"location":"concepts/limitations/#best-practices-for-mitigation","title":"Best Practices for Mitigation","text":"<ol> <li>Use Multi-Agent Systems</li> <li>Distribute tasks across agents</li> <li>Enable parallel processing</li> <li>Implement cross-validation</li> <li> <p>Foster collaboration</p> </li> <li> <p>Implement Verification</p> </li> <li>Cross-check results</li> <li>Use consensus mechanisms</li> <li>Monitor accuracy metrics</li> <li> <p>Track performance</p> </li> <li> <p>Optimize Resource Usage</p> </li> <li>Balance load distribution</li> <li>Cache frequent operations</li> <li>Implement efficient queuing</li> <li>Monitor system health</li> </ol>"},{"location":"concepts/limitations/#conclusion","title":"Conclusion","text":"<p>Understanding these limitations is crucial for: - Designing robust multi-agent systems - Implementing effective mitigation strategies - Optimizing system performance - Ensuring reliable outputs</p> <p>The next section explores how Multi-Agent Architecture addresses these limitations through collaborative approaches and specialized agent roles. </p>"},{"location":"contributors/docs/","title":"Contributing to Swarms Documentation","text":"<p>The Swarms documentation serves as the primary gateway for developer and user engagement within the Swarms ecosystem. Comprehensive, clear, and consistently updated documentation accelerates adoption, reduces support requests, and helps maintain a thriving developer community. This guide offers an in-depth, actionable framework for contributing to the Swarms documentation site, covering the full lifecycle from initial setup to the implementation of our bounty-based rewards program. </p> <p>This guide is designed for first-time contributors, experienced engineers, and technical writers alike. It emphasizes professional standards, collaborative development practices, and incentivized participation through our structured rewards program. Contributors play a key role in helping us scale and evolve our ecosystem by improving the clarity, accessibility, and technical depth of our documentation.</p>"},{"location":"contributors/docs/#1-introduction","title":"1. Introduction","text":"<p>Documentation in the Swarms ecosystem is not simply static text. It is a living, breathing system that guides users, developers, and enterprises in effectively utilizing our frameworks, SDKs, APIs, and tools. Whether you are documenting a new feature, refining an API call, writing a tutorial, or correcting existing information, every contribution has a direct impact on the product\u2019s usability and user satisfaction. </p> <p>Objectives of this Guide:</p> <ul> <li> <p>Define a standardized contribution workflow for Swarms documentation.</p> </li> <li> <p>Clarify documentation roles, responsibilities, and submission expectations.</p> </li> <li> <p>Establish quality benchmarks, review procedures, and formatting rules.</p> </li> <li> <p>Introduce the Swarms Documentation Bounty Program to incentivize excellence.</p> </li> </ul>"},{"location":"contributors/docs/#2-why-documentation-is-a-strategic-asset","title":"2. Why Documentation Is a Strategic Asset","text":"<ol> <li>Accelerates Onboarding: Reduces friction for new users, enabling faster adoption and integration.</li> <li>Improves Support Efficiency: Decreases dependency on live support and helps automate resolution of common queries.</li> <li>Builds Community Trust: Transparent documentation invites feedback and fosters a sense of shared ownership.</li> <li>Enables Scalability: As Swarms evolves, up-to-date documentation ensures that teams across the globe can keep pace.</li> </ol> <p>By treating documentation as a core product component, we ensure continuity, scalability, and user satisfaction.</p>"},{"location":"contributors/docs/#3-understanding-the-swarms-ecosystem","title":"3. Understanding the Swarms Ecosystem","text":"<p>The Swarms ecosystem consists of multiple tightly integrated components that serve developers and enterprise clients alike:</p> <ul> <li> <p>Core Documentation Repository: The main documentation hub for all Swarms technologies GitHub.</p> </li> <li> <p>Rust SDK (<code>swarms_rs</code>): Official documentation for the Rust implementation. Repo.</p> </li> <li> <p>Tools Documentation (<code>swarms_tools</code>): Guides for CLI and GUI utilities.</p> </li> <li> <p>Hosted API Reference: Up-to-date REST API documentation: Swarms API Docs.</p> </li> <li> <p>Marketplace &amp; Chat: Web platforms and communication interfaces swarms.world.</p> </li> </ul> <p>All contributions funnel through the <code>docs/</code> directory in the core repo and are structured via MkDocs.</p>"},{"location":"contributors/docs/#4-documentation-tools-and-platforms","title":"4. Documentation Tools and Platforms","text":"<p>Swarms documentation is powered by MkDocs, an extensible static site generator tailored for project documentation. To contribute, you should be comfortable with:</p> <ul> <li> <p>Markdown: For formatting structure, code snippets, lists, and links.</p> </li> <li> <p>MkDocs Configuration: <code>mkdocs.yml</code> manages structure, theme, and navigation.</p> </li> <li> <p>Version Control: GitHub for branching, version tracking, and collaboration.</p> </li> </ul> <p>Recommended Tooling:</p> <ul> <li> <p>Markdown linters to enforce syntax consistency.</p> </li> <li> <p>Spellcheckers to ensure grammatical accuracy.</p> </li> <li> <p>Doc generators for automated API reference extraction.</p> </li> </ul>"},{"location":"contributors/docs/#5-getting-started-with-contributions","title":"5. Getting Started with Contributions","text":""},{"location":"contributors/docs/#51-system-requirements","title":"5.1 System Requirements","text":"<ul> <li> <p>Git v2.30 or higher</p> </li> <li> <p>Node.js and npm for related dependency management</p> </li> <li> <p>MkDocs and Material for MkDocs theme (<code>pip install mkdocs mkdocs-material</code>)</p> </li> <li> <p>A GitHub account with permissions to fork and submit pull requests</p> </li> </ul>"},{"location":"contributors/docs/#52-forking-the-swarms-repository","title":"5.2 Forking the Swarms Repository","text":"<ol> <li> <p>Visit: <code>https://github.com/kyegomez/swarms</code></p> </li> <li> <p>Click on Fork to create your version of the repository</p> </li> </ol>"},{"location":"contributors/docs/#53-clone-and-configure-locally","title":"5.3 Clone and Configure Locally","text":"<pre><code>git clone https://github.com/&lt;your-username&gt;/swarms.git\ncd swarms/docs\ngit checkout -b feature/docs-&lt;short-description&gt;\n</code></pre>"},{"location":"contributors/docs/#6-understanding-the-repository-structure","title":"6. Understanding the Repository Structure","text":"<p>Explore the documentation directory:</p> <pre><code>docs/\n\u251c\u2500\u2500 index.md\n\u251c\u2500\u2500 mkdocs.yml\n\u251c\u2500\u2500 swarms_rs/\n\u2502   \u251c\u2500\u2500 overview.md\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 swarms_tools/\n    \u251c\u2500\u2500 install.md\n    \u2514\u2500\u2500 ...\n</code></pre>"},{"location":"contributors/docs/#61-sdktools-directories","title":"6.1 SDK/Tools Directories","text":"<ul> <li> <p>Rust SDK (<code>docs/swarms_rs</code>): Guides, references, and API walkthroughs for the Rust-based implementation.</p> </li> <li> <p>Swarms Tools (<code>docs/swarms_tools</code>): CLI guides, GUI usage instructions, and architecture documentation.</p> </li> </ul> <p>Add new <code>.md</code> files in the folder corresponding to your documentation type.</p>"},{"location":"contributors/docs/#62-configuring-navigation-in-mkdocs","title":"6.2 Configuring Navigation in MkDocs","text":"<p>Update <code>mkdocs.yml</code> to integrate your new document:</p> <pre><code>nav:\n  - Home: index.md\n  - Swarms Rust:\n      - Overview: swarms_rs/overview.md\n      - Your Topic: swarms_rs/your_file.md\n  - Swarms Tools:\n      - Installation: swarms_tools/install.md\n      - Your Guide: swarms_tools/your_file.md\n</code></pre>"},{"location":"contributors/docs/#7-writing-and-editing-documentation","title":"7. Writing and Editing Documentation","text":""},{"location":"contributors/docs/#71-content-standards","title":"7.1 Content Standards","text":"<ul> <li> <p>Clarity: Explain complex ideas in simple, direct language.</p> </li> <li> <p>Style Consistency: Match the tone and structure of existing docs.</p> </li> <li> <p>Accuracy: Validate all technical content and code snippets.</p> </li> <li> <p>Accessibility: Include alt text for images and use semantic Markdown.</p> </li> </ul>"},{"location":"contributors/docs/#72-markdown-best-practices","title":"7.2 Markdown Best Practices","text":"<ul> <li> <p>Sequential heading levels (<code>#</code>, <code>##</code>, <code>###</code>)</p> </li> <li> <p>Use fenced code blocks with language identifiers</p> </li> <li> <p>Create readable line spacing and avoid unnecessary line breaks</p> </li> </ul>"},{"location":"contributors/docs/#73-file-placement-protocol","title":"7.3 File Placement Protocol","text":"<p>Place <code>.md</code> files into the correct subdirectory:</p> <ul> <li> <p>Rust SDK Docs: <code>docs/swarms_rs/</code></p> </li> <li> <p>Tooling Docs: <code>docs/swarms_tools/</code></p> </li> </ul>"},{"location":"contributors/docs/#8-updating-navigation-configuration","title":"8. Updating Navigation Configuration","text":"<p>After writing your content:</p> <ol> <li>Open <code>mkdocs.yml</code></li> <li>Identify where your file belongs</li> <li>Add it to the <code>nav</code> hierarchy</li> <li>Preview changes:</li> </ol> <pre><code>mkdocs serve\n# Open http://127.0.0.1:8000 to verify output\n</code></pre>"},{"location":"contributors/docs/#9-workflow-branches-commits-pull-requests","title":"9. Workflow: Branches, Commits, Pull Requests","text":""},{"location":"contributors/docs/#91-branch-naming-guidelines","title":"9.1 Branch Naming Guidelines","text":"<ul> <li>Use prefix and description, e.g.:</li> <li> <p><code>feature/docs-api-pagination</code></p> </li> <li> <p><code>fix/docs-typo-tooling</code></p> </li> </ul>"},{"location":"contributors/docs/#92-writing-clear-commits","title":"9.2 Writing Clear Commits","text":"<p>Follow Conventional Commits:</p> <pre><code>docs(swarms_rs): add stream API tutorial\ndocs(swarms_tools): correct CLI usage example\n</code></pre>"},{"location":"contributors/docs/#93-submitting-a-pull-request","title":"9.3 Submitting a Pull Request","text":"<ol> <li>Push your feature branch</li> <li>Open a new PR to the main repository</li> <li>Use a descriptive title and include:</li> <li>Summary of changes</li> <li>Justification</li> <li>Screenshots or previews</li> <li>Tag relevant reviewers and apply labels (<code>documentation</code>, <code>bounty-eligible</code>)</li> </ol>"},{"location":"contributors/docs/#10-review-qa-and-merging","title":"10. Review, QA, and Merging","text":"<p>Every PR undergoes automated and human review:</p> <ul> <li> <p>CI Checks: Syntax validation, link checking, and formatting</p> </li> <li> <p>Manual Review: Maintain clarity, completeness, and relevance</p> </li> <li> <p>Iteration: Collaborate through feedback and finalize changes</p> </li> </ul> <p>Once approved, maintainers will merge and deploy the updated documentation.</p>"},{"location":"contributors/docs/#11-swarms-documentation-bounty-initiative","title":"11. Swarms Documentation Bounty Initiative","text":"<p>To foster continuous improvement, we offer structured rewards for eligible contributions:</p>"},{"location":"contributors/docs/#111-contribution-types","title":"11.1 Contribution Types","text":"<ul> <li> <p>Creating comprehensive new tutorials and deep dives</p> </li> <li> <p>Updating outdated references and examples</p> </li> <li> <p>Fixing typos, grammar, and formatting errors</p> </li> <li> <p>Translating existing content</p> </li> </ul>"},{"location":"contributors/docs/#112-reward-structure","title":"11.2 Reward Structure","text":"Tier Description Payout (USD) Bronze Typos or minor enhancements (&lt; 100 words) $1 - $5 Silver Small tutorials, API examples (100\u2013500 words) $5 - $20 Gold Major updates or guides (&gt; 500 words) $20 - $50 Platinum Multi-part guides or new documentation verticals $50 - 300"},{"location":"contributors/docs/#113-claiming-bounties","title":"11.3 Claiming Bounties","text":"<ol> <li>Label your PR <code>bounty-eligible</code></li> <li>Describe expected tier and rationale</li> <li>Review team assesses scope and assigns reward</li> <li>Rewards paid post-merge via preferred method (PayPal, crypto, or wire)</li> </ol>"},{"location":"contributors/docs/#12-best-practices-for-efficient-contribution","title":"12. Best Practices for Efficient Contribution","text":"<ul> <li> <p>Stay Updated: Sync your fork weekly to avoid merge conflicts</p> </li> <li> <p>Atomic PRs: Submit narrowly scoped changes for faster review</p> </li> <li> <p>Use Visuals: Support documentation with screenshots or diagrams</p> </li> <li> <p>Cross-Reference: Link to related documentation for completeness</p> </li> <li> <p>Version Awareness: Specify SDK/tool versions in code examples</p> </li> </ul>"},{"location":"contributors/docs/#13-style-guide-snapshot","title":"13. Style Guide Snapshot","text":"<ul> <li> <p>Voice: Informative, concise, and respectful</p> </li> <li> <p>Terminology: Use standardized terms (<code>Swarm</code>, <code>Swarms</code>) consistently</p> </li> <li> <p>Code: Format snippets using language-specific linters</p> </li> <li> <p>Accessibility: Include alt attributes and avoid ambiguous links</p> </li> </ul>"},{"location":"contributors/docs/#14-monitoring-improving-documentation-health","title":"14. Monitoring &amp; Improving Documentation Health","text":"<p>We use analytics and community input to prioritize improvements:</p> <ul> <li> <p>Traffic Reports: Track most/least visited pages</p> </li> <li> <p>Search Logs: Detect content gaps from common search terms</p> </li> <li> <p>Feedback Forms: Collect real-world user input</p> </li> </ul> <p>Schedule quarterly audits to refine structure and content across all repositories.</p>"},{"location":"contributors/docs/#15-community-promotion-engagement","title":"15. Community Promotion &amp; Engagement","text":"<p>Promote your contributions via:</p> <ul> <li> <p>Swarms Discord: https://discord.gg/jM3Z6M9uMq</p> </li> <li> <p>Swarms Telegram: https://t.me/swarmsgroupchat</p> </li> <li> <p>Swarms Twitter: https://x.com/swarms_corp</p> </li> <li> <p>Startup Program Showcases: https://www.swarms.xyz/programs/startups</p> </li> </ul> <p>Active contributors are often spotlighted for leadership roles and community awards.</p>"},{"location":"contributors/docs/#16-resource-index","title":"16. Resource Index","text":"<ul> <li> <p>Core GitHub Repo: https://github.com/kyegomez/swarms</p> </li> <li> <p>Rust SDK Repo: https://github.com/The-Swarm-Corporation/swarms-rs</p> </li> <li> <p>Swarms API Docs: https://docs.swarms.world/en/latest/swarms_cloud/swarms_api/</p> </li> <li> <p>Marketplace: https://swarms.world</p> </li> </ul> <p>Join our monthly Documentation Office Hours for real-time mentorship and Q&amp;A.</p>"},{"location":"contributors/docs/#17-frequently-asked-questions","title":"17. Frequently Asked Questions","text":"<p>Q1: Is MkDocs required to contribute? A: It's recommended but not required; Markdown knowledge is sufficient to get started.</p> <p>Q2: Can I rework existing sections? A: Yes, propose changes via issues first, or submit PRs with clear descriptions.</p> <p>Q3: When are bounties paid? A: Within 30 days of merge, following internal validation.</p>"},{"location":"contributors/docs/#18-final-thoughts","title":"18. Final Thoughts","text":"<p>The Swarms documentation is a critical piece of our technology stack. As a contributor, your improvements\u2014big or small\u2014directly impact adoption, user retention, and developer satisfaction. This guide aims to equip you with the tools, practices, and incentives to make meaningful contributions. Your work helps us deliver a more usable, scalable, and inclusive platform.</p> <p>We look forward to your pull requests, feedback, and ideas.</p>"},{"location":"contributors/environment_setup/","title":"Environment Setup Guide for Swarms Contributors","text":"<p>Welcome to the Swarms development environment setup guide! This comprehensive guide will walk you through setting up your development environment from scratch, whether you're a first-time contributor or an experienced developer.</p> <p>\ud83d\ude80 One-Click Setup (Recommended)</p> <p>New! Use our automated setup script that handles everything: <pre><code>git clone https://github.com/kyegomez/swarms.git\ncd swarms\nchmod +x scripts/setup.sh\n./scripts/setup.sh\n</code></pre> This script automatically installs Poetry, creates a virtual environment, installs all dependencies, sets up pre-commit hooks, and more!</p> <p>Manual Setup</p> <p>Alternative: For manual control, install Python 3.10+, Git, and Poetry, then run: <pre><code>git clone https://github.com/kyegomez/swarms.git\ncd swarms\npoetry install --with dev\n</code></pre></p>"},{"location":"contributors/environment_setup/#prerequisites","title":"Prerequisites","text":"<p>Before setting up your development environment, ensure you have the following installed:</p>"},{"location":"contributors/environment_setup/#system-requirements","title":"System Requirements","text":"Tool Version Purpose Python 3.10+ Core runtime Git 2.30+ Version control Poetry 1.4+ Dependency management (recommended) Node.js 16+ Documentation tools (optional)"},{"location":"contributors/environment_setup/#operating-system-support","title":"Operating System Support","text":"macOSUbuntu/DebianWindows <pre><code># Install Homebrew if not already installed\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\n# Install prerequisites\nbrew install python@3.10 git poetry node\n</code></pre> <pre><code># Update package list\nsudo apt update\n\n# Install Python 3.10 and pip\nsudo apt install python3.10 python3.10-venv python3-pip git curl\n\n# Install Poetry\ncurl -sSL https://install.python-poetry.org | python3 -\n\n# Add Poetry to PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\necho 'export PATH=\"$HOME/.local/bin:$PATH\"' &gt;&gt; ~/.bashrc\n</code></pre> <ol> <li>Install Python 3.10+ from python.org</li> <li>Install Git from git-scm.com</li> <li>Install Poetry using PowerShell: <pre><code>(Invoke-WebRequest -Uri https://install.python-poetry.org -UseBasicParsing).Content | python -\n</code></pre></li> </ol>"},{"location":"contributors/environment_setup/#automated-setup-recommended","title":"Automated Setup (Recommended)","text":"<p>We provide a comprehensive setup script that automates the entire development environment setup process. This is the recommended approach for new contributors.</p>"},{"location":"contributors/environment_setup/#what-the-setup-script-does","title":"What the Setup Script Does","text":"<p>The <code>scripts/setup.sh</code> script automatically handles:</p> <ul> <li>\u2705 Python Version Check: Verifies Python 3.10+ is installed</li> <li>\u2705 Poetry Installation: Installs Poetry if not present</li> <li>\u2705 Virtual Environment: Creates and configures a project-specific virtual environment</li> <li>\u2705 Dependencies: Installs all main, development, lint, and test dependencies</li> <li>\u2705 Pre-commit Hooks: Sets up and installs pre-commit hooks for code quality</li> <li>\u2705 Environment Template: Creates a <code>.env</code> file template with common variables</li> <li>\u2705 Verification: Runs initial setup verification checks</li> <li>\u2705 Helpful Output: Provides colored output and next steps</li> </ul>"},{"location":"contributors/environment_setup/#running-the-automated-setup","title":"Running the Automated Setup","text":"<pre><code># Clone the repository\ngit clone https://github.com/kyegomez/swarms.git\ncd swarms\n\n# Make the script executable and run it\nchmod +x scripts/setup.sh\n./scripts/setup.sh\n</code></pre>"},{"location":"contributors/environment_setup/#script-features","title":"Script Features","text":"\ud83c\udfaf Smart Detection\ud83d\udd27 Comprehensive Setup\ud83d\udccb Environment Template\ud83d\udca1 Helpful Guidance <p>The script intelligently detects your system state: - Checks if Poetry is already installed - Verifies Python version compatibility - Detects existing virtual environments - Checks for Git repository status</p> <p>Installs everything you need: <pre><code># All dependency groups\npoetry install --with dev,lint,test\n\n# Pre-commit hooks\npre-commit install\npre-commit install --hook-type commit-msg\n\n# Initial verification run\npre-commit run --all-files\n</code></pre></p> <p>Creates a starter <code>.env</code> file: <pre><code># Generated .env template\nOPENAI_API_KEY=your_openai_api_key_here\nANTHROPIC_API_KEY=your_anthropic_key_here\nLOG_LEVEL=INFO\nDEVELOPMENT=true\n</code></pre></p> <p>Provides next steps and useful commands: - How to activate the virtual environment - Essential Poetry commands - Testing and development workflow - Troubleshooting tips</p>"},{"location":"contributors/environment_setup/#when-to-use-manual-setup","title":"When to Use Manual Setup","text":"<p>Use the manual setup approach if you: - Want full control over each step - Have specific system requirements - Are troubleshooting installation issues - Prefer to understand each component</p>"},{"location":"contributors/environment_setup/#repository-setup","title":"Repository Setup","text":""},{"location":"contributors/environment_setup/#step-1-fork-and-clone","title":"Step 1: Fork and Clone","text":"<ol> <li> <p>Fork the repository on GitHub: github.com/kyegomez/swarms</p> </li> <li> <p>Clone your fork: <pre><code>git clone https://github.com/YOUR_USERNAME/swarms.git\ncd swarms\n</code></pre></p> </li> <li> <p>Add upstream remote: <pre><code>git remote add upstream https://github.com/kyegomez/swarms.git\n</code></pre></p> </li> <li> <p>Verify remotes: <pre><code>git remote -v\n# origin    https://github.com/YOUR_USERNAME/swarms.git (fetch)\n# origin    https://github.com/YOUR_USERNAME/swarms.git (push)\n# upstream  https://github.com/kyegomez/swarms.git (fetch)\n# upstream  https://github.com/kyegomez/swarms.git (push)\n</code></pre></p> </li> </ol>"},{"location":"contributors/environment_setup/#dependency-management","title":"Dependency Management","text":"<p>Choose your preferred method for managing dependencies:</p> Poetry (Recommended)pip + venv <p>Poetry provides superior dependency resolution and virtual environment management.</p> <p>Traditional pip-based setup with virtual environments.</p>"},{"location":"contributors/environment_setup/#installation","title":"Installation","text":"<pre><code># Navigate to project directory\ncd swarms\n\n# Install all dependencies including development tools\npoetry install --with dev,lint,test\n\n# Activate the virtual environment\npoetry shell\n</code></pre>"},{"location":"contributors/environment_setup/#useful-poetry-commands","title":"Useful Poetry Commands","text":"<pre><code># Add a new dependency\npoetry add package_name\n\n# Add a development dependency\npoetry add --group dev package_name\n\n# Update dependencies\npoetry update\n\n# Show dependency tree\npoetry show --tree\n\n# Run commands in the virtual environment\npoetry run python your_script.py\n</code></pre>"},{"location":"contributors/environment_setup/#installation_1","title":"Installation","text":"<pre><code># Navigate to project directory\ncd swarms\n\n# Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On macOS/Linux:\nsource venv/bin/activate\n# On Windows:\nvenv\\Scripts\\activate\n\n# Upgrade pip\npip install --upgrade pip\n\n# Install core dependencies\npip install -r requirements.txt\n\n# Install documentation dependencies (optional)\npip install -r docs/requirements.txt\n</code></pre>"},{"location":"contributors/environment_setup/#development-tools-setup","title":"Development Tools Setup","text":""},{"location":"contributors/environment_setup/#code-quality-tools","title":"Code Quality Tools","text":"<p>Swarms uses several tools to maintain code quality:</p> FormattingLintingType Checking <p>Black - Code formatter <pre><code># Format code\npoetry run black swarms/\n# or with pip:\nblack swarms/\n\n# Check formatting without making changes\nblack swarms/ --check --diff\n</code></pre></p> <p>Ruff - Fast Python linter <pre><code># Run linter\npoetry run ruff check swarms/\n# or with pip:\nruff check swarms/\n\n# Auto-fix issues\nruff check swarms/ --fix\n</code></pre></p> <p>MyPy - Static type checker <pre><code># Run type checking\npoetry run mypy swarms/\n# or with pip:\nmypy swarms/\n</code></pre></p>"},{"location":"contributors/environment_setup/#pre-commit-hooks-optional-but-recommended","title":"Pre-commit Hooks (Optional but Recommended)","text":"<p>Set up pre-commit hooks to automatically run quality checks:</p> <pre><code># Install pre-commit\npoetry add --group dev pre-commit\n# or with pip:\npip install pre-commit\n\n# Install git hooks\npre-commit install\n\n# Run on all files\npre-commit run --all-files\n</code></pre> <p>The project uses the latest ruff-pre-commit configuration with separate hooks for linting and formatting:</p> <ul> <li>ruff-check: Runs the linter with automatic fixes (<code>--fix</code> flag)</li> <li>ruff-format: Runs the formatter for code styling</li> <li>types_or: [python, pyi]: Excludes Jupyter notebooks from processing</li> </ul> <p>This configuration ensures consistent code quality and style across the project while avoiding conflicts with Jupyter notebook files.</p>"},{"location":"contributors/environment_setup/#testing-setup","title":"Testing Setup","text":""},{"location":"contributors/environment_setup/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\npoetry run pytest\n# or with pip:\npytest\n\n# Run tests with coverage\npoetry run pytest --cov=swarms tests/\n\n# Run specific test file\npoetry run pytest tests/test_specific_file.py\n\n# Run tests matching a pattern\npoetry run pytest -k \"test_agent\"\n</code></pre>"},{"location":"contributors/environment_setup/#test-structure","title":"Test Structure","text":"<p>The project uses pytest with the following structure: <pre><code>tests/\n\u251c\u2500\u2500 agents/          # Agent-related tests\n\u251c\u2500\u2500 structs/         # Multi-agent structure tests\n\u251c\u2500\u2500 tools/           # Tool tests\n\u251c\u2500\u2500 utils/           # Utility tests\n\u2514\u2500\u2500 conftest.py      # Test configuration\n</code></pre></p>"},{"location":"contributors/environment_setup/#writing-tests","title":"Writing Tests","text":"<pre><code># Example test file: tests/test_example.py\nimport pytest\nfrom swarms import Agent\n\ndef test_agent_creation():\n    \"\"\"Test that an agent can be created successfully.\"\"\"\n    agent = Agent(\n        agent_name=\"test_agent\",\n        system_prompt=\"You are a helpful assistant\"\n    )\n    assert agent.agent_name == \"test_agent\"\n\n@pytest.mark.parametrize(\"input_val,expected\", [\n    (\"hello\", \"HELLO\"),\n    (\"world\", \"WORLD\"),\n])\ndef test_uppercase(input_val, expected):\n    \"\"\"Example parametrized test.\"\"\"\n    assert input_val.upper() == expected\n</code></pre>"},{"location":"contributors/environment_setup/#documentation-setup","title":"Documentation Setup","text":""},{"location":"contributors/environment_setup/#building-documentation-locally","title":"Building Documentation Locally","text":"<pre><code># Install documentation dependencies\npip install -r docs/requirements.txt\n\n# Navigate to docs directory\ncd docs\n\n# Serve documentation locally\nmkdocs serve\n# Documentation will be available at http://127.0.0.1:8000\n</code></pre>"},{"location":"contributors/environment_setup/#documentation-structure","title":"Documentation Structure","text":"<pre><code>docs/\n\u251c\u2500\u2500 index.md              # Homepage\n\u251c\u2500\u2500 mkdocs.yml           # MkDocs configuration\n\u251c\u2500\u2500 swarms/              # Core documentation\n\u251c\u2500\u2500 examples/            # Examples and tutorials\n\u251c\u2500\u2500 contributors/        # Contributor guides\n\u2514\u2500\u2500 assets/              # Images and static files\n</code></pre>"},{"location":"contributors/environment_setup/#writing-documentation","title":"Writing Documentation","text":"<p>Use Markdown with MkDocs extensions:</p> <pre><code># Page Title\n\n!!! tip \"Pro Tip\"\n    Use admonitions to highlight important information.\n\n=== \"Python\"\n    ```python\n    from swarms import Agent\n    agent = Agent()\n    ```\n\n=== \"CLI\"\n    ```bash\n    swarms create-agent --name myagent\n    ```\n</code></pre>"},{"location":"contributors/environment_setup/#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file for local development:</p> <pre><code># Copy example environment file\ncp .env.example .env  # if it exists\n\n# Or create your own .env file\ntouch .env\n</code></pre> <p>Common environment variables: <pre><code># .env file\nOPENAI_API_KEY=your_openai_api_key_here\nANTHROPIC_API_KEY=your_anthropic_api_key_here\nGROQ_API_KEY=your_groq_api_key_here\n\n# Development settings\nDEBUG=true\nLOG_LEVEL=INFO\n\n# Optional: Database settings\nDATABASE_URL=sqlite:///swarms.db\n</code></pre></p>"},{"location":"contributors/environment_setup/#verification-steps","title":"Verification Steps","text":"<p>Automated Verification</p> <p>If you used the automated setup script (<code>./scripts/setup.sh</code>), most verification steps are handled automatically. The script runs verification checks and reports any issues.</p> <p>For manual setups, verify your setup is working correctly:</p>"},{"location":"contributors/environment_setup/#1-basic-import-test","title":"1. Basic Import Test","text":"<pre><code>poetry run python -c \"from swarms import Agent; print('\u2705 Import successful')\"\n</code></pre>"},{"location":"contributors/environment_setup/#2-run-a-simple-agent","title":"2. Run a Simple Agent","text":"<pre><code># test_setup.py\nfrom swarms import Agent\n\nagent = Agent(\n    agent_name=\"setup_test\",\n    system_prompt=\"You are a helpful assistant for testing setup.\",\n    max_loops=1\n)\n\nresponse = agent.run(\"Say hello!\")\nprint(f\"\u2705 Agent response: {response}\")\n</code></pre>"},{"location":"contributors/environment_setup/#3-code-quality-check","title":"3. Code Quality Check","text":"<pre><code># Run all quality checks\npoetry run black swarms/ --check\npoetry run ruff check swarms/\npoetry run pytest tests/ -x\n</code></pre>"},{"location":"contributors/environment_setup/#4-documentation-build","title":"4. Documentation Build","text":"<pre><code>cd docs\nmkdocs build\necho \"\u2705 Documentation built successfully\"\n</code></pre>"},{"location":"contributors/environment_setup/#development-workflow","title":"Development Workflow","text":""},{"location":"contributors/environment_setup/#creating-a-feature-branch","title":"Creating a Feature Branch","text":"<pre><code># Sync with upstream\ngit fetch upstream\ngit checkout master\ngit rebase upstream/master\n\n# Create feature branch\ngit checkout -b feature/your-feature-name\n\n# Make your changes...\n# Add and commit\ngit add .\ngit commit -m \"feat: add your feature description\"\n\n# Push to your fork\ngit push origin feature/your-feature-name\n</code></pre>"},{"location":"contributors/environment_setup/#daily-development-commands","title":"Daily Development Commands","text":"<pre><code># Start development session\ncd swarms\npoetry shell  # or source venv/bin/activate\n\n# Pull latest changes\ngit fetch upstream\ngit rebase upstream/master\n\n# Run tests during development\npoetry run pytest tests/ -v\n\n# Format and lint before committing\npoetry run black swarms/\npoetry run ruff check swarms/ --fix\n\n# Run a quick smoke test\npoetry run python -c \"from swarms import Agent; print('\u2705 All good')\"\n</code></pre>"},{"location":"contributors/environment_setup/#troubleshooting","title":"Troubleshooting","text":"<p>First Step: Try the Automated Setup</p> <p>If you're experiencing setup issues, try running our automated setup script first: <pre><code>chmod +x scripts/setup.sh\n./scripts/setup.sh\n</code></pre> This script handles most common setup problems automatically and provides helpful error messages.</p>"},{"location":"contributors/environment_setup/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"Poetry IssuesPython Version IssuesImport ErrorsTest Failures <p>Problem: Poetry command not found <pre><code># Solution: Add Poetry to PATH\nexport PATH=\"$HOME/.local/bin:$PATH\"\n# Add to your shell profile (.bashrc, .zshrc, etc.)\n</code></pre></p> <p>Problem: Poetry install fails <pre><code># Solution: Clear cache and reinstall\npoetry cache clear --all pypi\npoetry install --with dev\n</code></pre></p> <p>Problem: Wrong Python version <pre><code># Check Python version\npython --version\n\n# Use pyenv to manage Python versions\ncurl https://pyenv.run | bash\npyenv install 3.10.12\npyenv local 3.10.12\n</code></pre></p> <p>Problem: Cannot import swarms modules <pre><code># Ensure you're in the virtual environment\npoetry shell\n# or\nsource venv/bin/activate\n\n# Install in development mode\npoetry install --with dev\n# or\npip install -e .\n</code></pre></p> <p>Problem: Tests fail due to missing dependencies <pre><code># Install test dependencies\npoetry install --with test\n# or\npip install pytest pytest-cov pytest-mock\n</code></pre></p>"},{"location":"contributors/environment_setup/#getting-help","title":"Getting Help","text":"<p>If you encounter issues:</p> <ol> <li>Check the FAQ in the main documentation</li> <li>Search existing issues on GitHub</li> <li>Ask in the Discord community: discord.gg/jM3Z6M9uMq</li> <li>Create a GitHub issue with:</li> <li>Your operating system</li> <li>Python version</li> <li>Error messages</li> <li>Steps to reproduce</li> </ol>"},{"location":"contributors/environment_setup/#material-next-step-next-steps","title":":material-next-step: Next Steps","text":"<p>Now that your environment is set up:</p> <ol> <li>Read the Contributing Guide: contributors/main.md</li> <li>Explore the Codebase: Start with <code>swarms/structs/agent.py</code></li> <li>Run Examples: Check out <code>examples/</code> directory</li> <li>Pick an Issue: Look for <code>good-first-issue</code> labels on GitHub</li> <li>Join the Community: Discord, Twitter, and GitHub discussions</li> </ol> <p>You're Ready!</p> <p>Your Swarms development environment is now set up! You're ready to contribute to the most important technology for multi-agent collaboration.</p>"},{"location":"contributors/environment_setup/#quick-reference","title":"Quick Reference","text":""},{"location":"contributors/environment_setup/#essential-commands","title":"Essential Commands","text":"<pre><code># Setup (choose one)\n./scripts/setup.sh                   # Automated setup (recommended)\npoetry install --with dev            # Manual dependency install\n\n# Daily workflow\npoetry shell                          # Activate environment\npoetry run pytest                    # Run tests\npoetry run black swarms/             # Format code\npoetry run ruff check swarms/        # Lint code\n\n# Git workflow\ngit fetch upstream                    # Get latest changes\ngit rebase upstream/master           # Update your branch\ngit checkout -b feature/name         # Create feature branch\ngit push origin feature/name         # Push your changes\n\n# Documentation\ncd docs &amp;&amp; mkdocs serve              # Serve docs locally\nmkdocs build                         # Build docs\n</code></pre>"},{"location":"contributors/environment_setup/#project-structure","title":"Project Structure","text":"<pre><code>swarms/\n\u251c\u2500\u2500 swarms/              # Core package\n\u2502   \u251c\u2500\u2500 agents/         # Agent implementations\n\u2502   \u251c\u2500\u2500 structs/        # Multi-agent structures\n\u2502   \u251c\u2500\u2500 tools/          # Agent tools\n\u2502   \u2514\u2500\u2500 utils/          # Utilities\n\u251c\u2500\u2500 examples/           # Usage examples\n\u251c\u2500\u2500 tests/              # Test suite\n\u251c\u2500\u2500 docs/               # Documentation\n\u251c\u2500\u2500 pyproject.toml      # Poetry configuration\n\u2514\u2500\u2500 requirements.txt    # Pip dependencies\n</code></pre> <p>Happy coding! \ud83d\ude80 </p>"},{"location":"contributors/main/","title":"Contributing to Swarms: Building the Infrastructure for The Agentic Economy","text":"<p>Multi-agent collaboration is the most important technology in human history. It will reshape civilization by enabling billions of autonomous agents to coordinate and solve problems at unprecedented scale.</p> <p>The Foundation of Tomorrow</p> <p>Swarms is the foundational infrastructure powering this autonomous economy. By contributing, you're building the systems that will enable the next generation of intelligent automation.</p>"},{"location":"contributors/main/#what-youre-building","title":"What You're Building","text":"Autonomous SystemsIntelligence NetworksSmart MarketsProblem SolvingInfrastructure <p>Autonomous Resource Allocation</p> <p>Global supply chains and energy distribution optimized in real-time</p> <p>Distributed Decision Making</p> <p>Collaborative intelligence networks across industries and governments</p> <p>Self-Organizing Markets</p> <p>Agent-driven marketplaces that automatically balance supply and demand</p> <p>Collaborative Problem Solving</p> <p>Massive agent swarms tackling climate change, disease, and scientific discovery</p> <p>Adaptive Infrastructure</p> <p>Self-healing systems that evolve without human intervention</p>"},{"location":"contributors/main/#why-contribute-to-swarms","title":"Why Contribute to Swarms?","text":""},{"location":"contributors/main/#shape-the-future-of-civilization","title":"Shape the Future of Civilization","text":"<p>Your Impact</p> <ul> <li>Define standards for multi-agent communication protocols</li> <li>Build architectural patterns for distributed intelligence systems</li> <li>Create frameworks for deploying agent swarms in production</li> <li>Establish ethical guidelines for autonomous agent collaboration</li> </ul>"},{"location":"contributors/main/#recognition-and-professional-development","title":"Recognition and Professional Development","text":"<p>Immediate Recognition</p> <ul> <li>Social Media Features - All merged PRs showcased publicly</li> <li>Bounty Programs - Financial rewards for high-impact contributions</li> <li>Fast-Track Hiring - Priority consideration for core team positions</li> <li>Community Spotlights - Regular recognition and acknowledgments</li> </ul> <p>Career Benefits</p> <ul> <li>Multi-agent expertise highly valued by AI industry</li> <li>Portfolio demonstrates cutting-edge technical skills</li> <li>Direct networking with leading researchers and companies</li> <li>Thought leadership opportunities in emerging field</li> </ul>"},{"location":"contributors/main/#technical-expertise-development","title":"Technical Expertise Development","text":"<p>Master cutting-edge technologies:</p> Technology Area Skills You'll Develop Swarm Intelligence Design sophisticated agent coordination mechanisms Distributed Computing Build scalable architectures for thousands of agents Communication Protocols Create novel interaction patterns Production AI Deploy and orchestrate enterprise-scale systems Research Implementation Turn cutting-edge papers into working code"},{"location":"contributors/main/#research-community-access","title":"Research Community Access","text":"<p>Collaborative Environment</p> <ul> <li>Work with experts from academic institutions and industry</li> <li>Regular technical seminars and research discussions</li> <li>Structured mentorship from experienced contributors</li> <li>Applied research opportunities with real-world impact</li> </ul>"},{"location":"contributors/main/#contribution-opportunities","title":"Contribution Opportunities","text":"New ContributorsExperienced DevelopersResearchers"},{"location":"contributors/main/#perfect-for-getting-started","title":"Perfect for Getting Started","text":"<ul> <li>Documentation - Improve guides, tutorials, and API references</li> <li>Bug Reports - Identify and document issues</li> <li>Code Quality - Participate in testing and review processes</li> <li>Community Support - Help users in forums and discussions</li> </ul>"},{"location":"contributors/main/#advanced-technical-work","title":"Advanced Technical Work","text":"<ul> <li>Core Architecture - Design fundamental system components</li> <li>Performance Optimization - Enhance coordination and communication efficiency</li> <li>Research Implementation - Turn cutting-edge papers into working code</li> <li>Integration Development - Build connections with AI tools and platforms</li> </ul>"},{"location":"contributors/main/#research-and-innovation","title":"Research and Innovation","text":"<ul> <li>Algorithm Development - Implement novel multi-agent algorithms</li> <li>Experimental Frameworks - Create evaluation and benchmarking tools</li> <li>Theoretical Contributions - Develop research documentation and frameworks</li> <li>Academic Collaboration - Partner on funded research projects</li> </ul>"},{"location":"contributors/main/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributors/main/#step-1-get-started","title":"Step 1: Get Started","text":"<p>Essential Resources</p> <p> Documentation GitHub Repository Community Channels</p>"},{"location":"contributors/main/#step-2-find-your-path","title":"Step 2: Find Your Path","text":"<pre><code>graph TD\n    A[Choose Your Path] --&gt; B[Browse Issues]\n    A --&gt; C[Review Roadmap]\n    A --&gt; D[Propose Ideas]\n    B --&gt; E[good first issue]\n    B --&gt; F[help wanted]\n    C --&gt; G[Core Features]\n    C --&gt; H[Research Areas]\n    D --&gt; I[Discussion Forums]</code></pre>"},{"location":"contributors/main/#step-3-make-impact","title":"Step 3: Make Impact","text":"<ol> <li>Fork &amp; Setup - Configure your development environment</li> <li>Develop - Create your contribution</li> <li>Submit - Open a pull request</li> <li>Collaborate - Work with maintainers</li> <li>Celebrate - See your work recognized</li> </ol>"},{"location":"contributors/main/#recognition-framework","title":"Recognition Framework","text":""},{"location":"contributors/main/#immediate-benefits","title":"Immediate Benefits","text":"<p>Instant Recognition</p> Benefit Description Social Media Features Every merged PR showcased publicly Community Recognition Contributor badges and documentation credits Professional References Formal acknowledgment for portfolios Direct Mentorship Access to core team guidance"},{"location":"contributors/main/#long-term-opportunities","title":"Long-term Opportunities","text":"<p>Career Growth</p> <ul> <li>Team Positions - Fast-track consideration for core team roles</li> <li>Conference Speaking - Present work at AI conferences and events</li> <li>Industry Connections - Network with leading AI organizations</li> <li>Research Collaboration - Partner with academic institutions</li> </ul>"},{"location":"contributors/main/#societal-impact","title":"Societal Impact","text":"<p>Building Solutions for Humanity</p> <p>Swarms enables technology that addresses critical challenges:</p> ResearchHealthcareEnvironmentEducationEconomy <p>Scientific Research</p> <p>Accelerate collaborative research and discovery across disciplines</p> <p>Healthcare Innovation</p> <p>Support drug discovery and personalized medicine development</p> <p>Environmental Solutions</p> <p>Monitor climate and optimize sustainability initiatives</p> <p>Educational Technology</p> <p>Create adaptive learning systems for personalized education</p> <p>Economic Innovation</p> <p>Generate new opportunities and efficiency improvements</p>"},{"location":"contributors/main/#get-involved","title":"Get Involved","text":""},{"location":"contributors/main/#connect-with-us","title":"Connect With Us","text":"<p>Join the Community</p> <p> GitHub Repository Documentation Community Forums</p> <p>The Future is Now</p> <p>Multi-agent collaboration will define the next century of human progress. The autonomous economy depends on the infrastructure we build today.</p> <p>Your Mission</p> <p>Your contribution to Swarms helps create the foundation for billions of autonomous agents working together to solve humanity's greatest challenges.</p> <p>Join us in building the most important technology of our time.</p> <p>Built with  by the global Swarms community</p>"},{"location":"contributors/tools/","title":"Contributing Tools and Plugins to the Swarms Ecosystem","text":""},{"location":"contributors/tools/#introduction","title":"Introduction","text":"<p>The Swarms ecosystem is a modular, intelligent framework built to support the seamless integration, execution, and orchestration of dynamic tools that perform specific functions. These tools form the foundation for how autonomous agents operate, enabling them to retrieve data, communicate with APIs, conduct computational tasks, and respond intelligently to real-world requests. By contributing to Swarms Tools, developers can empower agents with capabilities that drive practical, enterprise-ready applications.</p> <p>This guide provides a comprehensive roadmap for contributing tools and plugins to the Swarms Tools repository. It is written for software engineers, data scientists, platform architects, and technologists who seek to develop modular, production-grade functionality within the Swarms agent framework.</p> <p>Whether your expertise lies in finance, security, machine learning, or developer tooling, this documentation outlines the essential standards, workflows, and integration patterns to make your contributions impactful and interoperable.</p>"},{"location":"contributors/tools/#repository-architecture","title":"Repository Architecture","text":"<p>The Swarms Tools GitHub repository is meticulously organized to maintain structure, scalability, and domain-specific clarity. Each folder within the repository represents a vertical where tools can be contributed and extended over time. These folders include:</p> <ul> <li> <p><code>finance/</code>: Market analytics, stock price retrievers, blockchain APIs, etc.</p> </li> <li> <p><code>social/</code>: Sentiment analysis, engagement tracking, and media scraping utilities.</p> </li> <li> <p><code>health/</code>: Interfaces for EHR systems, wearable device APIs, or health informatics.</p> </li> <li> <p><code>ai/</code>: Model-serving utilities, embedding services, and prompt engineering functions.</p> </li> <li> <p><code>security/</code>: Encryption libraries, risk scoring tools, penetration test interfaces.</p> </li> <li> <p><code>devtools/</code>: Build tools, deployment utilities, code quality analyzers.</p> </li> <li> <p><code>misc/</code>: General-purpose helpers or utilities that serve multiple domains.</p> </li> </ul> <p>Each tool inside these directories is implemented as a single, self-contained function. These functions are expected to adhere to Swarms-wide standards for clarity, typing, documentation, and API key handling.</p>"},{"location":"contributors/tools/#tool-development-specifications","title":"Tool Development Specifications","text":"<p>To ensure long-term maintainability and smooth agent-tool integration, each contribution must strictly follow the specifications below.</p>"},{"location":"contributors/tools/#1-function-structure-and-api-usage","title":"1. Function Structure and API Usage","text":"<pre><code>import requests\nimport os\n\ndef fetch_data(symbol: str, date_range: str) -&gt; str:\n    \"\"\"\n    Fetch financial data for a given symbol and date range.\n\n    Args:\n        symbol (str): Ticker symbol of the asset.\n        date_range (str): Timeframe for the data (e.g., '1d', '1m', '1y').\n\n    Returns:\n        str: A string containing financial data or an error message.\n    \"\"\"\n    api_key = os.getenv(\"FINANCE_API_KEY\")\n    url = f\"https://api.financeprovider.com/data?symbol={symbol}&amp;range={date_range}&amp;apikey={api_key}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.text\n    return \"Error fetching data.\"\n</code></pre> <p>All logic must be encapsulated inside a single callable function, written using pure Python. Where feasible, network requests should be stateless, side-effect-free, and gracefully handle errors or timeouts.</p>"},{"location":"contributors/tools/#2-type-hints-and-input-validation","title":"2. Type Hints and Input Validation","text":"<p>All function parameters must be typed using Python's type hinting system. Use built-in primitives where possible (e.g., <code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>) and make use of <code>Optional</code> or <code>Union</code> types when dealing with nullable parameters or multiple formats. This aids LLMs and type checkers in understanding expected input ranges.</p>"},{"location":"contributors/tools/#3-standardized-output-format","title":"3. Standardized Output Format","text":"<p>Regardless of internal logic or complexity, tools must return outputs in a consistent string format. This string can contain plain text or a serialized JSON object (as a string), but must not return raw objects, dictionaries, or binary blobs. This standardization ensures all downstream agents can interpret tool output predictably.</p>"},{"location":"contributors/tools/#4-api-key-management-best-practices","title":"4. API Key Management Best Practices","text":"<p>Security and environment isolation are paramount. Never hardcode API keys or sensitive credentials inside source code. Always retrieve them dynamically using the <code>os.getenv(\"ENV_VAR\")</code> approach. If a tool requires credentials, clearly document the required environment variable names in the function docstring.</p>"},{"location":"contributors/tools/#5-documentation-guidelines","title":"5. Documentation Guidelines","text":"<p>Every tool must include a detailed docstring that describes:</p> <ul> <li> <p>The function's purpose and operational scope</p> </li> <li> <p>All parameter types and formats</p> </li> <li> <p>A clear return type</p> </li> <li> <p>Usage examples or sample inputs/outputs</p> </li> </ul> <p>Example usage: <pre><code>result = fetch_data(\"AAPL\", \"1m\")\nprint(result)\n</code></pre></p> <p>Well-documented code accelerates adoption and improves LLM interpretability.</p>"},{"location":"contributors/tools/#contribution-workflow","title":"Contribution Workflow","text":"<p>To submit a tool, follow the workflow below. This ensures your code integrates cleanly and is easy for maintainers to review.</p>"},{"location":"contributors/tools/#step-1-fork-the-repository","title":"Step 1: Fork the Repository","text":"<p>Navigate to the Swarms Tools repository and fork it to your personal or organization\u2019s GitHub account.</p>"},{"location":"contributors/tools/#step-2-clone-your-fork","title":"Step 2: Clone Your Fork","text":"<pre><code>git clone https://github.com/YOUR_USERNAME/swarms-tools.git\ncd swarms-tools\n</code></pre>"},{"location":"contributors/tools/#step-3-create-a-feature-branch","title":"Step 3: Create a Feature Branch","text":"<pre><code>git checkout -b feature/add-tool-&lt;tool-name&gt;\n</code></pre> <p>Use descriptive branch names. This is especially helpful when collaborating in teams or maintaining audit trails.</p>"},{"location":"contributors/tools/#step-4-build-your-tool","title":"Step 4: Build Your Tool","text":"<p>Navigate into the appropriate category folder (e.g., <code>finance/</code>, <code>ai/</code>, etc.) and implement your tool according to the defined schema.</p> <p>If your tool belongs in a new category, you may create a new folder with a clear, lowercase name.</p>"},{"location":"contributors/tools/#step-5-run-local-tests-if-applicable","title":"Step 5: Run Local Tests (if applicable)","text":"<p>Ensure the function executes correctly and does not throw runtime errors. If feasible, test edge cases and verify consistent behavior across platforms.</p>"},{"location":"contributors/tools/#step-6-commit-your-changes","title":"Step 6: Commit Your Changes","text":"<pre><code>git add .\ngit commit -m \"Add &lt;tool_name&gt; under &lt;folder_name&gt;: API-based tool for X\"\n</code></pre>"},{"location":"contributors/tools/#step-7-push-to-github","title":"Step 7: Push to GitHub","text":"<pre><code>git push origin feature/add-tool-&lt;tool-name&gt;\n</code></pre>"},{"location":"contributors/tools/#step-8-submit-a-pull-request","title":"Step 8: Submit a Pull Request","text":"<p>On GitHub, open a pull request from your fork to the main Swarms Tools repository. Your PR description should: - Summarize the tool\u2019s functionality - Reference any related issues or enhancements - Include usage notes or setup instructions (e.g., required API keys)</p>"},{"location":"contributors/tools/#integration-with-swarms-agents","title":"Integration with Swarms Agents","text":"<p>Once your tool has been merged into the official repository, it can be utilized by Swarms agents as part of their available capabilities.</p> <p>The example below illustrates how to embed a newly added tool into an autonomous agent:</p> <pre><code>from swarms import Agent\nfrom finance.stock_price import get_stock_price\n\nagent = Agent(\n    agent_name=\"Devin\",\n    system_prompt=(\n        \"Autonomous agent that can interact with humans and other agents.\"\n        \" Be helpful and kind. Use the tools provided to assist the user.\"\n        \" Return all code in markdown format.\"\n    ),\n    llm=llm,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    interactive=True,\n    tools=[get_stock_price, terminal, browser, file_editor, create_file],\n    metadata_output_type=\"json\",\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\",\n)\n\nagent.run(\"Create a new file for a plan to take over the world.\")\n</code></pre> <p>By registering tools in the <code>tools</code> parameter during agent creation, you enable dynamic function calling. The agent interprets natural language input, selects the appropriate tool, and invokes it with valid arguments.</p> <p>This agent-tool paradigm enables highly flexible and responsive behavior across workflows involving research, automation, financial analysis, social listening, and more.</p>"},{"location":"contributors/tools/#tool-maintenance-and-long-term-ownership","title":"Tool Maintenance and Long-Term Ownership","text":"<p>Contributors are expected to uphold the quality of their tools post-merge. This includes:</p> <ul> <li> <p>Monitoring for issues or bugs reported by the community</p> </li> <li> <p>Updating tools when APIs deprecate or modify their behavior</p> </li> <li> <p>Improving efficiency, error handling, or documentation over time</p> </li> </ul> <p>If a tool becomes outdated or unsupported, maintainers may archive or revise it to maintain ecosystem integrity.</p> <p>Contributors whose tools receive wide usage or demonstrate excellence in design may be offered elevated privileges or invited to maintain broader tool categories.</p>"},{"location":"contributors/tools/#best-practices-for-enterprise-grade-contributions","title":"Best Practices for Enterprise-Grade Contributions","text":"<p>To ensure your tool is production-ready and enterprise-compliant, observe the following practices:</p> <ul> <li> <p>Run static type checking with <code>mypy</code></p> </li> <li> <p>Use formatters like <code>black</code> and linters such as <code>flake8</code></p> </li> <li> <p>Avoid unnecessary external dependencies</p> </li> <li> <p>Keep functions modular and readable</p> </li> <li> <p>Prefer named parameters over positional arguments for clarity</p> </li> <li> <p>Handle API errors gracefully and return user-friendly messages</p> </li> <li> <p>Document limitations or assumptions in the docstring</p> </li> </ul> <p>Optional but encouraged: - Add unit tests to validate function output</p> <ul> <li>Benchmark performance if your tool operates on large datasets</li> </ul>"},{"location":"contributors/tools/#conclusion","title":"Conclusion","text":"<p>The Swarms ecosystem is built on the principle of extensibility through community-driven contributions. By submitting modular, typed, and well-documented tools to the Swarms Tools repository, you directly enhance the problem-solving power of intelligent agents.</p> <p>This documentation serves as your blueprint for contributing high-quality, reusable functionality. From idea to implementation to integration, your efforts help shape the future of collaborative, agent-powered software.</p> <p>We encourage all developers, data scientists, and domain experts to contribute meaningfully. Review existing tools for inspiration, or create something entirely novel.</p> <p>To begin, fork the Swarms Tools repository and start building impactful, reusable tools that can scale across agents and use cases.</p>"},{"location":"corporate/2024_2025_goals/","title":"Swarms Goals &amp; Milestone Tracking: A Vision for 2024 and Beyond","text":"<p>As we propel Swarms into a new frontier, we\u2019ve set ambitious yet achievable goals for the coming years that will solidify Swarms as a leader in multi-agent  orchestration. This document outlines our vision, the goals for 2024 and 2025, and how we track our progress through meticulously designed milestones and metrics.</p>"},{"location":"corporate/2024_2025_goals/#our-vision-the-agentic-ecosystem","title":"Our Vision: The Agentic Ecosystem","text":"<p>We envision an ecosystem where agents are pervasive and serve as integral collaborators in business processes, daily life, and complex problem-solving. By leveraging  the collective intelligence of swarms, we believe we can achieve massive gains in productivity, scalability, and impact. Our target is to establish the Swarms platform as the go-to environment for deploying and managing agents at an unprecedented scale\u2014making agents as common and indispensable as mobile apps are today. This future  will see agents integrated into nearly every digital interaction, creating a seamless extension of human capability and reducing the cognitive load on individuals and organizations.</p> <p>We believe that agents will transition from being simple tools to becoming full-fledged partners that can understand user needs, predict outcomes, and adapt to  changes dynamically. Our vision is not just about increasing numbers; it\u2019s about building a smarter, more interconnected agentic ecosystem where every agent has a purpose and contributes to a collective intelligence that continuously evolves. By cultivating a diverse array of agents capable of handling various specialized tasks, we aim to create an environment in which these digital collaborators function as a cohesive whole\u2014one that can amplify human ingenuity and productivity beyond current limits.</p>"},{"location":"corporate/2024_2025_goals/#goals-for-2024-and-2025","title":"Goals for 2024 and 2025","text":"<p>To achieve our vision, we have laid out a structured growth trajectory for Swarms, driven by clear numerical targets:</p> <ol> <li> <p>End of 2024: 500 Million Agents    Currently, our platform hosts 45 million agents. By the end of 2024, our goal is to reach 500 million agents deployed on Swarms. This means achieving sustained exponential growth, which will require doubling or even tripling the total number of agents roughly every month from now until December 2024. Such growth will necessitate not only scaling infrastructure but also improving the ease with which users can develop and deploy agents, expanding educational resources, and fostering a vibrant community that drives innovation in agent design. To achieve this milestone, we plan to invest heavily in making our platform user-friendly, including simplifying onboarding processes and providing extensive educational content. Additionally, we aim to build out our infrastructure to support the necessary scalability and ensure the seamless operation of a growing number of agents. Beyond merely scaling in numbers, we are also focused on increasing the diversity of tasks that agents can perform, thereby enhancing the practical value of deploying agents on Swarms.</p> </li> <li> <p>End of 2025: 10 Billion+ Agents    The long-term vision extends further to reach 10 billion agents by the end of 2025. This ambitious goal reflects not only the organic growth of our user base but     also the increasing role of swarms in business applications, personal projects, and global problem-solving initiatives. This goal requires continuous monthly     doubling of agents and a clear roadmap of user engagement and deployment. By scaling to this level, we envision Swarms as a cornerstone of automation and productivity enhancement, where agents autonomously manage everything from mundane tasks to sophisticated strategic decisions, effectively enhancing human capabilities. This expansion will rely on the development of a robust ecosystem in which users can easily create, share, and enhance agents. We will foster partnerships with industries that can benefit from scalable agentic solutions\u2014spanning healthcare, finance, education, and beyond. Our strategy includes developing domain-specific templates and specialized agents that cater to niche needs, thereby making Swarms an indispensable solution for businesses and individuals alike.</p> </li> </ol>"},{"location":"corporate/2024_2025_goals/#tracking-progress-the-power-of-metrics","title":"Tracking Progress: The Power of Metrics","text":"<p>Achieving these goals is not just about reaching numerical targets but ensuring that our users are deriving tangible value from Swarms and deploying agents effectively. To measure success, we\u2019ve defined several key performance indicators (KPIs) and milestones:</p>"},{"location":"corporate/2024_2025_goals/#1-growth-in-agent-deployment","title":"1. Growth in Agent Deployment","text":"<p>The number of agents deployed per month will be our primary growth metric. With our goal of doubling agent count every month, this metric serves as an overall health indicator for platform adoption and usage. Growth in deployment indicates that our platform is attracting users who see value in creating and deploying agents to solve diverse challenges.</p> <p>Key Milestones:</p> <ul> <li> <p>November 2024: Surpass 250 million agents.  </p> </li> <li> <p>December 2024: Reach 500 million agents.  </p> </li> <li> <p>June 2025: Break the 5 billion agents mark.  </p> </li> <li> <p>December 2025: Hit 10 billion agents.  </p> </li> </ul> <p>To accomplish this, we must continually expand our infrastructure, maintain scalability, and create a seamless user onboarding process. We\u2019ll ensure that adding agents is frictionless and that our platform can accommodate this rapid growth. By integrating advanced orchestration capabilities, we will enable agents to form more complex collaborations and achieve tasks that previously seemed out of reach. Furthermore, we will develop analytics tools to track the success and efficiency of these agents, giving users real-time feedback to optimize their deployment strategies.</p>"},{"location":"corporate/2024_2025_goals/#2-agents-deployed-per-user-engagement-indicator","title":"2. Agents Deployed Per User: Engagement Indicator","text":"<p>A core belief of Swarms is that agents are here to make life easier for their users\u2014whether it\u2019s automating mundane tasks, handling complex workflows, or enhancing creative endeavors. Therefore, we measure the number of agents deployed per user per month as a key metric for engagement. Tracking this metric allows us to understand how effectively our users are utilizing the platform, and how deeply agents are becoming embedded into their workflows.</p> <p>This metric ensures that users aren\u2019t just joining Swarms, but they are actively building and deploying agents to solve real problems. Our milestone for engagement is to see increasing growth in agents deployed per user month over month, which indicates a deeper integration of Swarms into daily workflows and business processes. We want our users to view Swarms as their go-to solution for any problem they face, which means ensuring that agents are providing real, tangible benefits.</p> <p>Key Milestones:</p> <ul> <li> <p>November 2024: Achieve an average of 20 agents deployed per user each month. </p> </li> <li> <p>June 2025: Target 100-200+ agents deployed per user.  </p> </li> </ul> <p>To drive these numbers, we plan to improve user support, enhance educational materials, host workshops, and create an environment that empowers users to deploy agents for increasingly complex use-cases. Additionally, we will introduce templates and pre-built agents that users can customize, reducing the barriers to entry and enabling  rapid deployment for new users. We are also developing gamified elements that reward users for deploying more agents and achieving milestones, fostering a competitive and engaging community atmosphere.</p>"},{"location":"corporate/2024_2025_goals/#3-active-vs-inactive-agents-measuring-churn","title":"3. Active vs. Inactive Agents: Measuring Churn","text":"<p>The number of inactive agents per user is an essential metric for understanding our churn rate. An agent is considered inactive when it remains undeployed or unused for a prolonged period, indicating that it\u2019s no longer delivering value to the user. Churn metrics provide valuable insights into the effectiveness of our agents and highlight areas where improvements are needed.</p> <p>We aim to minimize the number of inactive agents, as this will be a direct reflection of how well our agents are designed, integrated, and supported. A low churn rate means that users are finding long-term utility in their agents, which is key to our mission. Our platform\u2019s success depends on users consistently deploying agents  that remain active and valuable over time.</p> <p>Key Milestones:</p> <ul> <li> <p>December 2024: Ensure that no more than 30% of deployed agents are inactive.  </p> </li> <li> <p>December 2025: Aim for 10% or lower, reflecting strong agent usefulness and consistent platform value delivery.  </p> </li> </ul> <p>Reducing churn will require proactive measures, such as automated notifications to users about inactive agents, recommending potential uses, and implementing agent retraining features to enhance their adaptability over time. Educating users on prompting engineering, tool engineering, and RAG engineering also helps decrease these numbers as the number of inactive agents is evident that the user is not automating a business operation with that agent. We will also integrate machine learning models to predict agent inactivity and take corrective actions before agents become dormant. By offering personalized recommendations to users on how to enhance or repurpose inactive agents, we hope to ensure that all deployed agents are actively contributing value.</p>"},{"location":"corporate/2024_2025_goals/#milestones-and-success-criteria","title":"Milestones and Success Criteria","text":"<p>To reach these ambitious goals, we have broken our roadmap down into a series of actionable milestones:</p> <ol> <li> <p>Infrastructure Scalability (Q1 2025)    We will work on ensuring that our backend infrastructure can handle the scale required to reach 500 million agents by the end of 2024. This includes expanding server capacity, improving agent orchestration capabilities, and ensuring low latency across deployments. We will also focus on enhancing our database management systems to ensure efficient storage and retrieval of agent data, enabling seamless operation at a massive scale. Our infrastructure roadmap also includes implementing advanced load balancing techniques and predictive scaling mechanisms to ensure high availability and reliability.</p> </li> <li> <p>Improved User Experience (Q2 2025)    To encourage agent deployment and reduce churn, we will introduce new onboarding flows, agent-building wizards, and intuitive user interfaces. We will also implement     in-depth tutorials and documentation to simplify agent creation for new users. By making agent-building accessible even to those without programming expertise, we     will open the doors to a broader audience and drive exponential growth in the number of agents deployed. Additionally, we will integrate AI-driven suggestions and     contextual help to assist users at every step of the process, making the platform as intuitive as possible.</p> </li> <li> <p>Agent Marketplace (Q3 2025)    Launching the Swarms Marketplace for agents, prompts, and tools will allow users to share, discover, and even monetize their agents. This marketplace will be a crucial driver in both increasing the number of agents deployed and reducing inactive agents, as it will create an ecosystem of continuously evolving and highly useful agents. Users will have the opportunity to browse agents that others have developed, which can serve as inspiration or as a starting point for their own projects. We will also introduce ratings, reviews, and community feedback mechanisms to ensure that the most effective agents are highlighted and accessible.</p> </li> <li> <p>Community Engagement and Swarms Education (Ongoing)    Workshops, webinars, and events will be conducted throughout 2024 and 2025 to engage new users and educate them on building effective agents. The goal is to ensure that every user becomes proficient in deploying swarms of agents for meaningful tasks. We will foster an active community where users can exchange ideas, get help, and collaborate on projects, ultimately driving forward the growth of the Swarms ecosystem. We also plan to establish a mentor program where experienced users can guide newcomers, helping them get up to speed more quickly and successfully deploy agents.</p> </li> </ol>"},{"location":"corporate/2024_2025_goals/#actionable-strategies-for-goal-achievement","title":"Actionable Strategies for Goal Achievement","text":"<p>1. Developer Incentives One of our most important strategies will be the introduction of developer incentives. By providing rewards for creating agents, we foster an environment of creativity and encourage rapid growth in the number of useful agents on the platform. We will host hackathons, contests, and provide financial incentives to developers whose agents provide substantial value to the community. Additionally, we plan to create a tiered rewards system that acknowledges developers for the number of active deployments and the utility of their agents, motivating continuous improvement and innovation.</p> <p>2. Strategic Partnerships We plan to form partnerships with major technology providers and industry players to scale Swarms adoption. Integrating Swarms into existing business software and industrial processes will drive significant growth in agent numbers and usage. These partnerships will allow Swarms to become embedded into existing workflows, making it easier for users to understand the value and immediately apply agents to solve real-world challenges. We are also targeting partnerships with educational  institutions to provide Swarms as a learning platform for AI, encouraging students and researchers to contribute to our growing ecosystem.</p> <p>3. User Feedback Loop To ensure we are on track, a continuous feedback loop with our user community will help us understand what agents are effective, which require improvements, and where we need to invest our resources to maximize engagement. Users\u2019 experiences will shape our platform evolution. We will implement regular surveys, feedback forms, and user interviews to gather insights, and use this data to drive iterative development that is directly aligned with user needs. In addition, we will create an open feature request forum where users can vote on the most important features they want to see, ensuring that we are prioritizing our community\u2019s needs.</p> <p>4. Marketing and Awareness Campaigns Strategic campaigns to showcase the power of swarms in specific industries will highlight the versatility and impact of our agents. We plan to create case studies demonstrating how swarms solve complex problems in marketing, finance, customer service, and other verticals, and use these to attract a wider audience. Our content marketing strategy will include blogs, video tutorials, and success stories to help potential users visualize the transformative power of Swarms. We will also leverage social media campaigns and influencer partnerships to reach a broader audience and generate buzz around Swarms\u2019 capabilities.</p> <p>5. Educational Initiatives To lower the barrier to entry for new users, we will invest heavily in educational content. This includes video tutorials, comprehensive guides, and in-platform  learning modules. By making the learning process easy and engaging, we ensure that users quickly become proficient in creating and deploying agents, thereby increasing user satisfaction and reducing churn. A well-educated user base will lead to more agents being deployed effectively, contributing to our overall growth targets. We are  also developing certification programs for users and developers, providing a structured pathway to become proficient in Swarms technology and gain recognition for their skills.</p>"},{"location":"corporate/2024_2025_goals/#the-path-ahead-building-towards-10-billion-agents","title":"The Path Ahead: Building Towards 10 Billion Agents","text":"<p>To achieve our vision of 10 billion agents by the end of 2025, it\u2019s critical that we maintain an aggressive growth strategy while ensuring that agents are providing real value to users. This requires a deep focus on scalability, community growth, and user-centric development. It also demands a continuous feedback loop where  insights from agent deployments and user interactions drive platform evolution. By creating an environment where agents are easy to develop, share, and integrate, we will achieve sustainable growth that benefits not just Swarms, but the broader AI community.</p> <p>We envision swarms as a catalyst for democratizing access to AI. By enabling users across industries\u2014from healthcare to education to manufacturing\u2014to deploy agents that handle specialized tasks, we empower individuals and organizations to focus on creative, strategic endeavors rather than repetitive operational tasks. The journey to 10 billion agents is not just about scale; it\u2019s about creating meaningful and effective automation that transforms how work gets done. We believe that Swarms will ultimately reshape industries by making sophisticated automation accessible to all, driving a shift toward higher productivity and innovation.</p>"},{"location":"corporate/2024_2025_goals/#community-and-culture","title":"Community and Culture","text":"<p>Swarms will also be emphasizing the community aspect, building a culture of collaboration among users, developers, and businesses. By fostering open communication and enabling the sharing of agents, we encourage knowledge transfer and network effects, which help drive overall growth. Our goal is to create an environment where agents not only work individually but evolve as a collective intelligence network\u2014working towards a post-scarcity civilization where every problem  can be tackled by the right combination of swarms.</p> <p>We see the community as the heartbeat of Swarms, driving innovation, providing support, and expanding the use-cases for agents. Whether it\u2019s through forums, community  events, or user-generated content, we want Swarms to be the hub where people come together to solve the most pressing challenges of our time. By empowering our users  and encouraging collaboration, we can ensure that the platform continuously evolves and adapts to new needs and opportunities. Additionally, we plan to establish local Swarms chapters worldwide, where users can meet in person to share knowledge, collaborate on projects, and build lasting relationships that strengthen the global Swarms community.</p>"},{"location":"corporate/2024_2025_goals/#conclusion-measuring-success-one-milestone-at-a-time","title":"Conclusion: Measuring Success One Milestone at a Time","text":"<p>The path to 500 million agents by the end of 2024 and 10 billion agents by the end of 2025 is paved with strategic growth, infrastructure resilience, and user-centric improvements. Each milestone is a step closer to a fully realized vision of an agentic economy\u2014one where agents are ubiquitous, assisting individuals,  businesses, and entire industries in achieving their goals more efficiently.</p> <p>By tracking key metrics, such as growth in agent numbers, the rate of agent deployment per user, and reducing churn, we ensure that Swarms not only grows in size but also in effectiveness, adoption, and user satisfaction. Through a combination of infrastructure development, community engagement, incentives, and constant user feedback, we will create an ecosystem where agents thrive, users are empowered, and the entire platform evolves towards our ambitious vision.</p> <p>This is the journey of Swarms\u2014a journey towards redefining how we interact with AI, solve complex problems, and enhance productivity. With each milestone, we get closer to a future where swarms of agents are the bedrock of human-machine collaboration and an integral part of our daily lives. The journey ahead is one of  transformation, creativity, and collaboration, as we work together to create an AI-driven world that benefits everyone, enabling us to achieve more than we ever thought  possible. Our commitment to building an agentic ecosystem is unwavering, and we are excited to see the incredible impact that swarms of agents will have on the future of work, innovation, and human potential.</p>"},{"location":"corporate/architecture/","title":"Architecture","text":""},{"location":"corporate/architecture/#1-introduction","title":"1. Introduction","text":"<p>In today's rapidly evolving digital world, harnessing the collaborative power of multiple computational agents is more crucial than ever. 'Swarms' represents a bold stride in this direction\u2014a scalable and dynamic framework designed to enable swarms of agents to function in harmony and tackle complex tasks. This document serves as a comprehensive guide, elucidating the underlying architecture and strategies pivotal to realizing the Swarms vision.</p>"},{"location":"corporate/architecture/#2-the-vision","title":"2. The Vision","text":"<p>At its heart, the Swarms framework seeks to emulate the collaborative efficiency witnessed in natural systems, like ant colonies or bird flocks. These entities, though individually simple, achieve remarkable outcomes through collaboration. Similarly, Swarms will unleash the collective potential of numerous agents, operating cohesively.</p>"},{"location":"corporate/architecture/#3-architecture-overview","title":"3. Architecture Overview","text":""},{"location":"corporate/architecture/#31-agent-level","title":"3.1 Agent Level","text":"<p>The base level that serves as the building block for all further complexity.</p>"},{"location":"corporate/architecture/#mechanics","title":"Mechanics:","text":"<ul> <li>Model: At its core, each agent harnesses a powerful model like OpenAI's GPT.</li> <li>Vectorstore: A memory structure allowing agents to store and retrieve information.</li> <li>Tools: Utilities and functionalities that aid in the agent's task execution.</li> </ul>"},{"location":"corporate/architecture/#interaction","title":"Interaction:","text":"<p>Agents interact with the external world through their model and tools. The Vectorstore aids in retaining knowledge and facilitating inter-agent communication.</p>"},{"location":"corporate/architecture/#32-worker-infrastructure-level","title":"3.2 Worker Infrastructure Level","text":"<p>Building on the agent foundation, enhancing capability and readiness for swarm integration.</p>"},{"location":"corporate/architecture/#mechanics_1","title":"Mechanics:","text":"<ul> <li>Human Input Integration: Enables agents to accept and understand human-provided instructions.</li> <li>Unique Identifiers: Assigns each agent a unique ID to facilitate tracking and communication.</li> <li>Asynchronous Tools: Bolsters agents' capability to multitask and interact in real-time.</li> </ul>"},{"location":"corporate/architecture/#interaction_1","title":"Interaction:","text":"<p>Each worker is an enhanced agent, capable of operating independently or in sync with its peers, allowing for dynamic, scalable operations.</p>"},{"location":"corporate/architecture/#33-swarm-level","title":"3.3 Swarm Level","text":"<p>Multiple Worker Nodes orchestrated into a synchronized, collaborative entity.</p>"},{"location":"corporate/architecture/#mechanics_2","title":"Mechanics:","text":"<ul> <li>Orchestrator: The maestro, responsible for directing the swarm, task allocation, and communication.</li> <li>Scalable Communication Layer: Facilitates interactions among nodes and between nodes and the orchestrator.</li> <li>Task Assignment &amp; Completion Protocols: Structured procedures ensuring tasks are efficiently distributed and concluded.</li> </ul>"},{"location":"corporate/architecture/#interaction_2","title":"Interaction:","text":"<p>Nodes collaborate under the orchestrator's guidance, ensuring tasks are partitioned appropriately, executed, and results consolidated.</p>"},{"location":"corporate/architecture/#34-hivemind-level","title":"3.4 Hivemind Level","text":"<p>Envisioned as a 'Swarm of Swarms'. An upper echelon of collaboration.</p>"},{"location":"corporate/architecture/#mechanics_3","title":"Mechanics:","text":"<ul> <li>Hivemind Orchestrator: Oversees multiple swarm orchestrators, ensuring harmony on a grand scale.</li> <li>Inter-Swarm Communication Protocols: Dictates how swarms interact, exchange information, and co-execute tasks.</li> </ul>"},{"location":"corporate/architecture/#interaction_3","title":"Interaction:","text":"<p>Multiple swarms, each a formidable force, combine their prowess under the Hivemind. This level tackles monumental tasks by dividing them among swarms.</p>"},{"location":"corporate/architecture/#4-building-the-framework-a-task-checklist","title":"4. Building the Framework: A Task Checklist","text":""},{"location":"corporate/architecture/#41-foundations-agent-level","title":"4.1 Foundations: Agent Level","text":"<ul> <li>Define and standardize agent properties.</li> <li>Integrate desired model (e.g., OpenAI's GPT) with agent.</li> <li>Implement Vectorstore mechanisms: storage, retrieval, and communication protocols.</li> <li>Incorporate essential tools and utilities.</li> <li>Conduct preliminary testing: Ensure agents can execute basic tasks and utilize the Vectorstore.</li> </ul>"},{"location":"corporate/architecture/#42-enhancements-worker-infrastructure-level","title":"4.2 Enhancements: Worker Infrastructure Level","text":"<ul> <li>Interface agents with human input mechanisms.</li> <li>Assign and manage unique identifiers for each worker.</li> <li>Integrate asynchronous capabilities: Ensure real-time response and multitasking.</li> <li>Test worker nodes for both solitary and collaborative tasks.</li> </ul>"},{"location":"corporate/architecture/#43-cohesion-swarm-level","title":"4.3 Cohesion: Swarm Level","text":"<ul> <li>Design and develop the orchestrator: Ensure it can manage multiple worker nodes.</li> <li>Establish a scalable and efficient communication layer.</li> <li>Implement task distribution and retrieval protocols.</li> <li>Test swarms for efficiency, scalability, and robustness.</li> </ul>"},{"location":"corporate/architecture/#44-apex-collaboration-hivemind-level","title":"4.4 Apex Collaboration: Hivemind Level","text":"<ul> <li>Build the Hivemind Orchestrator: Ensure it can oversee multiple swarms.</li> <li>Define inter-swarm communication, prioritization, and task-sharing protocols.</li> <li>Develop mechanisms to balance loads and optimize resource utilization across swarms.</li> <li>Thoroughly test the Hivemind level for macro-task execution.</li> </ul>"},{"location":"corporate/architecture/#5-integration-and-communication-mechanisms","title":"5. Integration and Communication Mechanisms","text":""},{"location":"corporate/architecture/#51-vectorstore-as-the-universal-communication-layer","title":"5.1 Vectorstore as the Universal Communication Layer","text":"<p>Serving as the memory and communication backbone, the Vectorstore must: * Facilitate rapid storage and retrieval of high-dimensional vectors. * Enable similarity-based lookups: Crucial for recognizing patterns or finding similar outputs. * Scale seamlessly as agent count grows.</p>"},{"location":"corporate/architecture/#52-orchestrator-driven-communication","title":"5.2 Orchestrator-Driven Communication","text":"<ul> <li>Orchestrators, both at the swarm and hivemind level, should employ adaptive algorithms to optimally distribute tasks.</li> <li>Ensure real-time monitoring of task execution and worker node health.</li> <li>Integrate feedback loops: Allow for dynamic task reassignment in case of node failures or inefficiencies.</li> </ul>"},{"location":"corporate/architecture/#6-conclusion-forward-path","title":"6. Conclusion &amp; Forward Path","text":"<p>The Swarms framework, once realized, will usher in a new era of computational efficiency and collaboration. While the roadmap ahead is intricate, with diligent planning, development, and testing, Swarms will redefine the boundaries of collaborative computing.</p>"},{"location":"corporate/architecture/#overview","title":"Overview","text":""},{"location":"corporate/architecture/#1-model","title":"1. Model","text":"<p>Overview: The foundational level where a trained model (e.g., OpenAI GPT model) is initialized. It's the base on which further abstraction levels build upon. It provides the core capabilities to perform tasks, answer queries, etc.</p> <p>Diagram: <pre><code>[ Model (openai) ]\n</code></pre></p>"},{"location":"corporate/architecture/#2-agent-level","title":"2. Agent Level","text":"<p>Overview: At the agent level, the raw model is coupled with tools and a vector store, allowing it to be more than just a model. The agent can now remember, use tools, and become a more versatile entity ready for integration into larger systems.</p> <p>Diagram: <pre><code>+-----------+\n|   Agent   |\n| +-------+ |\n| | Model | |\n| +-------+ |\n| +-----------+ |\n| | VectorStore | |\n| +-----------+ |\n| +-------+ |\n| | Tools | |\n| +-------+ |\n+-----------+\n</code></pre></p>"},{"location":"corporate/architecture/#3-worker-infrastructure-level","title":"3. Worker Infrastructure Level","text":"<p>Overview: The worker infrastructure is a step above individual agents. Here, an agent is paired with additional utilities like human input and other tools, making it a more advanced, responsive unit capable of complex tasks.</p> <p>Diagram: <pre><code>+----------------+\n|  WorkerNode    |\n| +-----------+  |\n| |   Agent   |  |\n| | +-------+ |  |\n| | | Model | |  |\n| | +-------+ |  |\n| | +-------+ |  |\n| | | Tools | |  |\n| | +-------+ |  |\n| +-----------+  |\n|                |\n| +-----------+  |\n| |Human Input|  |\n| +-----------+  |\n|                |\n| +-------+      |\n| | Tools |      |\n| +-------+      |\n+----------------+\n</code></pre></p>"},{"location":"corporate/architecture/#4-swarm-level","title":"4. Swarm Level","text":"<p>Overview: At the swarm level, the orchestrator is central. It's responsible for assigning tasks to worker nodes, monitoring their completion, and handling the communication layer (for example, through a vector store or another universal communication mechanism) between worker nodes.</p> <p>Diagram: <pre><code>                     +------------+\n                     |Orchestrator|\n                     +------------+\n                           |\n            +---------------------------+\n            |                           |\n            |   Swarm-level Communication|\n            |          Layer (e.g.      |\n            |        Vector Store)      |\n            +---------------------------+\n             /          |          \\         \n  +---------------+  +---------------+  +---------------+\n  |WorkerNode 1   |  |WorkerNode 2   |  |WorkerNode n   |\n  |               |  |               |  |               |\n  +---------------+  +---------------+  +---------------+\n   | Task Assigned   | Task Completed   | Communication |\n</code></pre></p>"},{"location":"corporate/architecture/#5-hivemind-level","title":"5. Hivemind Level","text":"<p>Overview: At the Hivemind level, it's a multi-swarm setup, with an upper-layer orchestrator managing multiple swarm-level orchestrators. The Hivemind orchestrator is responsible for broader tasks like assigning macro-tasks to swarms, handling inter-swarm communications, and ensuring the overall system is functioning smoothly.</p> <p>Diagram: <pre><code>                     +--------+\n                     |Hivemind|\n                     +--------+\n                         |\n                 +--------------+\n                 |Hivemind      |\n                 |Orchestrator  |\n                 +--------------+\n            /         |          \\         \n    +------------+  +------------+  +------------+\n    |Orchestrator|  |Orchestrator|  |Orchestrator|\n    +------------+  +------------+  +------------+\n        |               |               |\n+--------------+ +--------------+ +--------------+\n|   Swarm-level| |   Swarm-level| |   Swarm-level|\n|Communication| |Communication| |Communication|\n|    Layer    | |    Layer    | |    Layer    |\n+--------------+ +--------------+ +--------------+\n    /    \\         /    \\         /     \\\n+-------+ +-------+ +-------+ +-------+ +-------+\n|Worker | |Worker | |Worker | |Worker | |Worker |\n| Node  | | Node  | | Node  | | Node  | | Node  |\n+-------+ +-------+ +-------+ +-------+ +-------+\n</code></pre></p> <p>This setup allows the Hivemind level to operate at a grander scale, with the capability to manage hundreds or even thousands of worker nodes across multiple swarms efficiently.</p>"},{"location":"corporate/architecture/#swarms-framework-development-strategy-checklist","title":"Swarms Framework Development Strategy Checklist","text":""},{"location":"corporate/architecture/#introduction","title":"Introduction","text":"<p>The development of the Swarms framework requires a systematic and granular approach to ensure that each component is robust and that the overall framework is efficient and scalable. This checklist will serve as a guide to building Swarms from the ground up, breaking down tasks into small, manageable pieces.</p>"},{"location":"corporate/architecture/#1-agent-level-development","title":"1. Agent Level Development","text":""},{"location":"corporate/architecture/#11-model-integration","title":"1.1 Model Integration","text":"<ul> <li> Research the most suitable models (e.g., OpenAI's GPT).</li> <li> Design an API for the agent to call the model.</li> <li> Implement error handling when model calls fail.</li> <li> Test the model with sample data for accuracy and speed.</li> </ul>"},{"location":"corporate/architecture/#12-vectorstore-implementation","title":"1.2 Vectorstore Implementation","text":"<ul> <li> Design the schema for the vector storage system.</li> <li> Implement storage methods to add, delete, and update vectors.</li> <li> Develop retrieval methods with optimization for speed.</li> <li> Create protocols for vector-based communication between agents.</li> <li> Conduct stress tests to ascertain storage and retrieval speed.</li> </ul>"},{"location":"corporate/architecture/#13-tools-utilities-integration","title":"1.3 Tools &amp; Utilities Integration","text":"<ul> <li> List out essential tools required for agent functionality.</li> <li> Develop or integrate APIs for each tool.</li> <li> Implement error handling and logging for tool interactions.</li> <li> Validate tools integration with unit tests.</li> </ul>"},{"location":"corporate/architecture/#2-worker-infrastructure-level-development","title":"2. Worker Infrastructure Level Development","text":""},{"location":"corporate/architecture/#21-human-input-integration","title":"2.1 Human Input Integration","text":"<ul> <li> Design a UI/UX for human interaction with worker nodes.</li> <li> Create APIs for input collection.</li> <li> Implement input validation and error handling.</li> <li> Test human input methods for clarity and ease of use.</li> </ul>"},{"location":"corporate/architecture/#22-unique-identifier-system","title":"2.2 Unique Identifier System","text":"<ul> <li> Research optimal formats for unique ID generation.</li> <li> Develop methods for generating and assigning IDs to agents.</li> <li> Implement a tracking system to manage and monitor agents via IDs.</li> <li> Validate the uniqueness and reliability of the ID system.</li> </ul>"},{"location":"corporate/architecture/#23-asynchronous-operation-tools","title":"2.3 Asynchronous Operation Tools","text":"<ul> <li> Incorporate libraries/frameworks to enable asynchrony.</li> <li> Ensure tasks within an agent can run in parallel without conflict.</li> <li> Test asynchronous operations for efficiency improvements.</li> </ul>"},{"location":"corporate/architecture/#3-swarm-level-development","title":"3. Swarm Level Development","text":""},{"location":"corporate/architecture/#31-orchestrator-design-development","title":"3.1 Orchestrator Design &amp; Development","text":"<ul> <li> Draft a blueprint of orchestrator functionalities.</li> <li> Implement methods for task distribution among worker nodes.</li> <li> Develop communication protocols for the orchestrator to monitor workers.</li> <li> Create feedback systems to detect and address worker node failures.</li> <li> Test orchestrator with a mock swarm to ensure efficient task allocation.</li> </ul>"},{"location":"corporate/architecture/#32-communication-layer-development","title":"3.2 Communication Layer Development","text":"<ul> <li> Select a suitable communication protocol/framework (e.g., gRPC, WebSockets).</li> <li> Design the architecture for scalable, low-latency communication.</li> <li> Implement methods for sending, receiving, and broadcasting messages.</li> <li> Test communication layer for reliability, speed, and error handling.</li> </ul>"},{"location":"corporate/architecture/#33-task-management-protocols","title":"3.3 Task Management Protocols","text":"<ul> <li> Develop a system to queue, prioritize, and allocate tasks.</li> <li> Implement methods for real-time task status tracking.</li> <li> Create a feedback loop for completed tasks.</li> <li> Test task distribution, execution, and feedback systems for efficiency.</li> </ul>"},{"location":"corporate/architecture/#4-hivemind-level-development","title":"4. Hivemind Level Development","text":""},{"location":"corporate/architecture/#41-hivemind-orchestrator-development","title":"4.1 Hivemind Orchestrator Development","text":"<ul> <li> Extend swarm orchestrator functionalities to manage multiple swarms.</li> <li> Create inter-swarm communication protocols.</li> <li> Implement load balancing mechanisms to distribute tasks across swarms.</li> <li> Validate hivemind orchestrator functionalities with multi-swarm setups.</li> </ul>"},{"location":"corporate/architecture/#42-inter-swarm-communication-protocols","title":"4.2 Inter-Swarm Communication Protocols","text":"<ul> <li> Design methods for swarms to exchange data.</li> <li> Implement data reconciliation methods for swarms working on shared tasks.</li> <li> Test inter-swarm communication for efficiency and data integrity.</li> </ul>"},{"location":"corporate/architecture/#5-scalability-performance-testing","title":"5. Scalability &amp; Performance Testing","text":"<ul> <li> Simulate heavy loads to test the limits of the framework.</li> <li> Identify and address bottlenecks in both communication and computation.</li> <li> Conduct speed tests under different conditions.</li> <li> Test the system's responsiveness under various levels of stress.</li> </ul>"},{"location":"corporate/architecture/#6-documentation-user-guide","title":"6. Documentation &amp; User Guide","text":"<ul> <li> Develop detailed documentation covering architecture, setup, and usage.</li> <li> Create user guides with step-by-step instructions.</li> <li> Incorporate visual aids, diagrams, and flowcharts for clarity.</li> <li> Update documentation regularly with new features and improvements.</li> </ul>"},{"location":"corporate/architecture/#7-continuous-integration-deployment","title":"7. Continuous Integration &amp; Deployment","text":"<ul> <li> Setup CI/CD pipelines for automated testing and deployment.</li> <li> Ensure automatic rollback in case of deployment failures.</li> <li> Integrate code quality and security checks in the pipeline.</li> <li> Document deployment strategies and best practices.</li> </ul>"},{"location":"corporate/architecture/#conclusion","title":"Conclusion","text":"<p>The Swarms framework represents a monumental leap in agent-based computation. This checklist provides a thorough roadmap for the framework's development, ensuring that every facet is addressed in depth. Through diligent adherence to this guide, the Swarms vision can be realized as a powerful, scalable, and robust system ready to tackle the challenges of tomorrow.</p> <p>(Note: This document, given the word limit, provides a high-level overview. A full 5000-word document would delve into even more intricate details, nuances, potential pitfalls, and include considerations for security, user experience, compatibility, etc.)</p>"},{"location":"corporate/bounties/","title":"Bounty Program","text":"<p>Our bounty program is an exciting opportunity for contributors to help us build the future of Swarms. By participating, you can earn rewards while contributing to a project that aims to revolutionize digital activity.</p> <p>Here's how it works:</p> <ol> <li> <p>Check out our Roadmap: We've shared our roadmap detailing our short and long-term goals. These are the areas where we're seeking contributions.</p> </li> <li> <p>Pick a Task: Choose a task from the roadmap that aligns with your skills and interests. If you're unsure, you can reach out to our team for guidance.</p> </li> <li> <p>Get to Work: Once you've chosen a task, start working on it. Remember, quality is key. We're looking for contributions that truly make a difference.</p> </li> <li> <p>Submit your Contribution: Once your work is complete, submit it for review. We'll evaluate your contribution based on its quality, relevance, and the value it brings to Swarms.</p> </li> <li> <p>Earn Rewards: If your contribution is approved, you'll earn a bounty. The amount of the bounty depends on the complexity of the task, the quality of your work, and the value it brings to Swarms.</p> </li> </ol>"},{"location":"corporate/bounties/#the-three-phases-of-our-bounty-program","title":"The Three Phases of Our Bounty Program","text":""},{"location":"corporate/bounties/#phase-1-building-the-foundation","title":"Phase 1: Building the Foundation","text":"<p>In the first phase, our focus is on building the basic infrastructure of Swarms. This includes developing key components like the Swarms class, integrating essential tools, and establishing task completion and evaluation logic. We'll also start developing our testing and evaluation framework during this phase. If you're interested in foundational work and have a knack for building robust, scalable systems, this phase is for you.</p>"},{"location":"corporate/bounties/#phase-2-enhancing-the-system","title":"Phase 2: Enhancing the System","text":"<p>In the second phase, we'll focus on enhancing Swarms by integrating more advanced features, improving the system's efficiency, and refining our testing and evaluation framework. This phase involves more complex tasks, so if you enjoy tackling challenging problems and contributing to the development of innovative features, this is the phase for you.</p>"},{"location":"corporate/bounties/#phase-3-towards-super-intelligence","title":"Phase 3: Towards Super-Intelligence","text":"<p>The third phase of our bounty program is the most exciting - this is where we aim to achieve super-intelligence. In this phase, we'll be working on improving the swarm's capabilities, expanding its skills, and fine-tuning the system based on real-world testing and feedback. If you're excited about the future of AI and want to contribute to a project that could potentially transform the digital world, this is the phase for you.</p> <p>Remember, our roadmap is a guide, and we encourage you to bring your own ideas and creativity to the table. We believe that every contribution, no matter how small, can make a difference. So join us on this exciting journey and help us create the future of Swarms.</p> <p>To participate in our bounty program, visit the Swarms Bounty Program Page. Let's build the future together!</p>"},{"location":"corporate/bounties/#bounties-for-roadmap-items","title":"Bounties for Roadmap Items","text":"<p>To accelerate the development of Swarms and to encourage more contributors to join our journey towards automating every digital activity in existence, we are announcing a Bounty Program for specific roadmap items. Each bounty will be rewarded based on the complexity and importance of the task. Below are the items available for bounty:</p> <ol> <li>Multi-Agent Debate Integration: $2000</li> <li>Meta Prompting Integration: $1500</li> <li>Swarms Class: $1500</li> <li>Integration of Additional Tools: $1000</li> <li>Task Completion and Evaluation Logic: $2000</li> <li>Ocean Integration: $2500</li> <li>Improved Communication: $2000</li> <li>Testing and Evaluation: $1500</li> <li>Worker Swarm Class: $2000</li> <li>Documentation: $500</li> </ol> <p>For each bounty task, there will be a strict evaluation process to ensure the quality of the contribution. This process includes a thorough review of the code and extensive testing to ensure it meets our standards.</p>"},{"location":"corporate/bounties/#3-phase-testing-framework","title":"3-Phase Testing Framework","text":"<p>To ensure the quality and efficiency of the Swarm, we will introduce a 3-phase testing framework which will also serve as our evaluation criteria for each of the bounty tasks.</p>"},{"location":"corporate/bounties/#phase-1-unit-testing","title":"Phase 1: Unit Testing","text":"<p>In this phase, individual modules will be tested to ensure that they work correctly in isolation. Unit tests will be designed for all functions and methods, with an emphasis on edge cases.</p>"},{"location":"corporate/bounties/#phase-2-integration-testing","title":"Phase 2: Integration Testing","text":"<p>After passing unit tests, we will test the integration of different modules to ensure they work correctly together. This phase will also test the interoperability of the Swarm with external systems and libraries.</p>"},{"location":"corporate/bounties/#phase-3-benchmarking-stress-testing","title":"Phase 3: Benchmarking &amp; Stress Testing","text":"<p>In the final phase, we will perform benchmarking and stress tests. We'll push the limits of the Swarm under extreme conditions to ensure it performs well in real-world scenarios. This phase will measure the performance, speed, and scalability of the Swarm under high load conditions.</p> <p>By following this 3-phase testing framework, we aim to develop a reliable, high-performing, and scalable Swarm that can automate all digital activities. </p>"},{"location":"corporate/bounties/#reverse-engineering-to-reach-phase-3","title":"Reverse Engineering to Reach Phase 3","text":"<p>To reach the Phase 3 level, we need to reverse engineer the tasks we need to complete. Here's an example of what this might look like:</p> <ol> <li> <p>Set Clear Expectations: Define what success looks like for each task. Be clear about the outputs and outcomes we expect. This will guide our testing and development efforts.</p> </li> <li> <p>Develop Testing Scenarios: Create a comprehensive list of testing scenarios that cover both common and edge cases. This will help us ensure that our Swarm can handle a wide range of situations.</p> </li> <li> <p>Write Test Cases: For each scenario, write detailed test cases that outline the exact steps to be followed, the inputs to be used, and the expected outputs.</p> </li> <li> <p>Execute the Tests: Run the test cases on our Swarm, making note of any issues or bugs that arise.</p> </li> <li> <p>Iterate and Improve: Based on the results of our tests, iterate and improve our Swarm. This may involve fixing bugs, optimizing code, or redesigning parts of our system.</p> </li> <li> <p>Repeat: Repeat this process until our Swarm meets our expectations and passes all test cases.</p> </li> </ol> <p>By following these steps, we will systematically build, test, and improve our Swarm until it reaches the Phase 3 level. This methodical approach will help us ensure that we create a reliable, high-performing, and scalable Swarm that can truly automate all digital activities.</p> <p>Let's shape the future of digital automation together!</p>"},{"location":"corporate/bounty_program/","title":"Swarms Bounty Program","text":"<p>The Swarms Bounty Program is an initiative designed to incentivize contributors to help us improve and expand the Swarms framework. With an impressive $150,000 allocated for bounties, contributors have the unique opportunity to earn generous rewards while gaining prestigious recognition in the Swarms community of over 9,000 agent engineers. This program offers more than just financial benefits; it allows contributors to play a pivotal role in advancing the field of multi-agent collaboration and AI automation, while also growing their professional skills and network. By joining the Swarms Bounty Program, you become part of an innovative movement shaping the future of technology.</p>"},{"location":"corporate/bounty_program/#why-contribute","title":"Why Contribute?","text":"<ol> <li> <p>Generous Rewards: The bounty pool totals $150,000, ensuring that contributors are fairly compensated for their valuable work on successfully completed tasks. Each task comes with its own reward, reflecting its complexity and impact.</p> </li> <li> <p>Community Status: Gain coveted recognition as a valued and active contributor within the thriving Swarms community. This status not only highlights your contributions but also builds your reputation among a network of AI engineers.</p> </li> <li> <p>Skill Development: Collaborate on cutting-edge AI projects, hone your expertise in agent engineering, and learn practical skills that can be applied to real-world challenges in the AI domain.</p> </li> <li> <p>Networking Opportunities: Work side-by-side with over 9,000 agent engineers in our active and supportive community. This network fosters collaboration, knowledge sharing, and mentorship opportunities that can significantly boost your career.</p> </li> </ol>"},{"location":"corporate/bounty_program/#how-it-works","title":"How It Works","text":"<ol> <li>Explore Issues and Tasks:</li> <li>Visit the Swarms GitHub Issues to find a comprehensive list of open tasks requiring attention. These issues range from coding challenges to documentation improvements, offering opportunities for contributors with various skill sets.</li> <li> <p>Check the Swarms Project Board for prioritized tasks and ongoing milestones. This board provides a clear view of project priorities and helps contributors align their efforts with the project's immediate goals.</p> </li> <li> <p>Claim a Bounty:</p> </li> <li>Identify a task that aligns with your interests and expertise.</li> <li>Comment on the issue to indicate your intent to work on it and describe your approach if necessary.</li> <li> <p>Await approval from the Swarms team before commencing work. Approval ensures clarity and avoids duplication of efforts by other contributors.</p> </li> <li> <p>Submit Your Work:</p> </li> <li>Complete the task as per the outlined requirements in the issue description. Pay close attention to details to ensure your submission meets the expectations.</li> <li>Submit your pull request (PR) on GitHub with all the required elements, including documentation, test cases, or any relevant files that demonstrate your work.</li> <li> <p>Engage with reviewers to refine your submission if requested.</p> </li> <li> <p>Earn Rewards:</p> </li> <li>Once your PR is reviewed, accepted, and merged into the main project, you will receive the bounty payment associated with the task.</li> <li>Your contributor status in the Swarms community will be updated, showcasing your involvement and accomplishments.</li> </ol>"},{"location":"corporate/bounty_program/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>To ensure high-quality contributions and streamline the process, please adhere to the following guidelines: - Familiarize yourself with the Swarms Contribution Guidelines. These guidelines outline coding standards, best practices, and procedures for contributing effectively.</p> <ul> <li> <p>Ensure your code is clean, modular, and well-documented. Contributions that adhere to the project's standards are more likely to be accepted.</p> </li> <li> <p>Actively communicate with the Swarms team and other contributors. Clear communication helps resolve uncertainties, avoids duplication, and fosters collaboration within the community.</p> </li> </ul>"},{"location":"corporate/bounty_program/#get-involved","title":"Get Involved","text":"<ol> <li>Join the Community:</li> <li> <p>Become an active member of the Swarms community by joining our Discord server: Join Now. The Discord server serves as a hub for discussions, updates, and support.</p> </li> <li> <p>Stay Updated:</p> </li> <li> <p>Keep track of the latest updates, announcements, and bounty opportunities by regularly checking the Discord channel and the GitHub repository.</p> </li> <li> <p>Start Contributing:</p> </li> <li>Dive into the Swarms GitHub repository: Swarms GitHub. Explore the codebase, familiarize yourself with the project structure, and identify areas where you can make an impact.</li> </ol>"},{"location":"corporate/bounty_program/#additional-benefits","title":"Additional Benefits","text":"<p>Beyond monetary rewards, contributors gain intangible benefits that elevate their professional journey:</p> <ul> <li> <p>Recognition: Your contributions will be showcased to a community of over 9,000 engineers, increasing your visibility and credibility in the AI field.</p> </li> <li> <p>Portfolio Building: Add high-impact contributions to your portfolio, demonstrating your skills and experience to potential employers or collaborators.</p> </li> <li> <p>Knowledge Sharing: Learn from and collaborate with experts in agent engineering, gaining insights into the latest advancements and best practices in the field.</p> </li> </ul>"},{"location":"corporate/bounty_program/#contact-us","title":"Contact Us","text":"<p>For any questions, support, or clarifications, reach out to the Swarms team:</p> <ul> <li> <p>Discord: Engage directly with the team and fellow contributors in our active channels.</p> </li> <li> <p>GitHub: Open an issue for specific questions or suggestions related to the project. We\u2019re here to guide and assist you at every step of your contribution journey.</p> </li> </ul> <p>Join us in building the future of multi-agent collaboration and AI automation. With your contributions, we can create something truly extraordinary and transformative. Together, let\u2019s pave the way for groundbreaking advancements in technology and innovation!</p>"},{"location":"corporate/checklist/","title":"Swarms Framework Development Strategy Checklist","text":""},{"location":"corporate/checklist/#introduction","title":"Introduction","text":"<p>The development of the Swarms framework requires a systematic and granular approach to ensure that each component is robust and that the overall framework is efficient and scalable. This checklist will serve as a guide to building Swarms from the ground up, breaking down tasks into small, manageable pieces.</p>"},{"location":"corporate/checklist/#1-agent-level-development","title":"1. Agent Level Development","text":""},{"location":"corporate/checklist/#11-model-integration","title":"1.1 Model Integration","text":"<ul> <li> Research the most suitable models (e.g., OpenAI's GPT).</li> <li> Design an API for the agent to call the model.</li> <li> Implement error handling when model calls fail.</li> <li> Test the model with sample data for accuracy and speed.</li> </ul>"},{"location":"corporate/checklist/#12-vectorstore-implementation","title":"1.2 Vectorstore Implementation","text":"<ul> <li> Design the schema for the vector storage system.</li> <li> Implement storage methods to add, delete, and update vectors.</li> <li> Develop retrieval methods with optimization for speed.</li> <li> Create protocols for vector-based communication between agents.</li> <li> Conduct stress tests to ascertain storage and retrieval speed.</li> </ul>"},{"location":"corporate/checklist/#13-tools-utilities-integration","title":"1.3 Tools &amp; Utilities Integration","text":"<ul> <li> List out essential tools required for agent functionality.</li> <li> Develop or integrate APIs for each tool.</li> <li> Implement error handling and logging for tool interactions.</li> <li> Validate tools integration with unit tests.</li> </ul>"},{"location":"corporate/checklist/#2-worker-infrastructure-level-development","title":"2. Worker Infrastructure Level Development","text":""},{"location":"corporate/checklist/#21-human-input-integration","title":"2.1 Human Input Integration","text":"<ul> <li> Design a UI/UX for human interaction with worker nodes.</li> <li> Create APIs for input collection.</li> <li> Implement input validation and error handling.</li> <li> Test human input methods for clarity and ease of use.</li> </ul>"},{"location":"corporate/checklist/#22-unique-identifier-system","title":"2.2 Unique Identifier System","text":"<ul> <li> Research optimal formats for unique ID generation.</li> <li> Develop methods for generating and assigning IDs to agents.</li> <li> Implement a tracking system to manage and monitor agents via IDs.</li> <li> Validate the uniqueness and reliability of the ID system.</li> </ul>"},{"location":"corporate/checklist/#23-asynchronous-operation-tools","title":"2.3 Asynchronous Operation Tools","text":"<ul> <li> Incorporate libraries/frameworks to enable asynchrony.</li> <li> Ensure tasks within an agent can run in parallel without conflict.</li> <li> Test asynchronous operations for efficiency improvements.</li> </ul>"},{"location":"corporate/checklist/#3-swarm-level-development","title":"3. Swarm Level Development","text":""},{"location":"corporate/checklist/#31-orchestrator-design-development","title":"3.1 Orchestrator Design &amp; Development","text":"<ul> <li> Draft a blueprint of orchestrator functionalities.</li> <li> Implement methods for task distribution among worker nodes.</li> <li> Develop communication protocols for the orchestrator to monitor workers.</li> <li> Create feedback systems to detect and address worker node failures.</li> <li> Test orchestrator with a mock swarm to ensure efficient task allocation.</li> </ul>"},{"location":"corporate/checklist/#32-communication-layer-development","title":"3.2 Communication Layer Development","text":"<ul> <li> Select a suitable communication protocol/framework (e.g., gRPC, WebSockets).</li> <li> Design the architecture for scalable, low-latency communication.</li> <li> Implement methods for sending, receiving, and broadcasting messages.</li> <li> Test communication layer for reliability, speed, and error handling.</li> </ul>"},{"location":"corporate/checklist/#33-task-management-protocols","title":"3.3 Task Management Protocols","text":"<ul> <li> Develop a system to queue, prioritize, and allocate tasks.</li> <li> Implement methods for real-time task status tracking.</li> <li> Create a feedback loop for completed tasks.</li> <li> Test task distribution, execution, and feedback systems for efficiency.</li> </ul>"},{"location":"corporate/checklist/#4-hivemind-level-development","title":"4. Hivemind Level Development","text":""},{"location":"corporate/checklist/#41-hivemind-orchestrator-development","title":"4.1 Hivemind Orchestrator Development","text":"<ul> <li> Extend swarm orchestrator functionalities to manage multiple swarms.</li> <li> Create inter-swarm communication protocols.</li> <li> Implement load balancing mechanisms to distribute tasks across swarms.</li> <li> Validate hivemind orchestrator functionalities with multi-swarm setups.</li> </ul>"},{"location":"corporate/checklist/#42-inter-swarm-communication-protocols","title":"4.2 Inter-Swarm Communication Protocols","text":"<ul> <li> Design methods for swarms to exchange data.</li> <li> Implement data reconciliation methods for swarms working on shared tasks.</li> <li> Test inter-swarm communication for efficiency and data integrity.</li> </ul>"},{"location":"corporate/checklist/#5-scalability-performance-testing","title":"5. Scalability &amp; Performance Testing","text":"<ul> <li> Simulate heavy loads to test the limits of the framework.</li> <li> Identify and address bottlenecks in both communication and computation.</li> <li> Conduct speed tests under different conditions.</li> <li> Test the system's responsiveness under various levels of stress.</li> </ul>"},{"location":"corporate/checklist/#6-documentation-user-guide","title":"6. Documentation &amp; User Guide","text":"<ul> <li> Develop detailed documentation covering architecture, setup, and usage.</li> <li> Create user guides with step-by-step instructions.</li> <li> Incorporate visual aids, diagrams, and flowcharts for clarity.</li> <li> Update documentation regularly with new features and improvements.</li> </ul>"},{"location":"corporate/checklist/#7-continuous-integration-deployment","title":"7. Continuous Integration &amp; Deployment","text":"<ul> <li> Setup CI/CD pipelines for automated testing and deployment.</li> <li> Ensure automatic rollback in case of deployment failures.</li> <li> Integrate code quality and security checks in the pipeline.</li> <li> Document deployment strategies and best practices.</li> </ul>"},{"location":"corporate/checklist/#conclusion","title":"Conclusion","text":"<p>The Swarms framework represents a monumental leap in agent-based computation. This checklist provides a thorough roadmap for the framework's development, ensuring that every facet is addressed in depth. Through diligent adherence to this guide, the Swarms vision can be realized as a powerful, scalable, and robust system ready to tackle the challenges of tomorrow.</p> <p>(Note: This document, given the word limit, provides a high-level overview. A full 5000-word document would delve into even more intricate details, nuances, potential pitfalls, and include considerations for security, user experience, compatibility, etc.)</p>"},{"location":"corporate/cost_analysis/","title":"Costs Structure of Deploying Autonomous Agents","text":""},{"location":"corporate/cost_analysis/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Our Time: Generating System Prompts and Custom Tools</li> <li>Consultancy Fees</li> <li>Model Inference Infrastructure</li> <li>Deployment and Continual Maintenance</li> <li>Output Metrics: Blogs Generation Rates</li> </ol>"},{"location":"corporate/cost_analysis/#1-introduction","title":"1. Introduction","text":"<p>Autonomous agents are revolutionizing various industries, from self-driving cars to chatbots and customer service solutions. The prospect of automation and improved efficiency makes these agents attractive investments. However, like any other technological solution, deploying autonomous agents involves several cost elements that organizations need to consider carefully. This comprehensive guide aims to provide an exhaustive outline of the costs associated with deploying autonomous agents.</p>"},{"location":"corporate/cost_analysis/#2-our-time-generating-system-prompts-and-custom-tools","title":"2. Our Time: Generating System Prompts and Custom Tools","text":""},{"location":"corporate/cost_analysis/#description","title":"Description","text":"<p>The deployment of autonomous agents often requires a substantial investment of time to develop system prompts and custom tools tailored to specific operational needs. </p>"},{"location":"corporate/cost_analysis/#costs","title":"Costs","text":"Task Time Required (Hours) Cost per Hour ($) Total Cost ($) System Prompts Design 50 100 5,000 Custom Tools Development 100 100 10,000 Total 150 15,000"},{"location":"corporate/cost_analysis/#3-consultancy-fees","title":"3. Consultancy Fees","text":""},{"location":"corporate/cost_analysis/#description_1","title":"Description","text":"<p>Consultation is often necessary for navigating the complexities of autonomous agents. This includes system assessment, customization, and other essential services.</p>"},{"location":"corporate/cost_analysis/#costs_1","title":"Costs","text":"Service Fees ($) Initial Assessment 5,000 System Customization 7,000 Training 3,000 Total 15,000"},{"location":"corporate/cost_analysis/#4-model-inference-infrastructure","title":"4. Model Inference Infrastructure","text":""},{"location":"corporate/cost_analysis/#description_2","title":"Description","text":"<p>The hardware and software needed for the agent's functionality, known as the model inference infrastructure, form a significant part of the costs.</p>"},{"location":"corporate/cost_analysis/#costs_2","title":"Costs","text":"Component Cost ($) Hardware 10,000 Software Licenses 2,000 Cloud Services 3,000 Total 15,000"},{"location":"corporate/cost_analysis/#5-deployment-and-continual-maintenance","title":"5. Deployment and Continual Maintenance","text":""},{"location":"corporate/cost_analysis/#description_3","title":"Description","text":"<p>Once everything is in place, deploying the autonomous agents and their ongoing maintenance are the next major cost factors.</p>"},{"location":"corporate/cost_analysis/#costs_3","title":"Costs","text":"Task Monthly Cost ($) Annual Cost ($) Deployment 5,000 60,000 Ongoing Maintenance 1,000 12,000 Total 6,000 72,000"},{"location":"corporate/cost_analysis/#6-output-metrics-blogs-generation-rates","title":"6. Output Metrics: Blogs Generation Rates","text":""},{"location":"corporate/cost_analysis/#description_4","title":"Description","text":"<p>To provide a sense of what an investment in autonomous agents can yield, we offer the following data regarding blogs that can be generated as an example of output.</p>"},{"location":"corporate/cost_analysis/#blogs-generation-rates","title":"Blogs Generation Rates","text":"Timeframe Number of Blogs Per Day 20 Per Week 140 Per Month 600"},{"location":"corporate/culture/","title":"Swarms Corp Culture Document","text":""},{"location":"corporate/culture/#our-mission-and-purpose","title":"Our Mission and Purpose","text":"<p>At Swarms Corp, we believe in more than just building technology. We are advancing humanity by pioneering systems that allow agents\u2014both AI and human\u2014to collaborate seamlessly, working toward the betterment of society and unlocking a future of abundance. Our mission is everything, and each of us is here because we understand the transformative potential of our work. We are not just a company; we are a movement aimed at reshaping the future. We strive to create systems that can tackle the most complex challenges facing humanity, from climate change to inequality, with solutions that are powered by collective intelligence. </p> <p>Our purpose goes beyond just technological advancement. We are here to create tools that empower people, uplift communities, and set a new standard for what technology can achieve when the mission is clear and the commitment is unwavering. We see every project as a step toward something greater\u2014an abundant future where human potential is limitless and artificial intelligence serves as a powerful ally to mankind.</p>"},{"location":"corporate/culture/#values-we-live-by","title":"Values We Live By","text":""},{"location":"corporate/culture/#1-hard-work-no-stone-unturned","title":"1. Hard Work: No Stone Unturned","text":"<p>We believe that hard work is the foundation of all great achievements. At Swarms Corp, each member of the team is dedicated to putting in the effort required to solve complex problems. This isn\u2019t just about long hours\u2014it\u2019s about focused, intentional work that leads to breakthroughs. We hold each other to high standards, and we don\u2019t shy away from the hard paths when the mission calls for it. Every challenge we face is an opportunity to demonstrate our resilience and our commitment to excellence. We understand that the pursuit of groundbreaking innovation demands not just effort, but a relentless curiosity and the courage to face the unknown.</p> <p>At Swarms Corp, we respect the grind because we know that transformative change doesn\u2019t happen overnight. It requires continuous effort, sacrifice, and an unwavering focus on the task at hand. We celebrate hard work, not because it\u2019s difficult, but because we understand its potential to transform ambitious ideas into tangible solutions. We honor the sweat equity that goes into building something that can truly make a difference.</p>"},{"location":"corporate/culture/#2-mission-above-everything","title":"2. Mission Above Everything","text":"<p>Our mission is our guiding star. Every decision, every task, and every project must align with our overarching purpose: advancing humanity and creating a post-scarcity world. This means sometimes putting the collective goal ahead of individual preferences or comfort. We\u2019re here to do something much larger than ourselves, and we prioritize the mission with relentless commitment. We know that personal sacrifices will often be necessary, and we embrace that reality because the rewards of our mission are far greater than any individual gain.</p> <p>When we say \"mission above everything,\" we mean that our focus is not just on immediate success, but on creating a lasting impact that will benefit future generations. Our mission provides meaning and direction to our daily efforts, and we see every task as a small yet crucial part of our broader vision. We remind ourselves constantly of why we are here and who we are working for\u2014not just our customers or stakeholders, but humanity as a whole.</p>"},{"location":"corporate/culture/#3-finding-the-shortest-path","title":"3. Finding the Shortest Path","text":"<p>Innovation thrives on efficiency. At Swarms Corp, we value finding the shortest, most effective paths to reach our goals. We encourage everyone to question the status quo, challenge existing processes, and ask, \u201cIs there a better way to do this?\u201d Creativity means finding new routes\u2014whether by leveraging automation, questioning outdated steps, or collaborating to uncover insights faster. We honor those who seek smarter paths over conventional ones. Efficiency is not just about saving time\u2014it\u2019s about maximizing impact and ensuring that every ounce of effort drives meaningful progress.</p> <p>Finding the shortest path is about eliminating unnecessary complexity and focusing our energy on what truly matters. We encourage a culture of continuous improvement, where each team member is empowered to innovate on processes, tools, and methodologies. The shortest path does not mean cutting corners\u2014it means removing obstacles, optimizing workflows, and focusing on high-leverage activities that bring us closer to our mission. We celebrate those who find elegant, effective solutions that others might overlook.</p>"},{"location":"corporate/culture/#4-advancing-humanity","title":"4. Advancing Humanity","text":"<p>The ultimate goal of everything we do is to elevate humanity. We envision a world where intelligence\u2014both human and artificial\u2014works in harmony to improve lives, solve global challenges, and expand possibilities. This ethos drives our work, whether it\u2019s developing advanced AI systems, collaborating with others to push technological boundaries, or thinking deeply about how our creations can impact society in positive ways. Every line of code, every idea, and every strategy should move us closer to this vision.</p> <p>Advancing humanity means we always think about the ethical implications of our work. We are deeply aware that the technology we create has the power to transform lives, and with that power comes the responsibility to ensure our contributions are always positive. We seek not only to push the boundaries of what technology can do but also to ensure that these advancements are inclusive and equitable. Our focus is on building a future where every person has access to the tools and opportunities they need to thrive.</p> <p>Our vision is to bridge the gap between technology and humanity\u2019s most pressing needs. We aim to democratize intelligence, making it available for everyone, regardless of their background or resources. This is how we advance humanity\u2014not just through technological feats, but by ensuring that our innovations serve the greater good and uplift everyone.</p>"},{"location":"corporate/culture/#our-way-of-working","title":"Our Way of Working","text":"<ul> <li> <p>Radical Ownership: Each team member is not just a contributor but an owner of their domain. We take full responsibility for outcomes, follow through on our promises, and ensure that nothing falls through the cracks. We don\u2019t wait for permission\u2014we act, innovate, and lead. Radical ownership means understanding that our actions have a direct impact on the success of our mission. It\u2019s about proactive problem-solving and always stepping up when we see an opportunity to make a difference.</p> </li> <li> <p>Honesty and Respect: We communicate openly and respect each other\u2019s opinions. Tough conversations are a natural part of building something impactful. We face challenges head-on with honesty and directness while maintaining a respectful and supportive atmosphere. Honesty fosters trust, and trust is the foundation of any high-performing team. We value feedback and see it as an essential tool for growth\u2014both for individuals and for the organization as a whole.</p> </li> <li> <p>One Team, One Mission: Collaboration isn\u2019t just encouraged\u2014it\u2019s essential. We operate as a swarm, where each agent contributes to a greater goal, learning from each other, sharing knowledge, and constantly iterating together. We celebrate wins collectively and approach obstacles with a unified spirit. No one succeeds alone; every achievement is the result of collective effort. We lift each other up, and we know that our strength lies in our unity and shared purpose.</p> </li> <li> <p>The Future is Ours to Shape: Our work is inherently future-focused. We\u2019re not satisfied with simply keeping up\u2014we want to set the pace. Every day, we take one step closer to a future where humanity\u2019s potential is limitless, where scarcity is eliminated, and where intelligence\u2014human and machine\u2014advances society. We are not passive participants in the future; we are active shapers of it. We imagine a better tomorrow, and then we take deliberate steps to create it. Our work today will define what the world looks like tomorrow.</p> </li> </ul>"},{"location":"corporate/culture/#expectations","title":"Expectations","text":"<ul> <li> <p>Be Bold: Don\u2019t be afraid to take risks. Innovation requires experimentation, and sometimes that means making mistakes. We support each other in learning from failures and taking smart, calculated risks. Boldness is at the heart of progress. We want every member of Swarms Corp to feel empowered to think outside the box, propose unconventional ideas, and drive innovation. Mistakes are seen not as setbacks, but as opportunities for learning and growth.</p> </li> <li> <p>Keep the Mission First: Every decision we make should be with our mission in mind. Ask yourself how your work advances the cause of creating an abundant future. The mission is the yardstick against which we measure our efforts, ensuring that everything we do pushes us closer to our ultimate goals. We understand that the mission is bigger than any one of us, and we strive to contribute meaningfully every day.</p> </li> <li> <p>Find Solutions, Not Problems: While identifying issues is important, we value those who come with solutions. Embrace challenges as opportunities to innovate and find ways to make an impact. We foster a culture of proactive problem-solving where obstacles are seen as opportunities to exercise creativity. If something\u2019s broken, we fix it. If there\u2019s a better way, we find it. We expect our team members to be solution-oriented, always seeking ways to turn challenges into stepping stones for progress.</p> </li> <li> <p>Think Big, Act Fast: We\u2019re not here to make small changes\u2014we\u2019re here to revolutionize how we think about intelligence, automation, and society. Dream big, but work with urgency. We are tackling problems of immense scale, and we must move with intention and speed. Thinking big means envisioning a world that is radically different and better, and acting fast means executing the steps to get us there without hesitation. We value ambition and the courage to move swiftly when the time is right.</p> </li> </ul>"},{"location":"corporate/culture/#our-commitment-to-you","title":"Our Commitment to You","text":"<p>Swarms Corp is a place for dreamers and doers, for those who are driven by purpose and are unafraid of the work required to achieve it. We commit to providing you with the tools, support, and environment you need to contribute meaningfully to our mission. We are here to advance humanity together, one agent, one solution, one breakthrough at a time. We pledge to nurture an environment that encourages creativity, collaboration, and bold thinking. Here, you will find a community that celebrates your wins, supports you through challenges, and pushes you to be your best self.</p> <p>Our commitment also includes ensuring that your voice is heard. We are building the future together, and every perspective matters. We strive to create an inclusive space where diversity of thought is welcomed, and where each team member feels valued for their unique contributions. At Swarms Corp, you are not just part of a team\u2014you are part of a mission that aims to change the course of humanity for the better. Together, we\u2019ll make the impossible possible, one breakthrough at a time.</p>"},{"location":"corporate/data_room/","title":"Swarms Data Room","text":""},{"location":"corporate/data_room/#table-of-contents","title":"Table of Contents","text":"<p>Introduction</p> <ul> <li> <p>Overview of the Company</p> </li> <li> <p>Vision and Mission Statement</p> </li> <li> <p>Executive Summary</p> </li> </ul> <p>Corporate Documents</p> <ul> <li> <p>Articles of Incorporation</p> </li> <li> <p>Bylaws</p> </li> <li> <p>Shareholder Agreements</p> </li> <li> <p>Board Meeting Minutes</p> </li> <li> <p>Company Structure and Org Chart</p> </li> </ul> <p>Financial Information</p> <ul> <li> <p>Historical Financial Statements</p> </li> <li> <p>Income Statements</p> </li> <li> <p>Balance Sheets</p> </li> <li> <p>Cash Flow Statements</p> </li> <li> <p>Financial Projections and Forecasts</p> </li> <li> <p>Cap Table</p> </li> <li> <p>Funding History and Use of Funds</p> </li> </ul> <p>Products and Services</p> <ul> <li> <p>Detailed Descriptions of Products/Services</p> </li> <li> <p>Product Development Roadmap</p> </li> <li> <p>User Manuals and Technical Specifications</p> </li> <li> <p>Case Studies and Use Cases</p> </li> </ul>"},{"location":"corporate/data_room/#introduction","title":"Introduction","text":"<p>Swarms provides automation-as-a-service through swarms of autonomous agents that work together as a team. We enable our customers to build, deploy, and scale production-grade multi-agent applications to automate real-world tasks.</p>"},{"location":"corporate/data_room/#vision","title":"Vision","text":"<p>Our vision for 2024 is to provide the most reliable infrastructure for deploying autonomous agents into the real world through the Swarm Cloud, our premier cloud platform for the scalable deployment of Multi-Modal Autonomous Agents. The platform focuses on delivering maximum value to users by only taking a small fee when utilizing the agents for the hosted compute power needed to host the agents.</p>"},{"location":"corporate/data_room/#executive-summary","title":"Executive Summary","text":"<p>The Swarm Corporation aims to enable AI models to automate complex workflows and operations, not just singular low-value tasks. We believe collaboration between multiple agents can overcome limitations of individual agents for reasoning, planning, etc. This will allow automation of processes in mission-critical industries like security, logistics, and manufacturing where AI adoption is currently low.  </p> <p>We provide an open source framework to deploy production-grade multi-modal agents in just a few lines of code. This builds our user base, recruits talent, gets customer feedback to improve products, gains awareness and trust.</p> <p>Our business model focuses on customer satisfaction, openness, integration with other tools/platforms, and production-grade reliability. </p> <p>Go-to-market strategy is to get the framework to product-market fit with over 50K weekly recurring users, then secure high-value contracts in target industries. Long-term monetization via microtransactions, usage-based pricing, subscriptions.</p> <p>The team has thousands of hours building and optimizing autonomous agents. Leadership includes AI engineers, product experts, open source contributors and community builders.</p> <p>Key milestones: get 80K framework users in January 2024, start contracts in target verticals, introduce commercial products in 2025 with various pricing models.</p>"},{"location":"corporate/data_room/#resources","title":"Resources","text":"<ul> <li>Swarm Pre-Seed Deck</li> <li>Swarm Memo</li> </ul>"},{"location":"corporate/data_room/#financial-documents","title":"Financial Documents","text":"<p>This section is dedicated entirely for corporate documents.</p> <ul> <li> <p>Cap Table</p> </li> <li> <p>Cashflow Prediction Sheet</p> </li> </ul>"},{"location":"corporate/data_room/#product","title":"Product","text":"<p>Swarms is an open source framework for developers in python to enable seamless, reliable, and scalable multi-agent orchestration through modularity, customization, and precision.</p> <ul> <li>Swarms Github Page:</li> <li>Swarms Memo</li> <li>Swarms Project Board</li> <li>Swarms Website</li> <li>Swarm Ecosystem</li> <li>Swarm Core</li> </ul>"},{"location":"corporate/data_room/#product-growth-metrics","title":"Product Growth Metrics","text":"Name Description Link Total Downloads of all time Total number of downloads for the product over its entire lifespan. Downloads this month Number of downloads for the product in the current month. Total Downloads this week Total number of downloads for the product in the current week. Github Forks Number of times the product's codebase has been copied for optimization, contribution, or usage. Github Stars Number of users who have 'liked' the project. Pip Module Metrics Various project statistics such as watchers, number of contributors, date repository was created, and more. CLICK HERE Contribution Based Statistics Statistics like number of contributors, lines of code changed, etc. HERE Github Community insights Insights into the Github community around the product. Github Community insights Github Traffic Metrics Metrics related to traffic, such as views and clones on Github. Github Traffic Metrics Issues with the framework Current open issues for the product on Github."},{"location":"corporate/demos/","title":"Demo Ideas","text":"<ul> <li> <p>We could also try to create an AI influencer run by a swarm, let it create a whole identity and generate images, memes, and other content for Twitter, Reddit, etc.</p> </li> <li> <p>had a thought that we should have either a more general one of these or a swarm or both -- need something connecting all the calendars, events, and initiatives of all the AI communities, langchain, laion, eluther, lesswrong, gato, rob miles, chatgpt hackers, etc etc</p> </li> <li> <p>Swarm of AI influencers to spread marketing</p> </li> <li> <p>Delegation System to better organize teams: Start with a team of passionate humans and let them self-report their skills/strengths so the agent has a concept of who to delegate to, then feed the agent a huge task list (like the bullet list a few messages above) that it breaks down into actionable steps and \"prompts\" specific team members to complete tasks. Could even suggest breakout teams of a few people with complementary skills to tackle more complex tasks. There can also be a live board that updates each time a team member completes something, to encourage momentum and keep track of progress</p> </li> </ul>"},{"location":"corporate/design/","title":"Design Philosophy Document for Swarms","text":""},{"location":"corporate/design/#usable","title":"Usable","text":""},{"location":"corporate/design/#objective","title":"Objective","text":"<p>Our goal is to ensure that Swarms is intuitive and easy to use for all users, regardless of their level of technical expertise. This includes the developers who implement Swarms in their applications, as well as end users who interact with the implemented systems.</p>"},{"location":"corporate/design/#tactics","title":"Tactics","text":"<ul> <li>Clear and Comprehensive Documentation: We will provide well-written and easily accessible documentation that guides users through using and understanding Swarms.</li> <li>User-Friendly APIs: We'll design clean and self-explanatory APIs that help developers to understand their purpose quickly.</li> <li>Prompt and Effective Support: We will ensure that support is readily available to assist users when they encounter problems or need help with Swarms.</li> </ul>"},{"location":"corporate/design/#reliable","title":"Reliable","text":""},{"location":"corporate/design/#objective_1","title":"Objective","text":"<p>Swarms should be dependable and trustworthy. Users should be able to count on Swarms to perform consistently and without error or failure.</p>"},{"location":"corporate/design/#tactics_1","title":"Tactics","text":"<ul> <li>Robust Error Handling: We will focus on error prevention, detection, and recovery to minimize failures in Swarms.</li> <li>Comprehensive Testing: We will apply various testing methodologies such as unit testing, integration testing, and stress testing to validate the reliability of our software.</li> <li>Continuous Integration/Continuous Delivery (CI/CD): We will use CI/CD pipelines to ensure that all changes are tested and validated before they're merged into the main branch.</li> </ul>"},{"location":"corporate/design/#fast","title":"Fast","text":""},{"location":"corporate/design/#objective_2","title":"Objective","text":"<p>Swarms should offer high performance and rapid response times. The system should be able to handle requests and tasks swiftly.</p>"},{"location":"corporate/design/#tactics_2","title":"Tactics","text":"<ul> <li>Efficient Algorithms: We will focus on optimizing our algorithms and data structures to ensure they run as quickly as possible.</li> <li>Caching: Where appropriate, we will use caching techniques to speed up response times.</li> <li>Profiling and Performance Monitoring: We will regularly analyze the performance of Swarms to identify bottlenecks and opportunities for improvement.</li> </ul>"},{"location":"corporate/design/#scalable","title":"Scalable","text":""},{"location":"corporate/design/#objective_3","title":"Objective","text":"<p>Swarms should be able to grow in capacity and complexity without compromising performance or reliability. It should be able to handle increased workloads gracefully.</p>"},{"location":"corporate/design/#tactics_3","title":"Tactics","text":"<ul> <li>Modular Architecture: We will design Swarms using a modular architecture that allows for easy scaling and modification.</li> <li>Load Balancing: We will distribute tasks evenly across available resources to prevent overload and maximize throughput.</li> <li>Horizontal and Vertical Scaling: We will design Swarms to be capable of both horizontal (adding more machines) and vertical (adding more power to an existing machine) scaling.</li> </ul>"},{"location":"corporate/design/#philosophy","title":"Philosophy","text":"<p>Swarms is designed with a philosophy of simplicity and reliability. We believe that software should be a tool that empowers users, not a hurdle that they need to overcome. Therefore, our focus is on usability, reliability, speed, and scalability. We want our users to find Swarms intuitive and dependable, fast and adaptable to their needs. This philosophy guides all of our design and development decisions.</p>"},{"location":"corporate/design/#swarm-architecture-design-document","title":"Swarm Architecture Design Document","text":""},{"location":"corporate/design/#overview","title":"Overview","text":"<p>The goal of the Swarm Architecture is to provide a flexible and scalable system to build swarm intelligence models that can solve complex problems. This document details the proposed design to create a plug-and-play system, which makes it easy to create custom swarms, and provides pre-configured swarms with multi-modal agents.</p>"},{"location":"corporate/design/#design-principles","title":"Design Principles","text":"<ul> <li>Modularity: The system will be built in a modular fashion, allowing various components to be easily swapped or upgraded.</li> <li>Interoperability: Different swarm classes and components should be able to work together seamlessly.</li> <li>Scalability: The design should support the growth of the system by adding more components or swarms.</li> <li>Ease of Use: Users should be able to easily create their own swarms or use pre-configured ones with minimal configuration.</li> </ul>"},{"location":"corporate/design/#design-components","title":"Design Components","text":""},{"location":"corporate/design/#baseswarm","title":"BaseSwarm","text":"<p>The BaseSwarm is an abstract base class which defines the basic structure of a swarm and the methods that need to be implemented. Any new swarm should inherit from this class and implement the required methods.</p>"},{"location":"corporate/design/#swarm-classes","title":"Swarm Classes","text":"<p>Various Swarm classes can be implemented inheriting from the BaseSwarm class. Each swarm class should implement the required methods for initializing the components, worker nodes, and boss node, and running the swarm.</p> <p>Pre-configured swarm classes with multi-modal agents can be provided for ease of use. These classes come with a default configuration of tools and agents, which can be used out of the box.</p>"},{"location":"corporate/design/#tools-and-agents","title":"Tools and Agents","text":"<p>Tools and agents are the components that provide the actual functionality to the swarms. They can be language models, AI assistants, vector stores, or any other components that can help in problem solving.</p> <p>To make the system plug-and-play, a standard interface should be defined for these components. Any new tool or agent should implement this interface, so that it can be easily plugged into the system.</p>"},{"location":"corporate/design/#usage","title":"Usage","text":"<p>Users can either use pre-configured swarms or create their own custom swarms.</p> <p>To use a pre-configured swarm, they can simply instantiate the corresponding swarm class and call the run method with the required objective.</p> <p>To create a custom swarm, they need to:</p> <ol> <li>Define a new swarm class inheriting from BaseSwarm.</li> <li>Implement the required methods for the new swarm class.</li> <li>Instantiate the swarm class and call the run method.</li> </ol>"},{"location":"corporate/design/#example","title":"Example","text":"<pre><code># Using pre-configured swarm\nswarm = PreConfiguredSwarm(openai_api_key)\nswarm.run_swarms(objective)\n\n# Creating custom swarm\nclass CustomSwarm(BaseSwarm):\n    # Implement required methods\n\nswarm = CustomSwarm(openai_api_key)\nswarm.run_swarms(objective)\n</code></pre>"},{"location":"corporate/design/#conclusion","title":"Conclusion","text":"<p>This Swarm Architecture design provides a scalable and flexible system for building swarm intelligence models. The plug-and-play design allows users to easily use pre-configured swarms or create their own custom swarms.</p>"},{"location":"corporate/design/#swarming-architectures","title":"Swarming Architectures","text":"<p>Sure, below are five different swarm architectures with their base requirements and an abstract class that processes these components:</p> <ol> <li> <p>Hierarchical Swarm: This architecture is characterized by a boss/worker relationship. The boss node takes high-level decisions and delegates tasks to the worker nodes. The worker nodes perform tasks and report back to the boss node. </p> <ul> <li>Requirements: Boss node (can be a large language model), worker nodes (can be smaller language models), and a task queue for task management.</li> </ul> </li> <li> <p>Homogeneous Swarm: In this architecture, all nodes in the swarm are identical and contribute equally to problem-solving. Each node has the same capabilities.</p> <ul> <li>Requirements: Homogeneous nodes (can be language models of the same size), communication protocol for nodes to share information.</li> </ul> </li> <li> <p>Heterogeneous Swarm: This architecture contains different types of nodes, each with its specific capabilities. This diversity can lead to more robust problem-solving.</p> <ul> <li>Requirements: Different types of nodes (can be different types and sizes of language models), a communication protocol, and a mechanism to delegate tasks based on node capabilities.</li> </ul> </li> <li> <p>Competitive Swarm: In this architecture, nodes compete with each other to find the best solution. The system may use a selection process to choose the best solutions.</p> <ul> <li>Requirements: Nodes (can be language models), a scoring mechanism to evaluate node performance, a selection mechanism.</li> </ul> </li> <li> <p>Cooperative Swarm: In this architecture, nodes work together and share information to find solutions. The focus is on cooperation rather than competition.</p> <ul> <li>Requirements: Nodes (can be language models), a communication protocol, a consensus mechanism to agree on solutions.</li> </ul> </li> <li> <p>Grid-based Swarm: This architecture positions agents on a grid, where they can only interact with their neighbors. This is useful for simulations, especially in fields like ecology or epidemiology.</p> <ul> <li>Requirements: Agents (can be language models), a grid structure, and a neighborhood definition (i.e., how to identify neighboring agents).</li> </ul> </li> <li> <p>Particle Swarm Optimization (PSO) Swarm: In this architecture, each agent represents a potential solution to an optimization problem. Agents move in the solution space based on their own and their neighbors' past performance. PSO is especially useful for continuous numerical optimization problems.</p> <ul> <li>Requirements: Agents (each representing a solution), a definition of the solution space, an evaluation function to rate the solutions, a mechanism to adjust agent positions based on performance.</li> </ul> </li> <li> <p>Ant Colony Optimization (ACO) Swarm: Inspired by ant behavior, this architecture has agents leave a pheromone trail that other agents follow, reinforcing the best paths. It's useful for problems like the traveling salesperson problem.</p> <ul> <li>Requirements: Agents (can be language models), a representation of the problem space, a pheromone updating mechanism.</li> </ul> </li> <li> <p>Genetic Algorithm (GA) Swarm: In this architecture, agents represent potential solutions to a problem. They can 'breed' to create new solutions and can undergo 'mutations'. GA swarms are good for search and optimization problems.</p> <ul> <li>Requirements: Agents (each representing a potential solution), a fitness function to evaluate solutions, a crossover mechanism to breed solutions, and a mutation mechanism.</li> </ul> </li> <li> <p>Stigmergy-based Swarm: In this architecture, agents communicate indirectly by modifying the environment, and other agents react to such modifications. It's a decentralized method of coordinating tasks.</p> <ul> <li>Requirements: Agents (can be language models), an environment that agents can modify, a mechanism for agents to perceive environment changes.</li> </ul> </li> </ol> <p>These architectures all have unique features and requirements, but they share the need for agents (often implemented as language models) and a mechanism for agents to communicate or interact, whether it's directly through messages, indirectly through the environment, or implicitly through a shared solution space. Some also require specific data structures, like a grid or problem space, and specific algorithms, like for evaluating solutions or updating agent positions.</p>"},{"location":"corporate/distribution/","title":"Swarms Monetization Strategy","text":"<p>This strategy includes a variety of business models, potential revenue streams, cashflow structures, and customer identification methods. Let's explore these further.</p>"},{"location":"corporate/distribution/#business-models","title":"Business Models","text":"<ol> <li> <p>Platform as a Service (PaaS): Provide the Swarms AI platform on a subscription basis, charged monthly or annually. This could be tiered based on usage and access to premium features. </p> </li> <li> <p>API Usage-based Pricing: Charge customers based on their usage of the Swarms API. The more requests made, the higher the fee.</p> </li> <li> <p>Managed Services: Offer complete end-to-end solutions where you manage the entire AI infrastructure for the clients. This could be on a contract basis with a recurring fee.</p> </li> <li> <p>Training and Certification: Provide Swarms AI training and certification programs for interested developers and businesses. These could be monetized as separate courses or subscription-based access.</p> </li> <li> <p>Partnerships: Collaborate with large enterprises and offer them dedicated Swarm AI services. These could be performance-based contracts, ensuring a mutually beneficial relationship.</p> </li> <li> <p>Data as a Service (DaaS): Leverage the data generated by Swarms for insights and analytics, providing valuable business intelligence to clients.</p> </li> </ol>"},{"location":"corporate/distribution/#potential-revenue-streams","title":"Potential Revenue Streams","text":"<ol> <li> <p>Subscription Fees: This would be the main revenue stream from providing the Swarms platform as a service.</p> </li> <li> <p>Usage Fees: Additional revenue can come from usage fees for businesses that have high demand for Swarms API.</p> </li> <li> <p>Contract Fees: From offering managed services and bespoke solutions to businesses.</p> </li> <li> <p>Training Fees: Revenue from providing training and certification programs to developers and businesses.</p> </li> <li> <p>Partnership Contracts: Large-scale projects with enterprises, involving dedicated Swarm AI services, could provide substantial income.</p> </li> <li> <p>Data Insights: Revenue from selling valuable business intelligence derived from Swarm's aggregated and anonymized data.</p> </li> </ol>"},{"location":"corporate/distribution/#potential-customers","title":"Potential Customers","text":"<ol> <li> <p>Businesses Across Sectors: Any business seeking to leverage AI for automation, efficiency, and data insights could be a potential customer. This includes sectors like finance, eCommerce, logistics, healthcare, and more.</p> </li> <li> <p>Developers: Both freelance and those working in organizations could use Swarms to enhance their projects and services. </p> </li> <li> <p>Enterprises: Large enterprises looking to automate and optimize their operations could greatly benefit from Swarms.</p> </li> <li> <p>Educational Institutions: Universities and research institutions could leverage Swarms for research and teaching purposes.</p> </li> </ol>"},{"location":"corporate/distribution/#roadmap","title":"Roadmap","text":"<ol> <li> <p>Landing Page Creation: Develop a dedicated product page on apac.ai for Swarms.</p> </li> <li> <p>Hosted Swarms API: Launch a cloud-based Swarms API service. It should be highly reliable, with robust documentation to attract daily users.</p> </li> <li> <p>Consumer and Enterprise Subscription Service: Launch a comprehensive subscription service on The Domain. This would provide users with access to a wide array of APIs and data streams.</p> </li> <li> <p>Dedicated Capacity Deals: Partner with large enterprises to offer them dedicated Swarm AI solutions for automating their operations.</p> </li> <li> <p>Enterprise Partnerships: Develop partnerships with large enterprises for extensive contract-based projects.</p> </li> <li> <p>Integration with Collaboration Platforms: Develop Swarms bots for platforms like Discord and Slack, charging users a subscription fee for access.</p> </li> <li> <p>Personal Data Instances: Offer users dedicated instances of all their data that the Swarm can query as needed.</p> </li> <li> <p>Browser Extension: Develop a browser extension that integrates with the Swarms platform, offering users a more seamless experience.</p> </li> </ol> <p>Remember, customer satisfaction and a value-centric approach are at the core of any successful monetization strategy. It's essential to continuously iterate and improve the product based on customer feedback and evolving market needs.</p>"},{"location":"corporate/distribution/#other-ideas","title":"Other ideas","text":"<ol> <li> <p>Platform as a Service (PaaS): Create a cloud-based platform that allows users to build, run, and manage applications without the complexity of maintaining the infrastructure. You could charge users a subscription fee for access to the platform and provide different pricing tiers based on usage levels. This could be an attractive solution for businesses that do not have the capacity to build or maintain their own swarm intelligence solutions.</p> </li> <li> <p>Professional Services: Offer consultancy and implementation services to businesses looking to utilize the Swarm technology. This could include assisting with integration into existing systems, offering custom development services, or helping customers to build specific solutions using the framework.</p> </li> <li> <p>Education and Training: Create a certification program for developers or companies looking to become proficient with the Swarms framework. This could be sold as standalone courses, or bundled with other services. </p> </li> <li> <p>Managed Services: Some companies may prefer to outsource the management of their Swarm-based systems. A managed services solution could take care of all the technical aspects, from hosting the solution to ensuring it runs smoothly, allowing the customer to focus on their core business.</p> </li> <li> <p>Data Analysis and Insights: Swarm intelligence can generate valuable data and insights. By anonymizing and aggregating this data, you could provide industry reports, trend analysis, and other valuable insights to businesses.</p> </li> </ol> <p>As for the type of platform, Swarms can be offered as a cloud-based solution given its scalability and flexibility. This would also allow you to apply a SaaS/PaaS type monetization model, which provides recurring revenue.</p> <p>Potential customers could range from small to large enterprises in various sectors such as logistics, eCommerce, finance, and technology, who are interested in leveraging artificial intelligence and machine learning for complex problem solving, optimization, and decision-making.</p> <p>Product Brief Monetization Strategy:</p> <p>Product Name: Swarms.AI Platform</p> <p>Product Description: A cloud-based AI and ML platform harnessing the power of swarm intelligence. </p> <ol> <li> <p>Platform as a Service (PaaS): Offer tiered subscription plans (Basic, Premium, Enterprise) to accommodate different usage levels and business sizes. </p> </li> <li> <p>Professional Services: Offer consultancy and custom development services to tailor the Swarms solution to the specific needs of the business.</p> </li> <li> <p>Education and Training: Launch an online Swarms.AI Academy with courses and certifications for developers and businesses. </p> </li> <li> <p>Managed Services: Provide a premium, fully-managed service offering that includes hosting, maintenance, and 24/7 support.</p> </li> <li> <p>Data Analysis and Insights: Offer industry reports and customized insights generated from aggregated and anonymized Swarm data.</p> </li> </ol> <p>Potential Customers: Enterprises in sectors such as logistics, eCommerce, finance, and technology. This can be sold globally, provided there's an internet connection.</p> <p>Marketing Channels: Online marketing (SEO, Content Marketing, Social Media), Partnerships with tech companies, Direct Sales to Enterprises.</p> <p>This strategy is designed to provide multiple revenue streams, while ensuring the Swarms.AI platform is accessible and useful to a range of potential customers.</p> <ol> <li> <p>AI Solution as a Service: By offering the Swarms framework as a service, businesses can access and utilize the power of multiple LLM agents without the need to maintain the infrastructure themselves. Subscription can be tiered based on usage and additional features.</p> </li> <li> <p>Integration and Custom Development: Offer integration services to businesses wanting to incorporate the Swarms framework into their existing systems. Also, you could provide custom development for businesses with specific needs not met by the standard framework.</p> </li> <li> <p>Training and Certification: Develop an educational platform offering courses, webinars, and certifications on using the Swarms framework. This can serve both developers seeking to broaden their skills and businesses aiming to train their in-house teams.</p> </li> <li> <p>Managed Swarms Solutions: For businesses that prefer to outsource their AI needs, provide a complete solution which includes the development, maintenance, and continuous improvement of swarms-based applications.</p> </li> <li> <p>Data Analytics Services: Leveraging the aggregated insights from the AI swarms, you could offer data analytics services. Businesses can use these insights to make informed decisions and predictions.</p> </li> </ol> <p>Type of Platform:</p> <p>Cloud-based platform or Software as a Service (SaaS) will be a suitable model. It offers accessibility, scalability, and ease of updates. </p> <p>Target Customers:</p> <p>The technology can be beneficial for businesses across sectors like eCommerce, technology, logistics, finance, healthcare, and education, among others.</p> <p>Product Brief Monetization Strategy:</p> <p>Product Name: Swarms.AI</p> <ol> <li> <p>AI Solution as a Service: Offer different tiered subscriptions (Standard, Premium, and Enterprise) each with varying levels of usage and features.</p> </li> <li> <p>Integration and Custom Development: Offer custom development and integration services, priced based on the scope and complexity of the project.</p> </li> <li> <p>Training and Certification: Launch the Swarms.AI Academy with courses and certifications, available for a fee. </p> </li> <li> <p>Managed Swarms Solutions: Offer fully managed solutions tailored to business needs, priced based on scope and service level agreements.</p> </li> <li> <p>Data Analytics Services: Provide insightful reports and data analyses, which can be purchased on a one-off basis or through a subscription.</p> </li> </ol> <p>By offering a variety of services and payment models, Swarms.AI will be able to cater to a diverse range of business needs, from small start-ups to large enterprises. Marketing channels would include digital marketing, partnerships with technology companies, presence in tech events, and direct sales to targeted industries.</p>"},{"location":"corporate/distribution/#roadmap_1","title":"Roadmap","text":"<ul> <li> <p>Create a landing page for swarms apac.ai/product/swarms</p> </li> <li> <p>Create Hosted Swarms API for anybody to just use without need for mega gpu infra, charge usage based pricing. Prerequisites for success =&gt; Swarms has to be extremely reliable + we need world class documentation and many daily users =&gt; how do we get many daily users? We provide a seamless and fluid experience, how do we create a seamless and fluid experience? We write good code that is modular, provides feedback to the user in times of distress, and ultimately accomplishes the user's tasks.</p> </li> <li> <p>Hosted consumer and enterprise subscription as a service on The Domain, where users can interact with 1000s of APIs and ingest 1000s of different data streams.</p> </li> <li> <p>Hosted dedicated capacity deals with mega enterprises on automating many operations with Swarms for monthly subscription 300,000+$ </p> </li> <li> <p>Partnerships with enterprises, massive contracts with performance based fee</p> </li> <li> <p>Have discord bot and or slack bot with users personal data, charge subscription + browser extension</p> </li> <li> <p>each user gets a dedicated ocean instance of all their data so the swarm can query it as needed.</p> </li> </ul>"},{"location":"corporate/distribution/#-","title":"---","text":""},{"location":"corporate/distribution/#swarms-monetization-strategy-a-revolutionary-ai-powered-future","title":"Swarms Monetization Strategy: A Revolutionary AI-powered Future","text":"<p>Swarms is a powerful AI platform leveraging the transformative potential of Swarm Intelligence. Our ambition is to monetize this groundbreaking technology in ways that generate significant cashflow while providing extraordinary value to our customers. </p> <p>Here we outline our strategic monetization pathways and provide a roadmap that plots our course to future success.</p>"},{"location":"corporate/distribution/#i-business-models","title":"I. Business Models","text":"<ol> <li> <p>Platform as a Service (PaaS): We provide the Swarms platform as a service, billed on a monthly or annual basis. Subscriptions can range from $50 for basic access, to $500+ for premium features and extensive usage.</p> </li> <li> <p>API Usage-based Pricing: Customers are billed according to their use of the Swarms API. Starting at $0.01 per request, this creates a cashflow model that rewards extensive platform usage.</p> </li> <li> <p>Managed Services: We offer end-to-end solutions, managing clients' entire AI infrastructure. Contract fees start from $100,000 per month, offering both a sustainable cashflow and considerable savings for our clients.</p> </li> <li> <p>Training and Certification: A Swarms AI training and certification program is available for developers and businesses. Course costs can range from $200 to $2,000, depending on course complexity and duration.</p> </li> <li> <p>Partnerships: We forge collaborations with large enterprises, offering dedicated Swarm AI services. These performance-based contracts start from $1,000,000, creating a potentially lucrative cashflow stream.</p> </li> <li> <p>Data as a Service (DaaS): Swarms generated data are mined for insights and analytics, with business intelligence reports offered from $500 each. </p> </li> </ol>"},{"location":"corporate/distribution/#ii-potential-revenue-streams","title":"II. Potential Revenue Streams","text":"<ol> <li> <p>Subscription Fees: From $50 to $500+ per month for platform access.</p> </li> <li> <p>Usage Fees: From $0.01 per API request, generating income from high platform usage.</p> </li> <li> <p>Contract Fees: Starting from $100,000 per month for managed services.</p> </li> <li> <p>Training Fees: From $200 to $2,000 for individual courses or subscription access.</p> </li> <li> <p>Partnership Contracts: Contracts starting from $100,000, offering major income potential.</p> </li> <li> <p>Data Insights: Business intelligence reports starting from $500.</p> </li> </ol>"},{"location":"corporate/distribution/#iii-potential-customers","title":"III. Potential Customers","text":"<ol> <li> <p>Businesses Across Sectors: Our offerings cater to businesses across finance, eCommerce, logistics, healthcare, and more.</p> </li> <li> <p>Developers: Both freelancers and organization-based developers can leverage Swarms for their projects.</p> </li> <li> <p>Enterprises: Swarms offers large enterprises solutions for optimizing operations.</p> </li> <li> <p>Educational Institutions: Universities and research institutions can use Swarms for research and teaching.</p> </li> </ol>"},{"location":"corporate/distribution/#iv-roadmap","title":"IV. Roadmap","text":"<ol> <li> <p>Landing Page Creation: Develop a dedicated Swarms product page on apac.ai.</p> </li> <li> <p>Hosted Swarms API: Launch a reliable, well-documented cloud-based Swarms API service.</p> </li> <li> <p>Consumer and Enterprise Subscription Service: Launch an extensive subscription service on The Domain, providing wide-ranging access to APIs and data streams.</p> </li> <li> <p>Dedicated Capacity Deals: Offer large enterprises dedicated Swarm AI solutions, starting from $300,000 monthly subscription.</p> </li> <li> <p>Enterprise Partnerships: Develop performance-based contracts with large enterprises.</p> </li> <li> <p>Integration with Collaboration Platforms: Develop Swarms bots for platforms like Discord and Slack, charging a subscription fee for access.</p> </li> <li> <p>Personal Data Instances: Offer users dedicated data instances that the Swarm can query as needed.</p> </li> <li> <p>Browser Extension: Develop a browser extension that integrates with the Swarms platform for seamless user experience.</p> </li> </ol> <p>Our North Star remains customer satisfaction and value provision.  As we embark on this journey, we continuously refine our product based on customer feedback and evolving market needs, ensuring we lead in the age of AI-driven solutions.</p>"},{"location":"corporate/distribution/#platform-distribution-strategy-for-swarms","title":"Platform Distribution Strategy for Swarms","text":"<p>*Note: This strategy aims to diversify the presence of 'Swarms' across various platforms and mediums while focusing on monetization and value creation for its users.</p>"},{"location":"corporate/distribution/#1-framework","title":"1. Framework:","text":""},{"location":"corporate/distribution/#objective","title":"Objective:","text":"<p>To offer Swarms as an integrated solution within popular frameworks to ensure that developers and businesses can seamlessly incorporate its functionalities.</p>"},{"location":"corporate/distribution/#strategy","title":"Strategy:","text":"<ul> <li> <p>Language/Framework Integration: </p> <ul> <li>Target popular frameworks like Django, Flask for Python, Express.js for Node, etc. </li> <li>Create SDKs or plugins for easy integration. </li> </ul> </li> <li> <p>Monetization: </p> <ul> <li>Freemium Model: Offer basic integration for free, and charge for additional features or advanced integrations.</li> <li>Licensing: Allow businesses to purchase licenses for enterprise-level integrations.</li> </ul> </li> <li> <p>Promotion:</p> <ul> <li>Engage in partnerships with popular online coding platforms like Udemy, Coursera, etc., offering courses and tutorials on integrating Swarms.</li> <li>Host webinars and write technical blogs to promote the integration benefits.</li> </ul> </li> </ul>"},{"location":"corporate/distribution/#2-paid-api","title":"2. Paid API:","text":""},{"location":"corporate/distribution/#objective_1","title":"Objective:","text":"<p>To provide a scalable solution for developers and businesses that want direct access to Swarms' functionalities without integrating the entire framework.</p>"},{"location":"corporate/distribution/#strategy_1","title":"Strategy:","text":"<ul> <li> <p>API Endpoints:</p> <ul> <li>Offer various endpoints catering to different functionalities.</li> <li>Maintain robust documentation to ensure ease of use.</li> </ul> </li> <li> <p>Monetization:</p> <ul> <li>Usage-based Pricing: Charge based on the number of API calls.</li> <li>Subscription Tiers: Provide tiered packages based on usage limits and advanced features.</li> </ul> </li> <li> <p>Promotion:</p> <ul> <li>List on API marketplaces like RapidAPI.</li> <li>Engage in SEO to make the API documentation discoverable.</li> </ul> </li> </ul>"},{"location":"corporate/distribution/#3-domain-hosted","title":"3. Domain Hosted:","text":""},{"location":"corporate/distribution/#objective_2","title":"Objective:","text":"<p>To provide a centralized web platform where users can directly access and engage with Swarms' offerings.</p>"},{"location":"corporate/distribution/#strategy_2","title":"Strategy:","text":"<ul> <li> <p>User-Friendly Interface:</p> <ul> <li>Ensure a seamless user experience with intuitive design.</li> <li>Incorporate features like real-time chat support, tutorials, and an FAQ section.</li> </ul> </li> <li> <p>Monetization:</p> <ul> <li>Subscription Model: Offer monthly/annual subscriptions for premium features.</li> <li>Affiliate Marketing: Partner with related tech products/services and earn through referrals.</li> </ul> </li> <li> <p>Promotion:</p> <ul> <li>Invest in PPC advertising on platforms like Google Ads.</li> <li>Engage in content marketing, targeting keywords related to Swarms' offerings.</li> </ul> </li> </ul>"},{"location":"corporate/distribution/#4-build-your-own-no-code-platform","title":"4. Build Your Own (No-Code Platform):","text":""},{"location":"corporate/distribution/#objective_3","title":"Objective:","text":"<p>To cater to the non-developer audience, allowing them to leverage Swarms' features without any coding expertise.</p>"},{"location":"corporate/distribution/#strategy_3","title":"Strategy:","text":"<ul> <li> <p>Drag-and-Drop Interface:</p> <ul> <li>Offer customizable templates.</li> <li>Ensure integration with popular platforms and apps.</li> </ul> </li> <li> <p>Monetization:</p> <ul> <li>Freemium Model: Offer basic features for free, and charge for advanced functionalities.</li> <li>Marketplace for Plugins: Allow third-party developers to sell their plugins/extensions on the platform.</li> </ul> </li> <li> <p>Promotion:</p> <ul> <li>Partner with no-code communities and influencers.</li> <li>Offer promotions and discounts to early adopters.</li> </ul> </li> </ul>"},{"location":"corporate/distribution/#5-marketplace-for-the-no-code-platform","title":"5. Marketplace for the No-Code Platform:","text":""},{"location":"corporate/distribution/#objective_4","title":"Objective:","text":"<p>To create an ecosystem where third-party developers can contribute, and users can enhance their Swarms experience.</p>"},{"location":"corporate/distribution/#strategy_4","title":"Strategy:","text":"<ul> <li> <p>Open API for Development:</p> <ul> <li>Offer robust documentation and developer support.</li> <li>Ensure a strict quality check for marketplace additions.</li> </ul> </li> <li> <p>Monetization:</p> <ul> <li>Revenue Sharing: Take a percentage cut from third-party sales.</li> <li>Featured Listings: Charge developers for premium listings.</li> </ul> </li> <li> <p>Promotion:</p> <ul> <li>Host hackathons and competitions to boost developer engagement.</li> <li>Promote top plugins/extensions through email marketing and on the main platform.</li> </ul> </li> </ul>"},{"location":"corporate/distribution/#future-outlook-expansion","title":"Future Outlook &amp; Expansion:","text":"<ul> <li>Hosted Dedicated Capacity: Hosted dedicated capacity deals for enterprises starting at 399,999$</li> <li>Decentralized Free Peer to peer endpoint hosted on The Grid: Hosted endpoint by the people for the people.</li> <li> <p>Browser Extenision: Athena browser extension for deep browser automation, subscription, usage, </p> </li> <li> <p>Mobile Application: Develop a mobile app version for Swarms to tap into the vast mobile user base.</p> </li> <li>Global Expansion: Localize the platform for non-English speaking regions to tap into global markets.</li> <li>Continuous Learning: Regularly collect user feedback and iterate on the product features.</li> </ul>"},{"location":"corporate/distribution/#50-creative-distribution-platforms-for-swarms","title":"50 Creative Distribution Platforms for Swarms","text":"<ol> <li> <p>E-commerce Integrations: Platforms like Shopify, WooCommerce, where Swarms can add value to sellers.</p> </li> <li> <p>Web Browser Extensions: Chrome, Firefox, and Edge extensions that bring Swarms features directly to users.</p> </li> <li> <p>Podcasting Platforms: Swarms-themed content on platforms like Spotify, Apple Podcasts to reach aural learners.</p> </li> <li> <p>Virtual Reality (VR) Platforms: Integration with VR experiences on Oculus or Viveport.</p> </li> <li> <p>Gaming Platforms: Tools or plugins for game developers on Steam, Epic Games.</p> </li> <li> <p>Decentralized Platforms: Using blockchain, create decentralized apps (DApps) versions of Swarms.</p> </li> <li> <p>Chat Applications: Integrate with popular messaging platforms like WhatsApp, Telegram, Slack.</p> </li> <li> <p>AI Assistants: Integration with Siri, Alexa, Google Assistant to provide Swarms functionalities via voice commands.</p> </li> <li> <p>Freelancing Websites: Offer tools or services for freelancers on platforms like Upwork, Fiverr.</p> </li> <li> <p>Online Forums: Platforms like Reddit, Quora, where users can discuss or access Swarms.</p> </li> <li> <p>Educational Platforms: Sites like Khan Academy, Udacity where Swarms can enhance learning experiences.</p> </li> <li> <p>Digital Art Platforms: Integrate with platforms like DeviantArt, Behance.</p> </li> <li> <p>Open-source Repositories: Hosting Swarms on GitHub, GitLab, Bitbucket with open-source plugins.</p> </li> <li> <p>Augmented Reality (AR) Apps: Create AR experiences powered by Swarms.</p> </li> <li> <p>Smart Home Devices: Integrate Swarms' functionalities into smart home devices.</p> </li> <li> <p>Newsletters: Platforms like Substack, where Swarms insights can be shared.</p> </li> <li> <p>Interactive Kiosks: In malls, airports, and other public places.</p> </li> <li> <p>IoT Devices: Incorporate Swarms in devices like smart fridges, smartwatches.</p> </li> <li> <p>Collaboration Tools: Platforms like Trello, Notion, offering Swarms-enhanced productivity.</p> </li> <li> <p>Dating Apps: An AI-enhanced matching algorithm powered by Swarms.</p> </li> <li> <p>Music Platforms: Integrate with Spotify, SoundCloud for music-related AI functionalities.</p> </li> <li> <p>Recipe Websites: Platforms like AllRecipes, Tasty with AI-recommended recipes.</p> </li> <li> <p>Travel &amp; Hospitality: Integrate with platforms like Airbnb, Tripadvisor for AI-based recommendations.</p> </li> <li> <p>Language Learning Apps: Duolingo, Rosetta Stone integrations.</p> </li> <li> <p>Virtual Events Platforms: Websites like Hopin, Zoom where Swarms can enhance the virtual event experience.</p> </li> <li> <p>Social Media Management: Tools like Buffer, Hootsuite with AI insights by Swarms.</p> </li> <li> <p>Fitness Apps: Platforms like MyFitnessPal, Strava with AI fitness insights.</p> </li> <li> <p>Mental Health Apps: Integration into apps like Calm, Headspace for AI-driven wellness.</p> </li> <li> <p>E-books Platforms: Amazon Kindle, Audible with AI-enhanced reading experiences.</p> </li> <li> <p>Sports Analysis Tools: Websites like ESPN, Sky Sports where Swarms can provide insights.</p> </li> <li> <p>Financial Tools: Integration into platforms like Mint, Robinhood for AI-driven financial advice.</p> </li> <li> <p>Public Libraries: Digital platforms of public libraries for enhanced reading experiences.</p> </li> <li> <p>3D Printing Platforms: Websites like Thingiverse, Shapeways with AI customization.</p> </li> <li> <p>Meme Platforms: Websites like Memedroid, 9GAG where Swarms can suggest memes.</p> </li> <li> <p>Astronomy Apps: Platforms like Star Walk, NASA's Eyes with AI-driven space insights.</p> </li> <li> <p>Weather Apps: Integration into Weather.com, AccuWeather for predictive analysis.</p> </li> <li> <p>Sustainability Platforms: Websites like Ecosia, GoodGuide with AI-driven eco-tips.</p> </li> <li> <p>Fashion Apps: Platforms like ASOS, Zara with AI-based style recommendations.</p> </li> <li> <p>Pet Care Apps: Integration into PetSmart, Chewy for AI-driven pet care tips.</p> </li> <li> <p>Real Estate Platforms: Websites like Zillow, Realtor with AI-enhanced property insights.</p> </li> <li> <p>DIY Platforms: Websites like Instructables, DIY.org with AI project suggestions.</p> </li> <li> <p>Genealogy Platforms: Ancestry, MyHeritage with AI-driven family tree insights.</p> </li> <li> <p>Car Rental &amp; Sale Platforms: Integration into AutoTrader, Turo for AI-driven vehicle suggestions.</p> </li> <li> <p>Wedding Planning Websites: Platforms like Zola, The Knot with AI-driven planning.</p> </li> <li> <p>Craft Platforms: Websites like Etsy, Craftsy with AI-driven craft suggestions.</p> </li> <li> <p>Gift Recommendation Platforms: AI-driven gift suggestions for websites like Gifts.com.</p> </li> <li> <p>Study &amp; Revision Platforms: Websites like Chegg, Quizlet with AI-driven study guides.</p> </li> <li> <p>Local Business Directories: Yelp, Yellow Pages with AI-enhanced reviews.</p> </li> <li> <p>Networking Platforms: LinkedIn, Meetup with AI-driven connection suggestions.</p> </li> <li> <p>Lifestyle Magazines' Digital Platforms: Websites like Vogue, GQ with AI-curated fashion and lifestyle insights.</p> </li> </ol> <p>Endnote: Leveraging these diverse platforms ensures that Swarms becomes an integral part of multiple ecosystems, enhancing its visibility and user engagement.</p>"},{"location":"corporate/failures/","title":"Failure Root Cause Analysis for Langchain","text":""},{"location":"corporate/failures/#1-introduction","title":"1. Introduction","text":"<p>Langchain is an open-source software that has gained massive popularity in the artificial intelligence ecosystem, serving as a tool for connecting different language models, especially GPT based models. However, despite its popularity and substantial investment, Langchain has shown several weaknesses that hinder its use in various projects, especially in complex and large-scale implementations. This document provides an analysis of the identified issues and proposes potential mitigation strategies.</p>"},{"location":"corporate/failures/#2-analysis-of-weaknesses","title":"2. Analysis of Weaknesses","text":""},{"location":"corporate/failures/#21-tool-lock-in","title":"2.1 Tool Lock-in","text":"<p>Langchain tends to enforce tool lock-in, which could prove detrimental for developers. Its design heavily relies on specific workflows and architectures, which greatly limits flexibility. Developers may find themselves restricted to certain methodologies, impeding their freedom to implement custom solutions or integrate alternative tools.</p>"},{"location":"corporate/failures/#mitigation","title":"Mitigation","text":"<p>An ideal AI framework should not be restrictive but should instead offer flexibility for users to integrate any agent on any architecture. Adopting an open architecture that allows for seamless interaction between various agents and workflows can address this issue.</p>"},{"location":"corporate/failures/#22-outdated-workflows","title":"2.2 Outdated Workflows","text":"<p>Langchain's current workflows and prompt engineering, mainly based on InstructGPT, are out of date, especially compared to newer models like ChatGPT/GPT-4.</p>"},{"location":"corporate/failures/#mitigation_1","title":"Mitigation","text":"<p>Keeping up with the latest AI models and workflows is crucial. The framework should have a mechanism for regular updates and seamless integration of up-to-date models and workflows.</p>"},{"location":"corporate/failures/#23-debugging-difficulties","title":"2.3 Debugging Difficulties","text":"<p>Debugging in Langchain is reportedly very challenging, even with verbose output enabled, making it hard to determine what is happening under the hood.</p>"},{"location":"corporate/failures/#mitigation_2","title":"Mitigation","text":"<p>The introduction of a robust debugging and logging system would help users understand the internals of the models, thus enabling them to pinpoint and rectify issues more effectively.</p>"},{"location":"corporate/failures/#24-limited-customization","title":"2.4 Limited Customization","text":"<p>Langchain makes it extremely hard to deviate from documented workflows. This becomes a challenge when developers need custom workflows for their specific use-cases.</p>"},{"location":"corporate/failures/#mitigation_3","title":"Mitigation","text":"<p>An ideal framework should support custom workflows and allow developers to hack and adjust the framework according to their needs.</p>"},{"location":"corporate/failures/#25-documentation","title":"2.5 Documentation","text":"<p>Langchain's documentation is reportedly missing relevant details, making it difficult for users to understand the differences between various agent types, among other things.</p>"},{"location":"corporate/failures/#mitigation_4","title":"Mitigation","text":"<p>Providing detailed and comprehensive documentation, including examples, FAQs, and best practices, is crucial. This will help users understand the intricacies of the framework, making it easier for them to implement it in their projects.</p>"},{"location":"corporate/failures/#26-negative-influence-on-ai-ecosystem","title":"2.6 Negative Influence on AI Ecosystem","text":"<p>The extreme popularity of Langchain seems to be warping the AI ecosystem to the point of causing harm, with other AI entities shifting their operations to align with Langchain's 'magic AI' approach.</p>"},{"location":"corporate/failures/#mitigation_5","title":"Mitigation","text":"<p>It's essential for any widely adopted framework to promote healthy practices in the broader ecosystem. One approach could be promoting open dialogue, inviting criticism, and being open to change based on feedback.</p>"},{"location":"corporate/failures/#3-conclusion","title":"3. Conclusion","text":"<p>While Langchain has made significant contributions to the AI landscape, these challenges hinder its potential. Addressing these issues will not only improve Langchain but also foster a healthier AI ecosystem. It's important to note that criticism, when approached constructively, can be a powerful tool for growth and innovation.</p>"},{"location":"corporate/failures/#list-of-weaknesses-in-glangchain-and-potential-mitigations","title":"List of weaknesses in gLangchain and Potential Mitigations","text":"<ol> <li>Tool Lock-in: Langchain encourages the use of specific tools, creating a lock-in problem with minimal benefits for developers. </li> </ol> <p>Mitigation Strategy: Langchain should consider designing the architecture to be more versatile and allow for the inclusion of a variety of tools. An open architecture will provide developers with more freedom and customization options.</p> <ol> <li>Outdated Workflow: The current workflow and prompt engineering of Langchain rely on outdated models like InstructGPT, which fall short compared to newer alternatives such as ChatGPT/GPT-4.</li> </ol> <p>Mitigation Strategy: Regular updates and adaptation of more recent models should be integrated into the Langchain framework.</p> <ol> <li>Debugging Difficulty: Debugging a Langchain error is a complicated task, even with verbose=True, leading to a discouraging developer experience.</li> </ol> <p>Mitigation Strategy: Develop a comprehensive debugging tool or improve current debugging processes for clearer and more accessible error detection and resolution.</p> <ol> <li>Lack of Customizability: Customizing workflows that are not documented in Langchain is quite challenging.</li> </ol> <p>Mitigation Strategy: Improve documentation and provide guides on how to customize workflows to enhance developer flexibility.</p> <ol> <li>Poor Documentation: Langchain's documentation misses key details that developers have to manually search for in the codebase.</li> </ol> <p>Mitigation Strategy: Enhance and improve the documentation of Langchain to provide clarity for developers and make navigation easier.</p> <ol> <li>Harmful Ecosystem Influence: Langchain's extreme popularity is influencing the AI ecosystem towards the workflows, potentially harming development and code clarity.</li> </ol> <p>Mitigation Strategy: Encourage diverse and balanced adoption of AI tools in the ecosystem.</p> <ol> <li>Suboptimal Performances: Langchain's performance is sometimes underwhelming, and there are no clear benefits in terms of performance or abstraction.</li> </ol> <p>Mitigation Strategy: Enhance the performance optimization of Langchain. Benchmarking against other tools can also provide performance improvement insights.</p> <ol> <li>Rigid General Interface: Langchain tries to do too many things, resulting in a rigid interface not suitable for practical use, especially in production.</li> </ol> <p>Mitigation Strategy: Focus on core features and allow greater flexibility in the interface. Adopting a modular approach where developers can pick and choose the features they want could also be helpful.</p> <ol> <li>Leaky Abstraction Problem: Langchain\u2019s full-on framework approach has created a leaky abstraction problem leading to a disappointing developer experience.</li> </ol> <p>Mitigation Strategy: Adopt a more balanced approach between a library and a framework. Provide a solid core feature set with the possibility to extend it according to the developers' needs. </p> <ol> <li>Excessive Focus on Third-party Services: Langchain overly focuses on supporting every single third-party service at the expense of customizability and fine-tuning for actual applications.</li> </ol> <p>Mitigation Strategy: Prioritize fine-tuning and customizability for developers, limiting the focus on third-party services unless they provide substantial value.</p> <p>Remember, any mitigation strategy will need to be tailored to Langchain's particular circumstances and developer feedback. It's also important to consider potential trade-offs and unintended consequences when implementing these strategies.</p>"},{"location":"corporate/faq/","title":"Faq","text":""},{"location":"corporate/faq/#faq-on-swarm-intelligence-and-multi-agent-systems","title":"FAQ on Swarm Intelligence and Multi-Agent Systems","text":""},{"location":"corporate/faq/#what-is-an-agent-in-the-context-of-ai-and-swarm-intelligence","title":"What is an agent in the context of AI and swarm intelligence?","text":"<p>In artificial intelligence (AI), an agent refers to an LLM with some objective to accomplish.</p> <p>In swarm intelligence, each agent interacts with other agents and possibly the environment to achieve complex collective behaviors or solve problems more efficiently than individual agents could on their own.</p>"},{"location":"corporate/faq/#what-do-you-need-swarms-at-all","title":"What do you need Swarms at all?","text":"<p>Individual agents are limited by a vast array of issues such as context window loss, single task execution, hallucination, and no collaboration.</p>"},{"location":"corporate/faq/#how-does-a-swarm-work","title":"How does a swarm work?","text":"<p>A swarm works through the principles of decentralized control, local interactions, and simple rules followed by each agent. Unlike centralized systems, where a single entity dictates the behavior of all components, in a swarm, each agent makes its own decisions based on local information and interactions with nearby agents. These local interactions lead to the emergence of complex, organized behaviors or solutions at the collective level, enabling the swarm to tackle tasks efficiently.</p>"},{"location":"corporate/faq/#why-do-you-need-more-agents-in-a-swarm","title":"Why do you need more agents in a swarm?","text":"<p>More agents in a swarm can enhance its problem-solving capabilities, resilience, and efficiency. With more agents:</p> <ul> <li>Diversity and Specialization: The swarm can leverage a wider range of skills, knowledge, and perspectives, allowing for more creative and effective solutions to complex problems.</li> <li>Scalability: Adding more agents can increase the swarm's capacity to handle larger tasks or multiple tasks simultaneously.</li> <li>Robustness: A larger number of agents enhances the system's redundancy and fault tolerance, as the failure of a few agents has a minimal impact on the overall performance of the swarm.</li> </ul>"},{"location":"corporate/faq/#isnt-it-more-expensive-to-use-more-agents","title":"Isn't it more expensive to use more agents?","text":"<p>While deploying more agents can initially increase costs, especially in terms of computational resources, hosting, and potentially API usage, there are several factors and strategies that can mitigate these expenses:</p> <ul> <li>Efficiency at Scale: Larger swarms can often solve problems more quickly or effectively, reducing the overall computational time and resources required.</li> <li>Optimization and Caching: Implementing optimizations and caching strategies can reduce redundant computations, lowering the workload on individual agents and the overall system.</li> <li>Dynamic Scaling: Utilizing cloud services that offer dynamic scaling can ensure you only pay for the resources you need when you need them, optimizing cost-efficiency.</li> </ul>"},{"location":"corporate/faq/#can-swarms-make-decisions-better-than-individual-agents","title":"Can swarms make decisions better than individual agents?","text":"<p>Yes, swarms can make better decisions than individual agents for several reasons:</p> <ul> <li>Collective Intelligence: Swarms combine the knowledge and insights of multiple agents, leading to more informed and well-rounded decision-making processes.</li> <li>Error Correction: The collaborative nature of swarms allows for error checking and correction among agents, reducing the likelihood of mistakes.</li> <li>Adaptability: Swarms are highly adaptable to changing environments or requirements, as the collective can quickly reorganize or shift strategies based on new information.</li> </ul>"},{"location":"corporate/faq/#how-do-agents-in-a-swarm-communicate","title":"How do agents in a swarm communicate?","text":"<p>Communication in a swarm can vary based on the design and purpose of the system but generally involves either direct or indirect interactions:</p> <ul> <li>Direct Communication: Agents exchange information directly through messaging, signals, or other communication protocols designed for the system.</li> <li>Indirect Communication: Agents influence each other through the environment, a method known as stigmergy. Actions by one agent alter the environment, which in turn influences the behavior of other agents.</li> </ul>"},{"location":"corporate/faq/#are-swarms-only-useful-in-computational-tasks","title":"Are swarms only useful in computational tasks?","text":"<p>While swarms are often associated with computational tasks, their applications extend far beyond. Swarms can be utilized in:</p> <ul> <li>Robotics: Coordinating multiple robots for tasks like search and rescue, exploration, or surveillance.</li> <li>Environmental Monitoring: Using sensor networks to monitor pollution, wildlife, or climate conditions.</li> <li>Social Sciences: Modeling social behaviors or economic systems to understand complex societal dynamics.</li> <li>Healthcare: Coordinating care strategies in hospital settings or managing pandemic responses through distributed data analysis.</li> </ul>"},{"location":"corporate/faq/#how-do-you-ensure-the-security-of-a-swarm-system","title":"How do you ensure the security of a swarm system?","text":"<p>Security in swarm systems involves:</p> <ul> <li>Encryption: Ensuring all communications between agents are encrypted to prevent unauthorized access or manipulation.</li> <li>Authentication: Implementing strict authentication mechanisms to verify the identity of each agent in the swarm.</li> <li>Resilience to Attacks: Designing the swarm to continue functioning effectively even if some agents are compromised or attacked, utilizing redundancy and fault tolerance strategies.</li> </ul>"},{"location":"corporate/faq/#how-do-individual-agents-within-a-swarm-share-insights-without-direct-learning-mechanisms-like-reinforcement-learning","title":"How do individual agents within a swarm share insights without direct learning mechanisms like reinforcement learning?","text":"<p>In the context of pre-trained Large Language Models (LLMs) that operate within a swarm, sharing insights typically involves explicit communication and data exchange protocols rather than direct learning mechanisms like reinforcement learning. Here's how it can work:</p> <ul> <li> <p>Shared Databases and Knowledge Bases: Agents can write to and read from a shared database or knowledge base where insights, generated content, and relevant data are stored. This allows agents to benefit from the collective experience of the swarm by accessing information that other agents have contributed.</p> </li> <li> <p>APIs for Information Exchange: Custom APIs can facilitate the exchange of information between agents. Through these APIs, agents can request specific information or insights from others within the swarm, effectively sharing knowledge without direct learning.</p> </li> </ul>"},{"location":"corporate/faq/#how-do-you-balance-the-autonomy-of-individual-llms-with-the-need-for-coherent-collective-behavior-in-a-swarm","title":"How do you balance the autonomy of individual LLMs with the need for coherent collective behavior in a swarm?","text":"<p>Balancing autonomy with collective coherence in a swarm of LLMs involves:</p> <ul> <li> <p>Central Coordination Mechanism: Implementing a lightweight central coordination mechanism that can assign tasks, distribute information, and collect outputs from individual LLMs. This ensures that while each LLM operates autonomously, their actions are aligned with the swarm's overall objectives.</p> </li> <li> <p>Standardized Communication Protocols: Developing standardized protocols for how LLMs communicate and share information ensures that even though each agent works autonomously, the information exchange remains coherent and aligned with the collective goals.</p> </li> </ul>"},{"location":"corporate/faq/#how-do-llm-swarms-adapt-to-changing-environments-or-tasks-without-machine-learning-techniques","title":"How do LLM swarms adapt to changing environments or tasks without machine learning techniques?","text":"<p>Adaptation in LLM swarms, without relying on machine learning techniques for dynamic learning, can be achieved through:</p> <ul> <li> <p>Dynamic Task Allocation: A central system or distributed algorithm can dynamically allocate tasks to different LLMs based on the changing environment or requirements. This ensures that the most suitable LLMs are addressing tasks for which they are best suited as conditions change.</p> </li> <li> <p>Pre-trained Versatility: Utilizing a diverse set of pre-trained LLMs with different specialties or training data allows the swarm to select the most appropriate agent for a task as the requirements evolve.</p> </li> <li> <p>In Context Learning: In context learning is another mechanism that can be employed within LLM swarms to adapt to changing environments or tasks. This approach involves leveraging the collective knowledge and experiences of the swarm to facilitate learning and improve performance. Here's how it can work:</p> </li> </ul>"},{"location":"corporate/faq/#can-llm-swarms-operate-in-physical-environments-or-are-they-limited-to-digital-spaces","title":"Can LLM swarms operate in physical environments, or are they limited to digital spaces?","text":"<p>LLM swarms primarily operate in digital spaces, given their nature as software entities. However, they can interact with physical environments indirectly through interfaces with sensors, actuaries, or other devices connected to the Internet of Things (IoT). For example, LLMs can process data from physical sensors and control devices based on their outputs, enabling applications like smart home management or autonomous vehicle navigation.</p>"},{"location":"corporate/faq/#without-direct-learning-from-each-other-how-do-agents-in-a-swarm-improve-over-time","title":"Without direct learning from each other, how do agents in a swarm improve over time?","text":"<p>Improvement over time in a swarm of pre-trained LLMs, without direct learning from each other, can be achieved through:</p> <ul> <li> <p>Human Feedback: Incorporating feedback from human operators or users can guide adjustments to the usage patterns or selection criteria of LLMs within the swarm, optimizing performance based on observed outcomes.</p> </li> <li> <p>Periodic Re-training and Updating: The individual LLMs can be periodically re-trained or updated by their developers based on collective insights and feedback from their deployment within swarms. While this does not involve direct learning from each encounter, it allows the LLMs to improve over time based on aggregated experiences.</p> </li> </ul> <p>These adjustments to the FAQ reflect the specific context of pre-trained LLMs operating within a swarm, focusing on communication, coordination, and adaptation mechanisms that align with their capabilities and constraints.</p>"},{"location":"corporate/faq/#conclusion","title":"Conclusion","text":"<p>Swarms represent a powerful paradigm in AI, offering innovative solutions to complex, dynamic problems through collective intelligence and decentralized control. While challenges exist, particularly regarding cost and security, strategic design and management can leverage the strengths of swarm intelligence to achieve remarkable efficiency, adaptability, and robustness in a wide range of applications.</p>"},{"location":"corporate/flywheel/","title":"The Swarms Flywheel","text":"<ol> <li> <p>Building a Supportive Community: Initiate by establishing an engaging and inclusive open-source community for both developers and sales freelancers around Swarms. Regular online meetups, webinars, tutorials, and sales training can make them feel welcome and encourage contributions and sales efforts.</p> </li> <li> <p>Increased Contributions and Sales Efforts: The more engaged the community, the more developers will contribute to Swarms and the more effort sales freelancers will put into selling Swarms.</p> </li> <li> <p>Improvement in Quality and Market Reach: More developer contributions mean better quality, reliability, and feature offerings from Swarms. Simultaneously, increased sales efforts from freelancers boost Swarms' market penetration and visibility.</p> </li> <li> <p>Rise in User Base: As Swarms becomes more robust and more well-known, the user base grows, driving more revenue.</p> </li> <li> <p>Greater Financial Incentives: Increased revenue can be redirected to offer more significant financial incentives to both developers and salespeople. Developers can be incentivized based on their contribution to Swarms, and salespeople can be rewarded with higher commissions.</p> </li> <li> <p>Attract More Developers and Salespeople: These financial incentives, coupled with the recognition and experience from participating in a successful project, attract more developers and salespeople to the community.</p> </li> <li> <p>Wider Adoption of Swarms: An ever-improving product, a growing user base, and an increasing number of passionate salespeople accelerate the adoption of Swarms.</p> </li> <li> <p>Return to Step 1: As the community, user base, and sales network continue to grow, the cycle repeats, each time speeding up the flywheel.</p> </li> </ol> <pre><code>               +---------------------+\n               |   Building a       |\n               |  Supportive        | &lt;--+\n               |   Community        |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               |   Increased        |    |\n               | Contributions &amp;    |    |\n               |   Sales Efforts    |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               |   Improvement in   |    |\n               | Quality &amp; Market   |    |\n               |       Reach        |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               |   Rise in User     |    |\n               |        Base        |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               |  Greater Financial |    |\n               |     Incentives     |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               | Attract More        |    |\n               | Developers &amp;       |    |\n               | Salespeople         |    |\n               +--------+-----------+    |\n                        |                |\n                        v                |\n               +--------+-----------+    |\n               |  Wider Adoption of  |    |\n               |       Swarms        |----+\n               +---------------------+\n</code></pre>"},{"location":"corporate/flywheel/#potential-risks-and-mitigations","title":"Potential Risks and Mitigations:","text":"<ol> <li>Insufficient Contributions or Quality of Work: Open-source efforts rely on individuals being willing and able to spend time contributing. If not enough people participate, or the work they produce is of poor quality, the product development could stall. </li> <li> <p>Mitigation: Create a robust community with clear guidelines, support, and resources. Provide incentives for quality contributions, such as a reputation system, swag, or financial rewards. Conduct thorough code reviews to ensure the quality of contributions.</p> </li> <li> <p>Lack of Sales Results: Commission-based salespeople will only continue to sell the product if they're successful. If they aren't making enough sales, they may lose motivation and cease their efforts.</p> </li> <li> <p>Mitigation: Provide adequate sales training and resources. Ensure the product-market fit is strong, and adjust messaging or sales tactics as necessary. Consider implementing a minimum commission or base pay to reduce risk for salespeople.</p> </li> <li> <p>Poor User Experience or User Adoption: If users don't find the product useful or easy to use, they won't adopt it, and the user base won't grow. This could also discourage salespeople and contributors.</p> </li> <li> <p>Mitigation: Prioritize user experience in the product development process. Regularly gather and incorporate user feedback. Ensure robust user support is in place.</p> </li> <li> <p>Inadequate Financial Incentives: If the financial rewards don't justify the time and effort contributors and salespeople are putting in, they will likely disengage.</p> </li> <li> <p>Mitigation: Regularly review and adjust financial incentives as needed. Ensure that the method for calculating and distributing rewards is transparent and fair.</p> </li> <li> <p>Security and Compliance Risks: As the user base grows and the software becomes more complex, the risk of security issues increases. Moreover, as contributors from various regions join, compliance with various international laws could become an issue.</p> </li> <li>Mitigation: Establish strong security practices from the start. Regularly conduct security audits. Seek legal counsel to understand and adhere to international laws and regulations.</li> </ol>"},{"location":"corporate/flywheel/#activation-plan-for-the-flywheel","title":"Activation Plan for the Flywheel:","text":"<ol> <li> <p>Community Building: Begin by fostering a supportive community around Swarms. Encourage early adopters to contribute and provide feedback. Create comprehensive documentation, community guidelines, and a forum for discussion and support.</p> </li> <li> <p>Sales and Development Training: Provide resources and training for salespeople and developers. Make sure they understand the product, its value, and how to effectively contribute or sell.</p> </li> <li> <p>Increase Contributions and Sales Efforts: Encourage increased participation by highlighting successful contributions and sales, rewarding top contributors and salespeople, and regularly communicating about the project's progress and impact.</p> </li> <li> <p>Iterate and Improve: Continually gather and implement feedback to improve Swarms and its market reach. The better the product and its alignment with the market, the more the user base will grow.</p> </li> <li> <p>Expand User Base: As the product improves and sales efforts continue, the user base should grow. Ensure you have the infrastructure to support this growth and maintain a positive user experience.</p> </li> <li> <p>Increase Financial Incentives: As the user base and product grow, so too should the financial incentives. Make sure rewards continue to be competitive and attractive.</p> </li> <li> <p>Attract More Contributors and Salespeople: As the financial incentives and success of the product increase, this should attract more contributors and salespeople, further feeding the flywheel.</p> </li> </ol> <p>Throughout this process, it's important to regularly reassess and adjust your strategy as necessary. Stay flexible and responsive to changes in the market, user feedback, and the evolving needs of the community.</p>"},{"location":"corporate/front_end_contributors/","title":"Frontend Contributor Guide","text":""},{"location":"corporate/front_end_contributors/#mission","title":"Mission","text":"<p>At the heart of Swarms is the mission to democratize multi-agent technology, making it accessible to businesses of all sizes around the globe. This technology, which allows for the orchestration of multiple autonomous agents to achieve complex goals, has the potential to revolutionize industries by enhancing efficiency, scalability, and innovation. Swarms is committed to leading this charge by developing a platform that empowers businesses and individuals to harness the power of multi-agent systems without the need for specialized knowledge or resources.</p>"},{"location":"corporate/front_end_contributors/#understanding-your-impact-as-a-frontend-engineer","title":"Understanding Your Impact as a Frontend Engineer","text":"<p>Crafting User Experiences: As a frontend engineer at Swarms, you play a crucial role in making multi-agent technology understandable and usable for businesses worldwide. Your work involves translating complex systems into intuitive interfaces, ensuring users can easily navigate, manage, and benefit from multi-agent solutions. By focusing on user-centric design and seamless integration, you help bridge the gap between advanced technology and practical business applications.</p> <p>Skills and Attributes for Success: Successful frontend engineers at Swarms combine technical expertise with a passion for innovation and a deep understanding of user needs. Proficiency in modern frontend technologies, such as React, NextJS, and Tailwind, is just the beginning. You also need a strong grasp of usability principles, accessibility standards, and the ability to work collaboratively with cross-functional teams. Creativity, problem-solving skills, and a commitment to continuous learning are essential for developing solutions that meet diverse business needs.</p>"},{"location":"corporate/front_end_contributors/#joining-the-team","title":"Joining the Team","text":"<p>As you contribute to Swarms, you become part of a collaborative effort to change the world. We value each contribution and provide constructive feedback to help you grow. Outstanding contributors who share our vision and demonstrate exceptional skill and dedication are invited to join our team, where they can have an even greater impact on our mission.</p>"},{"location":"corporate/front_end_contributors/#becoming-a-full-time-swarms-engineer","title":"Becoming a Full-Time Swarms Engineer:","text":"<p>Swarms is radically devoted to open source and transparency. To join the full time team, you must first contribute to the open source repository so we can assess your technical capability and general way of working. After a series of quality contributions, we'll offer you a full time position!</p> <p>Joining Swarms full-time means more than just a job. It's an opportunity to be at the forefront of technological innovation, working alongside passionate professionals dedicated to making a difference. We look for individuals who are not only skilled but also driven by the desire to make multi-agent technology accessible and beneficial to businesses worldwide.</p>"},{"location":"corporate/front_end_contributors/#resources","title":"Resources","text":"<ul> <li>Project Management Details</li> <li> <p>Linear: Our projects and tasks at a glance. Get a sense of our workflow and priorities.</p> <ul> <li>View on Linear </li> </ul> </li> <li> <p>Design System and UI/UX Guidelines</p> </li> <li> <p>Figma: Dive into our design system to grasp the aesthetics and user experience objectives of Swarms.</p> <ul> <li>View on Figma</li> </ul> </li> <li> <p>Swarms Platform Repository</p> </li> <li> <p>GitHub: The hub of our development activities. Familiarize yourself with our codebase and current projects.</p> <ul> <li>Visit GitHub Repository</li> </ul> </li> <li> <p>Swarms Community</p> </li> </ul>"},{"location":"corporate/front_end_contributors/#design-style-user-experience","title":"Design Style &amp; User Experience","text":"<ul> <li>How to build great products with game design, not gamification</li> </ul>"},{"location":"corporate/hiring/","title":"Careers at Swarms","text":"<p>We are a team of engineers, developers, and visionaries on a mission to build the future of AI by orchestrating multi-agent collaboration. We move fast, think ambitiously, and deliver with urgency. Join us if you want to be part of building the next generation of multi-agent systems, redefining how businesses automate operations and leverage AI.</p> <p>We offer none of the following benefits Yet:</p> <ul> <li> <p>No medical, dental, or vision insurance</p> </li> <li> <p>No paid time off</p> </li> <li> <p>No life or AD&amp;D insurance</p> </li> <li> <p>No short-term or long-term disability insurance</p> </li> <li> <p>No 401(k) plan</p> </li> </ul> <p>Working hours: 9 AM to 10 PM, every day, 7 days a week. This is not for people who seek work-life balance.</p>"},{"location":"corporate/hiring/#hiring-process-how-to-join-swarms","title":"Hiring Process: How to Join Swarms","text":"<p>We have a simple 3-step hiring process:</p> <p>NOTE We do not consider applicants who have not previously submitted a PR, to be considered a PR containing a new feature of a bug fixed must be submitted.</p> <ol> <li>Submit a pull request (PR): Start by submitting an approved PR to the Swarms GitHub repository or the appropriate repository .</li> <li>Code review: Our technical team will review your PR. If it meets our standards, you will be invited for a quick interview.</li> <li>Final interview: Discuss your contributions and approach with our team. If you pass, you're in!</li> </ol> <p>There are no recruiters. All evaluations are done by our technical team.</p>"},{"location":"corporate/hiring/#location","title":"Location","text":"<ul> <li> <p>Palo Alto CA Our Palo Alto office houses the majority of our core research teams including our prompting, agent design, and model training</p> </li> <li> <p>Miami Our miami office holds prompt engineering, agent design, and more.</p> </li> </ul>"},{"location":"corporate/hiring/#open-roles-at-swarms","title":"Open Roles at Swarms","text":"<p>Infrastructure Engineer</p> <ul> <li> <p>Build and maintain the systems that run our AI multi-agent infrastructure.</p> </li> <li> <p>Expertise in Skypilot, AWS, Terraform.</p> </li> <li> <p>Ensure seamless, high-availability environments for agent operations.</p> </li> </ul> <p>Agent Engineer</p> <ul> <li> <p>Design, develop, and orchestrate complex swarms of AI agents.</p> </li> <li> <p>Extensive experience with Python, multi-agent systems, and neural networks.</p> </li> <li> <p>Ability to create dynamic and efficient agent architectures from scratch.</p> </li> </ul> <p>Prompt Engineer</p> <ul> <li> <p>Craft highly optimized prompts that drive our LLM-based agents.</p> </li> <li> <p>Specialize in instruction-based prompts, multi-shot examples, and production-grade deployment.</p> </li> <li> <p>Collaborate with agents to deliver state-of-the-art solutions.</p> </li> </ul> <p>Front-End Engineer</p> <ul> <li> <p>Build sleek, intuitive interfaces for interacting with swarms of agents.</p> </li> <li> <p>Proficiency in Next.js, FastAPI, and modern front-end technologies.</p> </li> <li> <p>Design with the user experience in mind, integrating complex AI features into simple workflows.</p> </li> </ul>"},{"location":"corporate/metric/","title":"The Golden Metric: 95% User-Task-Completion-Satisfaction Rate","text":"<p>In the world of Swarms, there\u2019s one metric that stands above the rest: the User-Task-Completion-Satisfaction (UTCS) rate. This metric is the heart of our system, the pulse that keeps us moving forward. It\u2019s not just a number; it\u2019s a reflection of our commitment to our users and a measure of our success.</p>"},{"location":"corporate/metric/#what-is-the-utcs-rate","title":"What is the UTCS Rate?","text":"<p>The UTCS rate is a measure of how reliably and quickly Swarms can satisfy a user demand. It\u2019s calculated by dividing the number of tasks completed to the user\u2019s satisfaction by the total number of tasks. Multiply that by 100, and you\u2019ve got your UTCS rate.</p> <p>But what does it mean to complete a task to the user\u2019s satisfaction? It means that the task is not only completed, but completed in a way that meets or exceeds the user\u2019s expectations. It\u2019s about quality, speed, and reliability.</p>"},{"location":"corporate/metric/#why-is-the-utcs-rate-important","title":"Why is the UTCS Rate Important?","text":"<p>The UTCS rate is a direct reflection of the user experience. A high UTCS rate means that users are getting what they need from Swarms, and they\u2019re getting it quickly and reliably. It means that Swarms is doing its job, and doing it well.</p> <p>But the UTCS rate is not just about user satisfaction. It\u2019s also a measure of Swarms\u2019 efficiency and effectiveness. A high UTCS rate means that Swarms is able to complete tasks quickly and accurately, with minimal errors or delays. It\u2019s a sign of a well-oiled machine.</p>"},{"location":"corporate/metric/#how-do-we-achieve-a-95-utcs-rate","title":"How Do We Achieve a 95% UTCS Rate?","text":"<p>Achieving a 95% UTCS rate is no small feat. It requires a deep understanding of our users and their needs, a robust and reliable system, and a commitment to continuous improvement.</p>"},{"location":"corporate/metric/#here-are-some-strategies-were-implementing-to-reach-our-goal","title":"Here are some strategies we\u2019re implementing to reach our goal:","text":"<ul> <li> <p>Understanding User Needs: We must have agents that gain an understanding of the user's objective and break it up into it's most fundamental building blocks</p> </li> <li> <p>Improving System Reliability: We\u2019re working to make Swarms more reliable, reducing errors and improving the accuracy of task completion. This includes improving our algorithms, refining our processes, and investing in quality assurance.</p> </li> <li> <p>Optimizing for Speed: We\u2019re optimizing Swarms to complete tasks as quickly as possible, without sacrificing quality. This includes improving our infrastructure, streamlining our workflows, and implementing performance optimizations.</p> </li> </ul> <p>*Iterating and Improving: We\u2019re committed to continuous improvement. We\u2019re constantly monitoring our UTCS rate and other key metrics, and we\u2019re always looking for ways to improve. We\u2019re not afraid to experiment, iterate, and learn from our mistakes.</p> <p>Achieving a 95% UTCS rate is a challenging goal, but it\u2019s a goal worth striving for. It\u2019s a goal that will drive us to improve, innovate, and deliver the best possible experience for our users. And in the end, that\u2019s what Swarms is all about.</p>"},{"location":"corporate/metric/#your-feedback-matters-help-us-optimize-the-utcs-rate","title":"Your Feedback Matters: Help Us Optimize the UTCS Rate","text":"<p>As we initiate the journey of Swarms, we seek your feedback to better guide our growth and development. Your opinions and suggestions are crucial for us, helping to mold our product, pricing, branding, and a host of other facets that influence your experience.</p>"},{"location":"corporate/metric/#your-insights-on-the-utcs-rate","title":"Your Insights on the UTCS Rate","text":"<p>Our goal is to maintain a UTCS (User-Task-Completion-Satisfaction) rate of 95%. This metric is integral to the success of Swarms, indicating the efficiency and effectiveness with which we satisfy user requests. However, it's a metric that we can't optimize alone - we need your help.</p> <p>Here's what we want to understand from you:</p> <ol> <li>Satisfaction: What does a \"satisfactorily completed task\" mean to you? Are there specific elements that contribute to a task being carried out to your satisfaction? </li> <li>Timeliness: How important is speed in the completion of a task? What would you consider a reasonable timeframe for a task to be completed?</li> <li>Usability: How intuitive and user-friendly do you find the Swarms platform? Are there any aspects of the platform that you believe could be enhanced?</li> <li>Reliability: How much does consistency in performance matter to you? Can you share any experiences where Swarms either met or fell short of your expectations?</li> <li>Value for Money: How do you perceive our pricing? Does the value Swarms provides align with the costs?</li> </ol> <p>We invite you to share your experiences, thoughts, and ideas. Whether it's a simple suggestion or an in-depth critique, we appreciate and value your input.</p>"},{"location":"corporate/metric/#your-feedback-the-backbone-of-our-growth","title":"Your Feedback: The Backbone of our Growth","text":"<p>Your feedback is the backbone of Swarms' evolution. It drives us to refine our strategies, fuels our innovative spirit, and, most importantly, enables us to serve you better.</p> <p>As we launch, we open the conversation around these key aspects of Swarms, and we look forward to understanding your expectations, your needs, and how we can deliver the best experience for you.</p> <p>So, let's start this conversation - how can we make Swarms work best for you?</p> <p>Guide Our Growth: Help Optimize Swarms As we launch Swarms, your feedback is critical for enhancing our product, pricing, and branding. A key aim for us is a User-Task-Completion-Satisfaction (UTCS) rate of 95% - indicating our efficiency and effectiveness in meeting user needs. However, we need your insights to optimize this.</p> <p>Here's what we're keen to understand:</p> <p>Satisfaction: Your interpretation of a \"satisfactorily completed task\". Timeliness: The importance of speed in task completion for you. Usability: Your experiences with our platform\u2019s intuitiveness and user-friendliness. Reliability: The significance of consistent performance to you. Value for Money: Your thoughts on our pricing and value proposition. We welcome your thoughts, experiences, and suggestions. Your feedback fuels our evolution, driving us to refine strategies, boost innovation, and enhance your experience.</p> <p>Let's start the conversation - how can we make Swarms work best for you?</p> <p>The Golden Metric Analysis: The Ultimate UTCS Paradigm for Swarms</p>"},{"location":"corporate/metric/#introduction","title":"Introduction","text":"<p>In our ongoing journey to perfect Swarms, understanding how our product fares in the eyes of the end-users is paramount. Enter the User-Task-Completion-Satisfaction (UTCS) rate - our primary metric that gauges how reliably and swiftly Swarms can meet user demands. As we steer Swarms towards achieving a UTCS rate of 95%, understanding this metric's core and how to refine it becomes vital.</p>"},{"location":"corporate/metric/#decoding-utcs-an-analytical-overview","title":"Decoding UTCS: An Analytical Overview","text":"<p>The UTCS rate is not merely about task completion; it's about the comprehensive experience. Therefore, its foundations lie in:</p> <ol> <li>Quality: Ensuring tasks are executed flawlessly.</li> <li>Speed: Delivering results in the shortest possible time.</li> <li>Reliability: Consistency in quality and speed across all tasks.</li> </ol> <p>We can represent the UTCS rate with the following equation:</p> <pre><code>\\[ UTCS Rate = \\frac{(Completed Tasks \\times User Satisfaction)}{(Total Tasks)} \\times 100 \\]\n</code></pre> <p>Where: - Completed Tasks refer to the number of tasks Swarms executes without errors. - User Satisfaction is the subjective component, gauged through feedback mechanisms. This could be on a scale of 1-10 (or a percentage). - Total Tasks refer to all tasks processed by Swarms, regardless of the outcome.</p>"},{"location":"corporate/metric/#the-golden-metric-swarm-efficiency-index-sei","title":"The Golden Metric: Swarm Efficiency Index (SEI)","text":"<p>However, this basic representation doesn't factor in a critical component: system performance. Thus, we introduce the Swarm Efficiency Index (SEI). The SEI encapsulates not just the UTCS rate but also system metrics like memory consumption, number of tasks, and time taken. By blending these elements, we aim to present a comprehensive view of Swarm's prowess.</p> <p>Here\u2019s the formula:</p> <pre><code>\\[ SEI = \\frac{UTCS Rate}{(Memory Consumption + Time Window + Task Complexity)} \\]\n</code></pre> <p>Where: - Memory Consumption signifies the system resources used to accomplish tasks. - Time Window is the timeframe in which the tasks were executed. - Task Complexity could be a normalized scale that defines how intricate a task is (e.g., 1-5, with 5 being the most complex).</p> <p>Rationale: - Incorporating Memory Consumption: A system that uses less memory but delivers results is more efficient. By inverting memory consumption in the formula, we emphasize that as memory usage goes down, SEI goes up.</p> <ul> <li> <p>Considering Time: Time is of the essence. The faster the results without compromising quality, the better. By adding the Time Window, we emphasize that reduced task execution time increases the SEI.</p> </li> <li> <p>Factoring in Task Complexity: Not all tasks are equal. A system that effortlessly completes intricate tasks is more valuable. By integrating task complexity, we can normalize the SEI according to the task's nature.</p> </li> </ul>"},{"location":"corporate/metric/#implementing-sei-improving-utcs","title":"Implementing SEI &amp; Improving UTCS","text":"<p>Using feedback from elder-plinius, we can better understand and improve SEI and UTCS:</p> <ol> <li> <p>Feedback Across Skill Levels: By gathering feedback from users with different skill levels, we can refine our metrics, ensuring Swarms caters to all.</p> </li> <li> <p>Simplifying Setup: Detailed guides can help newcomers swiftly get on board, thus enhancing user satisfaction.</p> </li> <li> <p>Enhancing Workspace and Agent Management: A clearer view of the Swarm's internal structure, combined with on-the-go adjustments, can improve both the speed and quality of results.</p> </li> <li> <p>Introducing System Suggestions: A proactive Swarms that provides real-time insights and recommendations can drastically enhance user satisfaction, thus pushing up the UTCS rate.</p> </li> </ol>"},{"location":"corporate/metric/#conclusion","title":"Conclusion","text":"<p>The UTCS rate is undeniably a pivotal metric for Swarms. However, with the introduction of the Swarm Efficiency Index (SEI), we have an opportunity to encapsulate a broader spectrum of performance indicators, leading to a more holistic understanding of Swarms' efficiency. By consistently optimizing for SEI, we can ensure that Swarms not only meets user expectations but also operates at peak system efficiency.</p> <p>Research Analysis: Tracking and Ensuring Reliability of Swarm Metrics at Scale</p>"},{"location":"corporate/metric/#1-introduction","title":"1. Introduction","text":"<p>In our pursuit to optimize the User-Task-Completion-Satisfaction (UTCS) rate and Swarm Efficiency Index (SEI), reliable tracking of these metrics at scale becomes paramount. This research analysis delves into methodologies, technologies, and practices that can be employed to monitor these metrics accurately and efficiently across vast data sets.</p>"},{"location":"corporate/metric/#2-why-tracking-at-scale-is-challenging","title":"2. Why Tracking at Scale is Challenging","text":"<p>The primary challenges include:</p> <ul> <li>Volume of Data: As Swarms grows, the data generated multiplies exponentially.</li> <li>Variability of Data: Diverse user inputs lead to myriad output scenarios.</li> <li>System Heterogeneity: Different configurations and deployments can yield variable results.</li> </ul>"},{"location":"corporate/metric/#3-strategies-for-scalable-tracking","title":"3. Strategies for Scalable Tracking","text":""},{"location":"corporate/metric/#31-distributed-monitoring-systems","title":"3.1. Distributed Monitoring Systems","text":"<p>Recommendation: Implement distributed systems like Prometheus or InfluxDB.</p> <p>Rationale:  - Ability to collect metrics from various Swarm instances concurrently. - Scalable and can handle vast data influxes.</p>"},{"location":"corporate/metric/#32-real-time-data-processing","title":"3.2. Real-time Data Processing","text":"<p>Recommendation: Use stream processing systems like Apache Kafka or Apache Flink.</p> <p>Rationale:  - Enables real-time metric calculation. - Can handle high throughput and low-latency requirements.</p>"},{"location":"corporate/metric/#33-data-sampling","title":"3.3. Data Sampling","text":"<p>Recommendation: Random or stratified sampling of user sessions.</p> <p>Rationale:  - Reduces the data volume to be processed. - Maintains representativeness of overall user experience.</p>"},{"location":"corporate/metric/#4-ensuring-reliability-in-data-collection","title":"4. Ensuring Reliability in Data Collection","text":""},{"location":"corporate/metric/#41-redundancy","title":"4.1. Redundancy","text":"<p>Recommendation: Integrate redundancy into data collection nodes.</p> <p>Rationale: - Ensures no single point of failure. - Data loss prevention in case of system malfunctions.</p>"},{"location":"corporate/metric/#42-anomaly-detection","title":"4.2. Anomaly Detection","text":"<p>Recommendation: Implement AI-driven anomaly detection systems.</p> <p>Rationale:  - Identifies outliers or aberrations in metric calculations. - Ensures consistent and reliable data interpretation.</p>"},{"location":"corporate/metric/#43-data-validation","title":"4.3. Data Validation","text":"<p>Recommendation: Establish automated validation checks.</p> <p>Rationale: - Ensures only accurate and relevant data is considered. - Eliminates inconsistencies arising from corrupted or irrelevant data.</p>"},{"location":"corporate/metric/#5-feedback-loops-and-continuous-refinement","title":"5. Feedback Loops and Continuous Refinement","text":""},{"location":"corporate/metric/#51-user-feedback-integration","title":"5.1. User Feedback Integration","text":"<p>Recommendation: Develop an in-built user feedback mechanism.</p> <p>Rationale:  - Helps validate the perceived vs. actual performance. - Allows for continuous refining of tracking metrics and methodologies.</p>"},{"location":"corporate/metric/#52-ab-testing","title":"5.2. A/B Testing","text":"<p>Recommendation: Regularly conduct A/B tests for new tracking methods or adjustments.</p> <p>Rationale:  - Determines the most effective methods for data collection. - Validates new tracking techniques against established ones.</p>"},{"location":"corporate/metric/#6-conclusion","title":"6. Conclusion","text":"<p>To successfully and reliably track the UTCS rate and SEI at scale, it's essential to combine robust monitoring tools, data processing methodologies, and validation techniques. By doing so, Swarms can ensure that the metrics collected offer a genuine reflection of system performance and user satisfaction. Regular feedback and iterative refinement, rooted in a culture of continuous improvement, will further enhance the accuracy and reliability of these essential metrics.</p>"},{"location":"corporate/monthly_formula/","title":"Monthly formula","text":"In\u00a0[\u00a0]: Copied! <pre>def calculate_monthly_charge(\n    development_time_hours: float,\n    hourly_rate: float,\n    amortization_months: int,\n    api_calls_per_month: int,\n    cost_per_api_call: float,\n    monthly_maintenance: float,\n    additional_monthly_costs: float,\n    profit_margin_percentage: float,\n) -&gt; float:\n    \"\"\"\n    Calculate the monthly charge for a service based on various cost factors.\n\n    Parameters:\n    - development_time_hours (float): The total number of hours spent on development and setup.\n    - hourly_rate (float): The rate per hour for development and setup.\n    - amortization_months (int): The number of months over which to amortize the development and setup costs.\n    - api_calls_per_month (int): The number of API calls made per month.\n    - cost_per_api_call (float): The cost per API call.\n    - monthly_maintenance (float): The monthly maintenance cost.\n    - additional_monthly_costs (float): Any additional monthly costs.\n    - profit_margin_percentage (float): The desired profit margin as a percentage.\n\n    Returns:\n    - monthly_charge (float): The calculated monthly charge for the service.\n    \"\"\"\n\n    # Calculate Development and Setup Costs (amortized monthly)\n    development_and_setup_costs_monthly = (\n        development_time_hours * hourly_rate\n    ) / amortization_months\n\n    # Calculate Operational Costs per Month\n    operational_costs_monthly = (\n        (api_calls_per_month * cost_per_api_call)\n        + monthly_maintenance\n        + additional_monthly_costs\n    )\n\n    # Calculate Total Monthly Costs\n    total_monthly_costs = (\n        development_and_setup_costs_monthly\n        + operational_costs_monthly\n    )\n\n    # Calculate Pricing with Profit Margin\n    monthly_charge = total_monthly_costs * (\n        1 + profit_margin_percentage / 100\n    )\n\n    return monthly_charge\n</pre> def calculate_monthly_charge(     development_time_hours: float,     hourly_rate: float,     amortization_months: int,     api_calls_per_month: int,     cost_per_api_call: float,     monthly_maintenance: float,     additional_monthly_costs: float,     profit_margin_percentage: float, ) -&gt; float:     \"\"\"     Calculate the monthly charge for a service based on various cost factors.      Parameters:     - development_time_hours (float): The total number of hours spent on development and setup.     - hourly_rate (float): The rate per hour for development and setup.     - amortization_months (int): The number of months over which to amortize the development and setup costs.     - api_calls_per_month (int): The number of API calls made per month.     - cost_per_api_call (float): The cost per API call.     - monthly_maintenance (float): The monthly maintenance cost.     - additional_monthly_costs (float): Any additional monthly costs.     - profit_margin_percentage (float): The desired profit margin as a percentage.      Returns:     - monthly_charge (float): The calculated monthly charge for the service.     \"\"\"      # Calculate Development and Setup Costs (amortized monthly)     development_and_setup_costs_monthly = (         development_time_hours * hourly_rate     ) / amortization_months      # Calculate Operational Costs per Month     operational_costs_monthly = (         (api_calls_per_month * cost_per_api_call)         + monthly_maintenance         + additional_monthly_costs     )      # Calculate Total Monthly Costs     total_monthly_costs = (         development_and_setup_costs_monthly         + operational_costs_monthly     )      # Calculate Pricing with Profit Margin     monthly_charge = total_monthly_costs * (         1 + profit_margin_percentage / 100     )      return monthly_charge In\u00a0[\u00a0]: Copied! <pre># Example usage:\nmonthly_charge = calculate_monthly_charge(\n    development_time_hours=100,\n    hourly_rate=500,\n    amortization_months=12,\n    api_calls_per_month=500000,\n    cost_per_api_call=0.002,\n    monthly_maintenance=1000,\n    additional_monthly_costs=300,\n    profit_margin_percentage=10000,\n)\n</pre> # Example usage: monthly_charge = calculate_monthly_charge(     development_time_hours=100,     hourly_rate=500,     amortization_months=12,     api_calls_per_month=500000,     cost_per_api_call=0.002,     monthly_maintenance=1000,     additional_monthly_costs=300,     profit_margin_percentage=10000, ) In\u00a0[\u00a0]: Copied! <pre>print(f\"Monthly Charge: ${monthly_charge:.2f}\")\n</pre> print(f\"Monthly Charge: ${monthly_charge:.2f}\")"},{"location":"corporate/purpose/","title":"Purpose","text":""},{"location":"corporate/purpose/#purpose","title":"Purpose","text":"<p>Artificial Intelligence has grown at an exponential rate over the past decade. Yet, we are far from fully harnessing its potential. Today's AI operates in isolation, each working separately in their corner. But life doesn't work like that. The world doesn't work like that. Success isn't built in silos; it's built in teams.</p> <p>Imagine a world where AI models work in unison. Where they can collaborate, interact, and pool their collective intelligence to achieve more than any single model could. This is the future we envision. But today, we lack a framework for AI to collaborate effectively, to form a true swarm of intelligent agents.</p> <p>This is a difficult problem, one that has eluded solution. It requires sophisticated systems that can allow individual models to not just communicate but also understand each other, pool knowledge and resources, and create collective intelligence. This is the next frontier of AI.</p> <p>But here at Swarms, we have a secret sauce. It's not just a technology or a breakthrough invention. It's a way of thinking - the philosophy of rapid iteration. With each cycle, we make massive progress. We experiment, we learn, and we grow. We have developed a pioneering framework that can enable AI models to work together as a swarm, combining their strengths to create richer, more powerful outputs.</p> <p>We are uniquely positioned to take on this challenge with 1,500+ devoted researchers in Agora. We have assembled a team of world-class experts, experienced and driven, united by a shared vision. Our commitment to breaking barriers, pushing boundaries, and our belief in the power of collective intelligence makes us the best team to usher in this future to fundamentally advance our species, Humanity.</p>"},{"location":"corporate/research/","title":"Research Lists","text":"<p>A compilation of projects, papers, blogs in autonomous agents.</p>"},{"location":"corporate/research/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Introduction</li> <li>Projects</li> <li>Articles</li> <li>Talks</li> </ul>"},{"location":"corporate/research/#projects","title":"Projects","text":""},{"location":"corporate/research/#developer-tools","title":"Developer tools","text":"<ul> <li>[2023/8/10]  ModelScope-Agent - An Agent Framework Connecting Models in ModelScope with the World</li> <li>[2023/05/25][Gorilla](https://github.com/ShishirPatil/gorilla) - An API store for LLMs</li> <li>[2023/03/31][BMTools](https://github.com/OpenBMB/BMTools) - Tool Learning for Big Models, Open-Source Solutions of ChatGPT-Plugins</li> <li>[2023/03/09][LMQL](https://github.com/eth-sri/lmql) - A query language for programming (large) language models.</li> <li>[2022/10/25][Langchain](https://github.com/hwchase17/langchain) - \u26a1 Building applications with LLMs through composability \u26a1</li> </ul>"},{"location":"corporate/research/#applications","title":"Applications","text":"<ul> <li>[2023/07/08][ShortGPT](https://github.com/RayVentura/ShortGPT) - \ud83d\ude80\ud83c\udfac ShortGPT - An experimental AI framework for automated short/video content creation. Enables creators to rapidly produce, manage, and deliver content using AI and automation.</li> <li>[2023/07/05][gpt-researcher](https://github.com/assafelovic/gpt-researcher) - GPT based autonomous agent that does online comprehensive research on any given topic</li> <li>[2023/07/04][DemoGPT](https://github.com/melih-unsal/DemoGPT) - \ud83e\udde9DemoGPT enables you to create quick demos by just using prompts. [demo]</li> <li>[2023/06/30][MetaGPT](https://github.com/geekan/MetaGPT) - \ud83c\udf1f The Multi-Agent Framework: Given one line Requirement, return PRD, Design, Tasks, Repo</li> <li>[2023/06/11][gpt-engineer](https://github.com/AntonOsika/gpt-engineer) - Specify what you want it to build, the AI asks for clarification, and then builds it.</li> <li>[2023/05/16][SuperAGI](https://github.com/TransformerOptimus/SuperAGI) - &lt;\u26a1\ufe0f&gt; SuperAGI - A dev-first open source autonomous AI agent framework. Enabling developers to build, manage &amp; run useful autonomous agents quickly and reliably.</li> <li>[2023/05/13][Developer](https://github.com/smol-ai/developer) - Human-centric &amp; Coherent Whole Program Synthesis aka your own personal junior developer</li> <li>[2023/04/07][AgentGPT](https://github.com/reworkd/AgentGPT) - \ud83e\udd16 Assemble, configure, and deploy autonomous AI Agents in your browser. [demo]</li> <li>[2023/04/03][BabyAGI](https://github.com/yoheinakajima/babyagi) - an example of an AI-powered task management system</li> <li>[2023/03/30][AutoGPT](https://github.com/Significant-Gravitas/Auto-GPT) - An experimental open-source attempt to make GPT-4 fully autonomous.</li> </ul>"},{"location":"corporate/research/#benchmarks","title":"Benchmarks","text":"<ul> <li>[2023/08/07][AgentBench](https://github.com/THUDM/AgentBench) - A Comprehensive Benchmark to Evaluate LLMs as Agents. paper</li> <li>[2023/06/18][Auto-GPT-Benchmarks](https://github.com/Significant-Gravitas/Auto-GPT-Benchmarks) - A repo built for the purpose of benchmarking the performance of agents, regardless of how they are set up and how they work.</li> <li>[2023/05/28][ToolBench](https://github.com/OpenBMB/ToolBench) - An open platform for training, serving, and evaluating large language model for tool learning.</li> </ul>"},{"location":"corporate/research/#articles","title":"Articles","text":""},{"location":"corporate/research/#research-papers","title":"Research Papers","text":"<ul> <li>[2023/08/11][BOLAA: Benchmarking and Orchestrating LLM-Augmented Autonomous Agents](https://arxiv.org/pdf/2308.05960v1.pdf), Zhiwei Liu, et al.</li> <li>[2023/07/31][ToolLLM: Facilitating Large Language Models to Master 16000+ Real-world APIs](https://arxiv.org/abs/2307.16789), Yujia Qin, et al.</li> <li>[2023/07/16][Communicative Agents for Software Development](https://arxiv.org/abs/2307.07924), Chen Qian, et al.</li> <li>[2023/06/09][Mind2Web: Towards a Generalist Agent for the Web](https://arxiv.org/pdf/2306.06070.pdf), Xiang Deng, et al. [code] [demo]</li> <li>[2023/06/05][Orca: Progressive Learning from Complex Explanation Traces of GPT-4](https://arxiv.org/pdf/2306.02707.pdf), Subhabrata Mukherjee et al.</li> <li>[2023/05/25][Voyager: An Open-Ended Embodied Agent with Large Language Models](https://arxiv.org/pdf/2305.16291.pdf), Guanzhi Wang, et al. [code] [website]</li> <li>[2023/05/23][ReWOO: Decoupling Reasoning from Observations for Efficient Augmented Language Models](https://arxiv.org/pdf/2305.18323.pdf), Binfeng Xu, et al. [code]</li> <li>[2023/05/17][Tree of Thoughts: Deliberate Problem Solving with Large Language Models](https://arxiv.org/abs/2305.10601), Shunyu Yao, et al.[code] [code-orig] </li> <li>[2023/05/12][MEGABYTE: Predicting Million-byte Sequences with Multiscale Transformers](https://arxiv.org/abs/2305.07185), Lili Yu, et al.</li> <li>[2023/05/19][FrugalGPT: How to Use Large Language Models While Reducing Cost and Improving Performance](https://arxiv.org/abs/2305.05176), Lingjiao Chen, et al.</li> <li>[2023/05/06][Plan-and-Solve Prompting: Improving Zero-Shot Chain-of-Thought Reasoning by Large Language Models](https://arxiv.org/abs/2305.04091), Lei Wang, et al.</li> <li>[2023/05/01][Learning to Reason and Memorize with Self-Notes](https://arxiv.org/abs/2305.00833), Jack Lanchantin, et al.</li> <li>[2023/04/24][WizardLM: Empowering Large Language Models to Follow Complex Instructions](https://arxiv.org/abs/2304.12244), Can Xu, et al.</li> <li>[2023/04/22][LLM+P: Empowering Large Language Models with Optimal Planning Proficiency](https://arxiv.org/abs/2304.11477), Bo Liu, et al.</li> <li>[2023/04/07][Generative Agents: Interactive Simulacra of Human Behavior](https://arxiv.org/abs/2304.03442), Joon Sung Park, et al. [code]</li> <li>[2023/03/30][Self-Refine: Iterative Refinement with Self-Feedback](https://arxiv.org/abs/2303.17651), Aman Madaan, et al.[code]</li> <li>[2023/03/30][HuggingGPT: Solving AI Tasks with ChatGPT and its Friends in HuggingFace](https://arxiv.org/pdf/2303.17580.pdf), Yongliang Shen, et al. [code] [demo]</li> <li>[2023/03/20][Reflexion: Language Agents with Verbal Reinforcement Learning](https://arxiv.org/pdf/2303.11366.pdf), Noah Shinn, et al. [code]</li> <li>[2023/03/04][Towards A Unified Agent with Foundation Models](https://openreview.net/pdf?id=JK_B1tB6p-), Norman Di Palo et al.</li> <li>[2023/02/23][Not what you've signed up for: Compromising Real-World LLM-Integrated Applications with Indirect Prompt Injection](https://arxiv.org/abs/2302.12173), Sahar Abdelnab, et al.</li> <li>[2023/02/09][Toolformer: Language Models Can Teach Themselves to Use Tools](https://arxiv.org/pdf/2302.04761.pdf), Timo Schick, et al. [code]</li> <li>[2022/12/12][LMQL: Prompting Is Programming: A Query Language for Large Language Models](https://arxiv.org/abs/2212.06094), Luca Beurer-Kellner, et al.</li> <li>[2022/10/06][ReAct: Synergizing Reasoning and Acting in Language Models](https://arxiv.org/pdf/2210.03629.pdf), Shunyu Yao, et al. [code]</li> <li>[2022/07/20][Inner Monologue: Embodied Reasoning through Planning with Language Models](https://arxiv.org/pdf/2207.05608.pdf), Wenlong Huang, et al. [demo]</li> <li>[2022/04/04][Do As I Can, Not As I Say: Grounding Language in Robotic Affordances](), Michael Ahn, e al. [demo]</li> <li>[2021/12/17][WebGPT: Browser-assisted question-answering with human feedback](https://arxiv.org/pdf/2112.09332.pdf), Reiichiro Nakano, et al.</li> <li>[2021/06/17][LoRA: Low-Rank Adaptation of Large Language Models](https://arxiv.org/abs/2106.09685), Edward J. Hu, et al.</li> </ul>"},{"location":"corporate/research/#blog-articles","title":"Blog Articles","text":"<ul> <li>[2023/08/14][A Roadmap of AI Agents(Chinese)](https://zhuanlan.zhihu.com/p/649916692) By Haojie Pan</li> <li>[2023/06/23][LLM Powered Autonomous Agents](https://lilianweng.github.io/posts/2023-06-23-agent/) By Lilian Weng</li> <li>[2023/06/11][A CRITICAL LOOK AT AI-GENERATED SOFTWARE](https://spectrum.ieee.org/ai-software) By JAIDEEP VAIDYAHAFIZ ASIF</li> <li>[2023/04/29][AUTO-GPT: UNLEASHING THE POWER OF AUTONOMOUS AI AGENTS](https://www.leewayhertz.com/autogpt/) By Akash Takyar</li> <li>[2023/04/20][Conscious Machines: Experiments, Theory, and Implementations(Chinese)](https://pattern.swarma.org/article/230) By Jiang Zhang</li> <li>[2023/04/18][Autonomous Agents &amp; Agent Simulations](https://blog.langchain.dev/agents-round/) By Langchain</li> <li>[2023/04/16][4 Autonomous AI Agents you need to know](https://towardsdatascience.com/4-autonomous-ai-agents-you-need-to-know-d612a643fa92) By Sophia Yang</li> <li>[2023/03/31][ChatGPT that learns to use tools(Chinese)](https://zhuanlan.zhihu.com/p/618448188) By Haojie Pan</li> </ul>"},{"location":"corporate/research/#talks","title":"Talks","text":"<ul> <li>[2023/06/05][Two Paths to Intelligence](https://www.youtube.com/watch?v=rGgGOccMEiY&amp;t=1497s) by Geoffrey Hinton</li> <li>[2023/05/24][State of GPT](https://www.youtube.com/watch?v=bZQun8Y4L2A) by Andrej Karpathy | OpenAI </li> </ul>"},{"location":"corporate/roadmap/","title":"Roadmap","text":""},{"location":"corporate/roadmap/#the-plan","title":"The Plan","text":""},{"location":"corporate/roadmap/#phase-1-building-the-foundation","title":"Phase 1: Building the Foundation","text":"<p>In the first phase, our focus is on building the basic infrastructure of Swarms. This includes developing key components like the Swarms class, integrating essential tools, and establishing task completion and evaluation logic. We'll also start developing our testing and evaluation framework during this phase. If you're interested in foundational work and have a knack for building robust, scalable systems, this phase is for you.</p>"},{"location":"corporate/roadmap/#phase-2-optimizing-the-system","title":"Phase 2: Optimizing the System","text":"<p>In the second phase, we'll focus on optimizng Swarms by integrating more advanced features, improving the system's efficiency, and refining our testing and evaluation framework. This phase involves more complex tasks, so if you enjoy tackling challenging problems and contributing to the development of innovative features, this is the phase for you.</p>"},{"location":"corporate/roadmap/#phase-3-towards-super-intelligence","title":"Phase 3: Towards Super-Intelligence","text":"<p>The third phase of our bounty program is the most exciting - this is where we aim to achieve super-intelligence. In this phase, we'll be working on improving the swarm's capabilities, expanding its skills, and fine-tuning the system based on real-world testing and feedback. If you're excited about the future of AI and want to contribute to a project that could potentially transform the digital world, this is the phase for you.</p> <p>Remember, our roadmap is a guide, and we encourage you to bring your own ideas and creativity to the table. We believe that every contribution, no matter how small, can make a difference. So join us on this exciting journey and help us create the future of Swarms.</p>"},{"location":"corporate/swarm_cloud/","title":"The Swarm Cloud","text":""},{"location":"corporate/swarm_cloud/#business-model-plan-for-autonomous-agent-swarm-service","title":"Business Model Plan for Autonomous Agent Swarm Service","text":""},{"location":"corporate/swarm_cloud/#service-description","title":"Service Description","text":"<ul> <li>Overview: A platform allowing users to deploy swarms of autonomous agents in production-grade environments.</li> <li>Target Users: Industries requiring automation, monitoring, data collection, and more, such as manufacturing, logistics, agriculture, and surveillance.</li> </ul>"},{"location":"corporate/swarm_cloud/#operational-strategy","title":"Operational Strategy","text":"<ul> <li>Infrastructure: Robust cloud infrastructure to support agent deployment and data processing.</li> <li>Support and Maintenance: Continuous support for software updates, troubleshooting, and user assistance.</li> <li>Technology Development: Ongoing R&amp;D for enhancing agent capabilities and efficiency.</li> </ul>"},{"location":"corporate/swarm_cloud/#financial-projections","title":"Financial Projections","text":"<ul> <li>Revenue Streams: Mainly from per agent usage fees and hosting services.</li> <li>Cost Structure: Includes development, maintenance, infrastructure, marketing, and administrative costs.</li> <li>Break-even Analysis: Estimation based on projected user adoption rates and cost per agent.</li> </ul>"},{"location":"corporate/swarm_cloud/#revnue-streams","title":"Revnue Streams","text":"<pre><code>| Pricing Structure         | Description | Details |\n| ------------------------- | ----------- | ------- |\n| Usage-Based Per Agent     | Fees are charged based on the number of agents deployed and their usage duration. | - Ideal for clients needing a few agents for specific tasks. &lt;br&gt; - More agents or longer usage results in higher fees. |\n| Swarm Coverage Pricing    | Pricing based on the coverage area or scope of the swarm deployment. | - Suitable for tasks requiring large area coverage. &lt;br&gt; - Price scales with the size or complexity of the area covered. |\n| Performance-Based Pricing | Fees are tied to the performance or outcomes achieved by the agents. | - Clients pay for the effectiveness or results achieved by the agents. &lt;br&gt; - Higher fees for more complex or high-value tasks. |\n</code></pre> <ol> <li> <p>Pay-Per-Mission Pricing: Clients are charged for each specific task or mission completed by the agents.</p> </li> <li> <p>Per Agent Usage Fee: Charged based on the number of agents and the duration of their deployment.</p> </li> <li>Hosting Fees: Based on the data usage and processing requirements of the agents.</li> <li> <p>Volume Discounts: Available for large-scale deployments.</p> </li> <li> <p>Time-Based Subscription: A subscription model where clients pay a recurring fee for continuous access to a set number of agents.</p> </li> <li> <p>Dynamic Pricing: Prices fluctuate based on demand, time of day, or specific conditions.</p> </li> <li> <p>Tiered Usage Levels: Different pricing tiers based on the number of agents used or the complexity of tasks.</p> </li> <li> <p>Freemium Model: Basic services are free, but premium features or additional agents are paid.</p> </li> <li> <p>Outcome-Based Pricing: Charges are based on the success or quality of the outcomes achieved by the agents.</p> </li> <li> <p>Feature-Based Pricing: Different prices for different feature sets or capabilities of the agents.</p> </li> <li> <p>Volume Discounts: Reduced per-agent price for bulk deployments or long-term contracts.</p> </li> <li> <p>Peak Time Premiums: Higher charges during peak usage times or for emergency deployment.</p> </li> <li> <p>Bundled Services: Combining agent services with other products or services for a comprehensive package deal.</p> </li> <li> <p>Custom Solution Pricing: Tailor-made pricing for unique or specialized requirements.</p> </li> <li> <p>Data Analysis Fee: Charging for the data processing and analytics provided by the agents.</p> </li> <li> <p>Performance Tiers: Different pricing for varying levels of agent efficiency or performance.</p> </li> <li> <p>License Model: Clients purchase a license to deploy and use a certain number of agents.</p> </li> <li> <p>Cost-Plus Pricing: Pricing based on the cost of deployment plus a markup.</p> </li> <li> <p>Service Level Agreement (SLA) Pricing: Higher prices for higher levels of service guarantees.</p> </li> <li> <p>Pay-Per-Save Model: Charging based on the cost savings or value created by the agents for the client.</p> </li> <li> <p>Revenue Sharing: Sharing a percentage of the revenue generated through the use of agents.</p> </li> <li> <p>Geographic Pricing: Different pricing for different regions or markets.</p> </li> <li> <p>User-Based Pricing: Charging based on the number of users accessing and controlling the agents.</p> </li> <li> <p>Energy Usage Pricing: Prices based on the amount of energy consumed by the agents during operation.</p> </li> <li> <p>Event-Driven Pricing: Charging for specific events or triggers during the agent's operation.</p> </li> <li> <p>Seasonal Pricing: Adjusting prices based on seasonal demand or usage patterns.</p> </li> <li> <p>Partnership Models: Collaborating with other businesses and sharing revenue from combined services.</p> </li> <li> <p>Customizable Packages: Allowing clients to build their own package of services and capabilities, priced accordingly.</p> </li> </ol> <p>These diverse pricing strategies can be combined or tailored to fit different business models, client needs, and market dynamics. They also provide various methods of value extraction, ensuring flexibility and scalability in revenue generation.</p>"},{"location":"corporate/swarm_cloud/#icp-analysis","title":"ICP Analysis","text":""},{"location":"corporate/swarm_cloud/#ideal-customer-profile-icp-map","title":"Ideal Customer Profile (ICP) Map","text":""},{"location":"corporate/swarm_cloud/#1-manufacturing-and-industrial-automation","title":"1. Manufacturing and Industrial Automation","text":"<ul> <li>Characteristics: Large-scale manufacturers, high automation needs, emphasis on efficiency and precision.</li> <li>Needs: Process automation, quality control, predictive maintenance.</li> </ul>"},{"location":"corporate/swarm_cloud/#2-agriculture-and-farming","title":"2. Agriculture and Farming","text":"<ul> <li>Characteristics: Large agricultural enterprises, focus on modern farming techniques.</li> <li>Needs: Crop monitoring, automated harvesting, pest control.</li> </ul>"},{"location":"corporate/swarm_cloud/#3-logistics-and-supply-chain","title":"3. Logistics and Supply Chain","text":"<ul> <li>Characteristics: Companies with extensive logistics operations, warehousing, and supply chain management.</li> <li>Needs: Inventory tracking, automated warehousing, delivery optimization.</li> </ul>"},{"location":"corporate/swarm_cloud/#4-energy-and-utilities","title":"4. Energy and Utilities","text":"<ul> <li>Characteristics: Energy providers, utility companies, renewable energy farms.</li> <li>Needs: Infrastructure monitoring, predictive maintenance, efficiency optimization.</li> </ul>"},{"location":"corporate/swarm_cloud/#5-environmental-monitoring-and-conservation","title":"5. Environmental Monitoring and Conservation","text":"<ul> <li>Characteristics: Organizations focused on environmental protection, research institutions.</li> <li>Needs: Wildlife tracking, pollution monitoring, ecological research.</li> </ul>"},{"location":"corporate/swarm_cloud/#6-smart-cities-and-urban-planning","title":"6. Smart Cities and Urban Planning","text":"<ul> <li>Characteristics: Municipal governments, urban development agencies.</li> <li>Needs: Traffic management, infrastructure monitoring, public safety.</li> </ul>"},{"location":"corporate/swarm_cloud/#7-defense-and-security","title":"7. Defense and Security","text":"<ul> <li>Characteristics: Defense contractors, security firms, government agencies.</li> <li>Needs: Surveillance, reconnaissance, threat assessment.</li> </ul>"},{"location":"corporate/swarm_cloud/#8-healthcare-and-medical-facilities","title":"8. Healthcare and Medical Facilities","text":"<ul> <li>Characteristics: Large hospitals, medical research centers.</li> <li>Needs: Facility management, patient monitoring, medical logistics.</li> </ul>"},{"location":"corporate/swarm_cloud/#9-entertainment-and-event-management","title":"9. Entertainment and Event Management","text":"<ul> <li>Characteristics: Large-scale event organizers, theme parks.</li> <li>Needs: Crowd management, entertainment automation, safety monitoring.</li> </ul>"},{"location":"corporate/swarm_cloud/#10-construction-and-infrastructure","title":"10. Construction and Infrastructure","text":"<pre><code>- **Characteristics:** Major construction firms, infrastructure developers.\n- **Needs:** Site monitoring, material tracking, safety compliance.\n</code></pre>"},{"location":"corporate/swarm_cloud/#potential-market-size-table-in-markdown","title":"Potential Market Size Table (in Markdown)","text":"<pre><code>| Customer Segment             | Estimated Market Size (USD) | Notes |\n| ---------------------------- | --------------------------- | ----- |\n| Manufacturing and Industrial | $100 Billion                | High automation and efficiency needs drive demand. |\n| Agriculture and Farming      | $75 Billion                 | Growing adoption of smart farming technologies. |\n| Logistics and Supply Chain   | $90 Billion                 | Increasing need for automation in warehousing and delivery. |\n| Energy and Utilities         | $60 Billion                 | Focus on infrastructure monitoring and maintenance. |\n| Environmental Monitoring     | $30 Billion                 | Rising interest in climate and ecological data collection. |\n| Smart Cities and Urban Planning | $50 Billion              | Growing investment in smart city technologies. |\n| Defense and Security         | $120 Billion                | High demand for surveillance and reconnaissance tech. |\n| Healthcare and Medical       | $85 Billion                 | Need for efficient hospital management and patient care. |\n| Entertainment and Event Management | $40 Billion          | Innovative uses in crowd control and event safety. |\n| Construction and Infrastructure | $70 Billion              | Use in monitoring and managing large construction projects. |\n</code></pre>"},{"location":"corporate/swarm_cloud/#risk-analysis","title":"Risk Analysis","text":"<ul> <li>Market Risks: Adaptation rate and competition.</li> <li>Operational Risks: Reliability and scalability of infrastructure.</li> <li>Regulatory Risks: Compliance with data security and privacy laws.</li> </ul>"},{"location":"corporate/swarm_cloud/#business-model","title":"Business Model","text":""},{"location":"corporate/swarm_cloud/#the-swarm-cloud-business-model","title":"The Swarm Cloud: Business Model","text":""},{"location":"corporate/swarm_cloud/#unlocking-the-potential-of-autonomous-agent-technology","title":"Unlocking the Potential of Autonomous Agent Technology","text":"<p>1. Our Vision:    - Revolutionize industries through scalable, intelligent swarms of autonomous agents.    - Enable real-time data collection, analysis, and automated task execution.</p> <p>2. Service Offering:    - The Swarm Cloud Platform: Deploy and manage swarms of autonomous agents in production-grade environments.    - Applications: Versatile across industries \u2013 from smart agriculture to urban planning, logistics, and beyond.</p> <p>3. Key Features:    - High Scalability: Tailored solutions from small-scale deployments to large industrial operations.    - Real-Time Analytics: Instant data processing and actionable insights.    - User-Friendly Interface: Simplified control and monitoring of agent swarms.    - Robust Security: Ensuring data integrity and operational safety.</p> <p>4. Revenue Streams:    - Usage-Based Pricing: Charges based on the number of agents and operation duration.    - Subscription Models: Recurring revenue through scalable packages.    - Custom Solutions: Tailored pricing for bespoke deployments.</p> <p>5. Market Opportunity:    - Expansive Market: Addressing needs in a $500 billion global market spanning multiple sectors.    - Competitive Edge: Advanced technology offering superior efficiency and adaptability.</p> <p>6. Growth Strategy:    - R&amp;D Investment: Continuous enhancement of agent capabilities and platform features.    - Strategic Partnerships: Collaborations with industry leaders for market penetration.    - Marketing and Sales: Focused approach on high-potential sectors with tailored marketing strategies.</p> <p>7. Why Invest in The Swarm Cloud?    - Pioneering Technology: At the forefront of autonomous agent systems.    - Scalable Business Model: Designed for rapid expansion and adaptation to diverse market needs.    - Strong Market Demand: Positioned to capitalize on the growing trend of automation and AI.</p> <p>\"Empowering industries with intelligent, autonomous solutions \u2013 The Swarm Cloud is set to redefine efficiency and innovation.\"</p>"},{"location":"corporate/swarm_cloud/#conclusion","title":"Conclusion","text":"<p>The business model aims to provide a scalable, efficient, and cost-effective solution for industries looking to leverage the power of autonomous agent technology. With a structured pricing plan and a focus on continuous development and support, the service is positioned to meet diverse industry needs.</p>"},{"location":"corporate/swarm_memo/","title":"[Go To Market Strategy][GTM]","text":"<p>Our vision is to become the world leader in real-world production grade autonomous agent deployment through open-source product development, Deep Verticalization, and unmatched value delivery to the end user.</p> <p>We will focus on first accelerating the open source framework to PMF where it will serve as the backend for upstream products and services such as the Swarm Cloud which will enable enterprises to deploy autonomous agents with long term memory and tools in the cloud and a no-code platform for users to build their own swarm by dragging and dropping blocks.</p> <p>Our target user segment for the framework is AI engineers looking to deploy agents into high risk environments where reliability is crucial. </p> <p>Once PMF has been achieved and the framework has been extensively benchmarked we aim to establish high value contracts with customers in Security, Logistics, Manufacturing, Health and various other untapped industries.</p> <p>Our growth strategy for the OS framework can be summarized by:</p> <ul> <li>Educating developers on value of autonomous agent usage.</li> <li>Tutorial Walkthrough on various applications like deploying multi-modal agents through cameras or building custom swarms for a specific business operation.</li> <li>Demonstrate unmatched reliability by delighting users.</li> <li>Staying up to date with trends and integrating the latest models, frameworks, and methodologies.</li> <li>Building a loyal and devoted community for long term user retention. Join here</li> </ul> <p>As we continuously deliver value with the open framework we will strategically position ourselves to acquire leads for high value contracts by demonstrating the power, reliability, and performance of our framework openly.</p> <p>Acquire Full Access to the memo here: TSC Memo</p>"},{"location":"corporate/swarms_bounty_system/","title":"The Swarms Bounty System: Get Paid to Contribute to Open Source","text":"<p>In today's fast-paced world of software development, open source has become a driving force for innovation. Every single business and organization on the planet is dependent on open source software.</p> <p>The power of collaboration and community has proven to be a potent catalyst for creating robust, cutting-edge solutions. At Swarms, we recognize the immense value that open source contributors bring to the table, and we're thrilled to introduce our Bounty System \u2013 a program designed to reward developers for their invaluable contributions to the Swarms ecosystem.</p> <p>The Swarms Bounty System is a groundbreaking initiative that encourages developers from all walks of life to actively participate in the development and improvement of our suite of products, including the Swarms Python framework, Swarm Cloud, and Swarm Core. By leveraging the collective intelligence and expertise of the global developer community, we aim to foster a culture of continuous innovation and excellence.</p> <p>All bounties with rewards can be found here:</p>"},{"location":"corporate/swarms_bounty_system/#the-power-of-collaboration","title":"The Power of Collaboration","text":"<p>At the heart of the Swarms Bounty System lies the belief that collaboration is the key to unlocking the true potential of software development. By opening up our codebase to the vast talent pool of developers around the world, we're not only tapping into a wealth of knowledge and skills, but also fostering a sense of ownership and investment in the Swarms ecosystem.</p> <p>Whether you're a seasoned developer with years of experience or a passionate newcomer eager to learn and grow, the Swarms Bounty System offers a unique opportunity to contribute to cutting-edge projects and leave your mark on the technological landscape.</p>"},{"location":"corporate/swarms_bounty_system/#how-the-bounty-system-works","title":"How the Bounty System Works","text":"<p>The Swarms Bounty System is designed to be simple, transparent, and rewarding. Here's how it works:</p> <ol> <li> <p>Explore the Bounties: We maintain a comprehensive list of bounties, ranging from bug fixes and feature enhancements to entirely new projects. These bounties are categorized based on their complexity and potential impact, ensuring that there's something for everyone, regardless of their skill level or area of expertise. Bounties will be listed here</p> </li> <li> <p>Submit Your Contributions: Once you've identified a bounty that piques your interest, you can start working on it. When you're ready, submit your contribution in the form of a pull request, following our established guidelines and best practices.</p> </li> <li> <p>Review and Approval: Our dedicated team of reviewers will carefully evaluate your submission, ensuring that it meets our rigorous quality standards and aligns with the project's vision. They'll provide feedback and guidance, fostering a collaborative environment where you can learn and grow.</p> </li> <li> <p>Get Rewarded: Upon successful acceptance of your contribution, you'll be rewarded with a combination of cash and or stock incentives. The rewards are based on a tiered system, reflecting the complexity and impact of your contribution.</p> </li> </ol>"},{"location":"corporate/swarms_bounty_system/#the-rewards-system","title":"The Rewards System","text":"<p>At Swarms, we believe in recognizing and rewarding exceptional contributions. Our tiered rewards system is designed to incentivize developers to push the boundaries of innovation and drive the Swarms ecosystem forward. Here's how the rewards are structured:</p>"},{"location":"corporate/swarms_bounty_system/#tier-1-bug-fixes-and-minor-enhancements","title":"Tier 1: Bug Fixes and Minor Enhancements","text":"Reward Description Cash Reward $50 - $150 Stock Reward N/A <p>This tier covers minor bug fixes, documentation improvements, and small enhancements to existing features. While these contributions may seem insignificant, they play a crucial role in maintaining the stability and usability of our products.</p>"},{"location":"corporate/swarms_bounty_system/#tier-2-moderate-enhancements-and-new-features","title":"Tier 2: Moderate Enhancements and New Features","text":"Reward Description Cash Reward $151 - $300 Stock Reward 10+ <p>This tier encompasses moderate enhancements to existing features, as well as the implementation of new, non-critical features. Contributions in this tier demonstrate a deeper understanding of the project's architecture and a commitment to improving the overall user experience.</p>"},{"location":"corporate/swarms_bounty_system/#tier-3-major-features-and-groundbreaking-innovations","title":"Tier 3: Major Features and Groundbreaking Innovations","text":"Reward Description Cash Reward $301 - $++ Stock Reward 25+ <p>This tier is reserved for truly exceptional contributions that have the potential to revolutionize the Swarms ecosystem. Major feature additions, innovative architectural improvements, and groundbreaking new projects fall under this category. Developers who contribute at this level will be recognized as thought leaders and pioneers in their respective fields.</p> <p>It's important to note that the cash and stock rewards are subject to change based on the project's requirements, complexity, and overall impact. Additionally, we may introduce special bounties with higher reward tiers for particularly challenging or critical projects.</p>"},{"location":"corporate/swarms_bounty_system/#the-benefits-of-contributing","title":"The Benefits of Contributing","text":"<p>Participating in the Swarms Bounty System offers numerous benefits beyond the financial incentives. By contributing to our open source projects, you'll have the opportunity to:</p> <ol> <li> <p>Expand Your Skills: Working on real-world projects with diverse challenges will help you hone your existing skills and acquire new ones, making you a more versatile and valuable developer.</p> </li> <li> <p>Build Your Portfolio: Your contributions will become part of your professional portfolio, showcasing your expertise and dedication to the open source community.</p> </li> <li> <p>Network with Industry Experts: Collaborate with our team of seasoned developers and gain invaluable insights and mentorship from industry leaders.</p> </li> <li> <p>Shape the Future: Your contributions will directly impact the direction and evolution of the Swarms ecosystem, shaping the future of our products and services.</p> </li> <li> <p>Gain Recognition: Stand out in the crowded field of software development by having your contributions acknowledged and celebrated by the Swarms community.</p> </li> </ol>"},{"location":"corporate/swarms_bounty_system/#join-the-movement","title":"Join the Movement","text":"<p>The Swarms Bounty System is more than just a program; it's a movement that embraces the spirit of open source and fosters a culture of collaboration, innovation, and excellence. By joining our ranks, you'll become part of a vibrant community of developers who share a passion for pushing the boundaries of what's possible.</p> <p>Whether you're a seasoned veteran or a newcomer eager to make your mark, the Swarms Bounty System offers a unique opportunity to contribute to cutting-edge projects, earn rewards, and shape the future of software development.</p> <p>So, what are you waiting for? Explore our bounties, find your niche, and start contributing today. Together, we can build a brighter, more innovative future for the Swarms ecosystem and the entire software development community.</p> <p>Join the swarm community now:</p>"},{"location":"corporate/swarms_bounty_system/#resources","title":"Resources","text":"<ul> <li>Bounty Board</li> <li>Swarm Community</li> <li>Swarms Framework</li> <li>Swarm Cloud</li> <li>Swarm Ecosystem</li> </ul>"},{"location":"examples/","title":"Swarms Examples Index","text":"<p>Welcome to the comprehensive Swarms Examples Index! This curated collection showcases the power and versatility of the Swarms framework for building intelligent multi-agent systems. Whether you're a beginner looking to get started or an advanced developer seeking complex implementations, you'll find practical examples to accelerate your AI development journey.</p>"},{"location":"examples/#what-is-swarms","title":"What is Swarms?","text":"<p>Swarms is a cutting-edge framework for creating sophisticated multi-agent AI systems that can collaborate, reason, and solve complex problems together. From single intelligent agents to coordinated swarms of specialized AI workers, Swarms provides the tools and patterns you need to build the next generation of AI applications.</p>"},{"location":"examples/#what-youll-find-here","title":"What You'll Find Here","text":"<p>This index organizes 100+ production-ready examples from our Swarms Examples Repository and the main Swarms repository, covering:</p> <ul> <li> <p>Single Agent Systems: From basic implementations to advanced reasoning agents</p> </li> <li> <p>Multi-Agent Architectures: Collaborative swarms, hierarchical systems, and experimental topologies</p> </li> <li> <p>Industry Applications: Real-world use cases across finance, healthcare, security, and more</p> </li> <li> <p>Integration Examples: Connect with popular AI models, tools, and frameworks</p> </li> <li> <p>Advanced Patterns: RAG systems, function calling, MCP integration, and more</p> </li> </ul>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<p>New to Swarms? Start with the Easy Example under Single Agent Examples \u2192 Core Agents.</p> <p>Looking for comprehensive tutorials? Check out The Swarms Cookbook for detailed walkthroughs and advanced patterns.</p> <p>Want to see real-world applications? Explore the Industry Applications section to see how Swarms solves practical problems.</p>"},{"location":"examples/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p>Single Agent Examples - Individual AI agents with various capabilities</p> </li> <li> <p>Multi-Agent Examples - Collaborative systems and swarm architectures</p> </li> <li> <p>Additional Resources - Community links and support channels</p> </li> </ul>"},{"location":"examples/#single-agent-examples","title":"Single Agent Examples","text":""},{"location":"examples/#core-agents","title":"Core Agents","text":"Category Example Description Basic Easy Example Basic agent implementation demonstrating core functionality and setup Settings Agent Settings Comprehensive configuration options for customizing agent behavior and capabilities YAML Agents from YAML Creating and configuring agents using YAML configuration files for easy deployment Memory Agent with Long-term Memory Implementation of persistent memory capabilities for maintaining context across sessions"},{"location":"examples/#model-integrations","title":"Model Integrations","text":"Category Example Description Azure Azure OpenAI Agent Integration with Azure OpenAI services for enterprise-grade AI capabilities Groq Groq Agent High-performance inference using Groq's accelerated computing platform Custom Custom Model Agent Framework for integrating custom ML models into the agent architecture Cerebras Cerebras Example Integration with Cerebras AI platform for high-performance model inference Claude Claude 4 Example Anthropic Claude 4 model integration for advanced reasoning capabilities Swarms Claude Swarms Claude Example Optimized Claude integration within the Swarms framework Lumo Lumo Example Lumo AI model integration for specialized tasks VLLM VLLM Example High-performance inference using VLLM for large language models Llama4 LiteLLM Example Llama4 model integration using LiteLLM for efficient inference"},{"location":"examples/#tools-and-function-calling","title":"Tools and Function Calling","text":"Category Example Description Basic Tools Tool Agent Basic tool-using agent demonstrating external tool integration capabilities Advanced Tools Agent with Many Tools Advanced agent utilizing multiple tools for complex task execution OpenAI Functions OpenAI Function Caller Integration with OpenAI's function calling API for structured outputs Command Line Command Tool Agent Command-line interface tool integration Jamba Jamba Tool Agent Integration with Jamba framework for enhanced tool capabilities Pydantic Pydantic Tool Agent Tool validation and schema enforcement using Pydantic Function Caller Function Caller Example Advanced function calling capabilities with dynamic tool execution LiteLLM Tools LiteLLM Tool Example Tool integration using LiteLLM for model-agnostic function calling Swarms Tools Swarms Tools Example Native Swarms tool ecosystem integration Structured Outputs Structured Outputs Example Structured data output capabilities for consistent responses Schema Validation Schema Validation Example Tool schema validation and error handling"},{"location":"examples/#mcp-model-context-protocol-integration","title":"MCP (Model Context Protocol) Integration","text":"Category Example Description Agent Tools Agent Tools Dict Example MCP integration for dynamic tool management MCP Execute MCP Execute Example MCP command execution and response handling MCP Load Tools MCP Load Tools Example Dynamic tool loading through MCP protocol Multiple Servers MCP Multiple Servers Example Multi-server MCP configuration and management"},{"location":"examples/#rag-and-memory","title":"RAG and Memory","text":"Category Example Description Full RAG Full Agent RAG Example Complete RAG implementation with retrieval and generation Pinecone Pinecone Example Vector database integration using Pinecone for semantic search"},{"location":"examples/#reasoning-and-decision-making","title":"Reasoning and Decision Making","text":"Category Example Description Agent Judge Agent Judge Example Agent-based decision making and evaluation system MALT MALT Example Multi-agent logical reasoning framework Reasoning Duo Reasoning Duo Example Collaborative reasoning between two specialized agents"},{"location":"examples/#vision-and-multimodal","title":"Vision and Multimodal","text":"Category Example Description Image Batch Image Batch Example Batch processing of multiple images with vision capabilities Multimodal Multimodal Example Multi-modal agent supporting text, image, and audio inputs"},{"location":"examples/#utilities-and-output-formats","title":"Utilities and Output Formats","text":"Category Example Description XML Output XML Output Example Structured XML output formatting for agent responses CSV Agent CSV Agent Example CSV data processing and manipulation agent Swarm Matcher Swarm Matcher Example Agent matching and selection system"},{"location":"examples/#third-party-integrations","title":"Third-Party Integrations","text":"Category Example Description Microsoft AutoGen Integration Integration with Microsoft's AutoGen framework for autonomous agents LangChain LangChain Integration Combining LangChain's capabilities with Swarms for enhanced functionality Browser Multion Integration Web automation and browsing capabilities using Multion Team AI Crew AI Team-based AI collaboration using Crew AI framework Development Griptape Integration with Griptape for structured AI application development"},{"location":"examples/#industry-specific-agents","title":"Industry-Specific Agents","text":"Category Example Description Finance 401k Agent Retirement planning assistant with investment strategy recommendations Finance Estate Planning Comprehensive estate planning and wealth management assistant Security Perimeter Defense Security monitoring and threat detection system Research Perplexity Agent Advanced research automation using Perplexity AI integration Legal Alberto Agent Legal research and document analysis assistant Healthcare Pharma Agent Pharmaceutical research and drug interaction analysis"},{"location":"examples/#multi-agent-examples","title":"Multi-Agent Examples","text":""},{"location":"examples/#core-architectures","title":"Core Architectures","text":"Category Example Description Basic Build a Swarm Foundation for creating custom swarm architectures with multiple agents Auto Swarm Auto Swarm Self-organizing swarm with automatic task distribution and management Concurrent Concurrent Swarm Parallel execution of tasks across multiple agents for improved performance Star Star Swarm Centralized architecture with a hub agent coordinating peripheral agents Circular Circular Swarm Ring topology for cyclic information flow between agents Graph Workflow Graph Workflow Basic Minimal graph workflow with two agents and one task"},{"location":"examples/#concurrent-and-parallel-processing","title":"Concurrent and Parallel Processing","text":"Category Example Description Concurrent Concurrent Example Basic concurrent execution of multiple agents Concurrent Swarm Concurrent Swarm Example Advanced concurrent swarm with parallel task processing"},{"location":"examples/#hierarchical-and-sequential-workflows","title":"Hierarchical and Sequential Workflows","text":"Category Example Description Hierarchical Hierarchical Swarm Example Multi-level hierarchical agent organization Hierarchical Basic Hierarchical Swarm Basic Simplified hierarchical swarm implementation Hierarchical Advanced Hierarchical Advanced Advanced hierarchical swarm with complex agent relationships Sequential Workflow Sequential Workflow Example Linear workflow with agents processing tasks in sequence Sequential Swarm Sequential Swarm Example Sequential swarm with coordinated task execution"},{"location":"examples/#group-chat-and-interactive-systems","title":"Group Chat and Interactive Systems","text":"Category Example Description Group Chat Group Chat Example Multi-agent group chat system with turn-based communication Group Chat Advanced Group Chat Advanced Advanced group chat with enhanced interaction capabilities Mortgage Panel Mortgage Tax Panel Specialized panel for mortgage and tax discussions Interactive Group Chat Interactive Group Chat Interactive group chat with real-time user participation Dynamic Speaker Random Dynamic Speaker Dynamic speaker selection in group conversations Interactive Speaker Interactive Speaker Example Interactive speaker management in group chats Medical Panel Medical Panel Example Medical expert panel for healthcare discussions Stream Example Stream Example Streaming capabilities in interactive group chats"},{"location":"examples/#research-and-deep-analysis","title":"Research and Deep Analysis","text":"Category Example Description Deep Research Deep Research Example Comprehensive research system with multiple specialized agents Deep Research Swarm Deep Research Swarm Swarm-based deep research with collaborative analysis Scientific Agents Deep Research Swarm Example Scientific research swarm for academic and research applications"},{"location":"examples/#routing-and-decision-making","title":"Routing and Decision Making","text":"Category Example Description Model Router Model Router Example Intelligent routing of tasks to appropriate model agents Multi-Agent Router Multi-Agent Router Example Advanced routing system for multi-agent task distribution Swarm Router Swarm Router Example Swarm-specific routing and load balancing Majority Voting Majority Voting Example Consensus-based decision making using majority voting"},{"location":"examples/#council-and-collaborative-systems","title":"Council and Collaborative Systems","text":"Category Example Description Council Judge Council Judge Example Council-based decision making with expert judgment"},{"location":"examples/#advanced-collaboration","title":"Advanced Collaboration","text":"Category Example Description Enhanced Collaboration Enhanced Collaboration Example Advanced collaboration patterns between multiple agents Mixture of Agents Mixture of Agents Example Heterogeneous agent mixture for diverse task handling Aggregate Aggregate Example Aggregation of results from multiple agents"},{"location":"examples/#api-and-integration","title":"API and Integration","text":"Category Example Description Swarms API Swarms API Example API integration for Swarms multi-agent systems"},{"location":"examples/#utilities-and-batch-processing","title":"Utilities and Batch Processing","text":"Category Example Description Batch Agent Batch Agent Example Batch processing capabilities for multiple agents"},{"location":"examples/#experimental-architectures","title":"Experimental Architectures","text":"Category Example Description Monte Carlo Monte Carlo Swarm Probabilistic decision-making using Monte Carlo simulation across agents Federated Federated Swarm Distributed learning system with privacy-preserving agent collaboration Ant Colony Ant Swarm Bio-inspired optimization using ant colony algorithms for agent coordination Matrix Agent Matrix Grid-based agent organization for complex problem-solving DFS DFS Search Swarm Depth-first search swarm for complex problem exploration Pulsar Pulsar Swarm Pulsar-based coordination for synchronized agent behavior"},{"location":"examples/#collaboration-patterns","title":"Collaboration Patterns","text":"Category Example Description Delegation Agent Delegation Task delegation and management system Communication Message Pool Shared communication system for efficient agent interaction Scheduling Round Robin Round-robin task scheduling and execution Load Balancing Load Balancer Dynamic task distribution system for optimal resource utilization Consensus Majority Voting Consensus-building system using democratic voting among agents"},{"location":"examples/#industry-applications","title":"Industry Applications","text":"Category Example Description Finance Accountant Team Multi-agent system for financial analysis, bookkeeping, and tax planning Marketing Ad Generation Collaborative ad creation with copywriting and design agents Aerospace Space Traffic Control Complex simulation of space traffic management with multiple coordinating agents Agriculture Plant Biology Agricultural analysis and optimization using specialized biology agents Urban Dev Urban Planning City development planning with multiple specialized urban development agents Education Education System Personalized learning system with multiple teaching and assessment agents Security Email Phishing Detection Multi-agent security analysis and threat detection Fashion Personal Stylist Fashion recommendation system with style analysis and matching agents Healthcare Healthcare Assistant Medical diagnosis and treatment planning with specialist consultation agents Security Ops Security Team Comprehensive security operations with threat detection and response agents Medical X-Ray Analysis Multi-agent medical imaging analysis and diagnosis Business Business Strategy Strategic planning and business development swarm Research Astronomy Research Collaborative space research and astronomical analysis"},{"location":"examples/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p>Github</p> </li> <li> <p>Discord (https://t.co/zlLe07AqUX)</p> </li> <li> <p>Telegram (https://t.co/dSRy143zQv)</p> </li> <li> <p>X Community (https://x.com/i/communities/1875452887414804745)</p> </li> </ul>"},{"location":"examples/agent_stream/","title":"Agent with Streaming","text":"<p>The Swarms framework provides powerful real-time streaming capabilities for agents, allowing you to see responses being generated token by token as they're produced by the language model. This creates a more engaging and interactive experience, especially useful for long-form content generation, debugging, or when you want to provide immediate feedback to users.</p>"},{"location":"examples/agent_stream/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"examples/agent_stream/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\n</code></pre>"},{"location":"examples/agent_stream/#step-by-step","title":"Step by Step","text":"<ul> <li> <p>Install and put your keys in <code>.env</code></p> </li> <li> <p>Turn on streaming in <code>Agent()</code> with <code>streaming_on=True</code></p> </li> <li> <p>Optional: If you want to pretty print it, you can do <code>print_on=True</code>; if not, it will print normally</p> </li> </ul>"},{"location":"examples/agent_stream/#code","title":"Code","text":"<pre><code>from swarms import Agent\n\n# Enable real-time streaming\nagent = Agent(\n    agent_name=\"StoryAgent\",\n    model_name=\"gpt-4o-mini\",\n    streaming_on=True,  # \ud83d\udd25 This enables real streaming!\n    max_loops=1,\n    print_on=True,  # By default, it's False for raw streaming!\n)\n\n# This will now stream in real-time with a beautiful UI!\nresponse = agent.run(\"Tell me a detailed story about humanity colonizing the stars\")\nprint(response)\n</code></pre>"},{"location":"examples/agent_stream/#connect-with-us","title":"Connect With Us","text":"<p>If you'd like technical support, join our Discord below and stay updated on our Twitter for new updates!</p> Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"examples/cookbook_index/","title":"Swarms Cookbook Examples Index","text":"<p>This index provides a categorized list of examples and tutorials for using the Swarms Framework across different industries. Each example demonstrates practical applications and implementations using the framework.</p>"},{"location":"examples/cookbook_index/#finance-trading","title":"Finance &amp; Trading","text":"Name Description Link Tickr-Agent Financial analysis agent for stock market data using multithreaded processing and AI integration View Example CryptoAgent Real-time cryptocurrency data analysis and insights using CoinGecko integration View Example 10-K Analysis (Custom) Detailed analysis of SEC 10-K reports using specialized agents View Example 10-K Analysis (AgentRearrange) Mixed sequential and parallel analysis of 10-K reports View Example"},{"location":"examples/cookbook_index/#healthcare-medical","title":"Healthcare &amp; Medical","text":"Name Description Link MedInsight Pro Medical research summarization and analysis using AI-driven agents View Example Athletics Diagnosis Diagnosis and treatment system for extreme athletics using AgentRearrange View Example"},{"location":"examples/cookbook_index/#marketing-content","title":"Marketing &amp; Content","text":"Name Description Link NewsAgent Real-time news aggregation and summarization for business intelligence View Example Social Media Marketing Spreadsheet-based content generation for multi-platform marketing View Example"},{"location":"examples/cookbook_index/#accounting-finance-operations","title":"Accounting &amp; Finance Operations","text":"Name Description Link Accounting Agents Multi-agent system for financial projections and risk assessment View Example"},{"location":"examples/cookbook_index/#workshops-tutorials","title":"Workshops &amp; Tutorials","text":"Name Description Link GPTuesday Event Example of creating promotional content for tech events View Example"},{"location":"examples/cookbook_index/#additional-resources","title":"Additional Resources","text":"Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"examples/cookbook_index/#contributing","title":"Contributing","text":"<p>We welcome contributions! If you have an example or tutorial you'd like to add, please check our contribution guidelines.</p>"},{"location":"examples/cookbook_index/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details. </p>"},{"location":"examples/paper_implementations/","title":"Multi-Agent Paper Implementations","text":"<p>At Swarms, we are passionate about democratizing access to cutting-edge multi-agent research and making advanced AI collaboration accessible to everyone. Our mission is to bridge the gap between academic research and practical implementation by providing production-ready, open-source implementations of the most impactful multi-agent research papers.</p>"},{"location":"examples/paper_implementations/#why-multi-agent-research-matters","title":"Why Multi-Agent Research Matters","text":"<p>Multi-agent systems represent the next evolution in artificial intelligence, moving beyond single-agent limitations to harness the power of collective intelligence. These systems can:</p> <ul> <li>Overcome Individual Agent Constraints: Address memory limitations, hallucinations, and single-task focus through collaborative problem-solving</li> <li>Achieve Superior Performance: Combine specialized expertise across multiple agents to tackle complex, multifaceted challenges</li> <li>Enable Scalable Solutions: Distribute computational load and scale efficiently across multiple agents</li> <li>Foster Innovation: Create novel approaches through agent interaction and knowledge sharing</li> </ul>"},{"location":"examples/paper_implementations/#our-research-implementation-philosophy","title":"Our Research Implementation Philosophy","text":"<p>We believe that the best way to advance the field is through practical implementation and real-world validation. Our approach includes:</p> <ul> <li> <p>Faithful Reproduction: Implementing research papers with high fidelity to original methodologies</p> </li> <li> <p>Production Enhancement: Adding enterprise-grade features like error handling, monitoring, and scalability</p> </li> <li> <p>Open Source Commitment: Making all implementations freely available to the research community</p> </li> <li> <p>Continuous Improvement: Iterating on implementations based on community feedback and new research</p> </li> </ul>"},{"location":"examples/paper_implementations/#what-youll-find-here","title":"What You'll Find Here","text":"<p>This documentation showcases our comprehensive collection of multi-agent research implementations, including:</p> <ul> <li> <p>Academic Paper Implementations: Direct implementations of published research papers</p> </li> <li> <p>Enhanced Frameworks: Production-ready versions with additional features and optimizations</p> </li> <li> <p>Research Compilations: Curated lists of influential multi-agent papers and resources</p> </li> <li> <p>Practical Examples: Ready-to-use code examples and tutorials</p> </li> </ul> <p>Whether you're a researcher looking to validate findings, a developer building production systems, or a student learning about multi-agent AI, you'll find valuable resources here to advance your work.</p>"},{"location":"examples/paper_implementations/#join-the-multi-agent-revolution","title":"Join the Multi-Agent Revolution","text":"<p>We invite you to explore these implementations, contribute to our research efforts, and help shape the future of collaborative AI. Together, we can unlock the full potential of multi-agent systems and create AI that truly works as a team.</p>"},{"location":"examples/paper_implementations/#implemented-research-papers","title":"Implemented Research Papers","text":"Paper Name Description Original Paper Implementation Status Key Features MALT (Multi-Agent Learning Task) A sophisticated orchestration framework that coordinates multiple specialized AI agents to tackle complex tasks through structured conversations. arXiv:2412.01928 <code>swarms.structs.malt</code> \u2705 Complete Creator-Verifier-Refiner architecture, structured conversations, reliability guarantees MAI-DxO (MAI Diagnostic Orchestrator) An open-source implementation of Microsoft Research's \"Sequential Diagnosis with Language Models\" paper, simulating a virtual panel of physician-agents for iterative medical diagnosis. Microsoft Research Paper GitHub Repository \u2705 Complete Cost-effective medical diagnosis, physician-agent panel, iterative refinement AI-CoScientist A multi-agent AI framework for collaborative scientific research, implementing the \"Towards an AI Co-Scientist\" methodology with tournament-based hypothesis evolution. \"Towards an AI Co-Scientist\" Paper GitHub Repository \u2705 Complete Tournament-based selection, peer review systems, hypothesis evolution, Elo rating system Mixture of Agents (MoA) A sophisticated multi-agent architecture that implements parallel processing with iterative refinement, combining diverse expert agents for comprehensive analysis. Multi-agent collaboration concepts <code>swarms.structs.moa</code> \u2705 Complete Parallel processing, expert agent combination, iterative refinement, state-of-the-art performance Deep Research Swarm A production-grade research system that conducts comprehensive analysis across multiple domains using parallel processing and advanced AI agents. Research methodology <code>swarms.structs.deep_research_swarm</code> \u2705 Complete Parallel search processing, multi-agent coordination, information synthesis, concurrent execution Agent-as-a-Judge An evaluation framework that uses agents to evaluate other agents, implementing the \"Agent-as-a-Judge: Evaluate Agents with Agents\" methodology. arXiv:2410.10934 <code>swarms.agents.agent_judge</code> \u2705 Complete Agent evaluation, quality assessment, automated judging, performance metrics"},{"location":"examples/paper_implementations/#additional-research-resources","title":"Additional Research Resources","text":""},{"location":"examples/paper_implementations/#multi-agent-papers-compilation","title":"Multi-Agent Papers Compilation","text":"<p>We maintain a comprehensive list of multi-agent research papers at: awesome-multi-agent-papers</p>"},{"location":"examples/paper_implementations/#research-lists","title":"Research Lists","text":"<p>Our research compilation includes:</p> <ul> <li> <p>Projects: ModelScope-Agent, Gorilla, BMTools, LMQL, Langchain, MetaGPT, AutoGPT, and more</p> </li> <li> <p>Research Papers: BOLAA, ToolLLM, Communicative Agents, Mind2Web, Voyager, Tree of Thoughts, and many others</p> </li> <li> <p>Blog Articles: Latest insights and developments in autonomous agents</p> </li> <li> <p>Talks: Presentations from leading researchers like Geoffrey Hinton and Andrej Karpathy</p> </li> </ul>"},{"location":"examples/paper_implementations/#implementation-details","title":"Implementation Details","text":""},{"location":"examples/paper_implementations/#malt-framework","title":"MALT Framework","text":"<p>The MALT implementation provides:</p> <ul> <li> <p>Three-Agent Architecture: Creator, Verifier, and Refiner agents</p> </li> <li> <p>Structured Workflow: Coordinated task execution with conversation history</p> </li> <li> <p>Reliability Features: Error handling, validation, and quality assurance</p> </li> <li> <p>Extensibility: Custom agent integration and configuration options</p> </li> </ul>"},{"location":"examples/paper_implementations/#mai-dxo-system","title":"MAI-DxO System","text":"<p>The MAI Diagnostic Orchestrator features:</p> <ul> <li> <p>Virtual Physician Panel: Multiple specialized medical agents</p> </li> <li> <p>Cost Optimization: Efficient diagnostic workflows</p> </li> <li> <p>Iterative Refinement: Continuous improvement of diagnoses</p> </li> <li> <p>Medical Expertise: Domain-specific knowledge and reasoning</p> </li> </ul>"},{"location":"examples/paper_implementations/#ai-coscientist-framework","title":"AI-CoScientist Framework","text":"<p>The AI-CoScientist implementation includes:</p> <ul> <li> <p>Tournament-Based Selection: Elo rating system for hypothesis ranking</p> </li> <li> <p>Peer Review System: Comprehensive evaluation of scientific proposals</p> </li> <li> <p>Hypothesis Evolution: Iterative refinement based on feedback</p> </li> <li> <p>Diversity Control: Proximity analysis to maintain hypothesis variety</p> </li> </ul>"},{"location":"examples/paper_implementations/#mixture-of-agents-moa","title":"Mixture of Agents (MoA)","text":"<p>The MoA architecture provides:</p> <ul> <li> <p>Parallel Processing: Multiple agents working simultaneously</p> </li> <li> <p>Expert Specialization: Domain-specific agent capabilities</p> </li> <li> <p>Iterative Refinement: Continuous improvement through collaboration</p> </li> <li> <p>State-of-the-Art Performance: Achieving superior results through collective intelligence</p> </li> </ul>"},{"location":"examples/paper_implementations/#contributing","title":"Contributing","text":"<p>We welcome contributions to implement additional research papers! If you'd like to contribute:</p> <ol> <li>Identify a paper: Choose a relevant multi-agent research paper</li> <li>Propose implementation: Submit an issue with your proposal</li> <li>Implement: Create the implementation following our guidelines</li> <li>Document: Add comprehensive documentation and examples</li> <li>Test: Ensure robust testing and validation</li> </ol>"},{"location":"examples/paper_implementations/#citation","title":"Citation","text":"<p>If you use any of these implementations in your research, please cite the original papers and the Swarms framework:</p> <pre><code>@misc{SWARMS_2022,\n  author  = {Gomez, Kye and Pliny and More, Harshal and Swarms Community},\n  title   = {{Swarms: Production-Grade Multi-Agent Infrastructure Platform}},\n  year    = {2022},\n  howpublished = {\\url{https://github.com/kyegomez/swarms}},\n  note    = {Documentation available at \\url{https://docs.swarms.world}},\n  version = {latest}\n}\n</code></pre>"},{"location":"examples/paper_implementations/#community","title":"Community","text":"<p>Join our community to stay updated on the latest multi-agent research implementations:</p> <ul> <li> <p>Discord: Join our community</p> </li> <li> <p>Documentation: docs.swarms.world</p> </li> <li> <p>GitHub: kyegomez/swarms</p> </li> <li> <p>Research Papers: awesome-multi-agent-papers</p> </li> </ul>"},{"location":"examples/templates/","title":"Templates &amp; Applications Documentation","text":"<p>The Swarms framework is a powerful multi-agent orchestration platform that enables developers to build sophisticated AI agent systems. This documentation showcases the extensive ecosystem of templates, applications, and tools built on the Swarms framework, organized by industry and application type.</p> <p>\ud83d\udd17 Main Repository: Swarms Framework</p>"},{"location":"examples/templates/#healthcare-medical-applications","title":"\ud83c\udfe5 Healthcare &amp; Medical Applications","text":""},{"location":"examples/templates/#medical-diagnosis-analysis","title":"Medical Diagnosis &amp; Analysis","text":"Name Description Type Repository MRI-Swarm Multi-agent system for MRI image analysis and diagnosis Medical Imaging Healthcare DermaSwarm Dermatology-focused agent swarm for skin condition analysis Medical Diagnosis Healthcare Multi-Modal-XRAY-Diagnosis X-ray diagnosis using multi-modal AI agents Medical Imaging Healthcare Open-MAI-Dx-Orchestrator Medical AI diagnosis orchestration platform Medical Platform Healthcare radiology-swarm Radiology-focused multi-agent system Medical Imaging Healthcare"},{"location":"examples/templates/#medical-operations-administration","title":"Medical Operations &amp; Administration","text":"Name Description Type Repository MedicalCoderSwarm Medical coding automation using agent swarms Medical Coding Healthcare pharma-swarm Pharmaceutical research and development agents Pharmaceutical Healthcare MedGuard Medical data security and compliance system Medical Security Healthcare MedInsight-Pro Advanced medical insights and analytics platform Medical Analytics Healthcare"},{"location":"examples/templates/#financial-services-trading","title":"\ud83d\udcb0 Financial Services &amp; Trading","text":""},{"location":"examples/templates/#trading-investment","title":"Trading &amp; Investment","text":"Name Description Type Repository automated-crypto-fund Automated cryptocurrency trading fund management Crypto Trading Finance CryptoAgent Cryptocurrency analysis and trading agent Crypto Trading Finance AutoHedge Automated hedging strategies implementation Risk Management Finance BackTesterAgent Trading strategy backtesting automation Trading Tools Finance ForexTreeSwarm Forex trading decision tree swarm system Forex Trading Finance HTX-Swarm HTX exchange integration and trading automation Crypto Exchange Finance"},{"location":"examples/templates/#financial-analysis-management","title":"Financial Analysis &amp; Management","text":"Name Description Type Repository TickrAgent Stock ticker analysis and monitoring agent Stock Analysis Finance Open-Aladdin Open-source financial risk management system Risk Management Finance CryptoTaxSwarm Cryptocurrency tax calculation and reporting Tax Management Finance"},{"location":"examples/templates/#insurance-lending","title":"Insurance &amp; Lending","text":"Name Description Type Repository InsuranceSwarm Insurance claim processing and underwriting Insurance Finance MortgageUnderwritingSwarm Automated mortgage underwriting system Lending Finance"},{"location":"examples/templates/#research-development","title":"\ud83d\udd2c Research &amp; Development","text":""},{"location":"examples/templates/#scientific-research","title":"Scientific Research","text":"Name Description Type Repository AI-CoScientist AI research collaboration platform Research Platform Science auto-ai-research-team Automated AI research team coordination Research Automation Science Research-Paper-Writer-Swarm Automated research paper writing system Academic Writing Science"},{"location":"examples/templates/#mathematical-analytical","title":"Mathematical &amp; Analytical","text":"Name Description Type Repository Generalist-Mathematician-Swarm Mathematical problem-solving agent swarm Mathematics Science"},{"location":"examples/templates/#business-marketing","title":"\ud83d\udcbc Business &amp; Marketing","text":""},{"location":"examples/templates/#marketing-content","title":"Marketing &amp; Content","text":"Name Description Type Repository Marketing-Swarm-Template Marketing campaign automation template Marketing Automation Business Multi-Agent-Marketing-Course Educational course on multi-agent marketing Marketing Education Business NewsAgent News aggregation and analysis agent News Analysis Business"},{"location":"examples/templates/#legal-services","title":"Legal Services","text":"Name Description Type Repository Legal-Swarm-Template Legal document processing and analysis Legal Technology Business"},{"location":"examples/templates/#development-tools-platforms","title":"\ud83d\udee0\ufe0f Development Tools &amp; Platforms","text":""},{"location":"examples/templates/#core-platforms-operating-systems","title":"Core Platforms &amp; Operating Systems","text":"Name Description Type Repository AgentOS Operating system for AI agents Agent Platform Development swarm-ecosystem Complete ecosystem for swarm development Ecosystem Platform Development AgentAPIProduction Production-ready agent API system API Platform Development"},{"location":"examples/templates/#development-tools-utilities","title":"Development Tools &amp; Utilities","text":"Name Description Type Repository DevSwarm Development-focused agent swarm Development Tools Development FluidAPI Dynamic API generation and management API Tools Development OmniParse Universal document parsing system Document Processing Development doc-master Documentation generation and management Documentation Tools Development"},{"location":"examples/templates/#templates-examples","title":"Templates &amp; Examples","text":"Name Description Type Repository Multi-Agent-Template-App Template application for multi-agent systems Template Development swarms-examples Collection of Swarms framework examples Examples Development Phala-Deployment-Template Deployment template for Phala Network Deployment Template Development"},{"location":"examples/templates/#educational-resources","title":"\ud83d\udcda Educational Resources","text":""},{"location":"examples/templates/#courses-guides","title":"Courses &amp; Guides","text":"Name Description Type Repository Enterprise-Grade-Agents-Course Comprehensive course on enterprise AI agents Educational Course Education Agents-Beginner-Guide Beginner's guide to AI agents Educational Guide Education"},{"location":"examples/templates/#testing-evaluation","title":"Testing &amp; Evaluation","text":"Name Description Type Repository swarms-evals Evaluation framework for swarm systems Testing Framework Development"},{"location":"examples/templates/#getting-started","title":"\ud83d\ude80 Getting Started","text":""},{"location":"examples/templates/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.8+</p> </li> <li> <p>Basic understanding of AI agents and multi-agent systems</p> </li> <li> <p>Familiarity with the Swarms framework</p> </li> </ul>"},{"location":"examples/templates/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"examples/templates/#quick-start","title":"Quick Start","text":"<ol> <li> <p>Choose a template from the categories above</p> </li> <li> <p>Clone the repository</p> </li> <li> <p>Follow the setup instructions in the README</p> </li> <li> <p>Customize the agents for your specific use case</p> </li> </ol>"},{"location":"examples/templates/#contributing","title":"\ud83e\udd1d Contributing","text":"<p>The Swarms ecosystem is constantly growing. To contribute:</p> <ol> <li>Fork the main Swarms repository</li> <li>Create your feature branch</li> <li>Submit a pull request</li> <li>Join the community discussions</li> </ol>"},{"location":"examples/templates/#support-community","title":"\ud83d\udcde Support &amp; Community","text":"<p>Join our community of agent engineers and researchers for technical support, cutting-edge updates, and exclusive access to world-class agent engineering insights!</p> Platform Description Link \ud83c\udfe0 Main Repository Swarms Framework GitHub \ud83c\udfe2 Organization The Swarm Corporation GitHub Org \ud83c\udf10 Website Official project website swarms.ai \ud83d\udcda Documentation Official documentation and guides docs.swarms.world \ud83d\udcdd Blog Latest updates and technical articles Medium \ud83d\udcac Discord Live chat and community support Join Discord \ud83d\udc26 Twitter Latest news and announcements @kyegomez \ud83d\udc65 LinkedIn Professional network and updates The Swarm Corporation \ud83d\udcfa YouTube Tutorials and demos Swarms Channel \ud83c\udfab Events Join our community events Sign up here \ud83d\ude80 Onboarding Session Get onboarded with Kye Gomez, creator and lead maintainer of Swarms Book Session"},{"location":"examples/templates/#statistics","title":"\ud83d\udcca Statistics","text":"<ul> <li> <p>Total Projects: 35+</p> </li> <li> <p>Industries Covered: Healthcare, Finance, Research, Business, Development</p> </li> <li> <p>Project Types: Templates, Applications, Tools, Educational Resources</p> </li> <li> <p>Active Development: Continuous updates and new additions</p> </li> </ul>"},{"location":"governance/main/","title":"\ud83d\udd17 Links &amp; Resources","text":"<p>Welcome to the Swarms ecosystem. Click any tile below to explore our products, community, documentation, and social platforms.</p> \ud83d\udde3\ufe0f Swarms Chat \ud83d\udecd\ufe0f Swarms Marketplace \ud83d\udcda Swarms API Docs \ud83d\ude80 Swarms Startup Program \ud83d\udcbb GitHub: Swarms (Python) \ud83e\udd80 GitHub: Swarms (Rust) \ud83d\udcac Join Our Discord \ud83d\udcf1 Telegram Group \ud83d\udc26 Twitter / X \u270d\ufe0f Swarms Blog on Medium"},{"location":"governance/main/#quick-summary","title":"\ud83d\udca1 Quick Summary","text":"Category Link API Docs docs.swarms.world GitHub kyegomez/swarms GitHub (Rust) The-Swarm-Corporation/swarms-rs Chat UI swarms.world/platform/chat Marketplace swarms.world Startup App Apply Here Discord Join Now Telegram Group Chat Twitter/X @swarms_corp Blog medium.com/@kyeg <p>\ud83d\udc1d Swarms is building the agentic internet. Join the movement and build the future with us.</p>"},{"location":"guides/agent_evals/","title":"Agent evals","text":""},{"location":"guides/agent_evals/#understanding-agent-evaluation-mechanisms","title":"Understanding Agent Evaluation Mechanisms","text":"<p>Agent evaluation mechanisms play a crucial role in ensuring that autonomous agents, particularly in multi-agent systems, perform their tasks effectively and efficiently. This blog delves into the intricacies of agent evaluation, the importance of accuracy tracking, and the methodologies used to measure and visualize agent performance. We'll use Mermaid graphs to provide clear visual representations of these processes.</p>"},{"location":"guides/agent_evals/#1-introduction-to-agent-evaluation-mechanisms","title":"1. Introduction to Agent Evaluation Mechanisms","text":"<p>Agent evaluation mechanisms refer to the processes and criteria used to assess the performance of agents within a system. These mechanisms are essential for:</p> <ul> <li>Ensuring Reliability: Agents must consistently perform their designated tasks correctly.</li> <li>Improving Performance: Evaluation helps in identifying areas where agents can improve.</li> <li>Maintaining Accountability: It provides a way to hold agents accountable for their actions.</li> </ul>"},{"location":"guides/agent_evals/#2-key-components-of-agent-evaluation","title":"2. Key Components of Agent Evaluation","text":"<p>To effectively evaluate agents, several components and metrics are considered:</p>"},{"location":"guides/agent_evals/#a-performance-metrics","title":"a. Performance Metrics","text":"<p>These are quantitative measures used to assess how well an agent is performing. Common performance metrics include:</p> <ul> <li>Accuracy: The percentage of correct actions or decisions made by the agent.</li> <li>Precision and Recall: Precision measures the number of true positive results divided by the number of all positive results, while recall measures the number of true positive results divided by the number of positives that should have been retrieved.</li> <li>F1 Score: The harmonic mean of precision and recall.</li> <li>Response Time: How quickly an agent responds to a given task or query.</li> </ul>"},{"location":"guides/agent_evals/#b-evaluation-criteria","title":"b. Evaluation Criteria","text":"<p>Evaluation criteria define the standards or benchmarks against which agent performance is measured. These criteria are often task-specific and may include:</p> <ul> <li>Task Completion Rate: The percentage of tasks successfully completed by the agent.</li> <li>Error Rate: The frequency of errors made by the agent during task execution.</li> <li>Resource Utilization: How efficiently an agent uses resources such as memory and CPU.</li> </ul>"},{"location":"guides/agent_evals/#3-the-process-of-agent-evaluation","title":"3. The Process of Agent Evaluation","text":"<p>The evaluation process involves several steps, which can be visualized using Mermaid graphs:</p>"},{"location":"guides/agent_evals/#a-define-evaluation-metrics","title":"a. Define Evaluation Metrics","text":"<p>The first step is to define the metrics that will be used to evaluate the agent. This involves identifying the key performance indicators (KPIs) relevant to the agent's tasks.</p> <pre><code>graph TD\n    A[Define Evaluation Metrics] --&gt; B[Identify KPIs]\n    B --&gt; C[Accuracy]\n    B --&gt; D[Precision and Recall]\n    B --&gt; E[F1 Score]\n    B --&gt; F[Response Time]</code></pre>"},{"location":"guides/agent_evals/#b-collect-data","title":"b. Collect Data","text":"<p>Data collection involves gathering information on the agent's performance. This data can come from logs, user feedback, or direct observations.</p> <pre><code>graph TD\n    A[Collect Data] --&gt; B[Logs]\n    A --&gt; C[User Feedback]\n    A --&gt; D[Direct Observations]</code></pre>"},{"location":"guides/agent_evals/#c-analyze-performance","title":"c. Analyze Performance","text":"<p>Once data is collected, it is analyzed to assess the agent's performance against the defined metrics. This step may involve statistical analysis, machine learning models, or other analytical techniques.</p> <pre><code>graph TD\n    A[Analyze Performance] --&gt; B[Statistical Analysis]\n    A --&gt; C[Machine Learning Models]\n    A --&gt; D[Other Analytical Techniques]</code></pre>"},{"location":"guides/agent_evals/#d-generate-reports","title":"d. Generate Reports","text":"<p>After analysis, performance reports are generated. These reports provide insights into how well the agent is performing and identify areas for improvement.</p> <pre><code>graph TD\n    A[Generate Reports] --&gt; B[Performance Insights]\n    B --&gt; C[Identify Areas for Improvement]</code></pre>"},{"location":"guides/agent_evals/#4-tracking-agent-accuracy","title":"4. Tracking Agent Accuracy","text":"<p>Accuracy tracking is a critical aspect of agent evaluation. It involves measuring how often an agent's actions or decisions are correct. The following steps outline the process of tracking agent accuracy:</p>"},{"location":"guides/agent_evals/#a-define-correctness-criteria","title":"a. Define Correctness Criteria","text":"<p>The first step is to define what constitutes a correct action or decision for the agent.</p> <pre><code>graph TD\n    A[Define Correctness Criteria] --&gt; B[Task-Specific Standards]\n    B --&gt; C[Action Accuracy]\n    B --&gt; D[Decision Accuracy]</code></pre>"},{"location":"guides/agent_evals/#b-monitor-agent-actions","title":"b. Monitor Agent Actions","text":"<p>Agents' actions are continuously monitored to track their performance. This monitoring can be done in real-time or through periodic evaluations.</p> <pre><code>graph TD\n    A[Monitor Agent Actions] --&gt; B[Real-Time Monitoring]\n    A --&gt; C[Periodic Evaluations]</code></pre>"},{"location":"guides/agent_evals/#c-compare-against-correctness-criteria","title":"c. Compare Against Correctness Criteria","text":"<p>Each action or decision made by the agent is compared against the defined correctness criteria to determine its accuracy.</p> <pre><code>graph TD\n    A[Compare Against Correctness Criteria] --&gt; B[Evaluate Each Action]\n    B --&gt; C[Correct or Incorrect?]</code></pre>"},{"location":"guides/agent_evals/#d-calculate-accuracy-metrics","title":"d. Calculate Accuracy Metrics","text":"<p>Accuracy metrics are calculated based on the comparison results. These metrics provide a quantitative measure of the agent's accuracy.</p> <pre><code>graph TD\n    A[Calculate Accuracy Metrics] --&gt; B[Accuracy Percentage]\n    A --&gt; C[Error Rate]</code></pre>"},{"location":"guides/agent_evals/#5-measuring-agent-accuracy","title":"5. Measuring Agent Accuracy","text":"<p>Measuring agent accuracy involves several steps and considerations:</p>"},{"location":"guides/agent_evals/#a-data-labeling","title":"a. Data Labeling","text":"<p>To measure accuracy, the data used for evaluation must be accurately labeled. This involves annotating the data with the correct actions or decisions.</p> <pre><code>graph TD\n    A[Data Labeling] --&gt; B[Annotate Data with Correct Actions]\n    B --&gt; C[Ensure Accuracy of Labels]</code></pre>"},{"location":"guides/agent_evals/#b-establish-baseline-performance","title":"b. Establish Baseline Performance","text":"<p>A baseline performance level is established by evaluating a sample set of data. This baseline serves as a reference point for measuring improvements or declines in accuracy.</p> <pre><code>graph TD\n    A[Establish Baseline Performance] --&gt; B[Evaluate Sample Data]\n    B --&gt; C[Set Performance Benchmarks]</code></pre>"},{"location":"guides/agent_evals/#c-regular-evaluations","title":"c. Regular Evaluations","text":"<p>Agents are regularly evaluated to measure their accuracy over time. This helps in tracking performance trends and identifying any deviations from the expected behavior.</p> <pre><code>graph TD\n    A[Regular Evaluations] --&gt; B[Track Performance Over Time]\n    B --&gt; C[Identify Performance Trends]\n    B --&gt; D[Detect Deviations]</code></pre>"},{"location":"guides/agent_evals/#d-feedback-and-improvement","title":"d. Feedback and Improvement","text":"<p>Feedback from evaluations is used to improve the agent's performance. This may involve retraining the agent, adjusting its algorithms, or refining its decision-making processes.</p> <pre><code>graph TD\n    A[Feedback and Improvement] --&gt; B[Use Evaluation Feedback]\n    B --&gt; C[Retrain Agent]\n    B --&gt; D[Adjust Algorithms]\n    B --&gt; E[Refine Decision-Making Processes]</code></pre>"},{"location":"guides/agent_evals/#6-visualizing-agent-evaluation-with-mermaid-graphs","title":"6. Visualizing Agent Evaluation with Mermaid Graphs","text":"<p>Mermaid graphs provide a clear and concise way to visualize the agent evaluation process. Here are some examples of how Mermaid graphs can be used:</p>"},{"location":"guides/agent_evals/#a-overall-evaluation-process","title":"a. Overall Evaluation Process","text":"<pre><code>graph TD\n    A[Define Evaluation Metrics] --&gt; B[Collect Data]\n    B --&gt; C[Analyze Performance]\n    C --&gt; D[Generate Reports]</code></pre>"},{"location":"guides/agent_evals/#b-accuracy-tracking","title":"b. Accuracy Tracking","text":"<pre><code>graph TD\n    A[Define Correctness Criteria] --&gt; B[Monitor Agent Actions]\n    B --&gt; C[Compare Against Correctness Criteria]\n    C --&gt; D[Calculate Accuracy Metrics]</code></pre>"},{"location":"guides/agent_evals/#c-continuous-improvement-cycle","title":"c. Continuous Improvement Cycle","text":"<pre><code>graph TD\n    A[Regular Evaluations] --&gt; B[Track Performance Over Time]\n    B --&gt; C[Identify Performance Trends]\n    C --&gt; D[Detect Deviations]\n    D --&gt; E[Feedback and Improvement]\n    E --&gt; A</code></pre>"},{"location":"guides/agent_evals/#7-case-study-evaluating-a-chatbot-agent","title":"7. Case Study: Evaluating a Chatbot Agent","text":"<p>To illustrate the agent evaluation process, let's consider a case study involving a chatbot agent designed to assist customers in an e-commerce platform.</p>"},{"location":"guides/agent_evals/#a-define-evaluation-metrics_1","title":"a. Define Evaluation Metrics","text":"<p>For the chatbot, key performance metrics might include:</p> <ul> <li>Response Accuracy: The percentage of correct responses provided by the chatbot.</li> <li>Response Time: The average time taken by the chatbot to respond to user queries.</li> <li>Customer Satisfaction: Measured through user feedback and ratings.</li> </ul>"},{"location":"guides/agent_evals/#b-collect-data_1","title":"b. Collect Data","text":"<p>Data is collected from chatbot interactions, including user queries, responses, and feedback.</p>"},{"location":"guides/agent_evals/#c-analyze-performance_1","title":"c. Analyze Performance","text":"<p>Performance analysis involves comparing the chatbot's responses against a predefined set of correct responses and calculating accuracy metrics.</p>"},{"location":"guides/agent_evals/#d-generate-reports_1","title":"d. Generate Reports","text":"<p>Reports are generated to provide insights into the chatbot's performance, highlighting areas where it excels and areas needing improvement.</p>"},{"location":"guides/agent_evals/#8-best-practices-for-agent-evaluation","title":"8. Best Practices for Agent Evaluation","text":"<p>Here are some best practices to ensure effective agent evaluation:</p>"},{"location":"guides/agent_evals/#a-use-realistic-scenarios","title":"a. Use Realistic Scenarios","text":"<p>Evaluate agents in realistic scenarios that closely mimic real-world conditions. This ensures that the evaluation results are relevant and applicable.</p>"},{"location":"guides/agent_evals/#b-continuous-monitoring","title":"b. Continuous Monitoring","text":"<p>Continuously monitor agent performance to detect and address issues promptly. This helps in maintaining high performance levels.</p>"},{"location":"guides/agent_evals/#c-incorporate-user-feedback","title":"c. Incorporate User Feedback","text":"<p>User feedback is invaluable for improving agent performance. Incorporate feedback into the evaluation process to identify and rectify shortcomings.</p>"},{"location":"guides/agent_evals/#d-regular-updates","title":"d. Regular Updates","text":"<p>Regularly update the evaluation metrics and criteria to keep pace with evolving tasks and requirements.</p>"},{"location":"guides/agent_evals/#conclusion","title":"Conclusion","text":"<p>Agent evaluation mechanisms are vital for ensuring the reliability, efficiency, and effectiveness of autonomous agents. By defining clear evaluation metrics, continuously monitoring performance, and using feedback for improvement, we can develop agents that consistently perform at high levels. Visualizing the evaluation process with tools like Mermaid graphs further aids in understanding and communication. Through diligent evaluation and continuous improvement, we can harness the full potential of autonomous agents in various applications.</p>"},{"location":"guides/financial_analysis_swarm_mm/","title":"Building a Multi-Agent System for Real-Time Financial Analysis: A Comprehensive Tutorial","text":"<p>In this tutorial, we'll walk through the process of building a sophisticated multi-agent system for real-time financial analysis using the Swarms framework. This system is designed for financial analysts and developer analysts who want to leverage AI and multiple data sources to gain deeper insights into stock performance, market trends, and economic indicators.</p> <p>Before we dive into the code, let's briefly introduce the Swarms framework. Swarms is an innovative open-source project that simplifies the creation and management of AI agents. It's particularly well-suited for complex tasks like financial analysis, where multiple specialized agents can work together to provide comprehensive insights.</p> <p>For more information and to contribute to the project, visit the Swarms GitHub repository. We highly recommend exploring the documentation for a deeper understanding of Swarms' capabilities.</p> <p>Additional resources: - Swarms Discord for community discussions - Swarms Twitter for updates - Swarms Spotify for podcasts - Swarms Blog for in-depth articles - Swarms Website for an overview of the project</p> <p>Now, let's break down our financial analysis system step by step.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-1-setting-up-the-environment","title":"Step 1: Setting Up the Environment","text":"<p>First install the necessary packages:</p> <pre><code>$ pip3 install -U swarms yfiance swarm_models fredapi pandas \n</code></pre> <p>First, we need to set up our environment and import the necessary libraries:</p> <pre><code>import os\nimport time\nfrom datetime import datetime, timedelta\nimport yfinance as yf\nimport requests\nfrom fredapi import Fred\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom swarms import Agent, AgentRearrange\nfrom swarm_models import OpenAIChat\nimport logging\nfrom dotenv import load_dotenv\nimport asyncio\nimport aiohttp\nfrom ratelimit import limits, sleep_and_retry\n\n# Load environment variables\nload_dotenv()\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')\nlogger = logging.getLogger(__name__)\n\n# API keys\nPOLYGON_API_KEY = os.getenv('POLYGON_API_KEY')\nFRED_API_KEY = os.getenv('FRED_API_KEY')\nOPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\n\n# Initialize FRED client\nfred_client = Fred(api_key=FRED_API_KEY)\n\n# Polygon API base URL\nPOLYGON_BASE_URL = \"https://api.polygon.io\"\n</code></pre> <p>This section sets up our environment, imports necessary libraries, and initializes our API keys and clients. We're using <code>dotenv</code> to securely manage our API keys, and we've set up logging to track the execution of our script.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-2-implementing-rate-limiting","title":"Step 2: Implementing Rate Limiting","text":"<p>To respect API rate limits, we implement rate limiting decorators:</p> <pre><code>@sleep_and_retry\n@limits(calls=5, period=60)  # Adjust these values based on your Polygon API tier\nasync def call_polygon_api(session, endpoint, params=None):\n    url = f\"{POLYGON_BASE_URL}{endpoint}\"\n    params = params or {}\n    params['apiKey'] = POLYGON_API_KEY\n    async with session.get(url, params=params) as response:\n        response.raise_for_status()\n        return await response.json()\n\n@sleep_and_retry\n@limits(calls=120, period=60)  # FRED allows 120 requests per minute\ndef call_fred_api(func, *args, **kwargs):\n    return func(*args, **kwargs)\n</code></pre> <p>These decorators ensure that we don't exceed the rate limits for our API calls. The <code>call_polygon_api</code> function is designed to work with asynchronous code, while <code>call_fred_api</code> is a wrapper for synchronous FRED API calls.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-3-implementing-data-fetching-functions","title":"Step 3: Implementing Data Fetching Functions","text":"<p>Next, we implement functions to fetch data from various sources:</p>"},{"location":"guides/financial_analysis_swarm_mm/#yahoo-finance-integration","title":"Yahoo Finance Integration","text":"<pre><code>async def get_yahoo_finance_data(session, ticker, period=\"1d\", interval=\"1m\"):\n    try:\n        stock = yf.Ticker(ticker)\n        hist = await asyncio.to_thread(stock.history, period=period, interval=interval)\n        info = await asyncio.to_thread(lambda: stock.info)\n        return hist, info\n    except Exception as e:\n        logger.error(f\"Error fetching Yahoo Finance data for {ticker}: {e}\")\n        return None, None\n\nasync def get_yahoo_finance_realtime(session, ticker):\n    try:\n        stock = yf.Ticker(ticker)\n        return await asyncio.to_thread(lambda: stock.fast_info)\n    except Exception as e:\n        logger.error(f\"Error fetching Yahoo Finance realtime data for {ticker}: {e}\")\n        return None\n</code></pre> <p>These functions fetch historical and real-time data from Yahoo Finance. We use <code>asyncio.to_thread</code> to run the synchronous <code>yfinance</code> functions in a separate thread, allowing our main event loop to continue running.</p>"},{"location":"guides/financial_analysis_swarm_mm/#polygonio-integration","title":"Polygon.io Integration","text":"<pre><code>async def get_polygon_realtime_data(session, ticker):\n    try:\n        trades = await call_polygon_api(session, f\"/v2/last/trade/{ticker}\")\n        quotes = await call_polygon_api(session, f\"/v2/last/nbbo/{ticker}\")\n        return trades, quotes\n    except Exception as e:\n        logger.error(f\"Error fetching Polygon.io realtime data for {ticker}: {e}\")\n        return None, None\n\nasync def get_polygon_news(session, ticker, limit=10):\n    try:\n        news = await call_polygon_api(session, f\"/v2/reference/news\", params={\"ticker\": ticker, \"limit\": limit})\n        return news.get('results', [])\n    except Exception as e:\n        logger.error(f\"Error fetching Polygon.io news for {ticker}: {e}\")\n        return []\n</code></pre> <p>These functions fetch real-time trade and quote data, as well as news articles from Polygon.io. We use our <code>call_polygon_api</code> function to make these requests, ensuring we respect rate limits.</p>"},{"location":"guides/financial_analysis_swarm_mm/#fred-integration","title":"FRED Integration","text":"<pre><code>async def get_fred_data(session, series_id, start_date, end_date):\n    try:\n        data = await asyncio.to_thread(call_fred_api, fred_client.get_series, series_id, start_date, end_date)\n        return data\n    except Exception as e:\n        logger.error(f\"Error fetching FRED data for {series_id}: {e}\")\n        return None\n\nasync def get_fred_realtime(session, series_ids):\n    try:\n        data = {}\n        for series_id in series_ids:\n            series = await asyncio.to_thread(call_fred_api, fred_client.get_series, series_id)\n            data[series_id] = series.iloc[-1]  # Get the most recent value\n        return data\n    except Exception as e:\n        logger.error(f\"Error fetching FRED realtime data: {e}\")\n        return {}\n</code></pre> <p>These functions fetch historical and real-time economic data from FRED. Again, we use <code>asyncio.to_thread</code> to run the synchronous FRED API calls in a separate thread.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-4-creating-specialized-agents","title":"Step 4: Creating Specialized Agents","text":"<p>Now we create our specialized agents using the Swarms framework:</p> <pre><code>stock_agent = Agent(\n    agent_name=\"StockAgent\",\n    system_prompt=\"\"\"You are an expert stock analyst. Your task is to analyze real-time stock data and provide insights. \n    Consider price movements, trading volume, and any available company information. \n    Provide a concise summary of the stock's current status and any notable trends or events.\"\"\",\n    llm=OpenAIChat(api_key=OPENAI_API_KEY),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n)\n\nmarket_agent = Agent(\n    agent_name=\"MarketAgent\",\n    system_prompt=\"\"\"You are a market analysis expert. Your task is to analyze overall market conditions using real-time data. \n    Consider major indices, sector performance, and market-wide trends. \n    Provide a concise summary of current market conditions and any significant developments.\"\"\",\n    llm=OpenAIChat(api_key=OPENAI_API_KEY),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n)\n\nmacro_agent = Agent(\n    agent_name=\"MacroAgent\",\n    system_prompt=\"\"\"You are a macroeconomic analysis expert. Your task is to analyze key economic indicators and provide insights on the overall economic situation. \n    Consider GDP growth, inflation rates, unemployment figures, and other relevant economic data. \n    Provide a concise summary of the current economic situation and any potential impacts on financial markets.\"\"\",\n    llm=OpenAIChat(api_key=OPENAI_API_KEY),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n)\n\nnews_agent = Agent(\n    agent_name=\"NewsAgent\",\n    system_prompt=\"\"\"You are a financial news analyst. Your task is to analyze recent news articles related to specific stocks or the overall market. \n    Consider the potential impact of news events on stock prices or market trends. \n    Provide a concise summary of key news items and their potential market implications.\"\"\",\n    llm=OpenAIChat(api_key=OPENAI_API_KEY),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n)\n</code></pre> <p>Each agent is specialized in a different aspect of financial analysis. The <code>system_prompt</code> for each agent defines its role and the type of analysis it should perform.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-5-building-the-multi-agent-system","title":"Step 5: Building the Multi-Agent System","text":"<p>We then combine our specialized agents into a multi-agent system:</p> <pre><code>agents = [stock_agent, market_agent, macro_agent, news_agent]\nflow = \"StockAgent -&gt; MarketAgent -&gt; MacroAgent -&gt; NewsAgent\"\n\nagent_system = AgentRearrange(agents=agents, flow=flow)\n</code></pre> <p>The <code>flow</code> variable defines the order in which our agents will process information. This allows for a logical progression from specific stock analysis to broader market and economic analysis.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-6-implementing-real-time-analysis","title":"Step 6: Implementing Real-Time Analysis","text":"<p>Now we implement our main analysis function:</p> <pre><code>async def real_time_analysis(session, ticker):\n    logger.info(f\"Starting real-time analysis for {ticker}\")\n\n    # Fetch real-time data\n    yf_data, yf_info = await get_yahoo_finance_data(session, ticker)\n    yf_realtime = await get_yahoo_finance_realtime(session, ticker)\n    polygon_trades, polygon_quotes = await get_polygon_realtime_data(session, ticker)\n    polygon_news = await get_polygon_news(session, ticker)\n    fred_data = await get_fred_realtime(session, ['GDP', 'UNRATE', 'CPIAUCSL'])\n\n    # Prepare input for the multi-agent system\n    input_data = f\"\"\"\n    Yahoo Finance Data:\n    {yf_realtime}\n\n    Recent Stock History:\n    {yf_data.tail().to_string() if yf_data is not None else 'Data unavailable'}\n\n    Polygon.io Trade Data:\n    {polygon_trades}\n\n    Polygon.io Quote Data:\n    {polygon_quotes}\n\n    Recent News:\n    {polygon_news[:3] if polygon_news else 'No recent news available'}\n\n    Economic Indicators:\n    {fred_data}\n\n    Analyze this real-time financial data for {ticker}. Provide insights on the stock's performance, overall market conditions, relevant economic factors, and any significant news that might impact the stock or market.\n    \"\"\"\n\n    # Run the multi-agent analysis\n    try:\n        analysis = agent_system.run(input_data)\n        logger.info(f\"Analysis completed for {ticker}\")\n        return analysis\n    except Exception as e:\n        logger.error(f\"Error during multi-agent analysis for {ticker}: {e}\")\n        return f\"Error during analysis: {e}\"\n</code></pre> <p>This function fetches data from all our sources, prepares it as input for our multi-agent system, and then runs the analysis. The result is a comprehensive analysis of the stock, considering individual performance, market conditions, economic factors, and relevant news.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-7-implementing-advanced-use-cases","title":"Step 7: Implementing Advanced Use Cases","text":"<p>We then implement more advanced analysis functions:</p>"},{"location":"guides/financial_analysis_swarm_mm/#compare-stocks","title":"Compare Stocks","text":"<pre><code>async def compare_stocks(session, tickers):\n    results = {}\n    for ticker in tickers:\n        results[ticker] = await real_time_analysis(session, ticker)\n\n    comparison_prompt = f\"\"\"\n    Compare the following stocks based on the provided analyses:\n    {results}\n\n    Highlight key differences and similarities. Provide a ranking of these stocks based on their current performance and future prospects.\n    \"\"\"\n\n    try:\n        comparison = agent_system.run(comparison_prompt)\n        logger.info(f\"Stock comparison completed for {tickers}\")\n        return comparison\n    except Exception as e:\n        logger.error(f\"Error during stock comparison: {e}\")\n        return f\"Error during comparison: {e}\"\n</code></pre> <p>This function compares multiple stocks by running a real-time analysis on each and then prompting our multi-agent system to compare the results.</p>"},{"location":"guides/financial_analysis_swarm_mm/#sector-analysis","title":"Sector Analysis","text":"<pre><code>async def sector_analysis(session, sector):\n    sector_stocks = {\n        'Technology': ['AAPL', 'MSFT', 'GOOGL', 'AMZN', 'NVDA'],\n        'Finance': ['JPM', 'BAC', 'WFC', 'C', 'GS'],\n        'Healthcare': ['JNJ', 'UNH', 'PFE', 'ABT', 'MRK'],\n        'Consumer Goods': ['PG', 'KO', 'PEP', 'COST', 'WMT'],\n        'Energy': ['XOM', 'CVX', 'COP', 'SLB', 'EOG']\n    }\n\n    if sector not in sector_stocks:\n        return f\"Sector '{sector}' not found. Available sectors: {', '.join(sector_stocks.keys())}\"\n\n    stocks = sector_stocks[sector][:5]\n\n    sector_data = {}\n    for stock in stocks:\n        sector_data[stock] = await real_time_analysis(session, stock)\n\n    sector_prompt = f\"\"\"\n    Analyze the {sector} sector based on the following data from its top stocks:\n    {sector_data}\n\n    Provide insights on:\n    1. Overall sector performance\n    2. Key trends within the sector\n    3. Top performing stocks and why they're outperforming\n    4. Any challenges or opportunities facing the sector\n    \"\"\"\n\n    try:\n        analysis = agent_system.run(sector_prompt)\n        logger.info(f\"Sector analysis completed for {sector}\")\n        return analysis\n    except Exception as e:\n        logger.error(f\"Error during sector analysis for {sector}: {e}\")\n        return f\"Error during sector analysis: {e}\"\n</code></pre> <p>This function analyzes an entire sector by running real-time analysis on its top stocks and then prompting our multi-agent system to provide sector-wide insights.</p>"},{"location":"guides/financial_analysis_swarm_mm/#economic-impact-analysis","title":"Economic Impact Analysis","text":"<pre><code>async def economic_impact_analysis(session, indicator, threshold):\n    # Fetch historical data for the indicator\n    end_date = datetime.now().strftime('%Y-%m-%d')\n    start_date = (datetime.now() - timedelta(days=365)).strftime('%Y-%m-%d')\n    indicator_data = await get_fred_data(session, indicator, start_date, end_date)\n\n    if indicator_data is None or len(indicator_data) &lt; 2:\n        return f\"Insufficient data for indicator {indicator}\"\n\n    # Check if the latest value crosses the threshold\n    latest_value = indicator_data.iloc[-1]\n    previous_value = indicator_data.iloc[-2]\n    crossed_threshold = (latest_value &gt; threshold and previous_value &lt;= threshold) or (latest_value &lt; threshold and previous_value &gt;= threshold)\n\n    if crossed_threshold:\n        impact_prompt = f\"\"\"\n        The economic indicator {indicator} has crossed the threshold of {threshold}. Its current value is {latest_value}.\n\n        Historical data:\n        {indicator_data.tail().to_string()}\n\n        Analyze the potential impacts of this change on:\n        1. Overall economic conditions\n        2. Different market\n        2. Different market sectors\n        3. Specific types of stocks (e.g., growth vs. value)\n        4. Other economic indicators\n\n        Provide a comprehensive analysis of the potential consequences and any recommended actions for investors.\n        \"\"\"\n\n        try:\n            analysis = agent_system.run(impact_prompt)\n            logger.info(f\"Economic impact analysis completed for {indicator}\")\n            return analysis\n        except Exception as e:\n            logger.error(f\"Error during economic impact analysis for {indicator}: {e}\")\n            return f\"Error during economic impact analysis: {e}\"\n    else:\n        return f\"The {indicator} indicator has not crossed the threshold of {threshold}. Current value: {latest_value}\"\n</code></pre> <p>This function analyzes the potential impact of significant changes in economic indicators. It fetches historical data, checks if a threshold has been crossed, and if so, prompts our multi-agent system to provide a comprehensive analysis of the potential consequences.</p>"},{"location":"guides/financial_analysis_swarm_mm/#step-8-running-the-analysis","title":"Step 8: Running the Analysis","text":"<p>Finally, we implement our main function to run all of our analyses:</p> <pre><code>async def main():\n    async with aiohttp.ClientSession() as session:\n        # Example usage\n        analysis_result = await real_time_analysis(session, 'AAPL')\n        print(\"Single Stock Analysis:\")\n        print(analysis_result)\n\n        comparison_result = await compare_stocks(session, ['AAPL', 'GOOGL', 'MSFT'])\n        print(\"\\nStock Comparison:\")\n        print(comparison_result)\n\n        tech_sector_analysis = await sector_analysis(session, 'Technology')\n        print(\"\\nTechnology Sector Analysis:\")\n        print(tech_sector_analysis)\n\n        gdp_impact = await economic_impact_analysis(session, 'GDP', 22000)\n        print(\"\\nEconomic Impact Analysis:\")\n        print(gdp_impact)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>This <code>main</code> function demonstrates how to use all of our analysis functions. It runs a single stock analysis, compares multiple stocks, performs a sector analysis, and conducts an economic impact analysis.</p>"},{"location":"guides/financial_analysis_swarm_mm/#conclusion-and-next-steps","title":"Conclusion and Next Steps","text":"<p>This tutorial has walked you through the process of building a sophisticated multi-agent system for real-time financial analysis using the Swarms framework. Here's a summary of what we've accomplished:</p> <ol> <li>Set up our environment and API connections</li> <li>Implemented rate limiting to respect API constraints</li> <li>Created functions to fetch data from multiple sources (Yahoo Finance, Polygon.io, FRED)</li> <li>Designed specialized AI agents for different aspects of financial analysis</li> <li>Combined these agents into a multi-agent system</li> <li>Implemented advanced analysis functions including stock comparison, sector analysis, and economic impact analysis</li> </ol> <p>This system provides a powerful foundation for financial analysis, but there's always room for expansion and improvement. Here are some potential next steps:</p> <ol> <li> <p>Expand data sources: Consider integrating additional financial data providers for even more comprehensive analysis.</p> </li> <li> <p>Enhance agent specialization: You could create more specialized agents, such as a technical analysis agent or a sentiment analysis agent for social media data.</p> </li> <li> <p>Implement a user interface: Consider building a web interface or dashboard to make the system more user-friendly for non-technical analysts.</p> </li> <li> <p>Add visualization capabilities: Integrate data visualization tools to help interpret complex financial data more easily.</p> </li> <li> <p>Implement a backtesting system: Develop a system to evaluate your multi-agent system's performance on historical data.</p> </li> <li> <p>Explore advanced AI models: The Swarms framework supports various AI models. Experiment with different models to see which performs best for your specific use case.</p> </li> <li> <p>Implement real-time monitoring: Set up a system to continuously monitor markets and alert you to significant changes or opportunities.</p> </li> </ol> <p>Remember, the Swarms framework is a powerful and flexible tool that can be adapted to a wide range of complex tasks beyond just financial analysis. We encourage you to explore the Swarms GitHub repository for more examples and inspiration.</p> <p>For more in-depth discussions and community support, consider joining the Swarms Discord. You can also stay updated with the latest developments by following Swarms on Twitter.</p> <p>If you're interested in learning more about AI and its applications in various fields, check out the Swarms Spotify podcast and the Swarms Blog for insightful articles and discussions.</p> <p>Lastly, don't forget to visit the Swarms Website for a comprehensive overview of the project and its capabilities.</p> <p>By leveraging the power of multi-agent AI systems, you're well-equipped to navigate the complex world of financial markets. Happy analyzing!</p>"},{"location":"guides/financial_analysis_swarm_mm/#swarm-resources","title":"Swarm Resources:","text":"<ul> <li>Swarms Github</li> <li>Swarms Discord</li> <li>Swarms Twitter</li> <li>Swarms Spotify</li> <li>Swarms Blog</li> <li>Swarms Website</li> </ul>"},{"location":"guides/financial_data_api/","title":"Analyzing Financial Data with AI Agents using Swarms Framework","text":"<p>In the rapidly evolving landscape of quantitative finance, the integration of artificial intelligence with financial data analysis has become increasingly crucial. This blog post will explore how to leverage the power of AI agents, specifically using the Swarms framework, to analyze financial data from various top-tier data providers. We'll demonstrate how to connect these agents with different financial APIs, enabling sophisticated analysis and decision-making processes.</p>"},{"location":"guides/financial_data_api/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Swarms Framework</li> <li>Setting Up the Environment</li> <li>Connecting AI Agents with Financial Data Providers</li> <li>Polygon.io</li> <li>Alpha Vantage</li> <li>Yahoo Finance</li> <li>IEX Cloud</li> <li>Finnhub</li> <li>Advanced Analysis Techniques</li> <li>Best Practices and Considerations</li> <li>Conclusion</li> </ol>"},{"location":"guides/financial_data_api/#introduction-to-swarms-framework","title":"Introduction to Swarms Framework","text":"<p>The Swarms framework is a powerful tool for building and deploying AI agents that can interact with various data sources and perform complex analyses. In the context of financial data analysis, Swarms can be used to create intelligent agents that can process large volumes of financial data, identify patterns, and make data-driven decisions. Explore our github for examples, applications, and more.</p>"},{"location":"guides/financial_data_api/#setting-up-the-environment","title":"Setting Up the Environment","text":"<p>Before we dive into connecting AI agents with financial data providers, let's set up our environment:</p> <ol> <li>Install the Swarms framework:</li> </ol> <pre><code>pip install -U swarms\n</code></pre> <ol> <li>Install additional required libraries:</li> </ol> <pre><code>pip install requests pandas numpy matplotlib\n</code></pre> <ol> <li>Set up your API keys for the various financial data providers. It's recommended to use environment variables or a secure configuration file to store these keys.</li> </ol>"},{"location":"guides/financial_data_api/#connecting-ai-agents-with-financial-data-providers","title":"Connecting AI Agents with Financial Data Providers","text":"<p>Now, let's explore how to connect AI agents using the Swarms framework with different financial data providers.</p>"},{"location":"guides/financial_data_api/#polygonio","title":"Polygon.io","text":"<p>First, we'll create an AI agent that can fetch and analyze stock data from Polygon.io.</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport requests\nimport pandas as pd\n\nload_dotenv()\n\n# Polygon.io API setup\nPOLYGON_API_KEY = os.getenv(\"POLYGON_API_KEY\")\nPOLYGON_BASE_URL = \"https://api.polygon.io/v2\"\n\n# OpenAI API setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant. Your task is to analyze stock data and provide insights.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_stock_data(symbol, from_date, to_date):\n    endpoint = f\"{POLYGON_BASE_URL}/aggs/ticker/{symbol}/range/1/day/{from_date}/{to_date}\"\n    params = {\n        'apiKey': POLYGON_API_KEY,\n        'adjusted': 'true'\n    }\n    response = requests.get(endpoint, params=params)\n    data = response.json()\n    return pd.DataFrame(data['results'])\n\n# Example usage\nsymbol = \"AAPL\"\nfrom_date = \"2023-01-01\"\nto_date = \"2023-12-31\"\n\nstock_data = get_stock_data(symbol, from_date, to_date)\n\nanalysis_request = f\"\"\"\nAnalyze the following stock data for {symbol} from {from_date} to {to_date}:\n\n{stock_data.to_string()}\n\nProvide insights on the stock's performance, including trends, volatility, and any notable events.\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>In this example, we've created an AI agent that can fetch stock data from Polygon.io and perform an analysis based on that data. The agent uses the GPT-4 model to generate insights about the stock's performance.</p>"},{"location":"guides/financial_data_api/#alpha-vantage","title":"Alpha Vantage","text":"<p>Next, let's create an agent that can work with Alpha Vantage data to perform fundamental analysis.</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport requests\n\nload_dotenv()\n\n# Alpha Vantage API setup\nALPHA_VANTAGE_API_KEY = os.getenv(\"ALPHA_VANTAGE_API_KEY\")\nALPHA_VANTAGE_BASE_URL = \"https://www.alphavantage.co/query\"\n\n# OpenAI API setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Fundamental-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in fundamental analysis. Your task is to analyze company financials and provide insights.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_income_statement(symbol):\n    params = {\n        'function': 'INCOME_STATEMENT',\n        'symbol': symbol,\n        'apikey': ALPHA_VANTAGE_API_KEY\n    }\n    response = requests.get(ALPHA_VANTAGE_BASE_URL, params=params)\n    return response.json()\n\n# Example usage\nsymbol = \"MSFT\"\n\nincome_statement = get_income_statement(symbol)\n\nanalysis_request = f\"\"\"\nAnalyze the following income statement data for {symbol}:\n\n{income_statement}\n\nProvide insights on the company's financial health, profitability trends, and any notable observations.\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example demonstrates an AI agent that can fetch income statement data from Alpha Vantage and perform a fundamental analysis of a company's financials.</p>"},{"location":"guides/financial_data_api/#yahoo-finance","title":"Yahoo Finance","text":"<p>Now, let's create an agent that can work with Yahoo Finance data to perform technical analysis.</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport yfinance as yf\nimport pandas as pd\n\nload_dotenv()\n\n# OpenAI API setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Technical-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in technical analysis. Your task is to analyze stock price data and provide insights on trends and potential trading signals.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_stock_data(symbol, start_date, end_date):\n    stock = yf.Ticker(symbol)\n    data = stock.history(start=start_date, end=end_date)\n    return data\n\n# Example usage\nsymbol = \"GOOGL\"\nstart_date = \"2023-01-01\"\nend_date = \"2023-12-31\"\n\nstock_data = get_stock_data(symbol, start_date, end_date)\n\n# Calculate some technical indicators\nstock_data['SMA_20'] = stock_data['Close'].rolling(window=20).mean()\nstock_data['SMA_50'] = stock_data['Close'].rolling(window=50).mean()\n\nanalysis_request = f\"\"\"\nAnalyze the following stock price data and technical indicators for {symbol} from {start_date} to {end_date}:\n\n{stock_data.tail(30).to_string()}\n\nProvide insights on the stock's price trends, potential support and resistance levels, and any notable trading signals based on the moving averages.\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example shows an AI agent that can fetch stock price data from Yahoo Finance, calculate some basic technical indicators, and perform a technical analysis.</p>"},{"location":"guides/financial_data_api/#iex-cloud","title":"IEX Cloud","text":"<p>Let's create an agent that can work with IEX Cloud data to analyze company news sentiment.</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport requests\n\nload_dotenv()\n\n# IEX Cloud API setup\nIEX_CLOUD_API_KEY = os.getenv(\"IEX_CLOUD_API_KEY\")\nIEX_CLOUD_BASE_URL = \"https://cloud.iexapis.com/stable\"\n\n# OpenAI API setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"News-Sentiment-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in news sentiment analysis. Your task is to analyze company news and provide insights on the overall sentiment and potential impact on the stock.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_company_news(symbol, last_n):\n    endpoint = f\"{IEX_CLOUD_BASE_URL}/stock/{symbol}/news/last/{last_n}\"\n    params = {'token': IEX_CLOUD_API_KEY}\n    response = requests.get(endpoint, params=params)\n    return response.json()\n\n# Example usage\nsymbol = \"TSLA\"\nlast_n = 10\n\nnews_data = get_company_news(symbol, last_n)\n\nanalysis_request = f\"\"\"\nAnalyze the following recent news articles for {symbol}:\n\n{news_data}\n\nProvide insights on the overall sentiment of the news, potential impact on the stock price, and any notable trends or events mentioned.\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example demonstrates an AI agent that can fetch recent news data from IEX Cloud and perform a sentiment analysis on the company news.</p>"},{"location":"guides/financial_data_api/#finnhub","title":"Finnhub","text":"<p>Finally, let's create an agent that can work with Finnhub data to analyze earnings estimates and recommendations.</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport finnhub\n\nload_dotenv()\n\n# Finnhub API setup\nFINNHUB_API_KEY = os.getenv(\"FINNHUB_API_KEY\")\nfinnhub_client = finnhub.Client(api_key=FINNHUB_API_KEY)\n\n# OpenAI API setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Earnings-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in earnings analysis. Your task is to analyze earnings estimates and recommendations to provide insights on a company's financial outlook.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_earnings_estimates(symbol):\n    return finnhub_client.earnings_calendar(symbol=symbol, from_date=\"2023-01-01\", to_date=\"2023-12-31\")\n\ndef get_recommendations(symbol):\n    return finnhub_client.recommendation_trends(symbol)\n\n# Example usage\nsymbol = \"NVDA\"\n\nearnings_estimates = get_earnings_estimates(symbol)\nrecommendations = get_recommendations(symbol)\n\nanalysis_request = f\"\"\"\nAnalyze the following earnings estimates and recommendations for {symbol}:\n\nEarnings Estimates:\n{earnings_estimates}\n\nRecommendations:\n{recommendations}\n\nProvide insights on the company's expected financial performance, analyst sentiment, and any notable trends in the recommendations.\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example shows an AI agent that can fetch earnings estimates and analyst recommendations from Finnhub and perform an analysis on the company's financial outlook.</p>"},{"location":"guides/financial_data_api/#advanced-analysis-techniques","title":"Advanced Analysis Techniques","text":"<p>To further enhance the capabilities of our AI agents, we can implement more advanced analysis techniques:</p> <ol> <li> <p>Multi-source analysis: Combine data from multiple providers to get a more comprehensive view of a stock or market.</p> </li> <li> <p>Time series forecasting: Implement machine learning models for price prediction.</p> </li> <li> <p>Sentiment analysis of social media: Incorporate data from social media platforms to gauge market sentiment.</p> </li> <li> <p>Portfolio optimization: Use AI agents to suggest optimal portfolio allocations based on risk tolerance and investment goals.</p> </li> <li> <p>Anomaly detection: Implement algorithms to detect unusual patterns or events in financial data.</p> </li> </ol> <p>Here's an example of how we might implement a multi-source analysis:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport yfinance as yf\nimport requests\nimport pandas as pd\n\nload_dotenv()\n\n# API setup\nPOLYGON_API_KEY = os.getenv(\"POLYGON_API_KEY\")\nALPHA_VANTAGE_API_KEY = os.getenv(\"ALPHA_VANTAGE_API_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Multi-Source-Analysis-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant capable of analyzing data from multiple sources. Your task is to provide comprehensive insights on a stock based on various data points.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_stock_data_yf(symbol, start_date, end_date):\n    stock = yf.Ticker(symbol)\n    return stock.history(start=start_date, end=end_date)\n\ndef get_stock_data_polygon(symbol, from_date, to_date):\n    endpoint = f\"https://api.polygon.io/v2/aggs/ticker/{symbol}/range/1/day/{from_date}/{to_date}\"\n    params = {'apiKey': POLYGON_API_KEY, 'adjusted': 'true'}\n    response = requests.get(endpoint, params=params)\n    data = response.json()\n    return pd.DataFrame(data['results'])\n\ndef get_company_overview_av(symbol):\n    params = {\n        'function': 'OVERVIEW',\n        'symbol': symbol,\n        'apikey': ALPHA_VANTAGE_API_KEY\n    }\n    response = requests.get(\"https://www.alphavantage.co/query\", params=params)\n    return response.json()\n\n# Example usage\nsymbol = \"AAPL\"\nstart_date = \"2023-01-01\"\nend_date = \"2023-12-31\"\n\nyf_data = get_stock_data_yf(symbol, start_date, end_date)\npolygon_data = get_stock_data_polygon(symbol, start_date, end_date)\nav_overview = get_company_overview_av(symbol)\n\nanalysis_request = f\"\"\"\nAnalyze the following data for {symbol} from {start_date} to {end_date}:\n\nYahoo Finance Data:\n{yf_data.tail().to_string()}\n\nPolygon.io Data:\n{polygon_data.tail().to_string()}\n\nAlpha Vantage Company Overview:\n{av_overview}\n\nProvide a comprehensive analysis of the stock, including:\n1. Price trends and volatility\n2. Trading volume analysis\n3. Fundamental analysis based on the company overview\n4. Any discrepancies between data sources and potential reasons\n5. Overall outlook and potential risks/opportunities\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This multi-source analysis example combines data from Yahoo Finance, Polygon.io, and Alpha Vantage to provide a more comprehensive view of a stock. The AI agent can then analyze this diverse set of data to provide deeper insights.</p> <p>Now, let's explore some additional advanced analysis techniques:</p>"},{"location":"guides/financial_data_api/#time-series-forecasting","title":"Time Series Forecasting","text":"<p>We can implement a simple time series forecasting model using the Prophet library and integrate it with our AI agent:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport yfinance as yf\nimport pandas as pd\nfrom prophet import Prophet\nimport matplotlib.pyplot as plt\n\nload_dotenv()\n\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\nagent = Agent(\n    agent_name=\"Time-Series-Forecast-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in time series forecasting. Your task is to analyze stock price predictions and provide insights.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_stock_data(symbol, start_date, end_date):\n    stock = yf.Ticker(symbol)\n    data = stock.history(start=start_date, end=end_date)\n    return data\n\ndef forecast_stock_price(data, periods=30):\n    df = data.reset_index()[['Date', 'Close']]\n    df.columns = ['ds', 'y']\n\n    model = Prophet()\n    model.fit(df)\n\n    future = model.make_future_dataframe(periods=periods)\n    forecast = model.predict(future)\n\n    fig = model.plot(forecast)\n    plt.savefig('forecast_plot.png')\n    plt.close()\n\n    return forecast\n\n# Example usage\nsymbol = \"MSFT\"\nstart_date = \"2020-01-01\"\nend_date = \"2023-12-31\"\n\nstock_data = get_stock_data(symbol, start_date, end_date)\nforecast = forecast_stock_price(stock_data)\n\nanalysis_request = f\"\"\"\nAnalyze the following time series forecast for {symbol}:\n\nForecast Data:\n{forecast.tail(30).to_string()}\n\nThe forecast plot has been saved as 'forecast_plot.png'.\n\nProvide insights on:\n1. The predicted trend for the stock price\n2. Any seasonal patterns observed\n3. Potential factors that might influence the forecast\n4. Limitations of this forecasting method\n5. Recommendations for investors based on this forecast\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example demonstrates how to integrate a time series forecasting model (Prophet) with our AI agent. The agent can then provide insights based on the forecasted data.</p>"},{"location":"guides/financial_data_api/#sentiment-analysis-of-social-media","title":"Sentiment Analysis of Social Media","text":"<p>We can use a pre-trained sentiment analysis model to analyze tweets about a company and integrate this with our AI agent:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport tweepy\nfrom textblob import TextBlob\nimport pandas as pd\n\nload_dotenv()\n\n# Twitter API setup\nTWITTER_API_KEY = os.getenv(\"TWITTER_API_KEY\")\nTWITTER_API_SECRET = os.getenv(\"TWITTER_API_SECRET\")\nTWITTER_ACCESS_TOKEN = os.getenv(\"TWITTER_ACCESS_TOKEN\")\nTWITTER_ACCESS_TOKEN_SECRET = os.getenv(\"TWITTER_ACCESS_TOKEN_SECRET\")\n\nauth = tweepy.OAuthHandler(TWITTER_API_KEY, TWITTER_API_SECRET)\nauth.set_access_token(TWITTER_ACCESS_TOKEN, TWITTER_ACCESS_TOKEN_SECRET)\napi = tweepy.API(auth)\n\n# OpenAI setup\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\nagent = Agent(\n    agent_name=\"Social-Media-Sentiment-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in social media sentiment analysis. Your task is to analyze sentiment data from tweets and provide insights on market perception.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_tweets(query, count=100):\n    tweets = api.search_tweets(q=query, count=count, tweet_mode=\"extended\")\n    return [tweet.full_text for tweet in tweets]\n\ndef analyze_sentiment(tweets):\n    sentiments = [TextBlob(tweet).sentiment.polarity for tweet in tweets]\n    return pd.DataFrame({'tweet': tweets, 'sentiment': sentiments})\n\n# Example usage\nsymbol = \"TSLA\"\nquery = f\"${symbol} stock\"\n\ntweets = get_tweets(query)\nsentiment_data = analyze_sentiment(tweets)\n\nanalysis_request = f\"\"\"\nAnalyze the following sentiment data for tweets about {symbol} stock:\n\nSentiment Summary:\nPositive tweets: {sum(sentiment_data['sentiment'] &gt; 0)}\nNegative tweets: {sum(sentiment_data['sentiment'] &lt; 0)}\nNeutral tweets: {sum(sentiment_data['sentiment'] == 0)}\n\nAverage sentiment: {sentiment_data['sentiment'].mean()}\n\nSample tweets and their sentiments:\n{sentiment_data.head(10).to_string()}\n\nProvide insights on:\n1. The overall sentiment towards the stock\n2. Any notable trends or patterns in the sentiment\n3. Potential reasons for the observed sentiment\n4. How this sentiment might impact the stock price\n5. Limitations of this sentiment analysis method\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example shows how to perform sentiment analysis on tweets about a stock and integrate the results with our AI agent for further analysis.</p>"},{"location":"guides/financial_data_api/#portfolio-optimization","title":"Portfolio Optimization","text":"<p>We can use the PyPortfolioOpt library to perform portfolio optimization and have our AI agent provide insights:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.models import OpenAIChat\nfrom dotenv import load_dotenv\nimport yfinance as yf\nimport pandas as pd\nimport numpy as np\nfrom pypfopt import EfficientFrontier\nfrom pypfopt import risk_models\nfrom pypfopt import expected_returns\n\nload_dotenv()\n\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nmodel = OpenAIChat(\n    openai_api_key=OPENAI_API_KEY,\n    model_name=\"gpt-4\",\n    temperature=0.1\n)\n\nagent = Agent(\n    agent_name=\"Portfolio-Optimization-Agent\",\n    system_prompt=\"You are a financial analysis AI assistant specializing in portfolio optimization. Your task is to analyze optimized portfolio allocations and provide investment advice.\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    verbose=True\n)\n\ndef get_stock_data(symbols, start_date, end_date):\n    data = yf.download(symbols, start=start_date, end=end_date)['Adj Close']\n    return data\n\ndef optimize_portfolio(data):\n    mu = expected_returns.mean_historical_return(data)\n    S = risk_models.sample_cov(data)\n\n    ef = EfficientFrontier(mu, S)\n    weights = ef.max_sharpe()\n    cleaned_weights = ef.clean_weights()\n\n    return cleaned_weights\n\n# Example usage\nsymbols = [\"AAPL\", \"GOOGL\", \"MSFT\", \"AMZN\", \"FB\"]\nstart_date = \"2018-01-01\"\nend_date = \"2023-12-31\"\n\nstock_data = get_stock_data(symbols, start_date, end_date)\noptimized_weights = optimize_portfolio(stock_data)\n\nanalysis_request = f\"\"\"\nAnalyze the following optimized portfolio allocation:\n\n{pd.Series(optimized_weights).to_string()}\n\nThe optimization aimed to maximize the Sharpe ratio based on historical data from {start_date} to {end_date}.\n\nProvide insights on:\n1. The recommended allocation and its potential benefits\n2. Any notable concentrations or diversification in the portfolio\n3. Potential risks associated with this allocation\n4. How this portfolio might perform in different market conditions\n5. Recommendations for an investor considering this allocation\n6. Limitations of this optimization method\n\"\"\"\n\nanalysis = agent.run(analysis_request)\nprint(analysis)\n</code></pre> <p>This example demonstrates how to perform portfolio optimization using the PyPortfolioOpt library and have our AI agent provide insights on the optimized allocation.</p>"},{"location":"guides/financial_data_api/#best-practices-and-considerations","title":"Best Practices and Considerations","text":"<p>When using AI agents for financial data analysis, consider the following best practices:</p> <ol> <li> <p>Data quality: Ensure that the data you're feeding into the agents is accurate and up-to-date.</p> </li> <li> <p>Model limitations: Be aware of the limitations of both the financial models and the AI models being used.</p> </li> <li> <p>Regulatory compliance: Ensure that your use of AI in financial analysis complies with relevant regulations.</p> </li> <li> <p>Ethical considerations: Be mindful of potential biases in AI models and strive for fair and ethical analysis.</p> </li> <li> <p>Continuous monitoring: Regularly evaluate the performance of your AI agents and update them as needed.</p> </li> <li> <p>Human oversight: While AI agents can provide valuable insights, human judgment should always play a role in financial decision-making.</p> </li> <li> <p>Privacy and security: Implement robust security measures to protect sensitive financial data.</p> </li> </ol>"},{"location":"guides/financial_data_api/#conclusion","title":"Conclusion","text":"<p>The integration of AI agents with financial data APIs opens up exciting possibilities for advanced financial analysis. By leveraging the power of the Swarms framework and connecting it with various financial data providers, analysts and quants can gain deeper insights, automate complex analyses, and potentially make more informed investment decisions.</p> <p>However, it's crucial to remember that while AI agents can process vast amounts of data and identify patterns that humans might miss, they should be used as tools to augment human decision-making rather than replace it entirely. The financial markets are complex systems influenced by numerous factors, many of which may not be captured in historical data or current models.</p> <p>As the field of AI in finance continues to evolve, we can expect even more sophisticated analysis techniques and integrations. Staying updated with the latest developments in both AI and financial analysis will be key to leveraging these powerful tools effectively.</p>"},{"location":"guides/healthcare_blog/","title":"Unlocking Efficiency and Cost Savings in Healthcare: How Swarms of LLM Agents Can Revolutionize Medical Operations and Save Millions","text":"<p>The healthcare industry is a complex ecosystem where time and money are critical. From administrative tasks to patient care, medical professionals often struggle to keep up with mounting demands, leading to inefficiencies that cost both time and money. Swarms of Large Language Model (LLM) agents represent a groundbreaking solution to these problems. By leveraging artificial intelligence in the form of swarms, healthcare organizations can automate various tasks, optimize processes, and dramatically improve both the quality of care and operational efficiency.</p> <p>In this comprehensive analysis, we will explore how swarms of LLM agents can help healthcare and medical organizations save millions of dollars and thousands of hours annually. We will provide precise estimations based on industry data, calculate potential savings, and outline various use cases. Additionally, mermaid diagrams will be provided to illustrate swarm architectures, and reference links to Swarms GitHub and other resources will be included.</p>"},{"location":"guides/healthcare_blog/#1-administrative-automation","title":"1. Administrative Automation","text":""},{"location":"guides/healthcare_blog/#use-case-billing-and-claims-processing","title":"Use Case: Billing and Claims Processing","text":"<p>Administrative work is a major time drain in the healthcare sector, especially when it comes to billing and claims processing. The process is traditionally labor-intensive, requiring human staff to manually review and process claims, which often results in errors, delays, and higher operational costs.</p> <p>How Swarms of LLM Agents Can Help: Swarms of LLM agents can automate the entire billing and claims process, from coding procedures to filing claims with insurance companies. These agents can read medical records, understand the diagnosis codes (ICD-10), and automatically generate billing forms. With intelligent claims management, LLM agents can also follow up with insurance companies to ensure timely payment.</p> <p>Estimated Savings:</p> <ul> <li> <p>Average cost per manual claim: $25</p> </li> <li> <p>Average claims per hospital: 10,000 per month</p> </li> <li> <p>Swarms of LLM agents can reduce processing time by 90% and errors by 95%</p> </li> <li> <p>Estimated annual savings per hospital: </p> <ul> <li> <p>Savings per claim: $22.5 (90% reduction)</p> </li> <li> <p>Total annual savings: 10,000 claims/month \u00d7 12 months \u00d7 \\(22.5 = **\\)2.7 million**</p> </li> </ul> </li> </ul>"},{"location":"guides/healthcare_blog/#billing-and-claims-processing-swarm","title":"Billing and Claims Processing Swarm","text":"<pre><code>graph TD;\n    A[Medical Records] --&gt; B[ICD-10 Coding Agent];\n    B --&gt; C[Billing Form Agent];\n    C --&gt; D[Claims Submission Agent];\n    D --&gt; E[Insurance Follow-up Agent];\n    E --&gt; F[Payment Processing];</code></pre>"},{"location":"guides/healthcare_blog/#2-enhancing-clinical-decision-support","title":"2. Enhancing Clinical Decision Support","text":""},{"location":"guides/healthcare_blog/#use-case-diagnostic-assistance","title":"Use Case: Diagnostic Assistance","text":"<p>Doctors are increasingly turning to AI to assist in diagnosing complex medical conditions. Swarms of LLM agents can be trained to analyze patient data, laboratory results, and medical histories to assist doctors in making more accurate diagnoses.</p> <p>How Swarms of LLM Agents Can Help: A swarm of LLM agents can scan through thousands of medical records, journals, and patient histories to identify patterns or suggest rare diagnoses. These agents work collaboratively to analyze test results, compare symptoms with a vast medical knowledge base, and provide doctors with a list of probable diagnoses and recommended tests.</p> <p>Estimated Savings:</p> <ul> <li> <p>Time saved per diagnosis: 2 hours per patient</p> </li> <li> <p>Average patient cases per hospital: 5,000 per year</p> </li> <li> <p>Time saved annually: 2 \u00d7 5,000 = 10,000 hours</p> </li> <li> <p>Doctor's hourly rate: $150</p> </li> <li> <p>Total annual savings: 10,000 \u00d7 \\(150 = **\\)1.5 million**</p> </li> </ul>"},{"location":"guides/healthcare_blog/#diagnostic-swarm","title":"Diagnostic Swarm","text":"<pre><code>graph TD;\n    A[Patient Data] --&gt; B[Lab Results];\n    A --&gt; C[Medical History];\n    B --&gt; D[Symptom Analysis Agent];\n    C --&gt; E[Pattern Recognition Agent];\n    D --&gt; F[Diagnosis Suggestion Agent];\n    E --&gt; F;\n    F --&gt; G[Doctor];</code></pre>"},{"location":"guides/healthcare_blog/#3-streamlining-patient-communication","title":"3. Streamlining Patient Communication","text":""},{"location":"guides/healthcare_blog/#use-case-patient-follow-ups-and-reminders","title":"Use Case: Patient Follow-ups and Reminders","text":"<p>Timely communication with patients is critical for maintaining healthcare quality, but it can be extremely time-consuming for administrative staff. Missed appointments and delayed follow-ups lead to poor patient outcomes and lost revenue.</p> <p>How Swarms of LLM Agents Can Help: LLM agents can handle patient follow-ups by sending reminders for appointments, check-ups, and medication refills. Additionally, these agents can answer common patient queries, thereby reducing the workload for human staff. These agents can be connected to Electronic Health Record (EHR) systems to monitor patient data and trigger reminders based on predefined criteria.</p> <p>Estimated Savings:</p> <ul> <li> <p>Average cost per patient follow-up: $5</p> </li> <li> <p>Number of follow-ups: 20,000 annually per hospital</p> </li> <li> <p>Swarm efficiency: 90% reduction in manual effort</p> </li> <li> <p>Total annual savings: 20,000 \u00d7 \\(4.5 = **\\)90,000**</p> </li> </ul>"},{"location":"guides/healthcare_blog/#patient-follow-up-swarm","title":"Patient Follow-up Swarm","text":"<pre><code>graph TD;\n    A[Patient Data from EHR] --&gt; B[Appointment Reminder Agent];\n    A --&gt; C[Medication Reminder Agent];\n    B --&gt; D[Automated Text/Email];\n    C --&gt; D;\n    D --&gt; E[Patient];</code></pre>"},{"location":"guides/healthcare_blog/#4-optimizing-inventory-management","title":"4. Optimizing Inventory Management","text":""},{"location":"guides/healthcare_blog/#use-case-pharmaceutical-stock-management","title":"Use Case: Pharmaceutical Stock Management","text":"<p>Hospitals often struggle with managing pharmaceutical inventory efficiently. Overstocking leads to wasted resources, while understocking can be a critical problem for patient care.</p> <p>How Swarms of LLM Agents Can Help: A swarm of LLM agents can predict pharmaceutical needs by analyzing patient data, historical inventory usage, and supplier delivery times. These agents can dynamically adjust stock levels, automatically place orders, and ensure that hospitals have the right medications at the right time.</p> <p>Estimated Savings:</p> <ul> <li> <p>Annual waste due to overstocking: $500,000 per hospital</p> </li> <li> <p>Swarm efficiency: 80% reduction in overstocking</p> </li> <li> <p>Total annual savings: \\(500,000 \u00d7 0.8 = **\\)400,000**</p> </li> </ul>"},{"location":"guides/healthcare_blog/#inventory-management-swarm","title":"Inventory Management Swarm","text":"<pre><code>graph TD;\n    A[Patient Admission Data] --&gt; B[Inventory Prediction Agent];\n    B --&gt; C[Stock Adjustment Agent];\n    C --&gt; D[Supplier Ordering Agent];\n    D --&gt; E[Pharmacy];</code></pre>"},{"location":"guides/healthcare_blog/#5-improving-clinical-research","title":"5. Improving Clinical Research","text":""},{"location":"guides/healthcare_blog/#use-case-literature-review-and-data-analysis","title":"Use Case: Literature Review and Data Analysis","text":"<p>Medical researchers spend a significant amount of time reviewing literature and analyzing clinical trial data. Swarms of LLM agents can assist by rapidly scanning through research papers, extracting relevant information, and even suggesting areas for further investigation.</p> <p>How Swarms of LLM Agents Can Help: These agents can be trained to perform literature reviews, extract relevant data, and cross-reference findings with ongoing clinical trials. LLM agents can also simulate clinical trial results by analyzing historical data, offering valuable insights before actual trials commence.</p> <p>Estimated Savings:</p> <ul> <li> <p>Average time spent on literature review per paper: 5 hours</p> </li> <li> <p>Number of papers reviewed annually: 1,000</p> </li> <li> <p>Time saved: 80% reduction in review time</p> </li> <li> <p>Total time saved: 1,000 \u00d7 5 \u00d7 0.8 = 4,000 hours</p> </li> <li> <p>Researcher's hourly rate: $100</p> </li> <li> <p>Total annual savings: 4,000 \u00d7 \\(100 = **\\)400,000**</p> </li> </ul>"},{"location":"guides/healthcare_blog/#clinical-research-swarm","title":"Clinical Research Swarm","text":"<pre><code>graph TD;\n    A[Research Papers] --&gt; B[Data Extraction Agent];\n    B --&gt; C[Cross-reference Agent];\n    C --&gt; D[Simulation Agent];\n    D --&gt; E[Researcher];</code></pre>"},{"location":"guides/healthcare_blog/#6-automating-medical-record-keeping","title":"6. Automating Medical Record Keeping","text":""},{"location":"guides/healthcare_blog/#use-case-ehr-management-and-documentation","title":"Use Case: EHR Management and Documentation","text":"<p>Healthcare providers spend a significant amount of time inputting and managing Electronic Health Records (EHR). Manual entry often results in errors and takes away from the time spent with patients.</p> <p>How Swarms of LLM Agents Can Help: Swarms of LLM agents can automate the documentation process by transcribing doctor-patient interactions, updating EHRs in real-time, and even detecting errors in the documentation. These agents can integrate with voice recognition systems to create seamless workflows, freeing up more time for healthcare providers to focus on patient care.</p> <p>Estimated Savings:</p> <ul> <li> <p>Average time spent on EHR per patient: 20 minutes</p> </li> <li> <p>Number of patients annually: 30,000</p> </li> <li> <p>Time saved: 80% reduction in manual effort</p> </li> <li> <p>Total time saved: 30,000 \u00d7 20 minutes \u00d7 0.8 = 480,000 minutes or 8,000 hours</p> </li> <li> <p>Provider's hourly rate: $150</p> </li> <li> <p>Total annual savings: 8,000 \u00d7 \\(150 = **\\)1.2 million**</p> </li> </ul>"},{"location":"guides/healthcare_blog/#ehr-management-swarm","title":"EHR Management Swarm","text":"<pre><code>graph TD;\n    A[Doctor-Patient Interaction] --&gt; B[Voice-to-Text Agent];\n    B --&gt; C[EHR Update Agent];\n    C --&gt; D[Error Detection Agent];\n    D --&gt; E[EHR System];</code></pre>"},{"location":"guides/healthcare_blog/#7-reducing-diagnostic-errors","title":"7. Reducing Diagnostic Errors","text":""},{"location":"guides/healthcare_blog/#use-case-medical-imaging-analysis","title":"Use Case: Medical Imaging Analysis","text":"<p>Medical imaging, such as MRI and CT scans, requires expert interpretation, which can be both time-consuming and prone to errors. Misdiagnoses or delays in interpretation can lead to prolonged treatment times and increased costs.</p> <p>How Swarms of LLM Agents Can Help: Swarms of LLM agents trained in computer vision can analyze medical images more accurately and faster than human radiologists. These agents can compare current scans with historical data, detect anomalies, and provide a diagnosis within minutes. Additionally, the swarm can escalate complex cases to human experts when necessary.</p> <p>Estimated Savings:</p> <ul> <li> <p>Time saved per scan: 30 minutes</p> </li> <li> <p>Number of scans annually: 10,000</p> </li> <li> <p>Time saved: 10,000 \u00d7 30 minutes = 5,000 hours</p> </li> <li> <p>Radiologist's hourly rate: $200</p> </li> <li> <p>Total annual savings: 5,000 \u00d7 $</p> </li> </ul> <p>200 = $1 million</p>"},{"location":"guides/healthcare_blog/#medical-imaging-swarm","title":"Medical Imaging Swarm","text":"<pre><code>graph TD;\n    A[Medical Image] --&gt; B[Anomaly Detection Agent];\n    B --&gt; C[Comparison with Historical Data Agent];\n    C --&gt; D[Diagnosis Suggestion Agent];\n    D --&gt; E[Radiologist Review];</code></pre>"},{"location":"guides/healthcare_blog/#conclusion-the-financial-and-time-saving-impact-of-llm-swarms-in-healthcare","title":"Conclusion: The Financial and Time-Saving Impact of LLM Swarms in Healthcare","text":"<p>In this comprehensive analysis, we explored how swarms of LLM agents can revolutionize the healthcare and medical industries by automating complex, labor-intensive tasks that currently drain both time and resources. From billing and claims processing to diagnostic assistance, patient communication, and medical imaging analysis, these intelligent agents can work collaboratively to significantly improve efficiency while reducing costs. Through our detailed calculations, it is evident that healthcare organizations could save upwards of $7.29 million annually, along with thousands of hours in administrative and clinical work.</p> <p>Swarms of LLM agents not only promise financial savings but also lead to improved patient outcomes, streamlined research, and enhanced operational workflows. By adopting these agentic solutions, healthcare organizations can focus more on their mission of providing high-quality care while ensuring their systems run seamlessly and efficiently.</p> <p>To explore more about how swarms of agents can be tailored to your healthcare operations, you can visit the Swarms GitHub for code and documentation, explore our Swarms Website for further insights, and if you're ready to implement these solutions in your organization, feel free to book a call for a personalized consultation.</p> <p>The future of healthcare is agentic, and by embracing swarms of LLM agents, your organization can unlock unprecedented levels of productivity and savings.</p> <p>Swarms of LLM agents offer a powerful solution for medical and healthcare organizations looking to reduce costs and save time. Through automation, these agents can optimize everything from administrative tasks to clinical decision-making and inventory management. Based on the estimates provided, healthcare organizations can potentially save millions of dollars annually, all while improving the quality of care provided to patients.</p> <p>The table below summarizes the estimated savings for each use case:</p> Use Case Estimated Annual Savings Billing and Claims Processing $2.7 million Diagnostic Assistance $1.5 million Patient Follow-ups and Reminders $90,000 Pharmaceutical Stock Management $400,000 Clinical Research $400,000 EHR Management and Documentation $1.2 million Medical Imaging Analysis $1 million Total Estimated Savings $7.29 million"},{"location":"guides/healthcare_blog/#references","title":"References","text":"<ul> <li> <p>Swarms GitHub</p> </li> <li> <p>Swarms Website</p> </li> <li> <p>book a call </p> </li> <li> <p>Swarms Discord: https://discord.gg/jM3Z6M9uMq</p> </li> <li> <p>Swarms Twitter: https://x.com/swarms_corp</p> </li> <li> <p>Swarms Spotify: https://open.spotify.com/show/2HLiswhmUaMdjHC8AUHcCF?si=c831ef10c5ef4994</p> </li> </ul> <p>Swarms Blog: https://medium.com/@kyeg Swarms Website: https://swarms.xyz </p> <p>By adopting swarms of LLM agents, healthcare organizations can streamline operations, reduce inefficiencies, and focus on what truly matters\u2014delivering top-notch patient care.</p>"},{"location":"guides/pricing/","title":"Comparing LLM Provider Pricing: A Guide for Enterprises","text":"<p>Large language models (LLMs) have become a cornerstone of innovation for enterprises across various industries. </p> <p>As executives contemplate which model to integrate into their operations, understanding the intricacies of LLM provider pricing is crucial. </p> <p>This comprehensive guide delves into the tactical business considerations, unit economics, profit margins, and ROI calculations that will empower decision-makers to deploy the right AI solution for their organization.</p>"},{"location":"guides/pricing/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to LLM Pricing Models</li> <li>Understanding Unit Economics in LLM Deployment</li> <li>Profit Margins and Cost Structures</li> <li>LLM Pricing in Action: Case Studies</li> <li>Calculating ROI for LLM Integration</li> <li>Comparative Analysis of Major LLM Providers</li> <li>Hidden Costs and Considerations</li> <li>Optimizing LLM Usage for Cost-Efficiency</li> <li>Future Trends in LLM Pricing</li> <li>Strategic Decision-Making Framework</li> <li>Conclusion: Navigating the LLM Pricing Landscape</li> </ol>"},{"location":"guides/pricing/#1-introduction-to-llm-pricing-models","title":"1. Introduction to LLM Pricing Models","text":"<p>The pricing of Large Language Models (LLMs) is a complex landscape that can significantly impact an enterprise's bottom line. As we dive into this topic, it's crucial to understand the various pricing models employed by LLM providers and how they align with different business needs.</p>"},{"location":"guides/pricing/#pay-per-token-model","title":"Pay-per-Token Model","text":"<p>The most common pricing structure in the LLM market is the pay-per-token model. In this system, businesses are charged based on the number of tokens processed by the model. A token can be as short as one character or as long as one word, depending on the language and the specific tokenization method used by the model.</p> <p>Advantages: - Scalability: Costs scale directly with usage, allowing for flexibility as demand fluctuates. - Transparency: Easy to track and attribute costs to specific projects or departments.</p> <p>Disadvantages: - Unpredictability: Costs can vary significantly based on the verbosity of inputs and outputs. - Potential for overruns: Without proper monitoring, costs can quickly escalate.</p>"},{"location":"guides/pricing/#subscription-based-models","title":"Subscription-Based Models","text":"<p>Some providers offer subscription tiers that provide a set amount of compute resources or tokens for a fixed monthly or annual fee.</p> <p>Advantages: - Predictable costs: Easier budgeting and financial planning. - Potential cost savings: Can be more economical for consistent, high-volume usage.</p> <p>Disadvantages: - Less flexibility: May lead to underutilization or overages. - Commitment required: Often involves longer-term contracts.</p>"},{"location":"guides/pricing/#custom-enterprise-agreements","title":"Custom Enterprise Agreements","text":"<p>For large-scale deployments, providers may offer custom pricing agreements tailored to the specific needs of an enterprise.</p> <p>Advantages: - Optimized for specific use cases: Can include specialized support, SLAs, and pricing structures. - Potential for significant cost savings at scale.</p> <p>Disadvantages: - Complexity: Negotiating and managing these agreements can be resource-intensive. - Less standardization: Difficult to compare across providers.</p>"},{"location":"guides/pricing/#hybrid-models","title":"Hybrid Models","text":"<p>Some providers are beginning to offer hybrid models that combine elements of pay-per-token and subscription-based pricing.</p> <p>Advantages: - Flexibility: Can adapt to varying usage patterns. - Risk mitigation: Balances the benefits of both main pricing models.</p> <p>Disadvantages: - Complexity: Can be more challenging to understand and manage. - Potential for suboptimal pricing if not carefully structured.</p> <p>As we progress through this guide, we'll explore how these pricing models interact with various business considerations and how executives can leverage this understanding to make informed decisions.</p>"},{"location":"guides/pricing/#2-understanding-unit-economics-in-llm-deployment","title":"2. Understanding Unit Economics in LLM Deployment","text":"<p>To make informed decisions about LLM deployment, executives must have a clear grasp of the unit economics involved. This section breaks down the components that contribute to the cost per unit of LLM usage and how they impact overall business economics.</p>"},{"location":"guides/pricing/#defining-the-unit","title":"Defining the Unit","text":"<p>In the context of LLMs, a \"unit\" can be defined in several ways:</p> <ol> <li>Per Token: The most granular unit, often used in pricing models.</li> <li>Per Request: A single API call to the LLM, which may process multiple tokens.</li> <li>Per Task: A complete operation, such as generating a summary or answering a question, which may involve multiple requests.</li> <li>Per User Interaction: In customer-facing applications, this could be an entire conversation or session.</li> </ol> <p>Understanding which unit is most relevant to your use case is crucial for accurate economic analysis.</p>"},{"location":"guides/pricing/#components-of-unit-cost","title":"Components of Unit Cost","text":"<ol> <li>Direct LLM Costs</li> <li>Token processing fees</li> <li>API call charges</li> <li> <p>Data transfer costs</p> </li> <li> <p>Indirect Costs</p> </li> <li>Compute resources for pre/post-processing</li> <li>Storage for inputs, outputs, and fine-tuning data</li> <li> <p>Networking costs</p> </li> <li> <p>Operational Costs</p> </li> <li>Monitoring and management tools</li> <li>Integration and maintenance engineering time</li> <li> <p>Customer support related to AI functions</p> </li> <li> <p>Overhead</p> </li> <li>Legal and compliance costs</li> <li>Training and documentation</li> <li>Risk management and insurance</li> </ol>"},{"location":"guides/pricing/#calculating-unit-economics","title":"Calculating Unit Economics","text":"<p>To calculate the true unit economics, follow these steps:</p> <ol> <li> <p>Determine Total Costs: Sum all direct, indirect, operational, and overhead costs over a fixed period (e.g., monthly).</p> </li> <li> <p>Measure Total Units: Track the total number of relevant units processed in the same period.</p> </li> <li> <p>Calculate Cost per Unit: Divide total costs by total units.</p> </li> </ol> <pre><code>Cost per Unit = Total Costs / Total Units\n</code></pre> <ol> <li> <p>Analyze Revenue per Unit: If the LLM is part of a revenue-generating product, calculate the revenue attributed to each unit.</p> </li> <li> <p>Determine Profit per Unit: Subtract the cost per unit from the revenue per unit.</p> </li> </ol> <pre><code>Profit per Unit = Revenue per Unit - Cost per Unit\n</code></pre>"},{"location":"guides/pricing/#example-calculation","title":"Example Calculation","text":"<p>Let's consider a hypothetical customer service AI chatbot:</p> <ul> <li>Monthly LLM API costs: $10,000</li> <li>Indirect and operational costs: $5,000</li> <li>Total monthly interactions: 100,000</li> </ul> <pre><code>Cost per Interaction = ($10,000 + $5,000) / 100,000 = $0.15\n</code></pre> <p>If each interaction generates an average of $0.50 in value (through cost savings or revenue):</p> <pre><code>Profit per Interaction = $0.50 - $0.15 = $0.35\n</code></pre>"},{"location":"guides/pricing/#economies-of-scale","title":"Economies of Scale","text":"<p>As usage increases, unit economics often improve due to:</p> <ul> <li>Volume discounts from LLM providers</li> <li>Amortization of fixed costs over more units</li> <li>Efficiency gains through learning and optimization</li> </ul> <p>However, it's crucial to model how these economies of scale manifest in your specific use case, as they may plateau or even reverse at very high volumes due to increased complexity and support needs.</p>"},{"location":"guides/pricing/#diseconomies-of-scale","title":"Diseconomies of Scale","text":"<p>Conversely, be aware of potential diseconomies of scale:</p> <ul> <li>Increased complexity in managing large-scale deployments</li> <li>Higher costs for specialized talent as operations grow</li> <li>Potential for diminishing returns on very large language models</li> </ul> <p>By thoroughly understanding these unit economics, executives can make more informed decisions about which LLM provider and pricing model best aligns with their business objectives and scale.</p>"},{"location":"guides/pricing/#3-profit-margins-and-cost-structures","title":"3. Profit Margins and Cost Structures","text":"<p>Understanding profit margins and cost structures is crucial for executives evaluating LLM integration. This section explores how different pricing models and operational strategies can impact overall profitability.</p>"},{"location":"guides/pricing/#components-of-profit-margin","title":"Components of Profit Margin","text":"<ol> <li> <p>Gross Margin: The difference between revenue and the direct costs of LLM usage.    <pre><code>Gross Margin = Revenue - Direct LLM Costs\nGross Margin % = (Gross Margin / Revenue) * 100\n</code></pre></p> </li> <li> <p>Contribution Margin: Gross margin minus variable operational costs.    <pre><code>Contribution Margin = Gross Margin - Variable Operational Costs\n</code></pre></p> </li> <li> <p>Net Margin: The final profit after all costs, including fixed overheads.    <pre><code>Net Margin = Contribution Margin - Fixed Costs\nNet Margin % = (Net Margin / Revenue) * 100\n</code></pre></p> </li> </ol>"},{"location":"guides/pricing/#cost-structures-in-llm-deployment","title":"Cost Structures in LLM Deployment","text":"<ol> <li>Fixed Costs</li> <li>Subscription fees for LLM access (if using a subscription model)</li> <li>Base infrastructure costs</li> <li>Core team salaries</li> <li> <p>Licensing fees for essential software</p> </li> <li> <p>Variable Costs</p> </li> <li>Per-token or per-request charges</li> <li>Scaling infrastructure costs</li> <li>Usage-based API fees</li> <li> <p>Performance-based team bonuses</p> </li> <li> <p>Step Costs</p> </li> <li>Costs that increase in chunks as usage scales</li> <li>Examples: Adding new server clusters, hiring additional support staff</li> </ol>"},{"location":"guides/pricing/#analyzing-profit-margins-across-different-pricing-models","title":"Analyzing Profit Margins Across Different Pricing Models","text":"<p>Let's compare how different LLM pricing models might affect profit margins for a hypothetical AI-powered writing assistant service:</p> <p>Scenario: The service charges users $20/month and expects to process an average of 100,000 tokens per user per month.</p> <ol> <li>Pay-per-Token Model</li> <li>LLM cost: $0.06 per 1,000 tokens</li> <li>Monthly LLM cost per user: $6</li> <li> <p>Gross margin per user: $14 (70%)</p> </li> <li> <p>Subscription Model</p> </li> <li>Fixed monthly fee: $5,000 for up to 10 million tokens</li> <li>At 1,000 users: $5 per user</li> <li> <p>Gross margin per user: $15 (75%)</p> </li> <li> <p>Hybrid Model</p> </li> <li>Base fee: $2,000 per month</li> <li>Reduced per-token rate: $0.04 per 1,000 tokens</li> <li>Monthly LLM cost per user: \\(6 (\\)2 base + $4 usage)</li> <li>Gross margin per user: $14 (70%)</li> </ol>"},{"location":"guides/pricing/#strategies-for-improving-profit-margins","title":"Strategies for Improving Profit Margins","text":"<ol> <li>Optimize Token Usage</li> <li>Implement efficient prompting techniques</li> <li>Cache common responses</li> <li> <p>Use compression algorithms for inputs and outputs</p> </li> <li> <p>Leverage Economies of Scale</p> </li> <li>Negotiate better rates at higher volumes</li> <li> <p>Spread fixed costs across a larger user base</p> </li> <li> <p>Implement Tiered Pricing</p> </li> <li>Offer different service levels to capture more value from power users</li> <li> <p>Example: Basic (\\(10/month, 50K tokens), Pro (\\)30/month, 200K tokens)</p> </li> <li> <p>Vertical Integration</p> </li> <li>Invest in proprietary LLM development for core functionalities</li> <li> <p>Reduce dependency on third-party providers for critical operations</p> </li> <li> <p>Smart Caching and Pre-computation</p> </li> <li>Store and reuse common LLM outputs</li> <li> <p>Perform batch processing during off-peak hours</p> </li> <li> <p>Hybrid Cloud Strategies</p> </li> <li>Use on-premises solutions for consistent workloads</li> <li>Leverage cloud elasticity for demand spikes</li> </ol>"},{"location":"guides/pricing/#case-study-margin-improvement","title":"Case Study: Margin Improvement","text":"<p>Consider a company that initially used a pay-per-token model:</p> <p>Initial State: - Revenue per user: $20 - LLM cost per user: $6 - Other variable costs: $4 - Fixed costs per user: $5 - Net margin per user: $5 (25%)</p> <p>After Optimization: - Implemented efficient prompting: Reduced token usage by 20% - Negotiated volume discount: 10% reduction in per-token price - Introduced tiered pricing: Average revenue per user increased to $25 - Optimized operations: Reduced other variable costs to $3</p> <p>Result: - New LLM cost per user: $4.32 - New net margin per user: $12.68 (50.7%)</p> <p>This case study demonstrates how a holistic approach to margin improvement, addressing both revenue and various cost components, can significantly enhance profitability.</p> <p>Understanding these profit margin dynamics and cost structures is essential for executives to make informed decisions about LLM integration and to continuously optimize their AI-powered services for maximum profitability.</p>"},{"location":"guides/pricing/#4-llm-pricing-in-action-case-studies","title":"4. LLM Pricing in Action: Case Studies","text":"<p>To provide a concrete understanding of how LLM pricing models work in real-world scenarios, let's examine several case studies across different industries and use cases. These examples will illustrate the interplay between pricing models, usage patterns, and business outcomes.</p>"},{"location":"guides/pricing/#case-study-1-e-commerce-product-description-generator","title":"Case Study 1: E-commerce Product Description Generator","text":"<p>Company: GlobalMart, a large online retailer Use Case: Automated generation of product descriptions LLM Provider: GPT-4o</p> <p>Pricing Model: Pay-per-token - Input: $5.00 per 1M tokens - Output: $15.00 per 1M tokens</p> <p>Usage Pattern: - Average input: 50 tokens per product (product attributes) - Average output: 200 tokens per product (generated description) - Daily products processed: 10,000</p> <p>Daily Cost Calculation: 1. Input cost: (50 tokens * 10,000 products) / 1M * $5.00 = $2.50 2. Output cost: (200 tokens * 10,000 products) / 1M * $15.00 = $30.00 3. Total daily cost: $32.50</p> <p>Business Impact: - Reduced time to market for new products by 70% - Improved SEO performance due to unique, keyword-rich descriptions - Estimated daily value generated: $500 (based on increased sales and efficiency)</p> <p>ROI Analysis: - Daily investment: $32.50 - Daily return: $500 - ROI = (Return - Investment) / Investment * 100 = 1,438%</p> <p>Key Takeaway: The pay-per-token model works well for this use case due to the predictable and moderate token usage per task. The high ROI justifies the investment in a more advanced model like GPT-4o.</p>"},{"location":"guides/pricing/#case-study-2-customer-service-chatbot","title":"Case Study 2: Customer Service Chatbot","text":"<p>Company: TechSupport Inc., a software company Use Case: 24/7 customer support chatbot LLM Provider: Claude 3.5 Sonnet</p> <p>Pricing Model: Input: $3 per 1M tokens, Output: $15 per 1M tokens</p> <p>Usage Pattern: - Average conversation: 500 tokens input (customer queries + context), 1000 tokens output (bot responses) - Daily conversations: 5,000</p> <p>Daily Cost Calculation: 1. Input cost: (500 tokens * 5,000 conversations) / 1M * $3 = $7.50 2. Output cost: (1000 tokens * 5,000 conversations) / 1M * $15 = $75.00 3. Total daily cost: $82.50</p> <p>Business Impact: - Reduced customer wait times by 90% - Resolved 70% of queries without human intervention - Estimated daily cost savings: $2,000 (based on reduced human support hours)</p> <p>ROI Analysis: - Daily investment: $82.50 - Daily return: $2,000 - ROI = (Return - Investment) / Investment * 100 = 2,324%</p> <p>Key Takeaway: The higher cost of Claude 3.5 Sonnet is justified by its superior performance in handling complex customer queries, resulting in significant cost savings and improved customer satisfaction.</p>"},{"location":"guides/pricing/#case-study-3-financial-report-summarization","title":"Case Study 3: Financial Report Summarization","text":"<p>Company: FinAnalyze, a financial services firm Use Case: Automated summarization of lengthy financial reports LLM Provider: GPT-3.5 Turbo</p> <p>Pricing Model: Input: $0.50 per 1M tokens, Output: $1.50 per 1M tokens</p> <p>Usage Pattern: - Average report: 20,000 tokens input, 2,000 tokens output - Daily reports processed: 100</p> <p>Daily Cost Calculation: 1. Input cost: (20,000 tokens * 100 reports) / 1M * $0.50 = $100 2. Output cost: (2,000 tokens * 100 reports) / 1M * $1.50 = $30 3. Total daily cost: $130</p> <p>Business Impact: - Reduced analysis time by 80% - Improved consistency in report summaries - Enabled analysts to focus on high-value tasks - Estimated daily value generated: $1,000 (based on time savings and improved decision-making)</p> <p>ROI Analysis: - Daily investment: $130 - Daily return: $1,000 - ROI = (Return - Investment) / Investment * 100 = 669%</p> <p>Key Takeaway: The lower cost of GPT-3.5 Turbo is suitable for this task, which requires processing large volumes of text but doesn't necessarily need the most advanced language understanding. The high input token count makes the input pricing a significant factor in model selection.</p>"},{"location":"guides/pricing/#case-study-4-ai-powered-language-learning-app","title":"Case Study 4: AI-Powered Language Learning App","text":"<p>Company: LinguaLeap, an edtech startup Use Case: Personalized language exercises and conversations LLM Provider: Claude 3 Haiku</p> <p>Pricing Model: Input: $0.25 per 1M tokens, Output: $1.25 per 1M tokens</p> <p>Usage Pattern: - Average session: 300 tokens input (user responses + context), 500 tokens output (exercises + feedback) - Daily active users: 50,000 - Average sessions per user per day: 3</p> <p>Daily Cost Calculation: 1. Input cost: (300 tokens * 3 sessions * 50,000 users) / 1M * $0.25 = $11.25 2. Output cost: (500 tokens * 3 sessions * 50,000 users) / 1M * $1.25 = $93.75 3. Total daily cost: $105</p> <p>Business Impact: - Increased user engagement by 40% - Improved learning outcomes, leading to higher user retention - Enabled scaling to new languages without proportional increase in human tutors - Estimated daily revenue: $5,000 (based on subscription fees and in-app purchases)</p> <p>ROI Analysis: - Daily investment: $105 - Daily revenue: $5,000 - ROI = (Revenue - Investment) / Investment * 100 = 4,662%</p> <p>Key Takeaway: The high-volume, relatively simple interactions in this use case make Claude 3 Haiku an excellent choice. Its low cost allows for frequent interactions without prohibitive expenses, which is crucial for an app relying on regular user engagement.</p>"},{"location":"guides/pricing/#case-study-5-legal-document-analysis","title":"Case Study 5: Legal Document Analysis","text":"<p>Company: LegalEagle LLP, a large law firm Use Case: Contract review and risk assessment LLM Provider: Claude 3 Opus</p> <p>Pricing Model: Input: $15 per 1M tokens, Output: $75 per 1M tokens</p> <p>Usage Pattern: - Average contract: 10,000 tokens input, 3,000 tokens output (analysis and risk assessment) - Daily contracts processed: 50</p> <p>Daily Cost Calculation: 1. Input cost: (10,000 tokens * 50 contracts) / 1M * $15 = $7.50 2. Output cost: (3,000 tokens * 50 contracts) / 1M * $75 = $11.25 3. Total daily cost: $18.75</p> <p>Business Impact: - Reduced contract review time by 60% - Improved accuracy in identifying potential risks - Enabled handling of more complex cases - Estimated daily value: $10,000 (based on time savings and improved risk management)</p> <p>ROI Analysis: - Daily investment: $18.75 - Daily value: $10,000 - ROI = (Value - Investment) / Investment * 100 = 53,233%</p> <p>Key Takeaway: Despite the high cost per token, Claude 3 Opus's advanced capabilities justify its use in this high-stakes environment where accuracy and nuanced understanding are critical. The high value generated per task offsets the higher token costs.</p> <p>These case studies demonstrate how different LLM providers and pricing models can be optimal for various use cases, depending on factors such as token volume, task complexity, and the value generated by the AI application. Executives should carefully consider these factors when selecting an LLM provider and pricing model for their specific needs.</p>"},{"location":"guides/pricing/#5-calculating-roi-for-llm-integration","title":"5. Calculating ROI for LLM Integration","text":"<p>Calculating the Return on Investment (ROI) for LLM integration is crucial for executives to justify the expenditure and assess the business value of AI implementation. This section will guide you through the process of calculating ROI, considering both tangible and intangible benefits.</p>"},{"location":"guides/pricing/#the-roi-formula","title":"The ROI Formula","text":"<p>The basic ROI formula is:</p> <pre><code>ROI = (Net Benefit / Cost of Investment) * 100\n</code></pre> <p>For LLM integration, we can expand this to:</p> <pre><code>ROI = ((Total Benefits - Total Costs) / Total Costs) * 100\n</code></pre>"},{"location":"guides/pricing/#identifying-benefits","title":"Identifying Benefits","text":"<ol> <li>Direct Cost Savings</li> <li>Reduced labor costs</li> <li>Decreased operational expenses</li> <li> <p>Lower error-related costs</p> </li> <li> <p>Revenue Increases</p> </li> <li>New product offerings enabled by LLM</li> <li>Improved customer acquisition and retention</li> <li> <p>Upselling and cross-selling opportunities</p> </li> <li> <p>Productivity Gains</p> </li> <li>Time saved on repetitive tasks</li> <li>Faster decision-making processes</li> <li> <p>Improved employee efficiency</p> </li> <li> <p>Quality Improvements</p> </li> <li>Enhanced accuracy in outputs</li> <li>Consistency in service delivery</li> <li> <p>Reduced error rates</p> </li> <li> <p>Strategic Advantages</p> </li> <li>Market differentiation</li> <li>Faster time-to-market for new offerings</li> <li>Improved competitive positioning</li> </ol>"},{"location":"guides/pricing/#calculating-costs","title":"Calculating Costs","text":"<ol> <li>Direct LLM Costs</li> <li>API usage fees</li> <li> <p>Subscription costs</p> </li> <li> <p>Infrastructure Costs</p> </li> <li>Cloud computing resources</li> <li>Data storage</li> <li> <p>Networking expenses</p> </li> <li> <p>Integration and Development Costs</p> </li> <li>Initial setup and integration</li> <li>Ongoing maintenance and updates</li> <li> <p>Custom feature development</p> </li> <li> <p>Training and Support</p> </li> <li>Employee training programs</li> <li>User support and documentation</li> <li> <p>Change management initiatives</p> </li> <li> <p>Compliance and Security</p> </li> <li>Data privacy measures</li> <li>Security audits and implementations</li> <li>Regulatory compliance efforts</li> </ol>"},{"location":"guides/pricing/#step-by-step-roi-calculation","title":"Step-by-Step ROI Calculation","text":"<ol> <li> <p>Define the Time Period: Determine the timeframe for your ROI calculation (e.g., 1 year, 3 years).</p> </li> <li> <p>Estimate Total Benefits:</p> </li> <li>Quantify direct cost savings and revenue increases</li> <li>Assign monetary values to productivity gains and quality improvements</li> <li> <p>Estimate the value of strategic advantages (this may be more subjective)</p> </li> <li> <p>Calculate Total Costs:</p> </li> <li> <p>Sum up all direct and indirect costs related to LLM integration</p> </li> <li> <p>Apply the ROI Formula:    <pre><code>ROI = ((Total Benefits - Total Costs) / Total Costs) * 100\n</code></pre></p> </li> <li> <p>Consider Time Value of Money: For longer-term projections, use Net Present Value (NPV) to account for the time value of money.</p> </li> </ol>"},{"location":"guides/pricing/#example-roi-calculation","title":"Example ROI Calculation","text":"<p>Let's consider a hypothetical customer service chatbot implementation:</p> <p>Time Period: 1 year</p> <p>Benefits: - Labor cost savings: $500,000 - Increased sales from improved customer satisfaction: $300,000 - Productivity gains from faster query resolution: $200,000</p> <p>Total Benefits: $1,000,000</p> <p>Costs: - LLM API fees: $100,000 - Integration and development: $150,000 - Training and support: $50,000 - Infrastructure: $50,000</p> <p>Total Costs: $350,000</p> <p>ROI Calculation: <pre><code>ROI = (($1,000,000 - $350,000) / $350,000) * 100 = 185.7%\n</code></pre></p> <p>This indicates a strong positive return on investment, with benefits outweighing costs by a significant margin.</p>"},{"location":"guides/pricing/#considerations-for-accurate-roi-calculation","title":"Considerations for Accurate ROI Calculation","text":"<ol> <li> <p>Be Conservative in Estimates: It's better to underestimate benefits and overestimate costs to provide a more realistic view.</p> </li> <li> <p>Account for Ramp-Up Time: Full benefits may not be realized immediately. Consider a phased approach in your calculations.</p> </li> <li> <p>Include Opportunity Costs: Consider the potential returns if the investment were made elsewhere.</p> </li> <li> <p>Factor in Risk: Adjust your ROI based on the likelihood of achieving projected benefits.</p> </li> <li> <p>Consider Non-Financial Benefits: Some benefits, like improved employee satisfaction or enhanced brand perception, may not have direct financial equivalents but are still valuable.</p> </li> <li> <p>Perform Sensitivity Analysis: Calculate ROI under different scenarios (best case, worst case, most likely) to understand the range of possible outcomes.</p> </li> <li> <p>Benchmark Against Alternatives: Compare the ROI of LLM integration against other potential investments or solutions.</p> </li> </ol>"},{"location":"guides/pricing/#long-term-roi-considerations","title":"Long-Term ROI Considerations","text":"<p>While initial ROI calculations are crucial for decision-making, it's important to consider long-term implications:</p> <ol> <li>Scalability: How will ROI change as usage increases?</li> <li>Technological Advancements: Will newer, more efficient models become available?</li> <li>Market Changes: How might shifts in the competitive landscape affect the value proposition?</li> <li>Regulatory Environment: Could future regulations impact the cost or feasibility of LLM use?</li> </ol> <p>By thoroughly calculating and analyzing the ROI of LLM integration, executives can make data-driven decisions about AI investments and set realistic expectations for the value these technologies can bring to their organizations.</p>"},{"location":"guides/pricing/#6-comparative-analysis-of-major-llm-providers","title":"6. Comparative Analysis of Major LLM Providers","text":"<p>In this section, we'll compare the offerings of major LLM providers, focusing on their pricing structures, model capabilities, and unique selling points. This analysis will help executives understand the landscape and make informed decisions about which provider best suits their needs.</p>"},{"location":"guides/pricing/#openai","title":"OpenAI","text":"<p>Models: GPT-4o, GPT-3.5 Turbo</p> <p>Pricing Structure: - Pay-per-token model - Different rates for input and output tokens - Bulk discounts available for high-volume users</p> <p>Key Features: - State-of-the-art performance on a wide range of tasks - Regular model updates and improvements - Extensive documentation and community support</p> <p>Considerations: - Higher pricing compared to some competitors - Potential for rapid price changes as technology evolves - Usage limits and approval process for higher-tier models</p>"},{"location":"guides/pricing/#anthropic","title":"Anthropic","text":"<p>Models: Claude 3.5 Sonnet, Claude 3 Opus, Claude 3 Haiku</p> <p>Pricing Structure: - Pay-per-token model - Different rates for input and output tokens - Tiered pricing based on model capabilities</p> <p>Key Features: - Strong focus on AI safety and ethics - Long context windows (200K tokens) - Specialized models for different use cases (e.g., Haiku for speed, Opus for complex tasks)</p> <p>Considerations: - Newer to the market compared to OpenAI - Potentially more limited third-party integrations - Strong emphasis on responsible AI use</p>"},{"location":"guides/pricing/#google-vertex-ai","title":"Google (Vertex AI)","text":"<p>Models: PaLM 2 for Chat, PaLM 2 for Text</p> <p>Pricing Structure: - Pay-per-thousand characters model - Different rates for input and output - Additional charges for advanced features (e.g., semantic retrieval)</p> <p>Key Features: - Integration with Google Cloud ecosystem - Multi-modal capabilities (text, image, audio) - Enterprise-grade security and compliance features</p> <p>Considerations: - Pricing can be complex due to additional Google Cloud costs - Strong performance in specialized domains (e.g., coding, mathematical reasoning) - Potential for integration with other Google services</p>"},{"location":"guides/pricing/#amazon-bedrock","title":"Amazon (Bedrock)","text":"<p>Models: Claude (Anthropic), Titan</p> <p>Pricing Structure: - Pay-per-second of compute time - Additional charges for data transfer and storage</p> <p>Key Features: - Seamless integration with AWS services - Access to multiple model providers through a single API - Fine-tuning and customization options</p> <p>Considerations: - Pricing model can be less predictable for inconsistent workloads - Strong appeal for existing AWS customers - Potential for cost optimizations through AWS ecosystem</p>"},{"location":"guides/pricing/#microsoft-azure-openai-service","title":"Microsoft (Azure OpenAI Service)","text":"<p>Models: GPT-4, GPT-3.5 Turbo</p> <p>Pricing Structure: - Similar to OpenAI's pricing, but with Azure integration - Additional costs for Azure services (e.g., storage, networking)</p> <p>Key Features: - Enterprise-grade security and compliance - Integration with Azure AI services - Access to fine-tuning and customization options</p> <p>Considerations: - Attractive for organizations already using Azure - Potential for volume discounts through Microsoft Enterprise Agreements - Additional overhead for Azure management</p>"},{"location":"guides/pricing/#comparative-analysis","title":"Comparative Analysis","text":"Provider Pricing Model Strengths Considerations OpenAI Pay-per-token - Top performance- Regular updates- Strong community - Higher costs- Usage limits Anthropic Pay-per-token - Ethical focus- Long context- Specialized models - Newer provider- Limited integrations Google Pay-per-character - Google Cloud integration- Multi-modal- Enterprise features - Complex pricing- Google ecosystem lock-in Amazon Pay-per-compute time - AWS integration- Multiple providers- Customization options - Less predictable costs- AWS ecosystem focus Microsoft Pay-per-token (Azure-based) - Enterprise security- Azure integration- Fine-tuning options - Azure overhead- Potential lock-in"},{"location":"guides/pricing/#factors-to-consider-in-provider-selection","title":"Factors to Consider in Provider Selection","text":"<ol> <li> <p>Performance Requirements: Assess whether you need state-of-the-art performance or if a less advanced (and potentially cheaper) model suffices.</p> </li> <li> <p>Pricing Predictability: Consider whether your usage patterns align better with token-based or compute-time-based pricing.</p> </li> <li> <p>Integration Needs: Evaluate how well each provider integrates with your existing technology stack.</p> </li> <li> <p>Scalability: Assess each provider's ability to handle your expected growth in usage.</p> </li> <li> <p>Customization Options: Determine if you need fine-tuning or specialized model development capabilities.</p> </li> <li> <p>Compliance and Security: Consider your industry-specific regulatory requirements and each provider's security offerings.</p> </li> <li> <p>Support and Documentation: Evaluate the quality of documentation, community support, and enterprise-level assistance.</p> </li> <li> <p>Ethical Considerations: Assess each provider's stance on AI ethics and responsible use.</p> </li> <li> <p>Lock-In Concerns: Consider the long-term implications of committing to a specific provider or cloud ecosystem.</p> </li> <li> <p>Multi-Provider Strategy: Evaluate the feasibility and benefits of using multiple providers for different use cases.</p> </li> </ol> <p>By carefully comparing these providers and considering the factors most relevant to your organization, you can make an informed decision that balances cost, performance, and strategic fit. Remember that the LLM landscape is rapidly evolving, so it's important to regularly reassess your choices and stay informed about new developments and pricing changes.</p>"},{"location":"guides/pricing/#7-hidden-costs-and-considerations","title":"7. Hidden Costs and Considerations","text":"<p>When evaluating LLM providers and calculating the total cost of ownership, it's crucial to look beyond the advertised pricing and consider the hidden costs and additional factors that can significantly impact your budget and overall implementation success. This section explores these often-overlooked aspects to help executives make more comprehensive and accurate assessments.</p>"},{"location":"guides/pricing/#1-data-preparation-and-cleaning","title":"1. Data Preparation and Cleaning","text":"<p>Considerations: - Cost of data collection and aggregation - Expenses related to data cleaning and normalization - Ongoing data maintenance and updates</p> <p>Impact: - Can be time-consuming and labor-intensive - May require specialized tools or personnel - Critical for model performance and accuracy</p>"},{"location":"guides/pricing/#2-fine-tuning-and-customization","title":"2. Fine-Tuning and Customization","text":"<p>Considerations: - Costs associated with creating custom datasets - Compute resources required for fine-tuning - Potential need for specialized ML expertise</p> <p>Impact: - Can significantly improve model performance for specific tasks - May lead to better ROI in the long run - Increases initial implementation costs</p>"},{"location":"guides/pricing/#3-integration-and-development","title":"3. Integration and Development","text":"<p>Considerations: - Engineering time for API integration - Development of custom interfaces or applications - Ongoing maintenance and updates</p> <p>Impact: - Can be substantial, especially for complex integrations - May require hiring additional developers or consultants - Critical for seamless user experience and workflow integration</p>"},{"location":"guides/pricing/#4-monitoring-and-optimization","title":"4. Monitoring and Optimization","text":"<p>Considerations: - Tools and systems for performance monitoring - Regular audits and optimizations - Costs associated with debugging and troubleshooting</p> <p>Impact: - Ongoing expense that increases with scale - Essential for maintaining efficiency and cost-effectiveness - Can lead to significant savings through optimized usage</p>"},{"location":"guides/pricing/#5-compliance-and-security","title":"5. Compliance and Security","text":"<p>Considerations: - Legal counsel for data privacy and AI regulations - Implementation of security measures (e.g., encryption, access controls) - Regular audits and certifications</p> <p>Impact: - Can be substantial, especially in heavily regulated industries - Critical for risk management and maintaining customer trust - May limit certain use cases or require additional safeguards</p>"},{"location":"guides/pricing/#6-training-and-change-management","title":"6. Training and Change Management","text":"<ul> <li>Employee training programs</li> <li>Development of user guides and documentation</li> <li>Change management initiatives</li> </ul> <p>Impact: - Often underestimated but crucial for adoption - Can affect productivity during the transition period - Important for realizing the full potential of LLM integration</p>"},{"location":"guides/pricing/#7-scaling-costs","title":"7. Scaling Costs","text":"<p>Considerations: - Potential price increases as usage grows - Need for additional infrastructure or resources - Costs associated with managing increased complexity</p> <p>Impact: - Can lead to unexpected expenses if not properly forecasted - May require renegotiation of contracts or switching providers - Important to consider in long-term planning</p>"},{"location":"guides/pricing/#8-opportunity-costs","title":"8. Opportunity Costs","text":"<p>Considerations: - Time and resources diverted from other projects - Potential missed opportunities due to focus on LLM implementation - Learning curve and productivity dips during adoption</p> <p>Impact: - Difficult to quantify but important to consider - Can affect overall business strategy and priorities - May influence timing and scope of LLM integration</p>"},{"location":"guides/pricing/#9-vendor-lock-in","title":"9. Vendor Lock-in","text":"<p>Considerations: - Costs associated with switching providers - Dependency on provider-specific features or integrations - Potential for price increases once deeply integrated</p> <p>Impact: - Can limit flexibility and negotiating power - May affect long-term costs and strategic decisions - Important to consider multi-provider or portable implementation strategies</p>"},{"location":"guides/pricing/#10-ethical-and-reputational-considerations","title":"10. Ethical and Reputational Considerations","text":"<p>Considerations: - Potential backlash from AI-related controversies - Costs of ensuring ethical AI use and transparency - Investments in responsible AI practices</p> <p>Impact: - Can affect brand reputation and customer trust - May require ongoing public relations efforts - Important for long-term sustainability and social responsibility</p> <p>By carefully considering these hidden costs and factors, executives can develop a more comprehensive understanding of the total investment required for successful LLM integration. This holistic approach allows for better budgeting, risk management, and strategic planning.</p>"},{"location":"guides/pricing/#conclusion-navigating-the-llm-pricing-landscape","title":"Conclusion: Navigating the LLM Pricing Landscape","text":"<p>As we've explored throughout this guide, the landscape of LLM provider pricing is complex and multifaceted. From understanding the basic pricing models to calculating ROI and considering hidden costs, there are numerous factors that executives must weigh when making decisions about AI integration.</p> <p>Key takeaways include:</p> <ol> <li>The importance of aligning LLM selection with specific business needs and use cases.</li> <li>The need for thorough ROI analysis that goes beyond simple cost calculations.</li> <li>The value of considering both short-term implementation costs and long-term scalability.</li> <li>The critical role of hidden costs in determining the true total cost of ownership.</li> <li>The potential for significant business value when LLMs are strategically implemented and optimized.</li> </ol> <p>As the AI landscape continues to evolve rapidly, staying informed and adaptable is crucial. What may be the best choice today could change as new models are released, pricing structures shift, and your organization's needs evolve.</p> <p>To help you navigate these complexities and make the most informed decisions for your enterprise, we invite you to take the next steps in your AI journey:</p> <ol> <li> <p>Book a Consultation: Speak with our enterprise-grade LLM specialists who can provide personalized insights and recommendations tailored to your specific needs. Schedule a 15-minute call at https://cal.com/swarms/15min.</p> </li> <li> <p>Join Our Community: Connect with fellow AI executives, share experiences, and stay updated on the latest developments in the LLM space. Join our Discord community at https://discord.gg/yxU9t9da.</p> </li> </ol> <p>By leveraging expert guidance and peer insights, you can position your organization to make the most of LLM technologies while optimizing costs and maximizing value. The future of AI in enterprise is bright, and with the right approach, your organization can be at the forefront of this transformative technology.</p>"},{"location":"misc/features/20swarms/","title":"20swarms","text":"<pre><code># Swarm Alpha: Data Cruncher\n**Overview**: Processes large datasets.  \n**Strengths**: Efficient data handling.  \n**Weaknesses**: Requires structured data.  \n\n**Pseudo Code**:\n```sql\nFOR each data_entry IN dataset:\n    result = PROCESS(data_entry)\n    STORE(result)\nEND FOR\nRETURN aggregated_results\n</code></pre>"},{"location":"misc/features/20swarms/#swarm-beta-artistic-ally","title":"Swarm Beta: Artistic Ally","text":"<p>Overview: Generates art pieces. Strengths: Creativity. Weaknesses: Somewhat unpredictable.  </p> <p>Pseudo Code: <pre><code>INITIATE canvas_parameters\nSELECT art_style\nDRAW(canvas_parameters, art_style)\nRETURN finished_artwork\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-gamma-sound-sculptor","title":"Swarm Gamma: Sound Sculptor","text":"<p>Overview: Crafts audio sequences. Strengths: Diverse audio outputs. Weaknesses: Complexity in refining outputs.  </p> <p>Pseudo Code: <pre><code>DEFINE sound_parameters\nSELECT audio_style\nGENERATE_AUDIO(sound_parameters, audio_style)\nRETURN audio_sequence\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-delta-web-weaver","title":"Swarm Delta: Web Weaver","text":"<p>Overview: Constructs web designs. Strengths: Modern design sensibility. Weaknesses: Limited to web interfaces.  </p> <p>Pseudo Code: <pre><code>SELECT template\nAPPLY user_preferences(template)\nDESIGN_web(template, user_preferences)\nRETURN web_design\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-epsilon-code-compiler","title":"Swarm Epsilon: Code Compiler","text":"<p>Overview: Writes and compiles code snippets. Strengths: Quick code generation. Weaknesses: Limited to certain programming languages.  </p> <p>Pseudo Code: <pre><code>DEFINE coding_task\nWRITE_CODE(coding_task)\nCOMPILE(code)\nRETURN executable\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-zeta-security-shield","title":"Swarm Zeta: Security Shield","text":"<p>Overview: Detects system vulnerabilities. Strengths: High threat detection rate. Weaknesses: Potential false positives.  </p> <p>Pseudo Code: <pre><code>MONITOR system_activity\nIF suspicious_activity_detected:\n    ANALYZE threat_level\n    INITIATE mitigation_protocol\nEND IF\nRETURN system_status\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-eta-researcher-relay","title":"Swarm Eta: Researcher Relay","text":"<p>Overview: Gathers and synthesizes research data. Strengths: Access to vast databases. Weaknesses: Depth of research can vary.  </p> <p>Pseudo Code: <pre><code>DEFINE research_topic\nSEARCH research_sources(research_topic)\nSYNTHESIZE findings\nRETURN research_summary\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-theta-sentiment-scanner","title":"Swarm Theta: Sentiment Scanner","text":"<p>Overview: Analyzes text for sentiment and emotional tone. Strengths: Accurate sentiment detection. Weaknesses: Contextual nuances might be missed.  </p> <p>Pseudo Code: <pre><code>INPUT text_data\nANALYZE text_data FOR emotional_tone\nDETERMINE sentiment_value\nRETURN sentiment_value\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-iota-image-interpreter","title":"Swarm Iota: Image Interpreter","text":"<p>Overview: Processes and categorizes images. Strengths: High image recognition accuracy. Weaknesses: Can struggle with abstract visuals.  </p> <p>Pseudo Code: <pre><code>LOAD image_data\nPROCESS image_data FOR features\nCATEGORIZE image_based_on_features\nRETURN image_category\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-kappa-language-learner","title":"Swarm Kappa: Language Learner","text":"<p>Overview: Translates and interprets multiple languages. Strengths: Supports multiple languages. Weaknesses: Nuances in dialects might pose challenges.  </p> <p>Pseudo Code: <pre><code>RECEIVE input_text, target_language\nTRANSLATE input_text TO target_language\nRETURN translated_text\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-lambda-trend-tracker","title":"Swarm Lambda: Trend Tracker","text":"<p>Overview: Monitors and predicts trends based on data. Strengths: Proactive trend identification. Weaknesses: Requires continuous data stream.  </p> <p>Pseudo Code: <pre><code>COLLECT data_over_time\nANALYZE data_trends\nPREDICT upcoming_trends\nRETURN trend_forecast\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-mu-financial-forecaster","title":"Swarm Mu: Financial Forecaster","text":"<p>Overview: Analyzes financial data to predict market movements. Strengths: In-depth financial analytics. Weaknesses: Market volatility can affect predictions.  </p> <p>Pseudo Code: <pre><code>GATHER financial_data\nCOMPUTE statistical_analysis\nFORECAST market_movements\nRETURN financial_projections\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-nu-network-navigator","title":"Swarm Nu: Network Navigator","text":"<p>Overview: Optimizes and manages network traffic. Strengths: Efficient traffic management. Weaknesses: Depends on network infrastructure.  </p> <p>Pseudo Code: <pre><code>MONITOR network_traffic\nIDENTIFY congestion_points\nOPTIMIZE traffic_flow\nRETURN network_status\n</code></pre></p>"},{"location":"misc/features/20swarms/#swarm-xi-content-curator","title":"Swarm Xi: Content Curator","text":"<p>Overview: Gathers and presents content based on user preferences. Strengths: Personalized content delivery. Weaknesses: Limited by available content sources.  </p> <p>Pseudo Code: <pre><code>DEFINE user_preferences\nSEARCH content_sources\nFILTER content_matching_preferences\nDISPLAY curated_content\n</code></pre></p>"},{"location":"misc/features/SMAPS/","title":"Swarms Multi-Agent Permissions System (SMAPS)","text":""},{"location":"misc/features/SMAPS/#description","title":"Description","text":"<p>SMAPS is a robust permissions management system designed to integrate seamlessly with Swarm's multi-agent AI framework. Drawing inspiration from Amazon's IAM, SMAPS ensures secure, granular control over agent actions while allowing for collaborative human-in-the-loop interventions.</p>"},{"location":"misc/features/SMAPS/#technical-specification","title":"Technical Specification","text":""},{"location":"misc/features/SMAPS/#1-components","title":"1. Components","text":"<ul> <li>User Management: Handle user registrations, roles, and profiles.</li> <li>Agent Management: Register, monitor, and manage AI agents.</li> <li>Permissions Engine: Define and enforce permissions based on roles.</li> <li>Multiplayer Interface: Allows multiple human users to intervene, guide, or collaborate on tasks being executed by AI agents.</li> </ul>"},{"location":"misc/features/SMAPS/#2-features","title":"2. Features","text":"<ul> <li>Role-Based Access Control (RBAC):</li> <li>Users can be assigned predefined roles (e.g., Admin, Agent Supervisor, Collaborator).</li> <li> <p>Each role has specific permissions associated with it, defining what actions can be performed on AI agents or tasks.</p> </li> <li> <p>Dynamic Permissions:</p> </li> <li>Create custom roles with specific permissions.</li> <li> <p>Permissions granularity: From broad (e.g., view all tasks) to specific (e.g., modify parameters of a particular agent).</p> </li> <li> <p>Multiplayer Collaboration:</p> </li> <li>Multiple users can join a task in real-time.</li> <li>Collaborators can provide real-time feedback or guidance to AI agents.</li> <li> <p>A voting system for decision-making when human intervention is required.</p> </li> <li> <p>Agent Supervision:</p> </li> <li>Monitor agent actions in real-time.</li> <li> <p>Intervene, if necessary, to guide agent actions based on permissions.</p> </li> <li> <p>Audit Trail:</p> </li> <li>All actions, whether performed by humans or AI agents, are logged.</li> <li>Review historical actions, decisions, and interventions for accountability and improvement.</li> </ul>"},{"location":"misc/features/SMAPS/#3-security","title":"3. Security","text":"<ul> <li>Authentication: Secure login mechanisms with multi-factor authentication options.</li> <li>Authorization: Ensure users and agents can only perform actions they are permitted to.</li> <li>Data Encryption: All data, whether at rest or in transit, is encrypted using industry-standard protocols.</li> </ul>"},{"location":"misc/features/SMAPS/#4-integration","title":"4. Integration","text":"<ul> <li>APIs: Expose APIs for integrating SMAPS with other systems or for extending its capabilities.</li> <li>SDK: Provide software development kits for popular programming languages to facilitate integration and extension.</li> </ul>"},{"location":"misc/features/SMAPS/#documentation-description","title":"Documentation Description","text":"<p>Swarms Multi-Agent Permissions System (SMAPS) offers a sophisticated permissions management mechanism tailored for multi-agent AI frameworks. It combines the robustness of Amazon IAM-like permissions with a unique \"multiplayer\" feature, allowing multiple humans to collaboratively guide AI agents in real-time. This ensures not only that tasks are executed efficiently but also that they uphold the highest standards of accuracy and ethics. With SMAPS, businesses can harness the power of swarms with confidence, knowing that they have full control and transparency over their AI operations.</p>"},{"location":"misc/features/agent_archive/","title":"AgentArchive Documentation","text":""},{"location":"misc/features/agent_archive/#swarms-multi-agent-framework","title":"Swarms Multi-Agent Framework","text":"<p>AgentArchive is an advanced feature crafted to archive, bookmark, and harness the transcripts of agent runs. It promotes the storing and leveraging of successful agent interactions, offering a powerful means for users to derive \"recipes\" for future agents. Furthermore, with its public archive feature, users can contribute to and benefit from the collective wisdom of the community.</p>"},{"location":"misc/features/agent_archive/#overview","title":"Overview:","text":"<p>AgentArchive empowers users to: 1. Preserve complete transcripts of agent instances. 2. Bookmark and annotate significant runs. 3. Categorize runs using various tags. 4. Transform successful runs into actionable \"recipes\". 5. Publish and access a shared knowledge base via a public archive.</p>"},{"location":"misc/features/agent_archive/#features","title":"Features:","text":""},{"location":"misc/features/agent_archive/#1-archiving","title":"1. Archiving:","text":"<ul> <li>Save Transcripts: Retain the full narrative of an agent's interaction and choices.</li> <li>Searchable Database: Dive into archives using specific keywords, timestamps, or tags.</li> </ul>"},{"location":"misc/features/agent_archive/#2-bookmarking","title":"2. Bookmarking:","text":"<ul> <li>Highlight Essential Runs: Designate specific agent runs for future reference.</li> <li>Annotations: Embed notes or remarks to bookmarked runs for clearer understanding.</li> </ul>"},{"location":"misc/features/agent_archive/#3-tagging","title":"3. Tagging:","text":"<p>Organize and classify agent runs via: - Prompt: The originating instruction that triggered the agent run. - Tasks: Distinct tasks or operations executed by the agent. - Model: The specific AI model or iteration used during the interaction. - Temperature (Temp): The set randomness or innovation level for the agent.</p>"},{"location":"misc/features/agent_archive/#4-recipe-generation","title":"4. Recipe Generation:","text":"<ul> <li>Standardization: Convert successful run transcripts into replicable \"recipes\".</li> <li>Guidance: Offer subsequent agents a structured approach, rooted in prior successes.</li> <li>Evolution: Periodically refine recipes based on newer, enhanced runs.</li> </ul>"},{"location":"misc/features/agent_archive/#5-public-archive-sharing","title":"5. Public Archive &amp; Sharing:","text":"<ul> <li>Publish Successful Runs: Users can choose to share their successful agent runs.</li> <li>Collaborative Knowledge Base: Access a shared repository of successful agent interactions from the community.</li> <li>Ratings &amp; Reviews: Users can rate and review shared runs, highlighting particularly effective \"recipes.\"</li> <li>Privacy &amp; Redaction: Ensure that any sensitive information is automatically redacted before publishing.</li> </ul>"},{"location":"misc/features/agent_archive/#benefits","title":"Benefits:","text":"<ol> <li>Efficiency: Revisit past agent activities to inform and guide future decisions.</li> <li>Consistency: Guarantee a uniform approach to recurring challenges, leading to predictable and trustworthy outcomes.</li> <li>Collaborative Learning: Tap into a reservoir of shared experiences, fostering community-driven learning and growth.</li> <li>Transparency: By sharing successful runs, users can build trust and contribute to the broader community's success.</li> </ol>"},{"location":"misc/features/agent_archive/#usage","title":"Usage:","text":"<ol> <li>Access AgentArchive: Navigate to the dedicated section within the Swarms Multi-Agent Framework dashboard.</li> <li>Search, Filter &amp; Organize: Utilize the search bar and tagging system for precise retrieval.</li> <li>Bookmark, Annotate &amp; Share: Pin important runs, add notes, and consider sharing with the broader community.</li> <li>Engage with Public Archive: Explore, rate, and apply shared knowledge to enhance agent performance.</li> </ol> <p>With AgentArchive, users not only benefit from their past interactions but can also leverage the collective expertise of the Swarms community, ensuring continuous improvement and shared success.</p>"},{"location":"misc/features/fail_protocol/","title":"Swarms Multi-Agent Framework Documentation","text":""},{"location":"misc/features/fail_protocol/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Agent Failure Protocol</li> <li>Swarm Failure Protocol</li> </ul>"},{"location":"misc/features/fail_protocol/#agent-failure-protocol","title":"Agent Failure Protocol","text":""},{"location":"misc/features/fail_protocol/#1-overview","title":"1. Overview","text":"<p>Agent failures may arise from bugs, unexpected inputs, or external system changes. This protocol aims to diagnose, address, and prevent such failures.</p>"},{"location":"misc/features/fail_protocol/#2-root-cause-analysis","title":"2. Root Cause Analysis","text":"<ul> <li>Data Collection: Record the task, inputs, and environmental variables present during the failure.</li> <li>Diagnostic Tests: Run the agent in a controlled environment replicating the failure scenario.</li> <li>Error Logging: Analyze error logs to identify patterns or anomalies.</li> </ul>"},{"location":"misc/features/fail_protocol/#3-solution-brainstorming","title":"3. Solution Brainstorming","text":"<ul> <li>Code Review: Examine the code sections linked to the failure for bugs or inefficiencies.</li> <li>External Dependencies: Check if external systems or data sources have changed.</li> <li>Algorithmic Analysis: Evaluate if the agent's algorithms were overwhelmed or faced an unhandled scenario.</li> </ul>"},{"location":"misc/features/fail_protocol/#4-risk-analysis-solution-ranking","title":"4. Risk Analysis &amp; Solution Ranking","text":"<ul> <li>Assess the potential risks associated with each solution.</li> <li>Rank solutions based on:</li> <li>Implementation complexity</li> <li>Potential negative side effects</li> <li>Resource requirements</li> <li>Assign a success probability score (0.0 to 1.0) based on the above factors.</li> </ul>"},{"location":"misc/features/fail_protocol/#5-solution-implementation","title":"5. Solution Implementation","text":"<ul> <li>Implement the top 3 solutions sequentially, starting with the highest success probability.</li> <li>If all three solutions fail, trigger the \"Human-in-the-Loop\" protocol.</li> </ul>"},{"location":"misc/features/fail_protocol/#swarm-failure-protocol","title":"Swarm Failure Protocol","text":""},{"location":"misc/features/fail_protocol/#1-overview_1","title":"1. Overview","text":"<p>Swarm failures are more complex, often resulting from inter-agent conflicts, systemic bugs, or large-scale environmental changes. This protocol delves deep into such failures to ensure the swarm operates optimally.</p>"},{"location":"misc/features/fail_protocol/#2-root-cause-analysis_1","title":"2. Root Cause Analysis","text":"<ul> <li>Inter-Agent Analysis: Examine if agents were in conflict or if there was a breakdown in collaboration.</li> <li>System Health Checks: Ensure all system components supporting the swarm are operational.</li> <li>Environment Analysis: Investigate if external factors or systems impacted the swarm's operation.</li> </ul>"},{"location":"misc/features/fail_protocol/#3-solution-brainstorming_1","title":"3. Solution Brainstorming","text":"<ul> <li>Collaboration Protocols: Review and refine how agents collaborate.</li> <li>Resource Allocation: Check if the swarm had adequate computational and memory resources.</li> <li>Feedback Loops: Ensure agents are effectively learning from each other.</li> </ul>"},{"location":"misc/features/fail_protocol/#4-risk-analysis-solution-ranking_1","title":"4. Risk Analysis &amp; Solution Ranking","text":"<ul> <li>Assess the potential systemic risks posed by each solution.</li> <li>Rank solutions considering:</li> <li>Scalability implications</li> <li>Impact on individual agents</li> <li>Overall swarm performance potential</li> <li>Assign a success probability score (0.0 to 1.0) based on the above considerations.</li> </ul>"},{"location":"misc/features/fail_protocol/#5-solution-implementation_1","title":"5. Solution Implementation","text":"<ul> <li>Implement the top 3 solutions sequentially, prioritizing the one with the highest success probability.</li> <li>If all three solutions are unsuccessful, invoke the \"Human-in-the-Loop\" protocol for expert intervention.</li> </ul> <p>By following these protocols, the Swarms Multi-Agent Framework can systematically address and prevent failures, ensuring a high degree of reliability and efficiency.</p>"},{"location":"misc/features/human_in_loop/","title":"Human-in-the-Loop Task Handling Protocol","text":""},{"location":"misc/features/human_in_loop/#overview","title":"Overview","text":"<p>The Swarms Multi-Agent Framework recognizes the invaluable contributions humans can make, especially in complex scenarios where nuanced judgment is required. The \"Human-in-the-Loop Task Handling Protocol\" ensures that when agents encounter challenges they cannot handle autonomously, the most capable human collaborator is engaged to provide guidance, based on their skills and expertise.</p>"},{"location":"misc/features/human_in_loop/#protocol-steps","title":"Protocol Steps","text":""},{"location":"misc/features/human_in_loop/#1-task-initiation-analysis","title":"1. Task Initiation &amp; Analysis","text":"<ul> <li>When a task is initiated, agents first analyze the task's requirements.</li> <li>The system maintains an understanding of each task's complexity, requirements, and potential challenges.</li> </ul>"},{"location":"misc/features/human_in_loop/#2-automated-resolution-attempt","title":"2. Automated Resolution Attempt","text":"<ul> <li>Agents first attempt to resolve the task autonomously using their algorithms and data.</li> <li>If the task can be completed without issues, it progresses normally.</li> </ul>"},{"location":"misc/features/human_in_loop/#3-challenge-detection","title":"3. Challenge Detection","text":"<ul> <li>If agents encounter challenges or uncertainties they cannot resolve, the \"Human-in-the-Loop\" protocol is triggered.</li> </ul>"},{"location":"misc/features/human_in_loop/#4-human-collaborator-identification","title":"4. Human Collaborator Identification","text":"<ul> <li>The system maintains a dynamic profile of each human collaborator, cataloging their skills, expertise, and past performance on related tasks.</li> <li>Using this profile data, the system identifies the most capable human collaborator to assist with the current challenge.</li> </ul>"},{"location":"misc/features/human_in_loop/#5-real-time-collaboration","title":"5. Real-time Collaboration","text":"<ul> <li>The identified human collaborator is notified and provided with all the relevant information about the task and the challenge.</li> <li>Collaborators can provide guidance, make decisions, or even take over specific portions of the task.</li> </ul>"},{"location":"misc/features/human_in_loop/#6-task-completion-feedback-loop","title":"6. Task Completion &amp; Feedback Loop","text":"<ul> <li>Once the challenge is resolved, agents continue with the task until completion.</li> <li>Feedback from human collaborators is used to update agent algorithms, ensuring continuous learning and improvement.</li> </ul>"},{"location":"misc/features/human_in_loop/#best-practices","title":"Best Practices","text":"<ol> <li>Maintain Up-to-date Human Profiles: Ensure that the skillsets, expertise, and performance metrics of human collaborators are updated regularly.</li> <li>Limit Interruptions: Implement mechanisms to limit the frequency of human interventions, ensuring collaborators are not overwhelmed with requests.</li> <li>Provide Context: When seeking human intervention, provide collaborators with comprehensive context to ensure they can make informed decisions.</li> <li>Continuous Training: Regularly update and train agents based on feedback from human collaborators.</li> <li>Measure &amp; Optimize: Monitor the efficiency of the \"Human-in-the-Loop\" protocol, aiming to reduce the frequency of interventions while maximizing the value of each intervention.</li> <li>Skill Enhancement: Encourage human collaborators to continuously enhance their skills, ensuring that the collective expertise of the group grows over time.</li> </ol>"},{"location":"misc/features/human_in_loop/#conclusion","title":"Conclusion","text":"<p>The integration of human expertise with AI capabilities is a cornerstone of the Swarms Multi-Agent Framework. This \"Human-in-the-Loop Task Handling Protocol\" ensures that tasks are executed efficiently, leveraging the best of both human judgment and AI automation. Through collaborative synergy, we can tackle challenges more effectively and drive innovation.</p>"},{"location":"misc/features/info_sec/","title":"Secure Communication Protocols","text":""},{"location":"misc/features/info_sec/#overview","title":"Overview","text":"<p>The Swarms Multi-Agent Framework prioritizes the security and integrity of data, especially personal and sensitive information. Our Secure Communication Protocols ensure that all communications between agents are encrypted, authenticated, and resistant to tampering or unauthorized access.</p>"},{"location":"misc/features/info_sec/#features","title":"Features","text":""},{"location":"misc/features/info_sec/#1-end-to-end-encryption","title":"1. End-to-End Encryption","text":"<ul> <li>All inter-agent communications are encrypted using state-of-the-art cryptographic algorithms.</li> <li>This ensures that data remains confidential and can only be read by the intended recipient agent.</li> </ul>"},{"location":"misc/features/info_sec/#2-authentication","title":"2. Authentication","text":"<ul> <li>Before initiating communication, agents authenticate each other using digital certificates.</li> <li>This prevents impersonation attacks and ensures that agents are communicating with legitimate counterparts.</li> </ul>"},{"location":"misc/features/info_sec/#3-forward-secrecy","title":"3. Forward Secrecy","text":"<ul> <li>Key exchange mechanisms employ forward secrecy, meaning that even if a malicious actor gains access to an encryption key, they cannot decrypt past communications.</li> </ul>"},{"location":"misc/features/info_sec/#4-data-integrity","title":"4. Data Integrity","text":"<ul> <li>Cryptographic hashes ensure that the data has not been altered in transit.</li> <li>Any discrepancies in data integrity result in the communication being rejected.</li> </ul>"},{"location":"misc/features/info_sec/#5-zero-knowledge-protocols","title":"5. Zero-Knowledge Protocols","text":"<ul> <li>When handling especially sensitive data, agents use zero-knowledge proofs to validate information without revealing the actual data.</li> </ul>"},{"location":"misc/features/info_sec/#6-periodic-key-rotation","title":"6. Periodic Key Rotation","text":"<ul> <li>To mitigate the risk of long-term key exposure, encryption keys are periodically rotated.</li> <li>Old keys are securely discarded, ensuring that even if they are compromised, they cannot be used to decrypt communications.</li> </ul>"},{"location":"misc/features/info_sec/#best-practices-for-handling-personal-and-sensitive-information","title":"Best Practices for Handling Personal and Sensitive Information","text":"<ol> <li>Data Minimization: Agents should only request and process the minimum amount of personal data necessary for the task.</li> <li>Anonymization: Whenever possible, agents should anonymize personal data, stripping away identifying details.</li> <li>Data Retention Policies: Personal data should be retained only for the period necessary to complete the task, after which it should be securely deleted.</li> <li>Access Controls: Ensure that only authorized agents have access to personal and sensitive information. Implement strict access control mechanisms.</li> <li>Regular Audits: Conduct regular security audits to ensure compliance with privacy regulations and to detect any potential vulnerabilities.</li> <li>Training: All agents should be regularly updated and trained on the latest security protocols and best practices for handling sensitive data.</li> </ol>"},{"location":"misc/features/info_sec/#conclusion","title":"Conclusion","text":"<p>Secure communication is paramount in the Swarms Multi-Agent Framework, especially when dealing with personal and sensitive information. Adhering to these protocols and best practices ensures the safety, privacy, and trust of all stakeholders involved.</p>"},{"location":"misc/features/promptimizer/","title":"Promptimizer Documentation","text":""},{"location":"misc/features/promptimizer/#swarms-multi-agent-framework","title":"Swarms Multi-Agent Framework","text":"<p>The Promptimizer Tool stands as a cornerstone innovation within the Swarms Multi-Agent Framework, meticulously engineered to refine and supercharge prompts across diverse categories. Capitalizing on extensive libraries of best-practice prompting techniques, this tool ensures your prompts are razor-sharp, tailored, and primed for optimal outcomes.</p>"},{"location":"misc/features/promptimizer/#overview","title":"Overview:","text":"<p>The Promptimizer Tool is crafted to: 1. Rigorously analyze and elevate the quality of provided prompts. 2. Furnish best-in-class recommendations rooted in proven prompting strategies. 3. Serve a spectrum of categories, from technical operations to expansive creative ventures.</p>"},{"location":"misc/features/promptimizer/#core-features","title":"Core Features:","text":""},{"location":"misc/features/promptimizer/#1-deep-prompt-analysis","title":"1. Deep Prompt Analysis:","text":"<ul> <li>Clarity Matrix: A proprietary algorithm assessing prompt clarity, removing ambiguities and sharpening focus.</li> <li>Efficiency Gauge: Evaluates the prompt's structure to ensure swift and precise desired results.</li> </ul>"},{"location":"misc/features/promptimizer/#2-adaptive-recommendations","title":"2. Adaptive Recommendations:","text":"<ul> <li>Technique Engine: Suggests techniques aligned with the gold standard for the chosen category.</li> <li>Exemplar Database: Offers an extensive array of high-quality prompt examples for comparison and inspiration.</li> </ul>"},{"location":"misc/features/promptimizer/#3-versatile-category-framework","title":"3. Versatile Category Framework:","text":"<ul> <li>Tech Suite: Optimizes prompts for technical tasks, ensuring actionable clarity.</li> <li>Narrative Craft: Hones prompts to elicit vivid and coherent stories.</li> <li>Visual Visionary: Shapes prompts for precise and dynamic visual generation.</li> <li>Sonic Sculptor: Orchestrates prompts for audio creation, tuning into desired tones and moods.</li> </ul>"},{"location":"misc/features/promptimizer/#4-machine-learning-integration","title":"4. Machine Learning Integration:","text":"<ul> <li>Feedback Dynamo: Harnesses user feedback, continually refining the tool's recommendation capabilities.</li> <li>Live Library Updates: Periodic syncing with the latest in prompting techniques, ensuring the tool remains at the cutting edge.</li> </ul>"},{"location":"misc/features/promptimizer/#5-collaboration-sharing","title":"5. Collaboration &amp; Sharing:","text":"<ul> <li>TeamSync: Allows teams to collaborate on prompt optimization in real-time.</li> <li>ShareSpace: Share and access a community-driven repository of optimized prompts, fostering collective growth.</li> </ul>"},{"location":"misc/features/promptimizer/#benefits","title":"Benefits:","text":"<ol> <li>Precision Engineering: Harness the power of refined prompts, ensuring desired outcomes are achieved with surgical precision.</li> <li>Learning Hub: Immerse in a tool that not only refines but educates, enhancing the user's prompting acumen.</li> <li>Versatile Mastery: Navigate seamlessly across categories, ensuring top-tier prompt quality regardless of the domain.</li> <li>Community-driven Excellence: Dive into a world of shared knowledge, elevating the collective expertise of the Swarms community.</li> </ol>"},{"location":"misc/features/promptimizer/#usage-workflow","title":"Usage Workflow:","text":"<ol> <li>Launch the Prompt Optimizer: Access the tool directly from the Swarms Multi-Agent Framework dashboard.</li> <li>Prompt Entry: Input the initial prompt for refinement.</li> <li>Category Selection: Pinpoint the desired category for specialized optimization.</li> <li>Receive &amp; Review: Engage with the tool's recommendations, comparing original and optimized prompts.</li> <li>Collaborate, Implement &amp; Share: Work in tandem with team members, deploy the refined prompt, and consider contributing to the community repository.</li> </ol> <p>By integrating the Promptimizer Tool into their workflow, Swarms users stand poised to redefine the boundaries of what's possible, turning each prompt into a beacon of excellence and efficiency.</p>"},{"location":"misc/features/shorthand/","title":"Shorthand Communication System","text":""},{"location":"misc/features/shorthand/#swarms-multi-agent-framework","title":"Swarms Multi-Agent Framework","text":"<p>The Enhanced Shorthand Communication System is designed to streamline agent-agent communication within the Swarms Multi-Agent Framework. This system employs concise alphanumeric notations to relay task-specific details to agents efficiently.</p>"},{"location":"misc/features/shorthand/#format","title":"Format:","text":"<p>The shorthand format is structured as <code>[AgentType]-[TaskLayer].[TaskNumber]-[Priority]-[Status]</code>.</p>"},{"location":"misc/features/shorthand/#components","title":"Components:","text":""},{"location":"misc/features/shorthand/#1-agent-type","title":"1. Agent Type:","text":"<ul> <li>Denotes the specific agent role, such as:</li> <li><code>C</code>: Code agent</li> <li><code>D</code>: Data processing agent</li> <li><code>M</code>: Monitoring agent</li> <li><code>N</code>: Network agent</li> <li><code>R</code>: Resource management agent</li> <li><code>I</code>: Interface agent</li> <li><code>S</code>: Security agent</li> </ul>"},{"location":"misc/features/shorthand/#2-task-layer-number","title":"2. Task Layer &amp; Number:","text":"<ul> <li>Represents the task's category.</li> <li>Example: <code>1.8</code> signifies Task layer 1, task number 8.</li> </ul>"},{"location":"misc/features/shorthand/#3-priority","title":"3. Priority:","text":"<ul> <li>Indicates task urgency.</li> <li><code>H</code>: High</li> <li><code>M</code>: Medium</li> <li><code>L</code>: Low</li> </ul>"},{"location":"misc/features/shorthand/#4-status","title":"4. Status:","text":"<ul> <li>Gives a snapshot of the task's progress.</li> <li><code>I</code>: Initialized</li> <li><code>P</code>: In-progress</li> <li><code>C</code>: Completed</li> <li><code>F</code>: Failed</li> <li><code>W</code>: Waiting</li> </ul>"},{"location":"misc/features/shorthand/#extended-features","title":"Extended Features:","text":""},{"location":"misc/features/shorthand/#1-error-codes-for-failures","title":"1. Error Codes (for failures):","text":"<ul> <li><code>E01</code>: Resource issues</li> <li><code>E02</code>: Data inconsistency</li> <li><code>E03</code>: Dependency malfunction ... and more as needed.</li> </ul>"},{"location":"misc/features/shorthand/#2-collaboration-flag","title":"2. Collaboration Flag:","text":"<ul> <li><code>+</code>: Denotes required collaboration.</li> </ul>"},{"location":"misc/features/shorthand/#example-codes","title":"Example Codes:","text":"<ul> <li><code>C-1.8-H-I</code>: A high-priority coding task that's initializing.</li> <li><code>D-2.3-M-P</code>: A medium-priority data task currently in-progress.</li> <li><code>M-3.5-L-P+</code>: A low-priority monitoring task in progress needing collaboration.</li> </ul> <p>By leveraging the Enhanced Shorthand Communication System, the Swarms Multi-Agent Framework can ensure swift interactions, concise communications, and effective task management.</p>"},{"location":"swarms/contributing/","title":"Contribution Guidelines","text":""},{"location":"swarms/contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Project Overview</li> <li>Getting Started</li> <li>Installation</li> <li>Project Structure</li> <li>How to Contribute</li> <li>Reporting Issues</li> <li>Submitting Pull Requests</li> <li>Coding Standards</li> <li>Type Annotations</li> <li>Docstrings and Documentation</li> <li>Testing</li> <li>Code Style</li> <li>Areas Needing Contributions</li> <li>Writing Tests</li> <li>Improving Documentation</li> <li>Creating Training Scripts</li> <li>Community and Support</li> <li>License</li> </ul>"},{"location":"swarms/contributing/#project-overview","title":"Project Overview","text":"<p>swarms is a library focused on making it simple to orchestrate agents to automate real-world activities. The goal is to automate the world economy with these swarms of agents.</p> <p>We need your help to:</p> <ul> <li>Write Tests: Ensure the reliability and correctness of the codebase.</li> <li>Improve Documentation: Maintain clear and comprehensive documentation.</li> <li>Add New Orchestration Methods: Add multi-agent orchestration methods</li> <li>Removing Defunct Code: Removing bad code</li> </ul> <p>Your contributions will help us push the boundaries of AI and make this library a valuable resource for the community.</p>"},{"location":"swarms/contributing/#getting-started","title":"Getting Started","text":""},{"location":"swarms/contributing/#installation","title":"Installation","text":"<p>You can install swarms using <code>pip</code>:</p> <pre><code>pip3 install swarms\n</code></pre> <p>Alternatively, you can clone the repository:</p> <pre><code>git clone https://github.com/kyegomez/swarms\n</code></pre>"},{"location":"swarms/contributing/#project-structure","title":"Project Structure","text":"<ul> <li><code>swarms/</code>: Contains all the source code for the library.</li> <li><code>examples/</code>: Includes example scripts and notebooks demonstrating how to use the library.</li> <li><code>tests/</code>: (To be created) Will contain unit tests for the library.</li> <li><code>docs/</code>: (To be maintained) Contains documentation files.</li> </ul>"},{"location":"swarms/contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"swarms/contributing/#reporting-issues","title":"Reporting Issues","text":"<p>If you find any bugs, inconsistencies, or have suggestions for enhancements, please open an issue on GitHub:</p> <ol> <li>Search Existing Issues: Before opening a new issue, check if it has already been reported.</li> <li>Open a New Issue: If it hasn't been reported, create a new issue and provide detailed information.</li> <li>Title: A concise summary of the issue.</li> <li>Description: Detailed description, steps to reproduce, expected behavior, and any relevant logs or screenshots.</li> <li>Label Appropriately: Use labels to categorize the issue (e.g., bug, enhancement, documentation).</li> </ol>"},{"location":"swarms/contributing/#submitting-pull-requests","title":"Submitting Pull Requests","text":"<p>We welcome pull requests (PRs) for bug fixes, improvements, and new features. Please follow these guidelines:</p> <ol> <li>Fork the Repository: Create a personal fork of the repository on GitHub.</li> <li>Clone Your Fork: Clone your forked repository to your local machine.</li> </ol> <pre><code>git clone https://github.com/kyegomez/swarms.git\n</code></pre> <ol> <li>Create a New Branch: Use a descriptive branch name.</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n</code></pre> <ol> <li>Make Your Changes: Implement your code, ensuring it adheres to the coding standards.</li> <li>Add Tests: Write tests to cover your changes.</li> <li>Commit Your Changes: Write clear and concise commit messages.</li> </ol> <pre><code>git commit -am \"Add feature X\"\n</code></pre> <ol> <li>Push to Your Fork:</li> </ol> <pre><code>git push origin feature/your-feature-name\n</code></pre> <ol> <li> <p>Create a Pull Request:</p> </li> <li> <p>Go to the original repository on GitHub.</p> </li> <li>Click on \"New Pull Request\".</li> <li>Select your branch and create the PR.</li> <li> <p>Provide a clear description of your changes and reference any related issues.</p> </li> <li> <p>Respond to Feedback: Be prepared to make changes based on code reviews.</p> </li> </ol> <p>Note: It's recommended to create small and focused PRs for easier review and faster integration.</p>"},{"location":"swarms/contributing/#coding-standards","title":"Coding Standards","text":"<p>To maintain code quality and consistency, please adhere to the following standards.</p>"},{"location":"swarms/contributing/#type-annotations","title":"Type Annotations","text":"<ul> <li>Mandatory: All functions and methods must have type annotations.</li> <li>Example:</li> </ul> <pre><code>def add_numbers(a: int, b: int) -&gt; int:\n    return a + b\n</code></pre> <ul> <li>Benefits:</li> <li>Improves code readability.</li> <li>Helps with static type checking tools.</li> </ul>"},{"location":"swarms/contributing/#docstrings-and-documentation","title":"Docstrings and Documentation","text":"<ul> <li>Docstrings: Every public class, function, and method must have a docstring following the Google Python Style Guide or NumPy Docstring Standard.</li> <li>Content:</li> <li>Description: Briefly describe what the function or class does.</li> <li>Args: List and describe each parameter.</li> <li>Returns: Describe the return value(s).</li> <li> <p>Raises: List any exceptions that are raised.</p> </li> <li> <p>Example:</p> </li> </ul> <pre><code>def calculate_mean(values: List[float]) -&gt; float:\n    \"\"\"\n    Calculates the mean of a list of numbers.\n\n    Args:\n        values (List[float]): A list of numerical values.\n\n    Returns:\n        float: The mean of the input values.\n\n    Raises:\n        ValueError: If the input list is empty.\n    \"\"\"\n    if not values:\n        raise ValueError(\"The input list is empty.\")\n    return sum(values) / len(values)\n</code></pre> <ul> <li>Documentation: Update or create documentation pages if your changes affect the public API.</li> </ul>"},{"location":"swarms/contributing/#testing","title":"Testing","text":"<ul> <li>Required: All new features and bug fixes must include appropriate unit tests.</li> <li>Framework: Use <code>unittest</code>, <code>pytest</code>, or a similar testing framework.</li> <li>Test Location: Place tests in the <code>tests/</code> directory, mirroring the structure of <code>swarms/</code>.</li> <li>Test Coverage: Aim for high test coverage to ensure code reliability.</li> <li>Running Tests: Provide instructions for running tests.</li> </ul> <pre><code>pytest tests/\n</code></pre>"},{"location":"swarms/contributing/#code-style","title":"Code Style","text":"<ul> <li>PEP 8 Compliance: Follow PEP 8 style guidelines.</li> <li>Linting Tools: Use <code>flake8</code>, <code>black</code>, or <code>pylint</code> to check code style.</li> <li>Consistency: Maintain consistency with the existing codebase.</li> </ul>"},{"location":"swarms/contributing/#areas-needing-contributions","title":"Areas Needing Contributions","text":"<p>We have several areas where contributions are particularly welcome.</p>"},{"location":"swarms/contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Goal: Increase test coverage to ensure the library's robustness.</li> <li>Tasks:</li> <li>Write unit tests for existing code in <code>swarms/</code>.</li> <li>Identify edge cases and potential failure points.</li> <li>Ensure tests are repeatable and independent.</li> </ul>"},{"location":"swarms/contributing/#improving-documentation","title":"Improving Documentation","text":"<ul> <li>Goal: Maintain clear and comprehensive documentation for users and developers.</li> <li>Tasks:</li> <li>Update docstrings to reflect any changes.</li> <li>Add examples and tutorials in the <code>examples/</code> directory.</li> <li>Improve or expand the content in the <code>docs/</code> directory.</li> </ul>"},{"location":"swarms/contributing/#creating-multi-agent-orchestration-methods","title":"Creating Multi-Agent Orchestration Methods","text":"<ul> <li>Goal: Provide new multi-agent orchestration methods</li> </ul>"},{"location":"swarms/contributing/#community-and-support","title":"Community and Support","text":"<ul> <li>Communication: Engage with the community by participating in discussions on issues and pull requests.</li> <li>Respect: Maintain a respectful and inclusive environment.</li> <li>Feedback: Be open to receiving and providing constructive feedback.</li> </ul>"},{"location":"swarms/contributing/#license","title":"License","text":"<p>By contributing to swarms, you agree that your contributions will be licensed under the MIT License.</p> <p>Thank you for contributing to swarms! Your efforts help make this project better for everyone.</p> <p>If you have any questions or need assistance, please feel free to open an issue or reach out to the maintainers.</p>"},{"location":"swarms/ecosystem/","title":"Swarms Ecosystem","text":"<p>The Complete Enterprise-Grade Multi-Agent AI Platform</p>"},{"location":"swarms/ecosystem/#join-the-future-of-ai-development","title":"Join the Future of AI Development","text":"<p>We're Building the Operating System for the Agent Economy - The Swarms ecosystem represents the most comprehensive, production-ready multi-agent AI platform available today. From our flagship Python framework to high-performance Rust implementations and client libraries spanning every major programming language, we provide enterprise-grade tools that power the next generation of intelligent applications.</p>"},{"location":"swarms/ecosystem/#complete-product-portfolio","title":"Complete Product Portfolio","text":"Product Technology Status Repository Documentation Swarms Python Framework Python Production swarms Docs Swarms Rust Framework Rust Production swarms-rs Docs Python API Client Python Production swarms-sdk Docs TypeScript/Node.js Client TypeScript Production swarms-ts Coming Soon Go Client Go Production swarms-client-go Coming Soon Java Client Java Production swarms-java Coming Soon Kotlin Client Kotlin Q2 2025 In Development Coming Soon Ruby Client Ruby Q2 2025 In Development Coming Soon Rust Client Rust Q2 2025 In Development Coming Soon C#/.NET Client C# Q3 2025 In Development Coming Soon"},{"location":"swarms/ecosystem/#why-choose-the-swarms-ecosystem","title":"Why Choose the Swarms Ecosystem?","text":""},{"location":"swarms/ecosystem/#enterprise-grade-architecture","title":"Enterprise-Grade Architecture","text":"<ul> <li> <p>Production Ready: Battle-tested in enterprise environments with 99.9%+ uptime</p> </li> <li> <p>Scalable Infrastructure: Handle millions of agent interactions with automatic scaling</p> </li> <li> <p>Security First: End-to-end encryption, API key management, and enterprise compliance</p> </li> <li> <p>Observability: Comprehensive logging, monitoring, and debugging capabilities</p> </li> </ul>"},{"location":"swarms/ecosystem/#developer-experience","title":"Developer Experience","text":"<ul> <li> <p>Multiple Language Support: Native clients for every major programming language</p> </li> <li> <p>Unified API: Consistent interface across all platforms and languages</p> </li> <li> <p>Rich Documentation: Comprehensive guides, tutorials, and API references</p> </li> <li> <p>Active Community: 24/7 support through Discord, GitHub, and direct channels</p> </li> </ul>"},{"location":"swarms/ecosystem/#performance-reliability","title":"Performance &amp; Reliability","text":"<ul> <li> <p>High Throughput: Process thousands of concurrent agent requests</p> </li> <li> <p>Low Latency: Optimized for real-time applications and user experiences</p> </li> <li> <p>Fault Tolerance: Automatic retries, circuit breakers, and graceful degradation</p> </li> <li> <p>Multi-Cloud: Deploy on AWS, GCP, Azure, or on-premises infrastructure</p> </li> </ul>"},{"location":"swarms/ecosystem/#join-our-growing-community","title":"Join Our Growing Community","text":""},{"location":"swarms/ecosystem/#connect-with-developers-worldwide","title":"Connect With Developers Worldwide","text":"Platform Purpose Join Link Benefits Discord Community Real-time support &amp; discussions Join Discord \u2022 24/7 developer support\u2022 Weekly community events\u2022 Direct access to core team\u2022 Beta feature previews Twitter/X Latest updates &amp; announcements Follow @swarms_corp \u2022 Breaking news &amp; updates\u2022 Community highlights\u2022 Technical insights\u2022 Industry partnerships LinkedIn Professional network &amp; updates The Swarm Corporation \u2022 Professional networking\u2022 Career opportunities\u2022 Enterprise partnerships\u2022 Industry insights YouTube Tutorials &amp; technical content Swarms Channel \u2022 In-depth tutorials\u2022 Live coding sessions\u2022 Architecture deep dives\u2022 Community showcases"},{"location":"swarms/ecosystem/#contribute-to-the-ecosystem","title":"Contribute to the Ecosystem","text":""},{"location":"swarms/ecosystem/#how-you-can-make-an-impact","title":"How You Can Make an Impact","text":"Contribution Area Skills Needed Impact Level Getting Started Core Framework Development Python, Rust, Systems Design High Impact Contributing Guide Client Library Development Various Languages (Go, Java, TS, etc.) High Impact Client Development Documentation &amp; Tutorials Technical Writing, Examples High Impact Docs Contributing Testing &amp; Quality Assurance Testing Frameworks, QA Medium Impact Testing Guide UI/UX &amp; Design Design, Frontend Development Medium Impact Design Contributions Bug Reports &amp; Feature Requests User Experience, Testing Easy Start Report Issues"},{"location":"swarms/ecosystem/#were-hiring-top-talent","title":"We're Hiring Top Talent","text":""},{"location":"swarms/ecosystem/#join-the-team-building-the-future-of-the-world-economy","title":"Join the Team Building the Future Of The World Economy","text":"<p>Ready to work on cutting-edge agent technology that's shaping the future? We're actively recruiting exceptional engineers, researchers, and technical leaders to join our mission of building the operating system for the agent economy.</p> Why Join Swarms? What We Offer Cutting-Edge Technology Work on the most powerful multi-agent systems, distributed computing, and enterprise-scale infrastructure Global Impact Your code will power agent applications used by Fortune 500 companies and millions of developers World-Class Team Collaborate with top engineers, researchers, and industry experts from Google, OpenAI, and more Fast Growth Join a rapidly scaling company with massive market opportunity and venture backing"},{"location":"swarms/ecosystem/#open-positions","title":"Open Positions","text":"Position Role Description Senior Rust Engineers Building high-performance agent infrastructure Python Framework Engineers Expanding our core multi-agent capabilities DevOps/Platform Engineers Scaling cloud infrastructure for millions of agents Technical Writers Creating world-class developer documentation Solutions Engineers Helping enterprises adopt multi-agent AI <p>Ready to Build the Future? Apply Now at swarms.ai/hiring</p>"},{"location":"swarms/ecosystem/#get-started-today","title":"Get Started Today","text":""},{"location":"swarms/ecosystem/#quick-start-guide","title":"Quick Start Guide","text":"Step Action Time Required 1 Install Swarms Python Framework 5 minutes 2 Run Your First Agent 10 minutes 3 Try Multi-Agent Workflows 15 minutes 4 Join Our Discord Community 2 minutes 5 Explore Enterprise Features 20 minutes"},{"location":"swarms/ecosystem/#enterprise-support-partnerships","title":"Enterprise Support &amp; Partnerships","text":""},{"location":"swarms/ecosystem/#ready-to-scale-with-swarms","title":"Ready to Scale with Swarms?","text":"Contact Type Best For Response Time Contact Information Technical Support Development questions, troubleshooting &lt; 24 hours Book Support Call Enterprise Sales Custom deployments, enterprise licensing &lt; 4 hours kye@swarms.world Partnerships Integration partnerships, technology alliances &lt; 48 hours kye@swarms.world Investor Relations Investment opportunities, funding updates By appointment kye@swarms.world <p>Ready to build the future of AI? Start with Swarms today and join thousands of developers creating the next generation of intelligent applications.</p>"},{"location":"swarms/features/","title":"Feature Set","text":""},{"location":"swarms/features/#enterprise-features","title":"\u2728 Enterprise Features","text":"<p>Swarms delivers a comprehensive, enterprise-grade multi-agent infrastructure platform designed for production-scale deployments and seamless integration with existing systems.</p> Category Enterprise Capabilities Business Value \ud83c\udfe2 Enterprise Architecture \u2022 Production-Ready Infrastructure\u2022 High Availability Systems\u2022 Modular Microservices Design\u2022 Comprehensive Observability\u2022 Backwards Compatibility \u2022 99.9%+ Uptime Guarantee\u2022 Reduced Operational Overhead\u2022 Seamless Legacy Integration\u2022 Enhanced System Monitoring\u2022 Risk-Free Migration Path \ud83e\udd16 Multi-Agent Orchestration \u2022 Hierarchical Agent Swarms\u2022 Parallel Processing Pipelines\u2022 Sequential Workflow Orchestration\u2022 Graph-Based Agent Networks\u2022 Dynamic Agent Composition\u2022 Agent Registry Management \u2022 Complex Business Process Automation\u2022 Scalable Task Distribution\u2022 Flexible Workflow Adaptation\u2022 Optimized Resource Utilization\u2022 Centralized Agent Governance\u2022 Enterprise-Grade Agent Lifecycle Management \ud83d\udd04 Enterprise Integration \u2022 Multi-Model Provider Support\u2022 Custom Agent Development Framework\u2022 Extensive Enterprise Tool Library\u2022 Multiple Memory Systems\u2022 Backwards Compatibility with LangChain, AutoGen, CrewAI\u2022 Standardized API Interfaces \u2022 Vendor-Agnostic Architecture\u2022 Custom Solution Development\u2022 Extended Functionality Integration\u2022 Enhanced Knowledge Management\u2022 Seamless Framework Migration\u2022 Reduced Integration Complexity \ud83d\udcc8 Enterprise Scalability \u2022 Concurrent Multi-Agent Processing\u2022 Intelligent Resource Management\u2022 Load Balancing &amp; Auto-Scaling\u2022 Horizontal Scaling Capabilities\u2022 Performance Optimization\u2022 Capacity Planning Tools \u2022 High-Throughput Processing\u2022 Cost-Effective Resource Utilization\u2022 Elastic Scaling Based on Demand\u2022 Linear Performance Scaling\u2022 Optimized Response Times\u2022 Predictable Growth Planning \ud83d\udee0\ufe0f Developer Experience \u2022 Intuitive Enterprise API\u2022 Comprehensive Documentation\u2022 Active Enterprise Community\u2022 CLI &amp; SDK Tools\u2022 IDE Integration Support\u2022 Code Generation Templates \u2022 Accelerated Development Cycles\u2022 Reduced Learning Curve\u2022 Expert Community Support\u2022 Rapid Deployment Capabilities\u2022 Enhanced Developer Productivity\u2022 Standardized Development Patterns \ud83d\udd10 Enterprise Security \u2022 Comprehensive Error Handling\u2022 Advanced Rate Limiting\u2022 Real-Time Monitoring Integration\u2022 Detailed Audit Logging\u2022 Role-Based Access Control\u2022 Data Encryption &amp; Privacy \u2022 Enhanced System Reliability\u2022 API Security Protection\u2022 Proactive Issue Detection\u2022 Regulatory Compliance Support\u2022 Granular Access Management\u2022 Enterprise Data Protection \ud83d\udcca Advanced Enterprise Features \u2022 SpreadsheetSwarm for Mass Agent Management\u2022 Group Chat for Collaborative AI\u2022 Centralized Agent Registry\u2022 Mixture of Agents for Complex Solutions\u2022 Agent Performance Analytics\u2022 Automated Agent Optimization \u2022 Large-Scale Agent Operations\u2022 Team-Based AI Collaboration\u2022 Centralized Agent Governance\u2022 Sophisticated Problem Solving\u2022 Performance Insights &amp; Optimization\u2022 Continuous Agent Improvement \ud83d\udd0c Provider Ecosystem \u2022 OpenAI Integration\u2022 Anthropic Claude Support\u2022 ChromaDB Vector Database\u2022 Custom Provider Framework\u2022 Multi-Cloud Deployment\u2022 Hybrid Infrastructure Support \u2022 Provider Flexibility &amp; Independence\u2022 Advanced Vector Search Capabilities\u2022 Custom Integration Development\u2022 Cloud-Agnostic Architecture\u2022 Flexible Deployment Options\u2022 Risk Mitigation Through Diversification \ud83d\udcaa Production Readiness \u2022 Automatic Retry Mechanisms\u2022 Asynchronous Processing Support\u2022 Environment Configuration Management\u2022 Type Safety &amp; Validation\u2022 Health Check Endpoints\u2022 Graceful Degradation \u2022 Enhanced System Reliability\u2022 Improved Performance Characteristics\u2022 Simplified Configuration Management\u2022 Reduced Runtime Errors\u2022 Proactive Health Monitoring\u2022 Continuous Service Availability \ud83c\udfaf Enterprise Use Cases \u2022 Industry-Specific Agent Solutions\u2022 Custom Workflow Development\u2022 Regulatory Compliance Support\u2022 Extensible Framework Architecture\u2022 Multi-Tenant Support\u2022 Enterprise SLA Guarantees \u2022 Rapid Industry Deployment\u2022 Flexible Solution Architecture\u2022 Compliance-Ready Implementations\u2022 Future-Proof Technology Investment\u2022 Scalable Multi-Client Operations\u2022 Predictable Service Quality"},{"location":"swarms/features/#missing-a-feature","title":"\ud83d\ude80 Missing a Feature?","text":"<p>Swarms is continuously evolving to meet enterprise needs. If you don't see a specific feature or capability that your organization requires:</p>"},{"location":"swarms/features/#report-missing-features","title":"\ud83d\udcdd Report Missing Features","text":"<ul> <li> <p>Create a GitHub Issue to request new features</p> </li> <li> <p>Describe your use case and business requirements</p> </li> <li> <p>Our team will evaluate and prioritize based on enterprise demand</p> </li> </ul>"},{"location":"swarms/features/#schedule-a-consultation","title":"\ud83d\udcde Schedule a Consultation","text":"<ul> <li> <p>Book a call with our enterprise team for personalized guidance</p> </li> <li> <p>Discuss your specific multi-agent architecture requirements</p> </li> <li> <p>Get expert recommendations for your implementation strategy</p> </li> <li> <p>Explore custom enterprise solutions and integrations</p> </li> </ul> <p>Our team is committed to ensuring Swarms meets your enterprise multi-agent infrastructure needs. We welcome feedback and collaboration to build the most comprehensive platform for production-scale AI agent deployments.</p>"},{"location":"swarms/glossary/","title":"Glossary of Terms","text":"<p>Agent: An LLM (Large Language Model) equipped with tools and memory, operating with a specific objective in a loop. An agent can perform tasks, interact with other agents, and utilize external tools and memory systems to achieve its goals.</p> <p>Swarms: A group of more than two agents working together and communicating to accomplish a shared objective. Swarms enable complex, collaborative tasks that leverage the strengths of multiple agents.</p> <p>Tool: A Python function that is converted into a function call, allowing agents to perform specific actions or access external resources. Tools enhance the capabilities of agents by providing specialized functionalities.</p> <p>Memory System: A system for managing information retrieval and storage, often implemented as a Retrieval-Augmented Generation (RAG) system or a memory vector database. Memory systems enable agents to recall previous interactions, store new information, and improve decision-making based on historical data.</p> <p>LLM (Large Language Model): A type of AI model designed to understand and generate human-like text. LLMs, such as GPT-3 or GPT-4, are used as the core computational engine for agents.</p> <p>System Prompt: A predefined prompt that sets the context and instructions for an agent's task. The system prompt guides the agent's behavior and response generation.</p> <p>Max Loops: The maximum number of iterations an agent will perform to complete its task. This parameter helps control the extent of an agent's processing and ensures tasks are completed efficiently.</p> <p>Dashboard: A user interface that provides real-time monitoring and control over the agents and their activities. Dashboards can display agent status, logs, and performance metrics.</p> <p>Streaming On: A setting that enables agents to stream their output incrementally, providing real-time feedback as they process tasks. This feature is useful for monitoring progress and making adjustments on the fly.</p> <p>Verbose: A setting that controls the level of detail in an agent's output and logging. When verbose mode is enabled, the agent provides more detailed information about its operations and decisions.</p> <p>Multi-modal: The capability of an agent to process and integrate multiple types of data, such as text, images, and audio. Multi-modal agents can handle more complex tasks that require diverse inputs.</p> <p>Autosave: A feature that automatically saves the agent's state and progress at regular intervals. Autosave helps prevent data loss and allows for recovery in case of interruptions.</p> <p>Flow: The predefined sequence in which agents in a swarm interact and process tasks. The flow ensures that each agent's output is appropriately passed to the next agent, facilitating coordinated efforts.</p> <p>Long Term Memory: A component of the memory system that retains information over extended periods, enabling agents to recall and utilize past interactions and experiences.</p> <p>Output Schema: A structured format for the output generated by agents, often defined using data models like Pydantic's BaseModel. Output schemas ensure consistency and clarity in the information produced by agents.</p> <p>By understanding these terms, you can effectively build and orchestrate agents and swarms, leveraging their capabilities to perform complex, collaborative tasks.</p>"},{"location":"swarms/papers/","title":"awesome-multi-agent-papers","text":"<p>An awesome list of multi-agent papers that show you various swarm architectures and much more. Get started</p>"},{"location":"swarms/products/","title":"Swarms Products","text":"<p>Welcome to the official documentation for Swarms, the first multi-agent orchestration framework enabling seamless collaboration between LLMs and other tools to automate business operations at scale. Below, you\u2019ll find detailed descriptions of all Swarms products and services to help you get started and unlock the full potential of this groundbreaking platform.</p> Name Description Link Swarms Marketplace A platform to discover, share, and integrate prompts, agents, and tools. swarms.world Swarms Spreadsheet A tool for managing and scaling thousands of agent outputs, with results saved to a CSV file for easy analysis. swarms.world Drag n Drop Swarm An intuitive interface to visually create and manage swarms of agents through drag-and-drop functionality. swarms.world Swarms API An API enabling seamless integration of swarms of agents into your applications and workflows. swarms.world Wallet API A secure API for managing transactions and interactions within the Swarms ecosystem. Coming Soon Swarm Exchange A marketplace for buying and selling prompts, agents, and tools within the Swarms ecosystem. Coming Soon"},{"location":"swarms/products/#swarms-marketplace","title":"Swarms Marketplace","text":"<p>Website: swarms.world</p> <p>The Swarms Marketplace is your one-stop destination for discovering, adding, and managing:</p> <ul> <li> <p>Prompts: Access and share production-ready prompts for LLMs.</p> </li> <li> <p>Agents: Browse pre-built agents tailored for tasks in marketing, finance,  programming, and more.</p> </li> <li>Tools: Discover cutting-edge tools to enhance agent performance and expand  capabilities.</li> </ul>"},{"location":"swarms/products/#key-features","title":"Key Features:","text":"<ul> <li>Rating System: Evaluate and rate prompts, agents, and tools based on their  effectiveness.</li> <li> <p>Commenting System: Share feedback and insights with the Swarms community.</p> </li> <li> <p>Coming Soon: Buy and sell prompts, agents, and tools directly within the  marketplace.</p> </li> </ul>"},{"location":"swarms/products/#how-to-use","title":"How to Use:","text":"<ol> <li>Sign up at swarms.world.</li> <li>Explore the marketplace categories or search for specific solutions.</li> <li>Add your chosen resources to your Swarms account and integrate them into your operations.</li> </ol>"},{"location":"swarms/products/#swarms-spreadsheet","title":"Swarms Spreadsheet","text":"<p>Website: swarms.world</p> <p>The Swarms Spreadsheet is a powerful tool for managing outputs from thousands of agents efficiently. Ideal for businesses needing scalable solutions, it provides:</p>"},{"location":"swarms/products/#key-features_1","title":"Key Features:","text":"<ul> <li> <p>Batch Task Execution: Assign tasks to multiple agents simultaneously.</p> </li> <li> <p>CSV Integration: Automatically save agent outputs to CSV files for easy analysis.</p> </li> <li> <p>Customizable Agents: Upload single or multiple agents and run repeat tasks with  ease.</p> </li> <li>Metadata Capture: Leverage built-in Pydantic schemas to record all task details  and results.</li> </ul>"},{"location":"swarms/products/#use-cases","title":"Use Cases:","text":"<ul> <li> <p>Marketing: Generate and analyze campaign ideas at scale.</p> </li> <li> <p>Finance: Process financial models and scenarios quickly.</p> </li> <li> <p>Operations: Automate repetitive tasks across multiple domains.</p> </li> </ul>"},{"location":"swarms/products/#how-to-use_1","title":"How to Use:","text":"<ol> <li>Visit swarms.world and navigate to Swarms Spreadsheet.</li> <li>Upload your agents or create new ones.</li> <li>Run tasks and export results to a CSV file for further use.</li> </ol>"},{"location":"swarms/products/#drag-n-drop-swarm","title":"Drag-n-Drop Swarm","text":"<p>Website: swarms.world</p> <p>The Drag-n-Drop Swarm enables non-technical users to create and deploy agent workflows with a simple drag-and-drop interface. It\u2019s perfect for:</p>"},{"location":"swarms/products/#key-features_2","title":"Key Features:","text":"<ul> <li> <p>Visual Workflow Builder: Design agent interactions without writing code.</p> </li> <li> <p>Pre-Built Templates: Start quickly with ready-made workflows for common tasks.</p> </li> <li> <p>Intuitive Interface: Drag, drop, and connect agents to create robust automation  pipelines.</p> </li> </ul>"},{"location":"swarms/products/#how-to-use_2","title":"How to Use:","text":"<ol> <li>Access the Drag-n-Drop Swarm tool at swarms.world.</li> <li>Drag agents from the library into the workspace.</li> <li>Connect and configure agents to execute your desired workflow.</li> <li>Save and deploy your workflow instantly.</li> </ol>"},{"location":"swarms/products/#swarms-api","title":"Swarms API","text":"<p>Website: swarms.world</p> <p>The Swarms API provides developers with the ability to:</p>"},{"location":"swarms/products/#key-features_3","title":"Key Features:","text":"<ul> <li> <p>Agent Management: Programmatically create, update, and delete agents.</p> </li> <li> <p>Task Orchestration: Dynamically assign tasks to agents and monitor their progress.</p> </li> <li> <p>Custom Integration: Seamlessly integrate Swarms functionality into existing  applications and workflows.</p> </li> </ul>"},{"location":"swarms/products/#getting-started","title":"Getting Started:","text":"<ol> <li>Sign up for API access at swarms.world.</li> <li>Obtain your API key and authentication credentials.</li> <li>Refer to the API documentation for endpoint details and usage examples.</li> </ol>"},{"location":"swarms/products/#wallet-api","title":"Wallet API","text":"<p>The Wallet API enables secure and efficient transactions within the Swarms ecosystem, allowing users to:</p>"},{"location":"swarms/products/#key-features_4","title":"Key Features:","text":"<ul> <li> <p>Seamless Transactions: Manage payments for prompts, agents, and tools.</p> </li> <li> <p>Secure Wallets: Store and transfer funds safely within the Swarms platform.</p> </li> <li> <p>Transaction History: Access detailed logs of all wallet activity.</p> </li> </ul>"},{"location":"swarms/products/#getting-started_1","title":"Getting Started:","text":"<ol> <li>Enable your wallet in your Swarms account settings.</li> <li>Use the Wallet API to handle purchases and manage funds.</li> </ol>"},{"location":"swarms/products/#swarm-exchange-coming-soon","title":"Swarm Exchange (Coming Soon)","text":"<p>The Swarm Exchange will revolutionize the way agents and tools are traded in the Swarms ecosystem. It will feature:</p>"},{"location":"swarms/products/#key-features_5","title":"Key Features:","text":"<ul> <li> <p>Decentralized Marketplace: Trade agents and tools securely.</p> </li> <li> <p>Dynamic Pricing: Leverage demand-based pricing for assets.</p> </li> <li> <p>Global Access: Participate in the exchange from anywhere.</p> </li> </ul> <p>Stay tuned for updates on the Swarm Exchange launch.</p>"},{"location":"swarms/products/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p>GitHub Repository: Swarms Framework</p> </li> <li> <p>Documentation: Swarms Documentation</p> </li> <li> <p>Support: Contact us via our Discord Community.</p> </li> </ul> <p>Experience the future of multi-agent collaboration with Swarms. Start building your agentic workflows today!</p>"},{"location":"swarms/support/","title":"Technical Support","text":"<p>Getting Help with the Swarms Multi-Agent Framework</p>"},{"location":"swarms/support/#getting-started-with-support","title":"Getting Started with Support","text":"<p>The Swarms team is committed to providing exceptional technical support to help you build production-grade multi-agent systems. Whether you're experiencing bugs, need implementation guidance, or want to request new features, we have multiple channels to ensure you get the help you need quickly and efficiently.</p>"},{"location":"swarms/support/#support-channels-overview","title":"Support Channels Overview","text":"Support Type Best For Response Time Channel Bug Reports Code issues, errors, unexpected behavior &lt; 24 hours GitHub Issues Feature Requests New capabilities, enhancements &lt; 48 hours Email kye@swarms.world Private Issues Security concerns, enterprise consulting &lt; 4 hours Book Support Call Real-time Help Quick questions, community discussions Immediate Discord Community Documentation Usage guides, examples, tutorials Self-service docs.swarms.world"},{"location":"swarms/support/#reporting-bugs-technical-issues","title":"Reporting Bugs &amp; Technical Issues","text":""},{"location":"swarms/support/#when-to-use-github-issues","title":"When to Use GitHub Issues","text":"<p>Use GitHub Issues for:</p> <ul> <li> <p>Code bugs and errors</p> </li> <li> <p>Installation problems</p> </li> <li> <p>Documentation issues</p> </li> <li> <p>Performance problems</p> </li> <li> <p>API inconsistencies</p> </li> <li> <p>Public technical discussions</p> </li> </ul>"},{"location":"swarms/support/#how-to-create-an-effective-bug-report","title":"How to Create an Effective Bug Report","text":"<ol> <li> <p>Visit our Issues page: https://github.com/kyegomez/swarms/issues</p> </li> <li> <p>Search existing issues to avoid duplicates</p> </li> <li> <p>Click \"New Issue\" and select the appropriate template</p> </li> <li> <p>Include the following information:</p> </li> </ol>"},{"location":"swarms/support/#bug-description","title":"Bug Description","text":"<p>A clear description of what the bug is.</p>"},{"location":"swarms/support/#environment","title":"Environment","text":"<ul> <li> <p>Swarms version: [e.g., 5.9.2]</p> </li> <li> <p>Python version: [e.g., 3.9.0]</p> </li> <li> <p>Operating System: [e.g., Ubuntu 20.04, macOS 14, Windows 11]</p> </li> <li> <p>Model provider: [e.g., OpenAI, Anthropic, Groq]</p> </li> </ul>"},{"location":"swarms/support/#steps-to-reproduce","title":"Steps to Reproduce","text":"<ol> <li>Step one</li> <li>Step two</li> <li>Step three</li> </ol>"},{"location":"swarms/support/#expected-behavior","title":"Expected Behavior","text":"<p>What you expected to happen.</p>"},{"location":"swarms/support/#actual-behavior","title":"Actual Behavior","text":"<p>What actually happened.</p>"},{"location":"swarms/support/#code-sample","title":"Code Sample","text":"<pre><code># Minimal code that reproduces the issue\nfrom swarms import Agent\n\nagent = Agent(model_name=\"gpt-4o-mini\")\nresult = agent.run(\"Your task here\")\n</code></pre>"},{"location":"swarms/support/#error-messages","title":"Error Messages","text":"<p>Paste any error messages or stack traces here</p>"},{"location":"swarms/support/#additional-context","title":"Additional Context","text":"<p>Any other context, screenshots, or logs that might help.</p>"},{"location":"swarms/support/#issue-templates-available","title":"Issue Templates Available","text":"Template Use Case Bug Report Standard bug reporting template Documentation Issues with docs, guides, examples Feature Request Suggesting new functionality Question General questions about usage Enterprise Enterprise-specific issues"},{"location":"swarms/support/#private-enterprise-support","title":"Private &amp; Enterprise Support","text":""},{"location":"swarms/support/#when-to-book-a-private-support-call","title":"When to Book a Private Support Call","text":"<p>Book a private consultation for:</p> <ul> <li> <p>Security vulnerabilities or concerns</p> </li> <li> <p>Enterprise deployment guidance</p> </li> <li> <p>Custom implementation consulting</p> </li> <li> <p>Architecture review sessions</p> </li> <li> <p>Performance optimization</p> </li> <li> <p>Integration troubleshooting</p> </li> <li> <p>Strategic technical planning</p> </li> </ul>"},{"location":"swarms/support/#how-to-schedule-support","title":"How to Schedule Support","text":"<ol> <li> <p>Visit our booking page: https://cal.com/swarms/swarms-technical-support?overlayCalendar=true</p> </li> <li> <p>Select an available time that works for your timezone</p> </li> <li> <p>Provide details about your issue or requirements</p> </li> <li> <p>Prepare for the call:</p> </li> <li> <p>Have your code/environment ready</p> </li> <li> <p>Prepare specific questions</p> </li> <li> <p>Include relevant error messages or logs</p> </li> <li> <p>Share your use case and goals</p> </li> </ol>"},{"location":"swarms/support/#what-to-expect","title":"What to Expect","text":"<ul> <li> <p>Direct access to Swarms core team members</p> </li> <li> <p>Screen sharing for live debugging</p> </li> <li> <p>Custom solutions tailored to your needs</p> </li> <li> <p>Follow-up resources and documentation</p> </li> <li> <p>Priority support for implementation</p> </li> </ul>"},{"location":"swarms/support/#real-time-community-support","title":"Real-Time Community Support","text":""},{"location":"swarms/support/#join-our-discord-community","title":"Join Our Discord Community","text":"<p>Get instant help from our active community of developers and core team members.</p> <p>Discord Benefits:</p> <ul> <li> <p>24/7 availability - Someone is always online</p> </li> <li> <p>Instant responses - Get help in real-time</p> </li> <li> <p>Community wisdom - Learn from other developers</p> </li> <li> <p>Specialized channels - Find the right help quickly</p> </li> <li> <p>Latest updates - Stay informed about new releases</p> </li> </ul>"},{"location":"swarms/support/#discord-channels-guide","title":"Discord Channels Guide","text":"Channel Purpose #general General discussions and introductions #technical-support Technical questions and troubleshooting #showcase Share your Swarms projects and demos #feature-requests Discuss potential new features #announcements Official updates and releases #resources Helpful links, tutorials, and guides"},{"location":"swarms/support/#getting-help-on-discord","title":"Getting Help on Discord","text":"<ol> <li> <p>Join here: https://discord.gg/jM3Z6M9uMq</p> </li> <li> <p>Read the rules and introduce yourself in #general</p> </li> <li> <p>Use the right channel for your question type</p> </li> <li> <p>Provide context when asking questions:    <pre><code>Python version: 3.9\nSwarms version: 5.9.2\nOS: macOS 14\nQuestion: How do I implement custom tools with MCP?\nWhat I tried: [paste your code]\nError: [paste error message]\n</code></pre></p> </li> <li> <p>Be patient and respectful - our community loves helping!</p> </li> </ol>"},{"location":"swarms/support/#feature-requests-enhancement-suggestions","title":"Feature Requests &amp; Enhancement Suggestions","text":""},{"location":"swarms/support/#when-to-email-for-feature-requests","title":"When to Email for Feature Requests","text":"<p>Contact us directly for:</p> <ul> <li> <p>Major new framework capabilities</p> </li> <li> <p>Architecture enhancements</p> </li> <li> <p>New model provider integrations</p> </li> <li> <p>Enterprise-specific features</p> </li> <li> <p>Analytics and monitoring tools</p> </li> <li> <p>UI/UX improvements</p> </li> </ul>"},{"location":"swarms/support/#how-to-submit-feature-requests","title":"How to Submit Feature Requests","text":"<p>Email: kye@swarms.world</p> <p>Subject Format: <code>[FEATURE REQUEST] Brief description</code></p> <p>Include in your email:</p> <pre><code>## Feature Description\nClear description of the proposed feature\n\n## Use Case\nWhy this feature is needed and how it would be used\n\n## Business Impact\nHow this would benefit the Swarms ecosystem\n\n## Technical Requirements\nAny specific technical considerations\n\n## Priority Level\n- Low: Nice to have\n\n- Medium: Would significantly improve workflow\n\n- High: Critical for adoption/production use\n\n\n## Alternatives Considered\nOther solutions you've explored\n\n## Implementation Ideas\nAny thoughts on how this could be implemented\n</code></pre>"},{"location":"swarms/support/#feature-request-process","title":"Feature Request Process","text":"<ol> <li>Email submission with detailed requirements</li> <li>Initial review within 48 hours</li> <li>Technical feasibility assessment</li> <li>Community feedback gathering (if applicable)</li> <li>Roadmap planning and timeline estimation</li> <li>Development and testing</li> <li>Release with documentation</li> </ol>"},{"location":"swarms/support/#self-service-resources","title":"Self-Service Resources","text":"<p>Before reaching out for support, check these resources:</p>"},{"location":"swarms/support/#documentation","title":"Documentation","text":"<ul> <li> <p>Complete Documentation - Comprehensive guides and API reference</p> </li> <li> <p>Installation Guide - Setup and configuration</p> </li> <li> <p>Quick Start - Get up and running fast</p> </li> <li> <p>Examples Gallery - Real-world use cases</p> </li> </ul>"},{"location":"swarms/support/#common-solutions","title":"Common Solutions","text":"Issue Solution Installation fails Check Environment Setup Model not responding Verify API keys in environment variables Import errors Ensure latest version: <code>pip install -U swarms</code> Memory issues Review Performance Guide Agent not working Check Basic Agent Example"},{"location":"swarms/support/#video-tutorials","title":"Video Tutorials","text":"<ul> <li> <p>YouTube Channel - Step-by-step tutorials</p> </li> <li> <p>Live Coding Sessions - Real-world implementations</p> </li> </ul>"},{"location":"swarms/support/#support-checklist","title":"Support Checklist","text":"<p>Before requesting support, please:</p> <ul> <li> <p> Check the documentation for existing solutions</p> </li> <li> <p> Search GitHub issues for similar problems</p> </li> <li> <p> Update to latest version: <code>pip install -U swarms</code></p> </li> <li> <p> Verify environment setup and API keys</p> </li> <li> <p> Test with minimal code to isolate the issue</p> </li> <li> <p> Gather error messages and relevant logs</p> </li> <li> <p> Note your environment (OS, Python version, Swarms version)</p> </li> </ul>"},{"location":"swarms/support/#support-best-practices","title":"Support Best Practices","text":""},{"location":"swarms/support/#for-faster-resolution","title":"For Faster Resolution","text":"<ol> <li>Be Specific: Provide exact error messages and steps to reproduce</li> <li>Include Code: Share minimal, runnable examples</li> <li>Environment Details: Always include version information</li> <li>Search First: Check if your issue has been addressed before</li> <li>One Issue Per Report: Don't combine multiple problems</li> <li>Follow Up: Respond promptly to requests for additional information</li> </ol>"},{"location":"swarms/support/#response-time-expectations","title":"Response Time Expectations","text":"Priority Response Time Resolution Time Critical (Production down) &lt; 2 hours &lt; 24 hours High (Major functionality blocked) &lt; 8 hours &lt; 48 hours Medium (Feature issues) &lt; 24 hours &lt; 1 week Low (Documentation, enhancements) &lt; 48 hours Next release"},{"location":"swarms/support/#contributing-back","title":"Contributing Back","text":"<p>Help improve support for everyone:</p> <ul> <li> <p>Answer questions in Discord or GitHub</p> </li> <li> <p>Improve documentation with your learnings</p> </li> <li> <p>Share examples of successful implementations</p> </li> <li> <p>Report bugs you discover</p> </li> <li> <p>Suggest improvements to this support process</p> </li> </ul> <p>Your contributions make Swarms better for everyone.</p>"},{"location":"swarms/support/#support-channel-summary","title":"Support Channel Summary","text":"Urgency Best Channel Emergency Book Immediate Call Urgent Discord #technical-support Standard GitHub Issues Feature Ideas Email kye@swarms.world <p>We're here to help you succeed with Swarms.</p>"},{"location":"swarms/agents/","title":"Agents Introduction","text":"<p>The Agent class is the core component of the Swarms framework, designed to create intelligent, autonomous AI agents capable of handling complex tasks through multi-modal processing, tool integration, and structured outputs. This comprehensive guide covers all aspects of the Agent class, from basic setup to advanced features.</p>"},{"location":"swarms/agents/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Prerequisites &amp; Installation</li> <li>Basic Agent Configuration</li> <li>Multi-Modal Capabilities</li> <li>Tool Integration</li> <li>Structured Outputs</li> <li>Advanced Features</li> <li>Best Practices</li> <li>Complete Examples</li> </ol>"},{"location":"swarms/agents/#prerequisites-installation","title":"Prerequisites &amp; Installation","text":""},{"location":"swarms/agents/#system-requirements","title":"System Requirements","text":"<ul> <li> <p>Python 3.7+</p> </li> <li> <p>OpenAI API key (for GPT models)</p> </li> <li> <p>Anthropic API key (for Claude models)</p> </li> </ul>"},{"location":"swarms/agents/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/agents/#environment-setup","title":"Environment Setup","text":"<p>Create a <code>.env</code> file with your API keys:</p> <pre><code>OPENAI_API_KEY=\"your-openai-api-key\"\nANTHROPIC_API_KEY=\"your-anthropic-api-key\"\nWORKSPACE_DIR=\"agent_workspace\"\n</code></pre>"},{"location":"swarms/agents/#basic-agent-configuration","title":"Basic Agent Configuration","text":""},{"location":"swarms/agents/#core-agent-structure","title":"Core Agent Structure","text":"<p>The Agent class provides a comprehensive set of parameters for customization:</p> <pre><code>from swarms import Agent\n\n# Basic agent initialization\nagent = Agent(\n    agent_name=\"MyAgent\",\n    agent_description=\"A specialized AI agent for specific tasks\",\n    system_prompt=\"You are a helpful assistant...\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    max_tokens=4096,\n    temperature=0.7,\n    output_type=\"str\",\n    safety_prompt_on=True\n)\n</code></pre>"},{"location":"swarms/agents/#key-configuration-parameters","title":"Key Configuration Parameters","text":"Parameter Type Description Default <code>agent_name</code> str Unique identifier for the agent Required <code>agent_description</code> str Detailed description of capabilities Required <code>system_prompt</code> str Core instructions defining behavior Required <code>model_name</code> str AI model to use \"gpt-4o-mini\" <code>max_loops</code> int Maximum execution loops 1 <code>max_tokens</code> int Maximum response tokens 4096 <code>temperature</code> float Response creativity (0-1) 0.7 <code>output_type</code> str Response format type \"str\" <code>multi_modal</code> bool Enable image processing False <code>safety_prompt_on</code> bool Enable safety checks True"},{"location":"swarms/agents/#simple-example","title":"Simple Example","text":"<pre><code>from swarms import Agent\n\n# Create a basic financial advisor agent\nfinancial_agent = Agent(\n    agent_name=\"Financial-Advisor\",\n    agent_description=\"Personal finance and investment advisor\",\n    system_prompt=\"\"\"You are an expert financial advisor with deep knowledge of:\n    - Investment strategies and portfolio management\n    - Risk assessment and mitigation\n    - Market analysis and trends\n    - Financial planning and budgeting\n\n    Provide clear, actionable advice while considering risk tolerance.\"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    temperature=0.3,\n    output_type=\"str\"\n)\n\n# Run the agent\nresponse = financial_agent.run(\"What are the best investment strategies for a 30-year-old?\")\nprint(response)\n</code></pre>"},{"location":"swarms/agents/#multi-modal-capabilities","title":"Multi-Modal Capabilities","text":""},{"location":"swarms/agents/#image-processing","title":"Image Processing","text":"<p>The Agent class supports comprehensive image analysis through vision-enabled models:</p> <pre><code>from swarms import Agent\n\n# Create a vision-enabled agent\nvision_agent = Agent(\n    agent_name=\"Vision-Analyst\",\n    agent_description=\"Advanced image analysis and quality control agent\",\n    system_prompt=\"\"\"You are an expert image analyst capable of:\n    - Detailed visual inspection and quality assessment\n    - Object detection and classification\n    - Scene understanding and context analysis\n    - Defect identification and reporting\n\n    Provide comprehensive analysis with specific observations.\"\"\",\n    model_name=\"gpt-4o-mini\",  # Vision-enabled model\n    multi_modal=True,  # Enable multi-modal processing\n    max_loops=1,\n    output_type=\"str\"\n)\n\n# Analyze a single image\nresponse = vision_agent.run(\n    task=\"Analyze this image for quality control purposes\",\n    img=\"path/to/image.jpg\"\n)\n\n# Process multiple images\nresponse = vision_agent.run(\n    task=\"Compare these images and identify differences\",\n    imgs=[\"image1.jpg\", \"image2.jpg\", \"image3.jpg\"],\n    summarize_multiple_images=True\n)\n</code></pre>"},{"location":"swarms/agents/#supported-image-formats","title":"Supported Image Formats","text":"Format Description Max Size JPEG/JPG Standard compressed format 20MB PNG Lossless with transparency 20MB GIF Animated (first frame only) 20MB WebP Modern efficient format 20MB"},{"location":"swarms/agents/#quality-control-example","title":"Quality Control Example","text":"<pre><code>from swarms import Agent\nfrom swarms.prompts.logistics import Quality_Control_Agent_Prompt\n\ndef security_analysis(danger_level: str) -&gt; str:\n    \"\"\"Analyze security danger level and return appropriate response.\"\"\"\n    danger_responses = {\n        \"low\": \"No immediate danger detected\",\n        \"medium\": \"Moderate security concern identified\",\n        \"high\": \"Critical security threat detected\",\n        None: \"No danger level assessment available\"\n    }\n    return danger_responses.get(danger_level, \"Unknown danger level\")\n\n# Quality control agent with tool integration\nquality_agent = Agent(\n    agent_name=\"Quality-Control-Agent\",\n    agent_description=\"Advanced quality control and security analysis agent\",\n    system_prompt=f\"\"\"\n    {Quality_Control_Agent_Prompt}\n\n    You have access to security analysis tools. When analyzing images:\n    1. Identify potential safety hazards\n    2. Assess quality standards compliance\n    3. Determine appropriate danger levels (low, medium, high)\n    4. Use the security_analysis function for threat assessment\n    \"\"\",\n    model_name=\"gpt-4o-mini\",\n    multi_modal=True,\n    max_loops=1,\n    tools=[security_analysis]\n)\n\n# Analyze factory image\nresponse = quality_agent.run(\n    task=\"Analyze this factory image for safety and quality issues\",\n    img=\"factory_floor.jpg\"\n)\n</code></pre>"},{"location":"swarms/agents/#tool-integration","title":"Tool Integration","text":""},{"location":"swarms/agents/#creating-custom-tools","title":"Creating Custom Tools","text":"<p>Tools are Python functions that extend your agent's capabilities:</p> <pre><code>import json\nimport requests\nfrom typing import Optional, Dict, Any\n\ndef get_weather_data(city: str, country: Optional[str] = None) -&gt; str:\n    \"\"\"\n    Get current weather data for a specified city.\n\n    Args:\n        city (str): The city name\n        country (Optional[str]): Country code (e.g., 'US', 'UK')\n\n    Returns:\n        str: JSON formatted weather data\n\n    Example:\n        &gt;&gt;&gt; weather = get_weather_data(\"San Francisco\", \"US\")\n        &gt;&gt;&gt; print(weather)\n        {\"temperature\": 18, \"condition\": \"partly cloudy\", ...}\n    \"\"\"\n    try:\n        # API call logic here\n        weather_data = {\n            \"city\": city,\n            \"country\": country,\n            \"temperature\": 18,\n            \"condition\": \"partly cloudy\",\n            \"humidity\": 65,\n            \"wind_speed\": 12\n        }\n        return json.dumps(weather_data, indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"Weather API error: {str(e)}\"})\n\ndef calculate_portfolio_metrics(prices: list, weights: list) -&gt; str:\n    \"\"\"\n    Calculate portfolio performance metrics.\n\n    Args:\n        prices (list): List of asset prices\n        weights (list): List of portfolio weights\n\n    Returns:\n        str: JSON formatted portfolio metrics\n    \"\"\"\n    try:\n        # Portfolio calculation logic\n        portfolio_value = sum(p * w for p, w in zip(prices, weights))\n        metrics = {\n            \"total_value\": portfolio_value,\n            \"weighted_average\": portfolio_value / sum(weights),\n            \"asset_count\": len(prices)\n        }\n        return json.dumps(metrics, indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"Calculation error: {str(e)}\"})\n</code></pre>"},{"location":"swarms/agents/#tool-integration-example","title":"Tool Integration Example","text":"<pre><code>from swarms import Agent\n\n# Create agent with custom tools\nmulti_tool_agent = Agent(\n    agent_name=\"Multi-Tool-Assistant\",\n    agent_description=\"Versatile assistant with weather and financial tools\",\n    system_prompt=\"\"\"You are a versatile assistant with access to:\n    - Weather data retrieval for any city\n    - Portfolio analysis and financial calculations\n\n    Use these tools to provide comprehensive assistance.\"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    tools=[get_weather_data, calculate_portfolio_metrics]\n)\n\n# Use the agent with tools\nresponse = multi_tool_agent.run(\n    \"What's the weather in New York and calculate metrics for a portfolio with prices [100, 150, 200] and weights [0.3, 0.4, 0.3]?\"\n)\n</code></pre>"},{"location":"swarms/agents/#api-integration-tools","title":"API Integration Tools","text":"<pre><code>import requests\nimport json\nfrom typing import List\n\ndef get_cryptocurrency_price(coin_id: str, vs_currency: str = \"usd\") -&gt; str:\n    \"\"\"Get current cryptocurrency price from CoinGecko API.\"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id,\n            \"vs_currencies\": vs_currency,\n            \"include_market_cap\": True,\n            \"include_24hr_vol\": True,\n            \"include_24hr_change\": True\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"API error: {str(e)}\"})\n\ndef get_top_cryptocurrencies(limit: int = 10) -&gt; str:\n    \"\"\"Get top cryptocurrencies by market cap.\"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/coins/markets\"\n        params = {\n            \"vs_currency\": \"usd\",\n            \"order\": \"market_cap_desc\",\n            \"per_page\": limit,\n            \"page\": 1\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"API error: {str(e)}\"})\n\n# Crypto analysis agent\ncrypto_agent = Agent(\n    agent_name=\"Crypto-Analysis-Agent\",\n    agent_description=\"Cryptocurrency market analysis and price tracking agent\",\n    system_prompt=\"\"\"You are a cryptocurrency analysis expert with access to:\n    - Real-time price data for any cryptocurrency\n    - Market capitalization rankings\n    - Trading volume and price change data\n\n    Provide insightful market analysis and investment guidance.\"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    tools=[get_cryptocurrency_price, get_top_cryptocurrencies]\n)\n\n# Analyze crypto market\nresponse = crypto_agent.run(\"Analyze the current Bitcoin price and show me the top 5 cryptocurrencies\")\n</code></pre>"},{"location":"swarms/agents/#structured-outputs","title":"Structured Outputs","text":""},{"location":"swarms/agents/#function-schema-definition","title":"Function Schema Definition","text":"<p>Define structured outputs using OpenAI's function calling format:</p> <pre><code>from swarms import Agent\n\n# Define function schemas for structured outputs\nstock_analysis_schema = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"analyze_stock_performance\",\n        \"description\": \"Analyze stock performance with detailed metrics\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"ticker\": {\n                    \"type\": \"string\",\n                    \"description\": \"Stock ticker symbol (e.g., AAPL, GOOGL)\"\n                },\n                \"analysis_type\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"technical\", \"fundamental\", \"comprehensive\"],\n                    \"description\": \"Type of analysis to perform\"\n                },\n                \"time_period\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"1d\", \"1w\", \"1m\", \"3m\", \"1y\"],\n                    \"description\": \"Time period for analysis\"\n                },\n                \"metrics\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"price\", \"volume\", \"pe_ratio\", \"market_cap\", \"volatility\"]\n                    },\n                    \"description\": \"Metrics to include in analysis\"\n                }\n            },\n            \"required\": [\"ticker\", \"analysis_type\"]\n        }\n    }\n}\n\nportfolio_optimization_schema = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"optimize_portfolio\",\n        \"description\": \"Optimize portfolio allocation based on risk and return\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"assets\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"object\",\n                        \"properties\": {\n                            \"symbol\": {\"type\": \"string\"},\n                            \"current_weight\": {\"type\": \"number\"},\n                            \"expected_return\": {\"type\": \"number\"},\n                            \"risk_level\": {\"type\": \"string\", \"enum\": [\"low\", \"medium\", \"high\"]}\n                        },\n                        \"required\": [\"symbol\", \"current_weight\"]\n                    }\n                },\n                \"risk_tolerance\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"conservative\", \"moderate\", \"aggressive\"]\n                },\n                \"investment_horizon\": {\n                    \"type\": \"integer\",\n                    \"minimum\": 1,\n                    \"maximum\": 30,\n                    \"description\": \"Investment time horizon in years\"\n                }\n            },\n            \"required\": [\"assets\", \"risk_tolerance\"]\n        }\n    }\n}\n\n# Create agent with structured outputs\nstructured_agent = Agent(\n    agent_name=\"Structured-Financial-Agent\",\n    agent_description=\"Financial analysis agent with structured output capabilities\",\n    system_prompt=\"\"\"You are a financial analysis expert that provides structured outputs.\n    Use the provided function schemas to format your responses consistently.\"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    tools_list_dictionary=[stock_analysis_schema, portfolio_optimization_schema]\n)\n\n# Generate structured analysis\nresponse = structured_agent.run(\n    \"Analyze Apple stock (AAPL) performance with comprehensive analysis for the last 3 months\"\n)\n</code></pre>"},{"location":"swarms/agents/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/agents/#dynamic-temperature-control","title":"Dynamic Temperature Control","text":"<pre><code>from swarms import Agent\n\n# Agent with dynamic temperature adjustment\nadaptive_agent = Agent(\n    agent_name=\"Adaptive-Response-Agent\",\n    agent_description=\"Agent that adjusts response creativity based on context\",\n    system_prompt=\"You are an adaptive AI that adjusts your response style based on the task complexity.\",\n    model_name=\"gpt-4o-mini\",\n    dynamic_temperature_enabled=True,  # Enable adaptive temperature\n    max_loops=1,\n    output_type=\"str\"\n)\n</code></pre>"},{"location":"swarms/agents/#output-type-configurations","title":"Output Type Configurations","text":"<pre><code># Different output type examples\njson_agent = Agent(\n    agent_name=\"JSON-Agent\",\n    system_prompt=\"Always respond in valid JSON format\",\n    output_type=\"json\"\n)\n\nstreaming_agent = Agent(\n    agent_name=\"Streaming-Agent\", \n    system_prompt=\"Provide detailed streaming responses\",\n    output_type=\"str-all-except-first\"\n)\n\nfinal_only_agent = Agent(\n    agent_name=\"Final-Only-Agent\",\n    system_prompt=\"Provide only the final result\",\n    output_type=\"final\"\n)\n</code></pre>"},{"location":"swarms/agents/#safety-and-content-filtering","title":"Safety and Content Filtering","text":"<pre><code>from swarms import Agent\n\n# Agent with enhanced safety features\nsafe_agent = Agent(\n    agent_name=\"Safe-Agent\",\n    agent_description=\"Agent with comprehensive safety measures\",\n    system_prompt=\"You are a helpful, harmless, and honest AI assistant.\",\n    model_name=\"gpt-4o-mini\",\n    safety_prompt_on=True,  # Enable safety prompts\n    max_loops=1,\n    temperature=0.3  # Lower temperature for more consistent, safe responses\n)\n</code></pre>"},{"location":"swarms/agents/#best-practices","title":"Best Practices","text":""},{"location":"swarms/agents/#error-handling-and-robustness","title":"Error Handling and Robustness","text":"<pre><code>import logging\nfrom swarms import Agent\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef robust_agent_execution(agent, task, max_retries=3):\n    \"\"\"Execute agent with retry logic and error handling.\"\"\"\n    for attempt in range(max_retries):\n        try:\n            response = agent.run(task)\n            logger.info(f\"Agent execution successful on attempt {attempt + 1}\")\n            return response\n        except Exception as e:\n            logger.error(f\"Attempt {attempt + 1} failed: {str(e)}\")\n            if attempt == max_retries - 1:\n                raise\n            time.sleep(2 ** attempt)  # Exponential backoff\n\n    return None\n\n# Example usage\ntry:\n    result = robust_agent_execution(agent, \"Analyze market trends\")\n    print(result)\nexcept Exception as e:\n    print(f\"Agent execution failed: {e}\")\n</code></pre>"},{"location":"swarms/agents/#performance-optimization","title":"Performance Optimization","text":"<pre><code>from swarms import Agent\nimport time\n\n# Optimized agent configuration\noptimized_agent = Agent(\n    agent_name=\"Optimized-Agent\",\n    agent_description=\"Performance-optimized agent configuration\",\n    system_prompt=\"You are an efficient AI assistant optimized for performance.\",\n    model_name=\"gpt-4o-mini\",  # Faster model\n    max_loops=1,  # Minimize loops\n    max_tokens=2048,  # Reasonable token limit\n    temperature=0.5,  # Balanced creativity\n    output_type=\"str\"\n)\n\n# Batch processing example\ndef process_tasks_batch(agent, tasks, batch_size=5):\n    \"\"\"Process multiple tasks efficiently.\"\"\"\n    results = []\n    for i in range(0, len(tasks), batch_size):\n        batch = tasks[i:i + batch_size]\n        batch_results = []\n\n        for task in batch:\n            start_time = time.time()\n            result = agent.run(task)\n            execution_time = time.time() - start_time\n\n            batch_results.append({\n                \"task\": task,\n                \"result\": result,\n                \"execution_time\": execution_time\n            })\n\n        results.extend(batch_results)\n        time.sleep(1)  # Rate limiting\n\n    return results\n</code></pre>"},{"location":"swarms/agents/#complete-examples","title":"Complete Examples","text":""},{"location":"swarms/agents/#multi-modal-quality-control-system","title":"Multi-Modal Quality Control System","text":"<pre><code>from swarms import Agent\nfrom swarms.prompts.logistics import Quality_Control_Agent_Prompt\n\ndef security_analysis(danger_level: str) -&gt; str:\n    \"\"\"Analyze security danger level and return appropriate response.\"\"\"\n    responses = {\n        \"low\": \"\u2705 No immediate danger detected - Safe to proceed\",\n        \"medium\": \"\u26a0\ufe0f Moderate security concern - Requires attention\",\n        \"high\": \"\ud83d\udea8 Critical security threat - Immediate action required\",\n        None: \"\u2753 No danger level assessment available\"\n    }\n    return responses.get(danger_level, \"Unknown danger level\")\n\ndef quality_assessment(quality_score: int) -&gt; str:\n    \"\"\"Assess quality based on numerical score (1-10).\"\"\"\n    if quality_score &gt;= 8:\n        return \"\u2705 Excellent quality - Meets all standards\"\n    elif quality_score &gt;= 6:\n        return \"\u26a0\ufe0f Good quality - Minor improvements needed\"\n    elif quality_score &gt;= 4:\n        return \"\u274c Poor quality - Significant issues identified\"\n    else:\n        return \"\ud83d\udea8 Critical quality failure - Immediate attention required\"\n\n# Advanced quality control agent\nquality_control_system = Agent(\n    agent_name=\"Advanced-Quality-Control-System\",\n    agent_description=\"Comprehensive quality control and security analysis system\",\n    system_prompt=f\"\"\"\n    {Quality_Control_Agent_Prompt}\n\n    You are an advanced quality control system with the following capabilities:\n\n    1. Visual Inspection: Analyze images for defects, compliance, and safety\n    2. Security Assessment: Identify potential security threats and hazards\n    3. Quality Scoring: Provide numerical quality ratings (1-10 scale)\n    4. Detailed Reporting: Generate comprehensive analysis reports\n\n    When analyzing images:\n    - Identify specific defects or issues\n    - Assess compliance with safety standards\n    - Determine appropriate danger levels (low, medium, high)\n    - Provide quality scores and recommendations\n    - Use available tools for detailed analysis\n\n    Always provide specific, actionable feedback.\n    \"\"\",\n    model_name=\"gpt-4o-mini\",\n    multi_modal=True,\n    max_loops=1,\n    tools=[security_analysis, quality_assessment],\n    output_type=\"str\"\n)\n\n# Process factory images\nfactory_images = [\"factory_floor.jpg\", \"assembly_line.jpg\", \"safety_equipment.jpg\"]\n\nfor image in factory_images:\n    print(f\"\\n--- Analyzing {image} ---\")\n    response = quality_control_system.run(\n        task=f\"Perform comprehensive quality control analysis of this image. Assess safety, quality, and provide specific recommendations.\",\n        img=image\n    )\n    print(response)\n</code></pre>"},{"location":"swarms/agents/#advanced-financial-analysis-agent","title":"Advanced Financial Analysis Agent","text":"<pre><code>from swarms import Agent\nimport json\nimport requests\n\ndef get_market_data(symbol: str, period: str = \"1y\") -&gt; str:\n    \"\"\"Get comprehensive market data for a symbol.\"\"\"\n    # Simulated market data (replace with real API)\n    market_data = {\n        \"symbol\": symbol,\n        \"current_price\": 150.25,\n        \"change_percent\": 2.5,\n        \"volume\": 1000000,\n        \"market_cap\": 2500000000,\n        \"pe_ratio\": 25.5,\n        \"dividend_yield\": 1.8,\n        \"52_week_high\": 180.50,\n        \"52_week_low\": 120.30\n    }\n    return json.dumps(market_data, indent=2)\n\ndef calculate_risk_metrics(prices: list, benchmark_prices: list) -&gt; str:\n    \"\"\"Calculate risk metrics for a portfolio.\"\"\"\n    import numpy as np\n\n    try:\n        returns = np.diff(prices) / prices[:-1]\n        benchmark_returns = np.diff(benchmark_prices) / benchmark_prices[:-1]\n\n        volatility = np.std(returns) * np.sqrt(252)  # Annualized\n        sharpe_ratio = (np.mean(returns) / np.std(returns)) * np.sqrt(252)\n        max_drawdown = np.max(np.maximum.accumulate(prices) - prices) / np.max(prices)\n\n        beta = np.cov(returns, benchmark_returns)[0, 1] / np.var(benchmark_returns)\n\n        risk_metrics = {\n            \"volatility\": float(volatility),\n            \"sharpe_ratio\": float(sharpe_ratio),\n            \"max_drawdown\": float(max_drawdown),\n            \"beta\": float(beta)\n        }\n\n        return json.dumps(risk_metrics, indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"Risk calculation error: {str(e)}\"})\n\n# Financial analysis schemas\nfinancial_analysis_schema = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"comprehensive_financial_analysis\",\n        \"description\": \"Perform comprehensive financial analysis with structured output\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"analysis_summary\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"overall_rating\": {\"type\": \"string\", \"enum\": [\"buy\", \"hold\", \"sell\"]},\n                        \"confidence_level\": {\"type\": \"number\", \"minimum\": 0, \"maximum\": 100},\n                        \"key_strengths\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                        \"key_concerns\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}},\n                        \"price_target\": {\"type\": \"number\"},\n                        \"risk_level\": {\"type\": \"string\", \"enum\": [\"low\", \"medium\", \"high\"]}\n                    }\n                },\n                \"technical_analysis\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"trend_direction\": {\"type\": \"string\", \"enum\": [\"bullish\", \"bearish\", \"neutral\"]},\n                        \"support_levels\": {\"type\": \"array\", \"items\": {\"type\": \"number\"}},\n                        \"resistance_levels\": {\"type\": \"array\", \"items\": {\"type\": \"number\"}},\n                        \"momentum_indicators\": {\"type\": \"array\", \"items\": {\"type\": \"string\"}}\n                    }\n                }\n            },\n            \"required\": [\"analysis_summary\", \"technical_analysis\"]\n        }\n    }\n}\n\n# Advanced financial agent\nfinancial_analyst = Agent(\n    agent_name=\"Advanced-Financial-Analyst\",\n    agent_description=\"Comprehensive financial analysis and investment advisory agent\",\n    system_prompt=\"\"\"You are an expert financial analyst with advanced capabilities in:\n\n    - Fundamental analysis and valuation\n    - Technical analysis and chart patterns\n    - Risk assessment and portfolio optimization\n    - Market sentiment analysis\n    - Economic indicator interpretation\n\n    Your analysis should be:\n    - Data-driven and objective\n    - Risk-aware and practical\n    - Clearly structured and actionable\n    - Compliant with financial regulations\n\n    Use available tools to gather market data and calculate risk metrics.\n    Provide structured outputs using the defined schemas.\"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    tools=[get_market_data, calculate_risk_metrics],\n    tools_list_dictionary=[financial_analysis_schema],\n    output_type=\"json\"\n)\n\n# Comprehensive financial analysis\nanalysis_response = financial_analyst.run(\n    \"Perform a comprehensive analysis of Apple Inc. (AAPL) including technical and fundamental analysis with structured recommendations\"\n)\n\nprint(json.dumps(json.loads(analysis_response), indent=2))\n</code></pre>"},{"location":"swarms/agents/#multi-agent-collaboration-system","title":"Multi-Agent Collaboration System","text":"<pre><code>from swarms import Agent\nimport json\n\n# Specialized agents for different tasks\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Market research and data analysis specialist\",\n    system_prompt=\"You are a market research expert specializing in data collection and analysis.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    temperature=0.3\n)\n\nstrategy_agent = Agent(\n    agent_name=\"Strategy-Advisor\", \n    agent_description=\"Strategic planning and recommendation specialist\",\n    system_prompt=\"You are a strategic advisor providing high-level recommendations based on research.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    temperature=0.5\n)\n\nexecution_agent = Agent(\n    agent_name=\"Execution-Planner\",\n    agent_description=\"Implementation and execution planning specialist\", \n    system_prompt=\"You are an execution expert creating detailed implementation plans.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    temperature=0.4\n)\n\ndef collaborative_analysis(topic: str):\n    \"\"\"Perform collaborative analysis using multiple specialized agents.\"\"\"\n\n    # Step 1: Research Phase\n    research_task = f\"Conduct comprehensive research on {topic}. Provide key findings, market data, and trends.\"\n    research_results = research_agent.run(research_task)\n\n    # Step 2: Strategy Phase\n    strategy_task = f\"Based on this research: {research_results}\\n\\nDevelop strategic recommendations for {topic}.\"\n    strategy_results = strategy_agent.run(strategy_task)\n\n    # Step 3: Execution Phase\n    execution_task = f\"Create a detailed implementation plan based on:\\nResearch: {research_results}\\nStrategy: {strategy_results}\"\n    execution_results = execution_agent.run(execution_task)\n\n    return {\n        \"research\": research_results,\n        \"strategy\": strategy_results,\n        \"execution\": execution_results\n    }\n\n# Example: Collaborative investment analysis\ninvestment_analysis = collaborative_analysis(\"renewable energy sector investment opportunities\")\n\nfor phase, results in investment_analysis.items():\n    print(f\"\\n=== {phase.upper()} PHASE ===\")\n    print(results)\n</code></pre>"},{"location":"swarms/agents/#support-and-resources","title":"Support and Resources","text":"<p>Join our community of agent engineers and researchers for technical support, cutting-edge updates, and exclusive access to world-class agent engineering insights!</p> Platform Description Link \ud83d\udcda Documentation Official documentation and guides docs.swarms.world \ud83d\udcdd Blog Latest updates and technical articles Medium \ud83d\udcac Discord Live chat and community support Join Discord \ud83d\udc26 Twitter Latest news and announcements @kyegomez \ud83d\udc65 LinkedIn Professional network and updates The Swarm Corporation \ud83d\udcfa YouTube Tutorials and demos Swarms Channel \ud83c\udfab Events Join our community events Sign up here \ud83d\ude80 Onboarding Session Get onboarded with Kye Gomez, creator and lead maintainer of Swarms Book Session"},{"location":"swarms/agents/#getting-help","title":"Getting Help","text":"<p>If you encounter issues or need assistance:</p> <ol> <li>Check the Documentation: Start with the official docs for comprehensive guides</li> <li>Search Issues: Look through existing GitHub issues for similar problems</li> <li>Join Discord: Get real-time help from the community</li> <li>Create an Issue: Report bugs or request features on GitHub</li> <li>Follow Updates: Stay informed about new releases and improvements</li> </ol>"},{"location":"swarms/agents/#contributing","title":"Contributing","text":"<p>We welcome contributions! Here's how to get involved:</p> <ul> <li> <p>Report Bugs: Help us improve by reporting issues</p> </li> <li> <p>Suggest Features: Share your ideas for new capabilities</p> </li> <li> <p>Submit Code: Contribute improvements and new features</p> </li> <li> <p>Improve Documentation: Help make our docs better</p> </li> <li> <p>Share Examples: Show how you're using Swarms in your projects</p> </li> </ul> <p>This guide covers the essential aspects of the Swarms Agent class. For the most up-to-date information and advanced features, please refer to the official documentation and community resources.</p>"},{"location":"swarms/agents/abstractagent/","title":"swarms.agents","text":""},{"location":"swarms/agents/abstractagent/#1-introduction","title":"1. Introduction","text":"<p><code>AbstractAgent</code> is an abstract class that serves as a foundation for implementing AI agents. An agent is an entity that can communicate with other agents and perform actions. The <code>AbstractAgent</code> class allows for customization in the implementation of the <code>receive</code> method, enabling different agents to define unique actions for receiving and processing messages.</p> <p><code>AbstractAgent</code> provides capabilities for managing tools and accessing memory, and has methods for running, chatting, and stepping through communication with other agents.</p>"},{"location":"swarms/agents/abstractagent/#2-class-definition","title":"2. Class Definition","text":"<pre><code>class AbstractAgent:\n    \"\"\"An abstract class for AI agent.\n\n    An agent can communicate with other agents and perform actions.\n    Different agents can differ in what actions they perform in the `receive` method.\n\n    Agents are full and completed:\n\n    Agents = llm + tools + memory\n    \"\"\"\n\n    def __init__(self, name: str):\n        \"\"\"\n        Args:\n            name (str): name of the agent.\n        \"\"\"\n        self._name = name\n\n    @property\n    def name(self):\n        \"\"\"Get the name of the agent.\"\"\"\n        return self._name\n\n    def tools(self, tools):\n        \"\"\"init tools\"\"\"\n\n    def memory(self, memory_store):\n        \"\"\"init memory\"\"\"\n\n    def reset(self):\n        \"\"\"(Abstract method) Reset the agent.\"\"\"\n\n    def run(self, task: str):\n        \"\"\"Run the agent once\"\"\"\n\n    def _arun(self, taks: str):\n        \"\"\"Run Async run\"\"\"\n\n    def chat(self, messages: List[Dict]):\n        \"\"\"Chat with the agent\"\"\"\n\n    def _achat(self, messages: List[Dict]):\n        \"\"\"Asynchronous Chat\"\"\"\n\n    def step(self, message: str):\n        \"\"\"Step through the agent\"\"\"\n\n    def _astep(self, message: str):\n        \"\"\"Asynchronous step\"\"\"\n</code></pre>"},{"location":"swarms/agents/abstractagent/#3-functionality-and-usage","title":"3. Functionality and Usage","text":"<p>The <code>AbstractAgent</code> class represents a generic AI agent and provides a set of methods to interact with it.</p> <p>To create an instance of an agent, the <code>name</code> of the agent should be specified.</p>"},{"location":"swarms/agents/abstractagent/#core-methods","title":"Core Methods","text":""},{"location":"swarms/agents/abstractagent/#1-reset","title":"1. <code>reset</code>","text":"<p>The <code>reset</code> method allows the agent to be reset to its initial state.</p> <pre><code>agent.reset()\n</code></pre>"},{"location":"swarms/agents/abstractagent/#2-run","title":"2. <code>run</code>","text":"<p>The <code>run</code> method allows the agent to perform a specific task.</p> <pre><code>agent.run(\"some_task\")\n</code></pre>"},{"location":"swarms/agents/abstractagent/#3-chat","title":"3. <code>chat</code>","text":"<p>The <code>chat</code> method enables communication with the agent through a series of messages.</p> <pre><code>messages = [{\"id\": 1, \"text\": \"Hello, agent!\"}, {\"id\": 2, \"text\": \"How are you?\"}]\nagent.chat(messages)\n</code></pre>"},{"location":"swarms/agents/abstractagent/#4-step","title":"4. <code>step</code>","text":"<p>The <code>step</code> method allows the agent to process a single message.</p> <pre><code>agent.step(\"Hello, agent!\")\n</code></pre>"},{"location":"swarms/agents/abstractagent/#asynchronous-methods","title":"Asynchronous Methods","text":"<p>The class also provides asynchronous variants of the core methods.</p>"},{"location":"swarms/agents/abstractagent/#additional-functionality","title":"Additional Functionality","text":"<p>Additional functionalities for agent initialization and management of tools and memory are also provided.</p> <pre><code>agent.tools(some_tools)\nagent.memory(some_memory_store)\n</code></pre>"},{"location":"swarms/agents/abstractagent/#4-additional-information-and-tips","title":"4. Additional Information and Tips","text":"<p>When implementing a new agent using the <code>AbstractAgent</code> class, ensure that the <code>receive</code> method is overridden to define the specific behavior of the agent upon receiving messages.</p>"},{"location":"swarms/agents/abstractagent/#5-references-and-resources","title":"5. References and Resources","text":"<p>For further exploration and understanding of AI agents and agent communication, refer to the relevant literature and research on this topic.</p>"},{"location":"swarms/agents/agent_judge/","title":"AgentJudge","text":"<p>A specialized agent for evaluating and judging outputs from other agents or systems. Acts as a quality control mechanism providing objective assessments and feedback.</p> <p>Based on the research paper: \"Agent-as-a-Judge: Evaluate Agents with Agents\" - arXiv:2410.10934</p>"},{"location":"swarms/agents/agent_judge/#overview","title":"Overview","text":"<p>The AgentJudge is designed to evaluate and critique outputs from other AI agents, providing structured feedback on quality, accuracy, and areas for improvement. It supports both single-shot evaluations and iterative refinement through multiple evaluation loops with context building.</p> <p>Key capabilities:</p> <ul> <li> <p>Quality Assessment: Evaluates correctness, clarity, and completeness of agent outputs</p> </li> <li> <p>Structured Feedback: Provides detailed critiques with strengths, weaknesses, and suggestions</p> </li> <li> <p>Multimodal Support: Can evaluate text outputs alongside images</p> </li> <li> <p>Context Building: Maintains evaluation context across multiple iterations</p> </li> <li> <p>Batch Processing: Efficiently processes multiple evaluations</p> </li> </ul>"},{"location":"swarms/agents/agent_judge/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Input Task] --&gt; B[AgentJudge]\n    B --&gt; C{Evaluation Mode}\n\n    C --&gt;|step()| D[Single Eval]\n    C --&gt;|run()| E[Iterative Eval]\n    C --&gt;|run_batched()| F[Batch Eval]\n\n    D --&gt; G[Agent Core]\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[LLM Model]\n    H --&gt; I[Quality Analysis]\n    I --&gt; J[Feedback &amp; Output]\n\n    subgraph \"Feedback Details\"\n        N[Strengths]\n        O[Weaknesses]\n        P[Improvements]\n        Q[Accuracy Check]\n    end\n\n    J --&gt; N\n    J --&gt; O\n    J --&gt; P\n    J --&gt; Q\n</code></pre>"},{"location":"swarms/agents/agent_judge/#class-reference","title":"Class Reference","text":""},{"location":"swarms/agents/agent_judge/#constructor","title":"Constructor","text":"<pre><code>AgentJudge(\n    id: str = str(uuid.uuid4()),\n    agent_name: str = \"Agent Judge\",\n    description: str = \"You're an expert AI agent judge...\",\n    system_prompt: str = AGENT_JUDGE_PROMPT,\n    model_name: str = \"openai/o1\",\n    max_loops: int = 1,\n    verbose: bool = False,\n    *args,\n    **kwargs\n)\n</code></pre>"},{"location":"swarms/agents/agent_judge/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>id</code> <code>str</code> <code>str(uuid.uuid4())</code> Unique identifier for the judge instance <code>agent_name</code> <code>str</code> <code>\"Agent Judge\"</code> Name of the agent judge <code>description</code> <code>str</code> <code>\"You're an expert AI agent judge...\"</code> Description of the agent's role <code>system_prompt</code> <code>str</code> <code>AGENT_JUDGE_PROMPT</code> System instructions for evaluation <code>model_name</code> <code>str</code> <code>\"openai/o1\"</code> LLM model for evaluation <code>max_loops</code> <code>int</code> <code>1</code> Maximum evaluation iterations <code>verbose</code> <code>bool</code> <code>False</code> Enable verbose logging"},{"location":"swarms/agents/agent_judge/#methods","title":"Methods","text":""},{"location":"swarms/agents/agent_judge/#step","title":"step()","text":"<pre><code>step(\n    task: str = None,\n    tasks: Optional[List[str]] = None,\n    img: Optional[str] = None\n) -&gt; str\n</code></pre> <p>Processes a single task or list of tasks and returns evaluation.</p> Parameter Type Default Description <code>task</code> <code>str</code> <code>None</code> Single task/output to evaluate <code>tasks</code> <code>List[str]</code> <code>None</code> List of tasks/outputs to evaluate <code>img</code> <code>str</code> <code>None</code> Path to image for multimodal evaluation <p>Returns: <code>str</code> - Detailed evaluation response</p>"},{"location":"swarms/agents/agent_judge/#run","title":"run()","text":"<pre><code>run(\n    task: str = None,\n    tasks: Optional[List[str]] = None,\n    img: Optional[str] = None\n) -&gt; List[str]\n</code></pre> <p>Executes evaluation in multiple iterations with context building.</p> Parameter Type Default Description <code>task</code> <code>str</code> <code>None</code> Single task/output to evaluate <code>tasks</code> <code>List[str]</code> <code>None</code> List of tasks/outputs to evaluate <code>img</code> <code>str</code> <code>None</code> Path to image for multimodal evaluation <p>Returns: <code>List[str]</code> - List of evaluation responses from each iteration</p>"},{"location":"swarms/agents/agent_judge/#run_batched","title":"run_batched()","text":"<pre><code>run_batched(\n    tasks: Optional[List[str]] = None,\n    imgs: Optional[List[str]] = None\n) -&gt; List[List[str]]\n</code></pre> <p>Executes batch evaluation of multiple tasks with corresponding images.</p> Parameter Type Default Description <code>tasks</code> <code>List[str]</code> <code>None</code> List of tasks/outputs to evaluate <code>imgs</code> <code>List[str]</code> <code>None</code> List of image paths (same length as tasks) <p>Returns: <code>List[List[str]]</code> - Evaluation responses for each task</p>"},{"location":"swarms/agents/agent_judge/#examples","title":"Examples","text":""},{"location":"swarms/agents/agent_judge/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms import AgentJudge\n\n# Initialize with default settings\njudge = AgentJudge()\n\n# Single task evaluation\nresult = judge.step(task=\"The capital of France is Paris.\")\nprint(result)\n</code></pre>"},{"location":"swarms/agents/agent_judge/#custom-configuration","title":"Custom Configuration","text":"<pre><code>from swarms import AgentJudge\n\n# Custom judge configuration\njudge = AgentJudge(\n    agent_name=\"content-evaluator\",\n    model_name=\"gpt-4\",\n    max_loops=3,\n    verbose=True\n)\n\n# Evaluate multiple outputs\noutputs = [\n    \"Agent CalculusMaster: The integral of x^2 + 3x + 2 is (1/3)x^3 + (3/2)x^2 + 2x + C\",\n    \"Agent DerivativeDynamo: The derivative of sin(x) is cos(x)\",\n    \"Agent LimitWizard: The limit of sin(x)/x as x approaches 0 is 1\"\n]\n\nevaluation = judge.step(tasks=outputs)\nprint(evaluation)\n</code></pre>"},{"location":"swarms/agents/agent_judge/#iterative-evaluation-with-context","title":"Iterative Evaluation with Context","text":"<pre><code>from swarms import AgentJudge\n\n# Multiple iterations with context building\njudge = AgentJudge(max_loops=3)\n\n# Each iteration builds on previous context\nevaluations = judge.run(task=\"Agent output: 2+2=5\")\nfor i, eval_result in enumerate(evaluations):\n    print(f\"Iteration {i+1}: {eval_result}\\n\")\n</code></pre>"},{"location":"swarms/agents/agent_judge/#multimodal-evaluation","title":"Multimodal Evaluation","text":"<pre><code>from swarms import AgentJudge\n\njudge = AgentJudge()\n\n# Evaluate with image\nevaluation = judge.step(\n    task=\"Describe what you see in this image\",\n    img=\"path/to/image.jpg\"\n)\nprint(evaluation)\n</code></pre>"},{"location":"swarms/agents/agent_judge/#batch-processing","title":"Batch Processing","text":"<pre><code>from swarms import AgentJudge\n\njudge = AgentJudge()\n\n# Batch evaluation with images\ntasks = [\n    \"Describe this chart\",\n    \"What's the main trend?\",\n    \"Any anomalies?\"\n]\nimages = [\n    \"chart1.png\",\n    \"chart2.png\", \n    \"chart3.png\"\n]\n\n# Each task evaluated independently\nevaluations = judge.run_batched(tasks=tasks, imgs=images)\nfor i, task_evals in enumerate(evaluations):\n    print(f\"Task {i+1} evaluations: {task_evals}\")\n</code></pre>"},{"location":"swarms/agents/agent_judge/#reference","title":"Reference","text":"<pre><code>@misc{zhuge2024agentasajudgeevaluateagentsagents,\n    title={Agent-as-a-Judge: Evaluate Agents with Agents}, \n    author={Mingchen Zhuge and Changsheng Zhao and Dylan Ashley and Wenyi Wang and Dmitrii Khizbullin and Yunyang Xiong and Zechun Liu and Ernie Chang and Raghuraman Krishnamoorthi and Yuandong Tian and Yangyang Shi and Vikas Chandra and J\u00fcrgen Schmidhuber},\n    year={2024},\n    eprint={2410.10934},\n    archivePrefix={arXiv},\n    primaryClass={cs.AI},\n    url={https://arxiv.org/abs/2410.10934}\n}\n</code></pre>"},{"location":"swarms/agents/consistency_agent/","title":"Consistency Agent Documentation","text":"<p>The <code>SelfConsistencyAgent</code> is a specialized agent designed for generating multiple independent responses to a given task and aggregating them into a single, consistent final answer. It leverages concurrent processing to enhance efficiency and employs a majority voting mechanism to ensure the reliability of the aggregated response.</p>"},{"location":"swarms/agents/consistency_agent/#purpose","title":"Purpose","text":"<p>The primary objective of the <code>SelfConsistencyAgent</code> is to provide a robust mechanism for decision-making and problem-solving by generating diverse responses and synthesizing them into a coherent final answer. This approach is particularly useful in scenarios where consistency and reliability are critical.</p>"},{"location":"swarms/agents/consistency_agent/#class-selfconsistencyagent","title":"Class: <code>SelfConsistencyAgent</code>","text":""},{"location":"swarms/agents/consistency_agent/#initialization","title":"Initialization","text":"<ul> <li><code>__init__</code>: Initializes the <code>SelfConsistencyAgent</code> with specified parameters.</li> </ul>"},{"location":"swarms/agents/consistency_agent/#arguments","title":"Arguments","text":"Argument Type Default Description <code>name</code> <code>str</code> <code>\"Self-Consistency-Agent\"</code> Name of the agent. <code>description</code> <code>str</code> <code>\"An agent that uses self consistency to generate a final answer.\"</code> Description of the agent's purpose. <code>system_prompt</code> <code>str</code> <code>CONSISTENCY_SYSTEM_PROMPT</code> System prompt for the reasoning agent. <code>model_name</code> <code>str</code> Required The underlying language model to use. <code>num_samples</code> <code>int</code> <code>5</code> Number of independent responses to generate. <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of reasoning loops per sample. <code>majority_voting_prompt</code> <code>Optional[str]</code> <code>majority_voting_prompt</code> Custom prompt for majority voting aggregation. <code>eval</code> <code>bool</code> <code>False</code> Enable evaluation mode for answer validation. <code>output_type</code> <code>OutputType</code> <code>\"dict\"</code> Format of the output. <code>random_models_on</code> <code>bool</code> <code>False</code> Enable random model selection for diversity."},{"location":"swarms/agents/consistency_agent/#methods","title":"Methods","text":"<ul> <li><code>run</code>: Generates multiple responses for the given task and aggregates them.</li> <li>Arguments:<ul> <li><code>task</code> (<code>str</code>): The input prompt.</li> <li><code>img</code> (<code>Optional[str]</code>, optional): Image input for vision tasks.</li> <li><code>answer</code> (<code>Optional[str]</code>, optional): Expected answer for validation (if eval=True).</li> </ul> </li> <li> <p>Returns: <code>Union[str, Dict[str, Any]]</code> - The aggregated final answer.</p> </li> <li> <p><code>aggregation_agent</code>: Aggregates a list of responses into a single final answer using majority voting.</p> </li> <li>Arguments:<ul> <li><code>responses</code> (<code>List[str]</code>): The list of responses.</li> <li><code>prompt</code> (<code>str</code>, optional): Custom prompt for the aggregation agent.</li> <li><code>model_name</code> (<code>str</code>, optional): Model to use for aggregation.</li> </ul> </li> <li> <p>Returns: <code>str</code> - The aggregated answer.</p> </li> <li> <p><code>check_responses_for_answer</code>: Checks if a specified answer is present in any of the provided responses.</p> </li> <li>Arguments:<ul> <li><code>responses</code> (<code>List[str]</code>): A list of responses to check.</li> <li><code>answer</code> (<code>str</code>): The answer to look for in the responses.</li> </ul> </li> <li> <p>Returns: <code>bool</code> - <code>True</code> if the answer is found, <code>False</code> otherwise.</p> </li> <li> <p><code>batched_run</code>: Run the agent on multiple tasks in batch.</p> </li> <li>Arguments:<ul> <li><code>tasks</code> (<code>List[str]</code>): List of tasks to be processed.</li> </ul> </li> <li>Returns: <code>List[Union[str, Dict[str, Any]]]</code> - List of results for each task.</li> </ul>"},{"location":"swarms/agents/consistency_agent/#examples","title":"Examples","text":""},{"location":"swarms/agents/consistency_agent/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code>from swarms.agents.consistency_agent import SelfConsistencyAgent\n\n# Initialize the agent\nagent = SelfConsistencyAgent(\n    name=\"Math-Reasoning-Agent\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    num_samples=5\n)\n\n# Define a task\ntask = \"What is the 40th prime number?\"\n\n# Run the agent\nfinal_answer = agent.run(task)\n\n# Print the final aggregated answer\nprint(\"Final aggregated answer:\", final_answer)\n</code></pre>"},{"location":"swarms/agents/consistency_agent/#example-2-using-custom-majority-voting-prompt","title":"Example 2: Using Custom Majority Voting Prompt","text":"<pre><code>from swarms.agents.consistency_agent import SelfConsistencyAgent\n\n# Initialize the agent with a custom majority voting prompt\nagent = SelfConsistencyAgent(\n    name=\"Reasoning-Agent\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    num_samples=5,\n    majority_voting_prompt=\"Please provide the most common response.\"\n)\n\n# Define a task\ntask = \"Explain the theory of relativity in simple terms.\"\n\n# Run the agent\nfinal_answer = agent.run(task)\n\n# Print the final aggregated answer\nprint(\"Final aggregated answer:\", final_answer)\n</code></pre>"},{"location":"swarms/agents/consistency_agent/#example-3-evaluation-mode","title":"Example 3: Evaluation Mode","text":"<pre><code>from swarms.agents.consistency_agent import SelfConsistencyAgent\n\n# Initialize the agent with evaluation mode\nagent = SelfConsistencyAgent(\n    name=\"Validation-Agent\",\n    model_name=\"gpt-4o-mini\",\n    num_samples=3,\n    eval=True\n)\n\n# Run with expected answer for validation\nresult = agent.run(\"What is 2 + 2?\", answer=\"4\", eval=True)\nif result is not None:\n    print(\"Validation passed:\", result)\nelse:\n    print(\"Validation failed - expected answer not found\")\n</code></pre>"},{"location":"swarms/agents/consistency_agent/#example-4-random-models-for-diversity","title":"Example 4: Random Models for Diversity","text":"<pre><code>from swarms.agents.consistency_agent import SelfConsistencyAgent\n\n# Initialize the agent with random model selection\nagent = SelfConsistencyAgent(\n    name=\"Diverse-Reasoning-Agent\",\n    model_name=\"gpt-4o-mini\",\n    num_samples=5,\n    random_models_on=True\n)\n\n# Run the agent\nresult = agent.run(\"What are the benefits of renewable energy?\")\nprint(\"Diverse reasoning result:\", result)\n</code></pre>"},{"location":"swarms/agents/consistency_agent/#example-5-batch-processing","title":"Example 5: Batch Processing","text":"<pre><code>from swarms.agents.consistency_agent import SelfConsistencyAgent\n\n# Initialize the agent\nagent = SelfConsistencyAgent(\n    name=\"Batch-Processing-Agent\",\n    model_name=\"gpt-4o-mini\",\n    num_samples=3\n)\n\n# Define multiple tasks\ntasks = [\n    \"What is the capital of France?\",\n    \"What is 15 * 23?\",\n    \"Explain photosynthesis in simple terms.\"\n]\n\n# Process all tasks\nresults = agent.batched_run(tasks)\n\n# Print results\nfor i, result in enumerate(results):\n    print(f\"Task {i+1} result: {result}\")\n</code></pre>"},{"location":"swarms/agents/consistency_agent/#key-features","title":"Key Features","text":""},{"location":"swarms/agents/consistency_agent/#self-consistency-technique","title":"Self-Consistency Technique","text":"<p>The agent implements the self-consistency approach based on the research paper \"Self-Consistency Improves Chain of Thought Reasoning in Language Models\" by Wang et al. (2022). This technique:</p> <ol> <li>Generates Multiple Independent Responses: Creates several reasoning paths for the same problem</li> <li>Analyzes Consistency: Examines agreement among different reasoning approaches</li> <li>Aggregates Results: Uses majority voting or consensus building</li> <li>Produces Reliable Output: Delivers a final answer reflecting the most reliable consensus</li> </ol>"},{"location":"swarms/agents/consistency_agent/#benefits","title":"Benefits","text":"<ul> <li>Mitigates Random Errors: Multiple reasoning paths reduce individual path errors</li> <li>Reduces Bias: Diverse approaches minimize single-method biases</li> <li>Improves Reliability: Consensus-based results are more trustworthy</li> <li>Handles Complexity: Better performance on complex problem-solving tasks</li> </ul>"},{"location":"swarms/agents/consistency_agent/#use-cases","title":"Use Cases","text":"<ul> <li>Mathematical Problem Solving: Where accuracy is critical</li> <li>Decision Making: When reliability is paramount</li> <li>Validation Tasks: When answers need verification</li> <li>Complex Reasoning: Multi-step problem solving</li> <li>Research Questions: Where multiple perspectives are valuable</li> </ul>"},{"location":"swarms/agents/consistency_agent/#technical-details","title":"Technical Details","text":""},{"location":"swarms/agents/consistency_agent/#concurrent-execution","title":"Concurrent Execution","text":"<p>The agent uses <code>ThreadPoolExecutor</code> to generate multiple responses concurrently, improving performance while maintaining independence between reasoning paths.</p>"},{"location":"swarms/agents/consistency_agent/#aggregation-process","title":"Aggregation Process","text":"<p>The aggregation uses an AI-powered agent that: - Identifies dominant responses - Analyzes disparities and disagreements - Evaluates consensus strength - Synthesizes minority insights - Provides comprehensive recommendations</p>"},{"location":"swarms/agents/consistency_agent/#output-formats","title":"Output Formats","text":"<p>The agent supports various output types: - <code>\"dict\"</code>: Dictionary format with conversation history - <code>\"str\"</code>: Simple string output - <code>\"list\"</code>: List format - <code>\"json\"</code>: JSON formatted output</p>"},{"location":"swarms/agents/consistency_agent/#limitations","title":"Limitations","text":"<ol> <li>Computational Cost: Higher <code>num_samples</code> increases processing time and cost</li> <li>Model Dependencies: Performance depends on the underlying model capabilities</li> <li>Consensus Challenges: May struggle with tasks where multiple valid approaches exist</li> <li>Memory Usage: Concurrent execution requires more memory resources</li> </ol>"},{"location":"swarms/agents/consistency_agent/#best-practices","title":"Best Practices","text":"<ol> <li>Sample Size: Use 3-7 samples for most tasks; increase for critical decisions</li> <li>Model Selection: Choose models with strong reasoning capabilities</li> <li>Evaluation Mode: Enable for tasks with known correct answers</li> <li>Custom Prompts: Tailor majority voting prompts for specific domains</li> <li>Batch Processing: Use <code>batched_run</code> for multiple related tasks</li> </ol>"},{"location":"swarms/agents/create_agents_yaml/","title":"Building Agents from a YAML File","text":"<p>The <code>create_agents_from_yaml</code> function is designed to dynamically create agents and orchestrate swarms based on configurations defined in a YAML file. It is particularly suited for enterprise use-cases, offering scalability and reliability for agent-based workflows.</p>"},{"location":"swarms/agents/create_agents_yaml/#key-features","title":"Key Features:","text":"<ul> <li>Multi-Agent Creation: Automatically instantiate multiple agents from a YAML file.</li> <li>Swarm Architecture: Supports swarm architectures where agents collaborate to solve complex tasks.</li> <li>Logging with Loguru: Includes robust logging for tracking operations and diagnosing issues.</li> <li>Flexible Return Types: Offers several return types based on the requirements of the system.</li> <li>Customizable: Supports additional arguments (<code>*args</code> and <code>**kwargs</code>) for fine-tuning agent behavior.</li> <li>Error Handling: Handles missing configurations and invalid inputs with meaningful error messages.</li> </ul>"},{"location":"swarms/agents/create_agents_yaml/#parameters","title":"Parameters","text":"Parameter Description Type Default Value Example <code>model</code> A callable representing the model (LLM or other) that agents will use. Callable None <code>OpenAIChat(model_name=\"gpt-4\")</code> <code>yaml_file</code> Path to the YAML file containing agent configurations. String \"agents.yaml\" <code>\"config/agents.yaml\"</code> <code>return_type</code> Determines the type of return object. Options: <code>\"auto\"</code>, <code>\"swarm\"</code>, <code>\"agents\"</code>, <code>\"both\"</code>, <code>\"tasks\"</code>, <code>\"run_swarm\"</code>. String \"auto\" <code>\"both\"</code> <code>*args</code> Additional positional arguments for further customization (e.g., agent behavior). List N/A N/A <code>**kwargs</code> Additional keyword arguments for customization (e.g., specific parameters passed to the agents or swarm). Dict N/A N/A"},{"location":"swarms/agents/create_agents_yaml/#return-types","title":"Return Types","text":"Return Type Description <code>SwarmRouter</code> Returns a <code>SwarmRouter</code> object, orchestrating the created agents, only if swarm architecture is defined in YAML. <code>Agent</code> Returns a single agent if only one is defined. <code>List[Agent]</code> Returns a list of agents if multiple are defined. <code>Tuple</code> If both agents and a swarm are present, returns both as a tuple (<code>SwarmRouter, List[Agent]</code>). <code>List[Dict]</code> Returns a list of task results if tasks were executed. <code>None</code> Returns nothing if an invalid return type is provided or an error occurs."},{"location":"swarms/agents/create_agents_yaml/#detailed-return-types","title":"Detailed Return Types","text":"Return Type Condition Example Return Value <code>\"auto\"</code> Automatically determines the return based on YAML content. <code>SwarmRouter</code> if swarm architecture is defined, otherwise <code>Agent</code> or <code>List[Agent]</code>. <code>\"swarm\"</code> Returns <code>SwarmRouter</code> if present; otherwise returns agents. <code>&lt;SwarmRouter&gt;</code> <code>\"agents\"</code> Returns a list of agents (or a single agent if only one is defined). <code>[&lt;Agent&gt;, &lt;Agent&gt;]</code> or <code>&lt;Agent&gt;</code> <code>\"both\"</code> Returns both <code>SwarmRouter</code> and agents in a tuple. <code>(&lt;SwarmRouter&gt;, [&lt;Agent&gt;, &lt;Agent&gt;])</code> <code>\"tasks\"</code> Returns the task results, if tasks were executed by agents. <code>[{'task': 'task_output'}, {'task2': 'output'}]</code> <code>\"run_swarm\"</code> Executes the swarm (if defined) and returns the result. <code>'Swarm task output here'</code>"},{"location":"swarms/agents/create_agents_yaml/#example-use-cases","title":"Example Use Cases","text":"<ol> <li>Creating Multiple Agents for Financial Analysis</li> </ol> <pre><code>agents:\n  - agent_name: \"Financial-Analysis-Agent\"\n    system_prompt: \"Analyze the best investment strategy for 2024.\"\n    max_loops: 1\n    autosave: true\n    verbose: false\n    context_length: 100000\n    output_type: \"str\"\n    task: \"Analyze stock options for long-term gains.\"\n\n  - agent_name: \"Risk-Analysis-Agent\"\n    system_prompt: \"Evaluate the risk of tech stocks in 2024.\"\n    max_loops: 2\n    autosave: false\n    verbose: true\n    context_length: 50000\n    output_type: \"json\"\n    task: \"What are the riskiest stocks in the tech sector?\"\n</code></pre> <pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_router import SwarmRouter\n\n# Model representing your LLM\ndef model(prompt):\n    return f\"Processed: {prompt}\"\n\n# Create agents and return them as a list\nagents = create_agents_from_yaml(model=model, yaml_file=\"agents.yaml\", return_type=\"agents\")\nprint(agents)\n</code></pre> <ol> <li>Running a Swarm of Agents to Solve a Complex Task</li> </ol> <pre><code>agents:\n  - agent_name: \"Legal-Agent\"\n    system_prompt: \"Provide legal advice on corporate structuring.\"\n    task: \"How to incorporate a business as an LLC?\"\n\nswarm_architecture:\n  name: \"Corporate-Swarm\"\n  description: \"A swarm for helping businesses with legal and tax advice.\"\n  swarm_type: \"ConcurrentWorkflow\"\n  task: \"How can we optimize a business structure for maximum tax efficiency?\"\n  max_loops: 3\n</code></pre> <pre><code>import os\n\nfrom dotenv import load_dotenv\nfrom loguru import logger\nfrom swarm_models import OpenAIChat\n\nfrom swarms.agents.create_agents_from_yaml import (\n    create_agents_from_yaml,\n)\n\n# Load environment variables\nload_dotenv()\n\n# Path to your YAML file\nyaml_file = \"agents_multi_agent.yaml\"\n\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\ntry:\n    # Create agents and run tasks (using 'both' to return agents and task results)\n    task_results = create_agents_from_yaml(\n        model=model, yaml_file=yaml_file, return_type=\"run_swarm\"\n    )\n\n    logger.info(f\"Results from agents: {task_results}\")\nexcept Exception as e:\n    logger.error(f\"An error occurred: {e}\")\n</code></pre> <ol> <li>Returning Both Agents and Tasks</li> </ol> <pre><code>agents:\n  - agent_name: \"Market-Research-Agent\"\n    system_prompt: \"What are the latest trends in AI?\"\n    task: \"Provide a market analysis for AI technologies in 2024.\"\n</code></pre> <pre><code>from swarms.structs.agent import Agent\n\n# Model representing your LLM\ndef model(prompt):\n    return f\"Processed: {prompt}\"\n\n# Create agents and run tasks, return both agents and task results\nswarm, agents = create_agents_from_yaml(model=model, yaml_file=\"agents.yaml\", return_type=\"both\")\nprint(swarm, agents)\n</code></pre>"},{"location":"swarms/agents/create_agents_yaml/#yaml-schema-overview","title":"YAML Schema Overview:","text":"<p>Below is a breakdown of the attributes expected in the YAML configuration file, which governs how agents and swarms are created.</p>"},{"location":"swarms/agents/create_agents_yaml/#yaml-attributes-table","title":"YAML Attributes Table:","text":"Attribute Name Description Type Required Default/Example Value <code>agents</code> List of agents to be created. Each agent must have specific configurations. List of dicts Yes <code>agent_name</code> The name of the agent. String Yes <code>\"Stock-Analysis-Agent\"</code> <code>system_prompt</code> The system prompt that the agent will use. String Yes <code>\"Your full system prompt here\"</code> <code>max_loops</code> Maximum number of iterations or loops for the agent. Integer No 1 <code>autosave</code> Whether the agent should automatically save its state. Boolean No <code>true</code> <code>dashboard</code> Whether to enable a dashboard for the agent. Boolean No <code>false</code> <code>verbose</code> Whether to run the agent in verbose mode (for debugging). Boolean No <code>false</code> <code>dynamic_temperature_enabled</code> Enable dynamic temperature adjustments during agent execution. Boolean No <code>false</code> <code>saved_state_path</code> Path where the agent's state is saved for recovery. String No <code>\"path_to_save_state.json\"</code> <code>user_name</code> Name of the user interacting with the agent. String No <code>\"default_user\"</code> <code>retry_attempts</code> Number of times to retry an operation in case of failure. Integer No 1 <code>context_length</code> Maximum context length for agent interactions. Integer No 100000 <code>return_step_meta</code> Whether to return metadata for each step of the task. Boolean No <code>false</code> <code>output_type</code> The type of output the agent will return (e.g., <code>str</code>, <code>json</code>). String No <code>\"str\"</code> <code>task</code> Task to be executed by the agent (optional). String No <code>\"What is the best strategy for long-term stock investment?\"</code>"},{"location":"swarms/agents/create_agents_yaml/#swarm-architecture-optional","title":"Swarm Architecture (Optional):","text":"Attribute Name Description Type Required Default/Example Value <code>swarm_architecture</code> Defines the swarm configuration. For more information on what can be added to the swarm architecture, please refer to the Swarm Router documentation. Dict No <code>name</code> The name of the swarm. String Yes <code>\"MySwarm\"</code> <code>description</code> Description of the swarm and its purpose. String No <code>\"A swarm for collaborative task solving\"</code> <code>max_loops</code> Maximum number of loops for the swarm. Integer No 5 <code>swarm_type</code> The type of swarm (e.g., <code>ConcurrentWorkflow</code>) <code>SequentialWorkflow</code>. String Yes <code>\"ConcurrentWorkflow\"</code> <code>task</code> The primary task assigned to the swarm. String No <code>\"How can we trademark concepts as a delaware C CORP for free?\"</code>"},{"location":"swarms/agents/create_agents_yaml/#yaml-schema-example","title":"YAML Schema Example:","text":"<p>Below is an updated YAML schema that conforms to the function's expectations:</p> <pre><code>agents:\n  - agent_name: \"Financial-Analysis-Agent\"\n    system_prompt: \"Your full system prompt here\"\n    max_loops: 1\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: true\n    saved_state_path: \"finance_agent.json\"\n    user_name: \"swarms_corp\"\n    retry_attempts: 1\n    context_length: 200000\n    return_step_meta: false\n    output_type: \"str\"\n    # task: \"How can I establish a ROTH IRA to buy stocks and get a tax break?\" # Turn off if using swarm\n\n  - agent_name: \"Stock-Analysis-Agent\"\n    system_prompt: \"Your full system prompt here\"\n    max_loops: 2\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: false\n    saved_state_path: \"stock_agent.json\"\n    user_name: \"stock_user\"\n    retry_attempts: 3\n    context_length: 150000\n    return_step_meta: true\n    output_type: \"json\"\n    # task: \"What is the best strategy for long-term stock investment?\"\n\n# Optional Swarm Configuration\nswarm_architecture:\n  name: \"MySwarm\"\n  description: \"A swarm for collaborative task solving\"\n  max_loops: 5\n  swarm_type: \"ConcurrentWorkflow\"\n  task: \"How can we trademark concepts as a delaware C CORP for free?\" # Main task \n</code></pre>"},{"location":"swarms/agents/create_agents_yaml/#diagram","title":"Diagram","text":"<pre><code>graph TD;\n    A[Task] --&gt;|Send to| B[Financial-Analysis-Agent]\n    A --&gt;|Send to| C[Stock-Analysis-Agent]</code></pre>"},{"location":"swarms/agents/create_agents_yaml/#how-to-use-create_agents_from_yaml-function-with-yaml","title":"How to Use <code>create_agents_from_yaml</code> Function with YAML:","text":"<ul> <li>You need to plug in your specific model until we can create a model router that can fetch any model and set specific settings</li> </ul>"},{"location":"swarms/agents/create_agents_yaml/#example-code","title":"Example Code:","text":"<pre><code>import os\n\nfrom dotenv import load_dotenv\nfrom loguru import logger\nfrom swarm_models import OpenAIChat\n\nfrom swarms.agents.create_agents_from_yaml import (\n    create_agents_from_yaml,\n)\n\n# Load environment variables\nload_dotenv()\n\n# Path to your YAML file\nyaml_file = \"agents.yaml\"\n\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\ntry:\n    # Create agents and run tasks (using 'both' to return agents and task results)\n    task_results = create_agents_from_yaml(\n        model=model, yaml_file=yaml_file, return_type=\"run_swarm\" # \n    )\n\n    logger.info(f\"Results from agents: {task_results}\")\nexcept Exception as e:\n    logger.error(f\"An error occurred: {e}\")\n</code></pre>"},{"location":"swarms/agents/create_agents_yaml/#error-handling","title":"Error Handling:","text":"<ol> <li>FileNotFoundError: If the specified YAML file does not exist.</li> <li>ValueError: Raised if there are invalid or missing configurations in the YAML file.</li> <li>Invalid Return Type: If an invalid return type is specified, the function will raise a <code>ValueError</code>.</li> </ol>"},{"location":"swarms/agents/create_agents_yaml/#conclusion","title":"Conclusion:","text":"<p>The <code>create_agents_from_yaml</code> function provides a flexible and powerful way to dynamically configure and execute agents, supporting a wide range of tasks and configurations for enterprise-level use cases. By following the YAML schema and function signature, users can easily define and manage their agents and swarms.</p>"},{"location":"swarms/agents/external_party_agents/","title":"Swarms External Agent Integration","text":"<p>Integrating external agents from other frameworks like Langchain, Griptape, and more is straightforward using Swarms. Below are step-by-step guides on how to bring these agents into Swarms by creating a new class, implementing the required methods, and ensuring compatibility.</p>"},{"location":"swarms/agents/external_party_agents/#quick-overview","title":"Quick Overview","text":"<ul> <li>Step 1: Create a new class that inherits the <code>Agent</code> class from Swarms.</li> <li>Step 2: Override the <code>.run(task: str) -&gt; str</code> method that will execute the agent and return a string response.</li> <li>Step 3: Optionally, add methods to save outputs to other formats like JSON, logs, or databases.</li> </ul>"},{"location":"swarms/agents/external_party_agents/#agent-class","title":"Agent Class","text":"<p>The primary structure you'll need to integrate any external agent is the <code>Agent</code> class from Swarms. Here\u2019s a template for how your new agent class should be structured:</p> <pre><code>from swarms import Agent\n\nclass ExternalAgent(Agent):\n    def run(self, task: str) -&gt; str:\n        # Implement logic to run external agent\n        pass\n\n    def save_to_json(self, output: str, filepath: str):\n        # Optionally save the result to a JSON file\n        with open(filepath, \"w\") as file:\n            json.dump({\"response\": output}, file)\n</code></pre>"},{"location":"swarms/agents/external_party_agents/#griptape-agent-integration-example","title":"Griptape Agent Integration Example","text":"<p>In this example, we will create a Griptape agent by inheriting from the Swarms <code>Agent</code> class and implementing the <code>run</code> method.</p>"},{"location":"swarms/agents/external_party_agents/#griptape-integration-steps","title":"Griptape Integration Steps:","text":"<ol> <li>Inherit from Swarms Agent: Inherit from the <code>SwarmsAgent</code> class.</li> <li>Create Griptape Agent: Initialize the Griptape agent inside your class and provide it with the necessary tools.</li> <li>Override the <code>run()</code> method: Implement logic to process a task string and execute the Griptape agent.</li> </ol>"},{"location":"swarms/agents/external_party_agents/#griptape-example-code","title":"Griptape Example Code:","text":"<pre><code>from swarms import (\n    Agent as SwarmsAgent,\n)  # Import the base Agent class from Swarms\nfrom griptape.structures import Agent as GriptapeAgent\nfrom griptape.tools import (\n    WebScraperTool,\n    FileManagerTool,\n    PromptSummaryTool,\n)\n\n# Create a custom agent class that inherits from SwarmsAgent\nclass GriptapeSwarmsAgent(SwarmsAgent):\n    def __init__(self, *args, **kwargs):\n        # Initialize the Griptape agent with its tools\n        self.agent = GriptapeAgent(\n            input=\"Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.\",\n            tools=[\n                WebScraperTool(off_prompt=True),\n                PromptSummaryTool(off_prompt=True),\n                FileManagerTool(),\n            ],\n            *args,\n            **kwargs,\n        )\n\n    # Override the run method to take a task and execute it using the Griptape agent\n    def run(self, task: str) -&gt; str:\n        # Extract URL and filename from task\n        url, filename = task.split(\",\")  # Example task string: \"https://example.com, output.txt\"\n        # Execute the Griptape agent\n        result = self.agent.run(url.strip(), filename.strip())\n        # Return the final result as a string\n        return str(result)\n\n\n# Example usage:\ngriptape_swarms_agent = GriptapeSwarmsAgent()\noutput = griptape_swarms_agent.run(\"https://griptape.ai, griptape.txt\")\nprint(output)\n</code></pre>"},{"location":"swarms/agents/external_party_agents/#explanation","title":"Explanation:","text":"<ol> <li>GriptapeSwarmsAgent: The custom class that integrates Griptape into Swarms.</li> <li>run(task: str): This method extracts inputs from the task string and runs the agent using Griptape tools.</li> <li>Tools: The Griptape agent is equipped with web scraping, summarization, and file management tools.</li> </ol>"},{"location":"swarms/agents/external_party_agents/#additional-features","title":"Additional Features:","text":"<p>You can enhance your external agents with additional features such as:</p> <ul> <li> <p>Saving outputs to JSON, databases, or logs.</p> </li> <li> <p>Handling errors and retry mechanisms for robustness.</p> </li> <li> <p>Custom logging with tools like Loguru for extensive debugging.</p> </li> </ul>"},{"location":"swarms/agents/external_party_agents/#langchain-agent-integration-example","title":"Langchain Agent Integration Example","text":"<p>Next, we demonstrate how to integrate a Langchain agent with Swarms by following similar steps.</p>"},{"location":"swarms/agents/external_party_agents/#langchain-integration-steps","title":"Langchain Integration Steps:","text":"<ol> <li>Inherit from Swarms Agent: Inherit from the <code>SwarmsAgent</code> class.</li> <li>Create Langchain Agent: Initialize a Langchain agent with the necessary components (like language models or memory modules).</li> <li>Override the <code>run()</code> method: Pass tasks to the Langchain agent and return the response.</li> </ol>"},{"location":"swarms/agents/external_party_agents/#langchain-example-code","title":"Langchain Example Code:","text":"<pre><code>from swarms import Agent as SwarmsAgent\nfrom langchain import LLMChain\nfrom langchain.llms import OpenAI\nfrom langchain.prompts import PromptTemplate\n\n# Create a custom agent class that inherits from SwarmsAgent\nclass LangchainSwarmsAgent(SwarmsAgent):\n    def __init__(self, *args, **kwargs):\n        # Initialize the Langchain agent with LLM and prompt\n        prompt_template = PromptTemplate(template=\"Answer the question: {question}\")\n        llm = OpenAI(model=\"gpt-3.5-turbo\")\n        self.chain = LLMChain(llm=llm, prompt=prompt_template)\n        super().__init__(*args, **kwargs)\n\n    # Override the run method to take a task and execute it using the Langchain agent\n    def run(self, task: str) -&gt; str:\n        # Pass the task to the Langchain agent\n        result = self.chain.run({\"question\": task})\n        # Return the final result as a string\n        return result\n\n# Example usage:\nlangchain_swarms_agent = LangchainSwarmsAgent()\noutput = langchain_swarms_agent.run(\"What is the capital of France?\")\nprint(output)\n</code></pre>"},{"location":"swarms/agents/external_party_agents/#explanation_1","title":"Explanation:","text":"<ol> <li>LangchainSwarmsAgent: The custom class integrates Langchain into Swarms.</li> <li>run(task: str): The task is passed to a language model via Langchain and returns a result.</li> </ol>"},{"location":"swarms/agents/external_party_agents/#additional-examples-from-other-providers","title":"Additional Examples from other providers","text":""},{"location":"swarms/agents/external_party_agents/#1-openai-function-calling-agents","title":"1. OpenAI Function Calling Agents","text":"<ul> <li>Description: OpenAI models like GPT-4 can now call functions programmatically. This makes it possible to create agents that execute external functions, APIs, or code snippets.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nimport openai\n\n# Custom OpenAI Function Calling Agent\nclass OpenAIFunctionAgent(SwarmsAgent):\n    def __init__(self, *args, **kwargs):\n        # Initialize OpenAI API credentials and settings\n        self.api_key = \"your_openai_api_key\"\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        # Example task: \"summarize, 'Provide a short summary of this text...'\"\n        command, input_text = task.split(\", \")\n        response = openai.Completion.create(\n            model=\"gpt-4\",\n            prompt=f\"{command}: {input_text}\",\n            temperature=0.5,\n            max_tokens=100,\n        )\n        return response.choices[0].text.strip()\n\n# Example usage:\nopenai_agent = OpenAIFunctionAgent()\noutput = openai_agent.run(\"summarize, Provide a short summary of this text...\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#2-rasa-agents","title":"2. Rasa Agents","text":"<ul> <li>Description: Rasa is a popular open-source framework for building conversational AI agents. You can integrate Rasa to build dialogue-based agents with Swarms.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nfrom rasa.core.agent import Agent as RasaAgent\nfrom rasa.core.interpreter import RasaNLUInterpreter\n\n# Custom Rasa Swarms Agent\nclass RasaSwarmsAgent(SwarmsAgent):\n    def __init__(self, model_path: str, *args, **kwargs):\n        # Initialize the Rasa agent with a pre-trained model\n        self.agent = RasaAgent.load(model_path)\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        # Pass user input to the Rasa agent\n        result = self.agent.handle_text(task)\n        # Return the final response from the agent\n        return result[0][\"text\"] if result else \"No response.\"\n\n# Example usage:\nrasa_swarms_agent = RasaSwarmsAgent(\"path/to/rasa_model\")\noutput = rasa_swarms_agent.run(\"Hello, how can I get a refund?\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#3-hugging-face-transformers","title":"3. Hugging Face Transformers","text":"<ul> <li>Description: Hugging Face offers a variety of pre-trained models, including transformers for NLP tasks. These can be easily integrated into Swarms for various tasks like text generation, question answering, and more.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nfrom transformers import pipeline\n\n# Custom Hugging Face Agent\nclass HuggingFaceSwarmsAgent(SwarmsAgent):\n    def __init__(self, model_name: str, *args, **kwargs):\n        # Initialize a pre-trained pipeline from Hugging Face\n        self.pipeline = pipeline(\"text-generation\", model=model_name)\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        # Generate text based on the task input\n        result = self.pipeline(task, max_length=50)\n        return result[0][\"generated_text\"]\n\n# Example usage:\nhf_swarms_agent = HuggingFaceSwarmsAgent(\"gpt2\")\noutput = hf_swarms_agent.run(\"Once upon a time in a land far, far away...\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#4-autogpt-or-babyagi","title":"4. AutoGPT or BabyAGI","text":"<ul> <li>Description: AutoGPT and BabyAGI are agent frameworks designed to be autonomous, where agents can recursively execute tasks and create new tasks based on previous outputs.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nfrom autogpt import AutoGPT\n\n# Custom AutoGPT Agent\nclass AutoGPTSwarmsAgent(SwarmsAgent):\n    def __init__(self, config, *args, **kwargs):\n        # Initialize AutoGPT with configuration\n        self.agent = AutoGPT(config)\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        # Execute task recursively using AutoGPT\n        result = self.agent.run(task)\n        return result\n\n# Example usage:\nautogpt_swarms_agent = AutoGPTSwarmsAgent({\"goal\": \"Solve world hunger\"})\noutput = autogpt_swarms_agent.run(\"Develop a plan to solve world hunger.\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#5-dialogflow-agents","title":"5. DialogFlow Agents","text":"<ul> <li>Description: DialogFlow by Google is used to build conversational agents. These agents can process user intents and deliver responses based on predefined conversation flows.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nfrom google.cloud import dialogflow\n\n# Custom DialogFlow Agent\nclass DialogFlowSwarmsAgent(SwarmsAgent):\n    def __init__(self, project_id: str, session_id: str, *args, **kwargs):\n        # Initialize DialogFlow session client\n        self.session_client = dialogflow.SessionsClient()\n        self.project_id = project_id\n        self.session_id = session_id\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        session = self.session_client.session_path(self.project_id, self.session_id)\n        text_input = dialogflow.TextInput(text=task, language_code=\"en-US\")\n        query_input = dialogflow.QueryInput(text=text_input)\n        response = self.session_client.detect_intent(\n            request={\"session\": session, \"query_input\": query_input}\n        )\n        return response.query_result.fulfillment_text\n\n# Example usage:\ndialogflow_swarms_agent = DialogFlowSwarmsAgent(\"your_project_id\", \"your_session_id\")\noutput = dialogflow_swarms_agent.run(\"Book me a flight to Paris.\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#6-chatterbot-agents","title":"6. ChatterBot Agents","text":"<ul> <li>Description: ChatterBot is a Python-based machine-learning conversational agent. It learns from previous conversations to generate intelligent responses.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nfrom chatterbot import ChatBot\n\n# Custom ChatterBot Agent\nclass ChatterBotSwarmsAgent(SwarmsAgent):\n    def __init__(self, name: str, *args, **kwargs):\n        # Initialize ChatterBot\n        self.agent = ChatBot(name)\n        super().__init__(*args, **kwargs)\n\n    def run(self, task: str) -&gt; str:\n        # Get a response from ChatterBot based on user input\n        response = self.agent.get_response(task)\n        return str(response)\n\n# Example usage:\nchatterbot_swarms_agent = ChatterBotSwarmsAgent(\"Assistant\")\noutput = chatterbot_swarms_agent.run(\"What is the capital of Italy?\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#7-custom-apis-as-agents","title":"7. Custom APIs as Agents","text":"<ul> <li>Description: You can create agents that integrate with any REST or GraphQL API by defining them as a task runner within Swarms. This allows for interaction with third-party services.</li> </ul> <p>## Example Integration:   <pre><code>from swarms import Agent as SwarmsAgent\nimport requests\n\n# Custom API Agent\nclass APIAgent(SwarmsAgent):\n    def run(self, task: str) -&gt; str:\n        # Parse task for API endpoint and parameters\n        endpoint, params = task.split(\", \")\n        response = requests.get(endpoint, params={\"q\": params})\n        return response.text\n\n# Example usage:\napi_swarms_agent = APIAgent()\noutput = api_swarms_agent.run(\"https://api.example.com/search, python\")\nprint(output)\n</code></pre></p>"},{"location":"swarms/agents/external_party_agents/#summary-of-integrations","title":"Summary of Integrations:","text":"<ul> <li> <p>Griptape: Integrate with tools for web scraping, summarization, etc.</p> </li> <li> <p>Langchain: Use powerful language model orchestration.</p> </li> <li> <p>OpenAI Function Calling: Directly run OpenAI API-based agents.</p> </li> <li> <p>Rasa: Build and integrate conversational agents.</p> </li> <li> <p>Hugging Face: Leverage transformer models.</p> </li> <li> <p>AutoGPT/BabyAGI: Recursive, autonomous task execution.</p> </li> <li> <p>DialogFlow: Integrate conversational flows for voice/chat-based systems.</p> </li> <li> <p>ChatterBot: Machine-learning conversational agents.</p> </li> <li> <p>Custom APIs: Leverage external APIs as agents for custom workflows.</p> </li> </ul>"},{"location":"swarms/agents/external_party_agents/#conclusion","title":"Conclusion:","text":"<p>By following the steps outlined above, you can seamlessly integrate external agent frameworks like Griptape and Langchain into Swarms. This makes Swarms a highly versatile platform for orchestrating various agentic workflows and leveraging the unique capabilities of different frameworks.</p> <p>For more examples and use cases, please refer to the official Swarms documentation site.</p>"},{"location":"swarms/agents/gkp_agent/","title":"Generated Knowledge Prompting (GKP) Agent","text":"<p>The GKP Agent is a sophisticated reasoning system that enhances its capabilities by generating relevant knowledge before answering queries. This approach, inspired by Liu et al. 2022, is particularly effective for tasks requiring commonsense reasoning and factual information.</p>"},{"location":"swarms/agents/gkp_agent/#overview","title":"Overview","text":"<p>The GKP Agent consists of three main components: 1. Knowledge Generator - Creates relevant factual information 2. Reasoner - Uses generated knowledge to form answers 3. Coordinator - Synthesizes multiple reasoning paths into a final answer</p>"},{"location":"swarms/agents/gkp_agent/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Input Query] --&gt; B[Knowledge Generator]\n    B --&gt; C[Generate Knowledge Items]\n    C --&gt; D[Reasoner]\n    D --&gt; E[Multiple Reasoning Paths]\n    E --&gt; F[Coordinator]\n    F --&gt; G[Final Answer]\n\n    subgraph \"Knowledge Generation\"\n        B\n        C\n    end\n\n    subgraph \"Reasoning\"\n        D\n        E\n    end\n\n    subgraph \"Coordination\"\n        F\n        G\n    end</code></pre>"},{"location":"swarms/agents/gkp_agent/#use-cases","title":"Use Cases","text":"<pre><code>graph LR\n    A[GKP Agent] --&gt; B[Commonsense Reasoning]\n    A --&gt; C[Factual Question Answering]\n    A --&gt; D[Complex Problem Solving]\n    A --&gt; E[Multi-step Reasoning]\n\n    B --&gt; B1[Everyday Logic]\n    B --&gt; B2[Social Situations]\n\n    C --&gt; C1[Historical Facts]\n    C --&gt; C2[Scientific Information]\n\n    D --&gt; D1[Technical Analysis]\n    D --&gt; D2[Decision Making]\n\n    E --&gt; E1[Chain of Thought]\n    E --&gt; E2[Multi-perspective Analysis]</code></pre>"},{"location":"swarms/agents/gkp_agent/#api-reference","title":"API Reference","text":""},{"location":"swarms/agents/gkp_agent/#gkpagent","title":"GKPAgent","text":"<p>The main agent class that orchestrates the knowledge generation and reasoning process.</p>"},{"location":"swarms/agents/gkp_agent/#initialization-parameters","title":"Initialization Parameters","text":"Parameter Type Default Description agent_name str \"gkp-agent\" Name identifier for the agent model_name str \"openai/o1\" LLM model to use for all components num_knowledge_items int 6 Number of knowledge snippets to generate per query"},{"location":"swarms/agents/gkp_agent/#methods","title":"Methods","text":"Method Description Parameters Returns process(query: str) Process a single query through the GKP pipeline query: str Dict[str, Any] containing full processing results run(queries: List[str], detailed_output: bool = False) Process multiple queries queries: List[str], detailed_output: bool Union[List[str], List[Dict[str, Any]]]"},{"location":"swarms/agents/gkp_agent/#knowledgegenerator","title":"KnowledgeGenerator","text":"<p>Component responsible for generating relevant knowledge for queries.</p>"},{"location":"swarms/agents/gkp_agent/#initialization-parameters_1","title":"Initialization Parameters","text":"Parameter Type Default Description agent_name str \"knowledge-generator\" Name identifier for the knowledge generator agent model_name str \"openai/o1\" Model to use for knowledge generation num_knowledge_items int 2 Number of knowledge items to generate per query"},{"location":"swarms/agents/gkp_agent/#methods_1","title":"Methods","text":"Method Description Parameters Returns generate_knowledge(query: str) Generate relevant knowledge for a query query: str List[str] of generated knowledge statements"},{"location":"swarms/agents/gkp_agent/#reasoner","title":"Reasoner","text":"<p>Component that uses generated knowledge to reason about and answer queries.</p>"},{"location":"swarms/agents/gkp_agent/#initialization-parameters_2","title":"Initialization Parameters","text":"Parameter Type Default Description agent_name str \"knowledge-reasoner\" Name identifier for the reasoner agent model_name str \"openai/o1\" Model to use for reasoning"},{"location":"swarms/agents/gkp_agent/#methods_2","title":"Methods","text":"Method Description Parameters Returns reason_and_answer(query: str, knowledge: str) Reason about a query using provided knowledge query: str, knowledge: str Dict[str, str] containing explanation, confidence, and answer"},{"location":"swarms/agents/gkp_agent/#example-usage","title":"Example Usage","text":"<pre><code>from swarms.agents.gkp_agent import GKPAgent\n\n# Initialize the GKP Agent\nagent = GKPAgent(\n    agent_name=\"gkp-agent\",\n    model_name=\"gpt-4\",  # Using OpenAI's model\n    num_knowledge_items=6,  # Generate 6 knowledge items per query\n)\n\n# Example queries\nqueries = [\n    \"What are the implications of quantum entanglement on information theory?\",\n]\n\n# Run the agent\nresults = agent.run(queries)\n\n# Print results\nfor i, result in enumerate(results):\n    print(f\"\\nQuery {i+1}: {queries[i]}\")\n    print(f\"Answer: {result}\")\n</code></pre>"},{"location":"swarms/agents/gkp_agent/#best-practices","title":"Best Practices","text":"<ol> <li>Knowledge Generation</li> <li>Set appropriate number of knowledge items based on query complexity</li> <li>Monitor knowledge quality and relevance</li> <li> <p>Adjust model parameters for optimal performance</p> </li> <li> <p>Reasoning Process</p> </li> <li>Ensure diverse reasoning paths for complex queries</li> <li>Validate confidence levels</li> <li> <p>Consider multiple perspectives</p> </li> <li> <p>Coordination</p> </li> <li>Review coordination logic for complex scenarios</li> <li>Validate final answers against source knowledge</li> <li>Monitor processing time and optimize if needed</li> </ol>"},{"location":"swarms/agents/gkp_agent/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Processing time increases with number of knowledge items</li> <li>Complex queries may require more knowledge items</li> <li>Consider caching frequently used knowledge</li> <li>Monitor token usage for cost optimization</li> </ul>"},{"location":"swarms/agents/gkp_agent/#error-handling","title":"Error Handling","text":"<p>The agent includes robust error handling for: - Invalid queries - Failed knowledge generation - Reasoning errors - Coordination failures</p>"},{"location":"swarms/agents/iterative_agent/","title":"Iterative Reflective Expansion (IRE) Algorithm Documentation","text":"<p>The Iterative Reflective Expansion (IRE) Algorithm is a sophisticated reasoning framework that employs iterative hypothesis generation, simulation, and refinement to solve complex problems. It leverages a multi-step approach where an AI agent generates initial solution paths, evaluates their effectiveness through simulation, reflects on errors, and dynamically revises reasoning strategies. Through continuous cycles of hypothesis testing and meta-cognitive reflection, the algorithm progressively converges on optimal solutions by learning from both successful and unsuccessful reasoning attempts.</p>"},{"location":"swarms/agents/iterative_agent/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    Problem_Input[\"\ud83e\udde9 Problem Input\"] --&gt; Generate_Hypotheses\n    Generate_Hypotheses[\"Generate Initial Hypotheses\"] --&gt; Simulate\n    subgraph Iterative Reflective Expansion Loop\n        Simulate[\"Simulate Reasoning Paths\"] --&gt; Evaluate\n        Evaluate[\"Evaluate Outcomes\"] --&gt; Reflect{Is solution satisfactory?}\n        Reflect --&gt;|No, issues found| Meta_Reflect\n        Reflect --&gt;|Yes| Promising\n        Meta_Reflect[\"Meta-Cognitive Reflection\"] --&gt; Revise_Paths\n        Meta_Reflect --&gt; Memory[(Reasoning Memory)]\n        Meta_Reflect --&gt; Memory\n        Revise_Paths[\"Revise Paths Based on Feedback\"] --&gt; Expand_Paths\n        Meta_Reflect --&gt; Revise_Path\n        Revise_Path[\"Revise Paths\"] --&gt; Expand_Paths\n        Expand_Paths[\"Iterative Expansion &amp; Pruning\"] --&gt; Simulate\n    end\n    Promising[\"Promising Paths Selected\"] --&gt; Memory\n    Memory[\"Memory Integration\"] --&gt; Synthesize\n    Synthesize[\"Synthesize Final Solution\"] --&gt; Final[\"Final Solution \u2705\"]\n</code></pre>"},{"location":"swarms/agents/iterative_agent/#workflow","title":"Workflow","text":"<ol> <li>Generate initial hypotheses</li> <li>Simulate paths</li> <li>Reflect on errors</li> <li>Revise paths</li> <li>Select promising paths</li> <li>Synthesize solution</li> </ol>"},{"location":"swarms/agents/iterative_agent/#class-iterativereflectiveexpansion","title":"Class: IterativeReflectiveExpansion","text":""},{"location":"swarms/agents/iterative_agent/#arguments","title":"Arguments","text":"Argument Type Default Description agent Agent None The Swarms agent instance used to perform reasoning tasks. max_iterations int 5 Maximum number of iterations for the reasoning process. return_list bool False If True, returns the conversation as a list of messages. return_dict bool False If True, returns the conversation as a dictionary of messages. prompt str GENERAL_REASONING_AGENT_SYS_PROMPT The system prompt for the agent."},{"location":"swarms/agents/iterative_agent/#methods","title":"Methods","text":"Method Description generate_initial_hypotheses Generates an initial set of reasoning hypotheses based on the problem input. simulate_path Simulates a given reasoning path and evaluates its effectiveness. meta_reflect Performs meta-cognitive reflection on the provided error information. revise_path Revises the reasoning path based on the provided feedback. select_promising_paths Selects the most promising reasoning paths from a list of candidates. synthesize_solution Synthesizes a final solution from the promising reasoning paths and historical memory. run Executes the Iterative Reflective Expansion process on the provided problem."},{"location":"swarms/agents/iterative_agent/#use-cases","title":"Use-Cases","text":""},{"location":"swarms/agents/iterative_agent/#example-1-solving-a-mathematical-problem","title":"Example 1: Solving a Mathematical Problem","text":"<pre><code>from swarms import IterativeReflectiveExpansion\n\nagent = IterativeReflectiveExpansion(\n    max_iterations=3,\n)\n\nagent.run(\"What is the 40th prime number?\")\n</code></pre>"},{"location":"swarms/agents/iterative_agent/#conclusion","title":"Conclusion","text":"<p>The Iterative Reflective Expansion (IRE) Algorithm is a powerful tool for solving complex problems through iterative reasoning and reflection. By leveraging the capabilities of a Swarms agent, it can dynamically adapt and refine its approach to converge on optimal solutions.</p>"},{"location":"swarms/agents/message/","title":"The Module/Class Name: Message","text":"<p>In the swarms.agents framework, the class <code>Message</code> is used to represent a message with timestamp and optional metadata.</p>"},{"location":"swarms/agents/message/#overview-and-introduction","title":"Overview and Introduction","text":"<p>The <code>Message</code> class is a fundamental component that enables the representation of messages within an agent system. Messages contain essential information such as the sender, content, timestamp, and optional metadata.</p>"},{"location":"swarms/agents/message/#class-definition","title":"Class Definition","text":""},{"location":"swarms/agents/message/#constructor-__init__","title":"Constructor: <code>__init__</code>","text":"<p>The constructor of the <code>Message</code> class takes three parameters:</p> <ol> <li><code>sender</code> (str): The sender of the message.</li> <li><code>content</code> (str): The content of the message.</li> <li><code>metadata</code> (dict or None): Optional metadata associated with the message.</li> </ol>"},{"location":"swarms/agents/message/#methods","title":"Methods","text":"<ol> <li><code>__repr__(self)</code>: Returns a string representation of the <code>Message</code> object, including the timestamp, sender, and content.</li> </ol> <pre><code>class Message:\n    \"\"\"\n    Represents a message with timestamp and optional metadata.\n\n    Usage\n    --------------\n    mes = Message(\n        sender = \"Kye\",\n        content = \"message\"\n    )\n\n    print(mes)\n    \"\"\"\n\n    def __init__(self, sender, content, metadata=None):\n        self.timestamp = datetime.datetime.now()\n        self.sender = sender\n        self.content = content\n        self.metadata = metadata or {}\n\n    def __repr__(self):\n        \"\"\"\n        __repr__ represents the string representation of the Message object.\n\n        Returns:\n        (str) A string containing the timestamp, sender, and content of the message.\n        \"\"\"\n        return f\"{self.timestamp} - {self.sender}: {self.content}\"\n</code></pre>"},{"location":"swarms/agents/message/#functionality-and-usage","title":"Functionality and Usage","text":"<p>The <code>Message</code> class represents a message in the agent system. Upon initialization, the <code>timestamp</code> is set to the current date and time, and the <code>metadata</code> is set to an empty dictionary if no metadata is provided.</p>"},{"location":"swarms/agents/message/#usage-example-1","title":"Usage Example 1","text":"<p>Creating a <code>Message</code> object and displaying its string representation.</p> <pre><code>mes = Message(sender=\"Kye\", content=\"Hello! How are you?\")\n\nprint(mes)\n</code></pre> <p>Output: <pre><code>2023-09-20 13:45:00 - Kye: Hello! How are you?\n</code></pre></p>"},{"location":"swarms/agents/message/#usage-example-2","title":"Usage Example 2","text":"<p>Creating a <code>Message</code> object with metadata.</p> <pre><code>metadata = {\"priority\": \"high\", \"category\": \"urgent\"}\nmes_with_metadata = Message(\n    sender=\"Alice\", content=\"Important update\", metadata=metadata\n)\n\nprint(mes_with_metadata)\n</code></pre> <p>Output: <pre><code>2023-09-20 13:46:00 - Alice: Important update\n</code></pre></p>"},{"location":"swarms/agents/message/#usage-example-3","title":"Usage Example 3","text":"<p>Creating a <code>Message</code> object without providing metadata.</p> <pre><code>mes_no_metadata = Message(sender=\"Bob\", content=\"Reminder: Meeting at 2PM\")\n\nprint(mes_no_metadata)\n</code></pre> <p>Output: <pre><code>2023-09-20 13:47:00 - Bob: Reminder: Meeting at 2PM\n</code></pre></p>"},{"location":"swarms/agents/message/#additional-information-and-tips","title":"Additional Information and Tips","text":"<p>When creating a new <code>Message</code> object, ensure that the required parameters <code>sender</code> and <code>content</code> are provided. The <code>timestamp</code> will automatically be assigned the current date and time. Optional <code>metadata</code> can be included to provide additional context or information associated with the message.</p>"},{"location":"swarms/agents/message/#references-and-resources","title":"References and Resources","text":"<p>For further information on the <code>Message</code> class and its usage, refer to the official swarms.agents documentation and relevant tutorials related to message handling and communication within the agent system.</p>"},{"location":"swarms/agents/new_agent/","title":"How to Create Good Agents","text":"<p>This guide will walk you through the steps to build high-quality agents by extending the <code>Agent</code> class. It emphasizes best practices, the use of type annotations, comprehensive documentation, and modular design to ensure maintainability and scalability. Additionally, you will learn how to incorporate a callable <code>llm</code> parameter or specify a <code>model_name</code> attribute to enhance flexibility and functionality. These principles ensure that agents are not only functional but also robust and adaptable to future requirements.</p>"},{"location":"swarms/agents/new_agent/#overview","title":"Overview","text":"<p>A good agent is a modular and reusable component designed to perform specific tasks efficiently. By inheriting from the base <code>Agent</code> class, developers can extend its functionality while adhering to standardized principles. Each custom agent should:</p> <ul> <li>Inherit from the <code>Agent</code> class to maintain compatibility with swarms.</li> <li>Define a <code>run(task: str, img: str)</code> method to execute tasks effectively.</li> <li>Include descriptive attributes such as <code>name</code>, <code>system_prompt</code>, and <code>description</code> to enhance clarity.</li> <li>Optionally, include an <code>llm</code> parameter (callable) or a <code>model_name</code> to enable seamless integration with language models.</li> <li>Emphasize modularity, allowing the agent to be reused across various contexts and tasks.</li> </ul> <p>By following these guidelines, you can create agents that integrate well with broader systems and exhibit high reliability in real-world applications.</p>"},{"location":"swarms/agents/new_agent/#creating-a-custom-agent","title":"Creating a Custom Agent","text":"<p>Here is a detailed template for creating a custom agent by inheriting the <code>Agent</code> class. This template demonstrates how to structure an agent with extendable and reusable features:</p> <pre><code>from typing import Callable, Any\nfrom swarms import Agent\n\nclass MyNewAgent(Agent):\n    \"\"\"\n    A custom agent class for specialized tasks.\n\n    Attributes:\n        name (str): The name of the agent.\n        system_prompt (str): The prompt guiding the agent's behavior.\n        description (str): A brief description of the agent's purpose.\n        llm (Callable, optional): A callable representing the language model to use.\n    \"\"\"\n\n    def __init__(self, name: str, system_prompt: str, model_name: str = None, description: str, llm: Callable = None):\n        \"\"\"\n        Initialize the custom agent.\n\n        Args:\n            name (str): The name of the agent.\n            system_prompt (str): The prompt guiding the agent.\n            model_name (str): The name of your model can use litellm [openai/gpt-4o]\n            description (str): A description of the agent's purpose.\n            llm (Callable, optional): A callable representing the language model to use.\n        \"\"\"\n        super().__init__(agent_name=name, system_prompt=system_prompt, model_name=model_name)\n        self.agent_name = agent_name\n        self.system_prompt system_prompt\n        self.description = description\n        self.model_name = model_name\n\n    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Execute the task assigned to the agent.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input for processing.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            Any: The result of the task execution.\n        \"\"\"\n        # Your custom logic \n        ...\n</code></pre> <p>This design ensures a seamless extension of functionality while maintaining clear and maintainable code.</p>"},{"location":"swarms/agents/new_agent/#key-considerations","title":"Key Considerations","text":""},{"location":"swarms/agents/new_agent/#1-type-annotations","title":"1. Type Annotations","text":"<p>Always use type hints for method parameters and return values. This improves code readability, supports static analysis tools, and reduces bugs, ensuring long-term reliability.</p>"},{"location":"swarms/agents/new_agent/#2-comprehensive-documentation","title":"2. Comprehensive Documentation","text":"<p>Provide detailed docstrings for all classes, methods, and attributes. Clear documentation ensures that your agent's functionality is understandable to both current and future collaborators.</p>"},{"location":"swarms/agents/new_agent/#3-modular-design","title":"3. Modular Design","text":"<p>Keep the agent logic modular and reusable. Modularity simplifies debugging, testing, and extending functionalities, making the code more adaptable to diverse scenarios.</p>"},{"location":"swarms/agents/new_agent/#4-flexible-model-integration","title":"4. Flexible Model Integration","text":"<p>Use either an <code>llm</code> callable or <code>model_name</code> attribute for integrating language models. This flexibility ensures your agent can adapt to various tasks, environments, and system requirements.</p>"},{"location":"swarms/agents/new_agent/#5-error-handling","title":"5. Error Handling","text":"<p>Incorporate robust error handling to manage unexpected inputs or issues during execution. This not only ensures reliability but also builds user trust in your system.</p>"},{"location":"swarms/agents/new_agent/#6-scalability-considerations","title":"6. Scalability Considerations","text":"<p>Ensure your agent design can scale to accommodate increased complexity or a larger number of tasks without compromising performance.</p>"},{"location":"swarms/agents/new_agent/#example-usage","title":"Example Usage","text":"<p>Here is an example of how to use your custom agent effectively:</p> <pre><code># Example LLM callable\nclass MockLLM:\n    \"\"\"\n    A mock language model class for simulating LLM behavior.\n\n    Methods:\n        run(task: str, img: str, *args: Any, **kwargs: Any) -&gt; str:\n            Processes the task and image input to return a simulated response.\n    \"\"\"\n\n    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -&gt; str:\n        return f\"Processed task '{task}' with image '{img}'\"\n\n# Create an instance of MyNewAgent\nagent = MyNewAgent(\n    name=\"ImageProcessor\",\n    system_prompt=\"Process images and extract relevant details.\",\n    description=\"An agent specialized in processing images and extracting insights.\",\n    llm=MockLLM().run\n)\n\n# Run a task\nresult = agent.run(task=\"Analyze content\", img=\"path/to/image.jpg\")\nprint(result)\n</code></pre> <p>This example showcases the practical application of the <code>MyNewAgent</code> class and highlights its extensibility.</p>"},{"location":"swarms/agents/new_agent/#production-grade-example-with-griptape-agent-integration-example","title":"Production-Grade Example with Griptape Agent Integration Example","text":"<p>In this example, we will create a Griptape agent by inheriting from the Swarms <code>Agent</code> class and implementing the <code>run</code> method.</p>"},{"location":"swarms/agents/new_agent/#griptape-integration-steps","title":"Griptape Integration Steps:","text":"<ol> <li>Inherit from Swarms Agent: Inherit from the <code>SwarmsAgent</code> class.</li> <li>Create Griptape Agent: Initialize the Griptape agent inside your class and provide it with the necessary tools.</li> <li>Override the <code>run()</code> method: Implement logic to process a task string and execute the Griptape agent.</li> </ol>"},{"location":"swarms/agents/new_agent/#griptape-example-code","title":"Griptape Example Code:","text":"<pre><code>from swarms import (\n    Agent as SwarmsAgent,\n)  # Import the base Agent class from Swarms\nfrom griptape.structures import Agent as GriptapeAgent\nfrom griptape.tools import (\n    WebScraperTool,\n    FileManagerTool,\n    PromptSummaryTool,\n)\n\n# Create a custom agent class that inherits from SwarmsAgent\nclass GriptapeSwarmsAgent(SwarmsAgent):\n    def __init__(self, name: str, system_prompt: str: str, *args, **kwargs):\n        super().__init__(agent_name=name, system_prompt=system_prompt)\n        # Initialize the Griptape agent with its tools\n        self.agent = GriptapeAgent(\n            input=\"Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.\",\n            tools=[\n                WebScraperTool(off_prompt=True),\n                PromptSummaryTool(off_prompt=True),\n                FileManagerTool(),\n            ],\n            *args,\n            **kwargs,\n        )\n\n    # Override the run method to take a task and execute it using the Griptape agent\n    def run(self, task: str) -&gt; str:\n        # Extract URL and filename from task\n        url, filename = task.split(\",\")  # Example task string: \"https://example.com, output.txt\"\n        # Execute the Griptape agent\n        result = self.agent.run(url.strip(), filename.strip())\n        # Return the final result as a string\n        return str(result)\n\n\n# Example usage:\ngriptape_swarms_agent = GriptapeSwarmsAgent()\noutput = griptape_swarms_agent.run(\"https://griptape.ai, griptape.txt\")\nprint(output)\n</code></pre>"},{"location":"swarms/agents/new_agent/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Test Extensively:    Validate your agent with various task inputs to ensure it performs as expected under different conditions.</p> </li> <li> <p>Follow the Single Responsibility Principle:    Design each agent to focus on a specific task or role, ensuring clarity and modularity in implementation.</p> </li> <li> <p>Log Actions:    Include detailed logging within the <code>run</code> method to capture key actions, inputs, and results for debugging and monitoring.</p> </li> <li> <p>Use Open-Source Contributions:    Contribute your custom agents to the Swarms repository at https://github.com/kyegomez/swarms. Sharing your innovations helps advance the ecosystem and encourages collaboration.</p> </li> <li> <p>Iterate and Refactor:    Continuously improve your agents based on feedback, performance evaluations, and new requirements to maintain relevance and functionality.</p> </li> </ol>"},{"location":"swarms/agents/new_agent/#conclusion","title":"Conclusion","text":"<p>By following these guidelines, you can create powerful and flexible agents tailored to specific tasks. Leveraging inheritance from the <code>Agent</code> class ensures compatibility and standardization across swarms. Emphasize modularity, thorough testing, and clear documentation to build agents that are robust, scalable, and easy to integrate. Collaborate with the community by submitting your innovative agents to the Swarms repository, contributing to a growing ecosystem of intelligent solutions. With a well-designed agent, you are equipped to tackle diverse challenges efficiently and effectively.</p>"},{"location":"swarms/agents/openai_assistant/","title":"OpenAI Assistant","text":"<p>The OpenAI Assistant class provides a wrapper around OpenAI's Assistants API, integrating it with the swarms framework.</p>"},{"location":"swarms/agents/openai_assistant/#overview","title":"Overview","text":"<p>The <code>OpenAIAssistant</code> class allows you to create and interact with OpenAI Assistants, providing a simple interface for:</p> <ul> <li>Creating assistants with specific roles and capabilities</li> <li>Adding custom functions that the assistant can call</li> <li>Managing conversation threads</li> <li>Handling tool calls and function execution</li> <li>Getting responses from the assistant</li> </ul>"},{"location":"swarms/agents/openai_assistant/#insstallation","title":"Insstallation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/agents/openai_assistant/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms import OpenAIAssistant\n\n#Create an assistant\nassistant = OpenAIAssistant(\n    name=\"Math Tutor\",\n    instructions=\"You are a helpful math tutor.\",\n    model=\"gpt-4o\",\n    tools=[{\"type\": \"code_interpreter\"}]\n)\n\n#Run a Task\nresponse = assistant.run(\"Solve the equation: 3x + 11 = 14\")\nprint(response)\n\n# Continue the conversation in the same thread\nfollow_up = assistant.run(\"Now explain how you solved it\")\nprint(follow_up)\n</code></pre>"},{"location":"swarms/agents/openai_assistant/#function-calling","title":"Function Calling","text":"<p>The assistant supports custom function integration:</p> <pre><code>def get_weather(location: str, unit: str = \"celsius\") -&gt; str:\n    # Mock weather function\n    return f\"The weather in {location} is 22 degrees {unit}\"\n\n# Add function to assistant\nassistant.add_function(\n    description=\"Get the current weather in a location\",\n    parameters={\n        \"type\": \"object\",\n        \"properties\": {\n            \"location\": {\n                \"type\": \"string\",\n                \"description\": \"City name\"\n            },\n            \"unit\": {\n                \"type\": \"string\",\n                \"enum\": [\"celsius\", \"fahrenheit\"],\n                \"default\": \"celsius\"\n            }\n        },\n        \"required\": [\"location\"]\n    }\n)\n</code></pre>"},{"location":"swarms/agents/openai_assistant/#api-reference","title":"API Reference","text":""},{"location":"swarms/agents/openai_assistant/#constructor","title":"Constructor","text":"<pre><code>OpenAIAssistant(\n    name: str,\n    instructions: Optional[str] = None,\n    model: str = \"gpt-4o\",\n    tools: Optional[List[Dict[str, Any]]] = None,\n    file_ids: Optional[List[str]] = None,\n    metadata: Optional[Dict[str, Any]] = None,\n    functions: Optional[List[Dict[str, Any]]] = None,\n)\n</code></pre>"},{"location":"swarms/agents/openai_assistant/#methods","title":"Methods","text":""},{"location":"swarms/agents/openai_assistant/#runtask-str-str","title":"run(task: str) -&gt; str","text":"<p>Sends a task to the assistant and returns its response. The conversation thread is maintained between calls.</p>"},{"location":"swarms/agents/openai_assistant/#add_functionfunc-callable-description-str-parameters-dictstr-any-none","title":"add_function(func: Callable, description: str, parameters: Dict[str, Any]) -&gt; None","text":"<p>Adds a callable function that the assistant can use during conversations.</p>"},{"location":"swarms/agents/openai_assistant/#add_messagecontent-str-file_ids-optionalliststr-none-none","title":"add_message(content: str, file_ids: Optional[List[str]] = None) -&gt; None","text":"<p>Adds a message to the current conversation thread.</p>"},{"location":"swarms/agents/openai_assistant/#error-handling","title":"Error Handling","text":"<p>The assistant implements robust error handling: - Retries on rate limits - Graceful handling of API errors - Clear error messages for debugging - Status monitoring for runs and completions</p>"},{"location":"swarms/agents/openai_assistant/#best-practices","title":"Best Practices","text":"<ol> <li>Thread Management</li> <li>Use the same assistant instance for related conversations</li> <li>Create new instances for unrelated tasks</li> <li> <p>Monitor thread status during long-running operations</p> </li> <li> <p>Function Integration</p> </li> <li>Keep functions simple and focused</li> <li>Provide clear descriptions and parameter schemas</li> <li>Handle errors gracefully in custom functions</li> <li> <p>Test functions independently before integration</p> </li> <li> <p>Performance</p> </li> <li>Reuse assistant instances when possible</li> <li>Monitor and handle rate limits appropriately</li> <li>Use appropriate polling intervals for status checks</li> <li>Consider implementing timeouts for long-running operations</li> </ol>"},{"location":"swarms/agents/openai_assistant/#references","title":"References","text":"<ul> <li>OpenAI Assistants API Documentation</li> <li>OpenAI Function Calling Guide</li> <li>OpenAI Rate Limits</li> </ul>"},{"location":"swarms/agents/reasoning_agent_router/","title":"ReasoningAgentRouter","text":"<p>Overview</p> <p>The ReasoningAgentRouter is a sophisticated agent routing system that enables dynamic selection and execution of different reasoning strategies based on the task requirements. It provides a flexible interface to work with multiple reasoning approaches including Reasoning Duo, Self-Consistency, IRE (Iterative Reflective Expansion), Reflexion, GKP (Generated Knowledge Prompting), and Agent Judge.</p>"},{"location":"swarms/agents/reasoning_agent_router/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    Task[Task Input] --&gt; Router[ReasoningAgentRouter]\n    Router --&gt; SelectSwarm{Select Swarm Type}\n    SelectSwarm --&gt;|Reasoning Duo| RD[ReasoningDuo]\n    SelectSwarm --&gt;|Self Consistency| SC[SelfConsistencyAgent]\n    SelectSwarm --&gt;|IRE| IRE[IterativeReflectiveExpansion]\n    SelectSwarm --&gt;|Reflexion| RF[ReflexionAgent]\n    SelectSwarm --&gt;|GKP| GKP[GKPAgent]\n    SelectSwarm --&gt;|Agent Judge| AJ[AgentJudge]\n    RD --&gt; Output[Task Output]\n    SC --&gt; Output\n    IRE --&gt; Output\n    RF --&gt; Output\n    GKP --&gt; Output\n    AJ --&gt; Output</code></pre>"},{"location":"swarms/agents/reasoning_agent_router/#configuration","title":"Configuration","text":""},{"location":"swarms/agents/reasoning_agent_router/#arguments","title":"Arguments","text":"<p>Constructor Parameters</p> Argument Type Default Description <code>agent_name</code> str \"reasoning_agent\" Name identifier for the agent <code>description</code> str \"A reasoning agent...\" Description of the agent's capabilities <code>model_name</code> str \"gpt-4o-mini\" The underlying language model to use <code>system_prompt</code> str \"You are a helpful...\" System prompt for the agent <code>max_loops</code> int 1 Maximum number of reasoning loops <code>swarm_type</code> agent_types \"reasoning_duo\" Type of reasoning swarm to use <code>num_samples</code> int 1 Number of samples for self-consistency <code>output_type</code> OutputType \"dict-all-except-first\" Format of the output <code>num_knowledge_items</code> int 6 Number of knowledge items for GKP agent <code>memory_capacity</code> int 6 Memory capacity for agents that support it <code>eval</code> bool False Enable evaluation mode for self-consistency <code>random_models_on</code> bool False Enable random model selection for diversity <code>majority_voting_prompt</code> Optional[str] None Custom prompt for majority voting <code>reasoning_model_name</code> Optional[str] \"claude-3-5-sonnet-20240620\" Model to use for reasoning in ReasoningDuo"},{"location":"swarms/agents/reasoning_agent_router/#available-agent-types","title":"Available Agent Types","text":"<p>Supported Types</p> <p>The following agent types are supported through the <code>swarm_type</code> parameter:</p> <ul> <li><code>\"reasoning-duo\"</code> or <code>\"reasoning-agent\"</code></li> <li><code>\"self-consistency\"</code> or <code>\"consistency-agent\"</code> </li> <li><code>\"ire\"</code> or <code>\"ire-agent\"</code></li> <li><code>\"ReflexionAgent\"</code></li> <li><code>\"GKPAgent\"</code></li> <li><code>\"AgentJudge\"</code></li> </ul>"},{"location":"swarms/agents/reasoning_agent_router/#agent-types-comparison","title":"Agent Types Comparison","text":"Reasoning DuoSelf ConsistencyIREReflexionAgentGKPAgentAgentJudge <p>Key Features</p> <ul> <li>Dual agent system</li> <li>Collaborative reasoning</li> <li>Split between reasoning and execution</li> </ul> <p>Best Use Cases</p> <ul> <li>Complex tasks requiring both analysis and action</li> <li>Multi-step problem solving</li> <li>Tasks needing verification</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>system_prompt</li> </ul> <p>Optional Parameters</p> <ul> <li>output_type</li> <li>reasoning_model_name (default: \"claude-3-5-sonnet-20240620\")</li> <li>max_loops</li> <li>img (for image input support)</li> </ul> <p>Key Features</p> <ul> <li>Multiple solution generation</li> <li>Consensus building</li> <li>Solution verification</li> <li>Concurrent execution</li> <li>AI-powered aggregation</li> </ul> <p>Best Use Cases</p> <ul> <li>Tasks requiring high reliability</li> <li>Problems with multiple approaches</li> <li>Validation-heavy tasks</li> <li>Mathematical problem solving</li> <li>Decision making scenarios</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>system_prompt</li> </ul> <p>Optional Parameters</p> <ul> <li>num_samples (default: 5)</li> <li>max_loops (default: 1)</li> <li>output_type (default: \"dict\")</li> <li>eval (default: False) - Enable answer validation</li> <li>random_models_on (default: False) - Enable model diversity</li> <li>majority_voting_prompt (default: None) - Custom aggregation prompt</li> </ul> <p>Key Features</p> <ul> <li>Iterative improvement</li> <li>Self-reflection</li> <li>Progressive refinement</li> </ul> <p>Best Use Cases</p> <ul> <li>Complex reasoning tasks</li> <li>Problems requiring refinement</li> <li>Learning from previous iterations</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>system_prompt</li> </ul> <p>Optional Parameters</p> <ul> <li>max_loops</li> <li>max_iterations</li> <li>output_type</li> </ul> <p>Key Features</p> <ul> <li>Self-reflection capabilities</li> <li>Learning from experience</li> <li>Adaptive reasoning</li> </ul> <p>Best Use Cases</p> <ul> <li>Tasks requiring introspection</li> <li>Continuous improvement scenarios</li> <li>Learning-based tasks</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>system_prompt</li> </ul> <p>Optional Parameters</p> <ul> <li>max_loops</li> </ul> <p>Key Features</p> <ul> <li>Knowledge generation</li> <li>Information synthesis</li> <li>Knowledge base management</li> </ul> <p>Best Use Cases</p> <ul> <li>Knowledge-intensive tasks</li> <li>Information gathering</li> <li>Research-based problems</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>num_knowledge_items</li> </ul> <p>Optional Parameters</p> <ul> <li>memory_capacity</li> </ul> <p>Key Features</p> <ul> <li>Solution evaluation</li> <li>Quality assessment</li> <li>Decision making</li> </ul> <p>Best Use Cases</p> <ul> <li>Quality control tasks</li> <li>Solution validation</li> <li>Performance evaluation</li> </ul> <p>Required Parameters</p> <ul> <li>model_name</li> <li>system_prompt</li> </ul> <p>Optional Parameters</p> <ul> <li>max_loops</li> </ul>"},{"location":"swarms/agents/reasoning_agent_router/#usage","title":"Usage","text":""},{"location":"swarms/agents/reasoning_agent_router/#methods","title":"Methods","text":"<p>Available Methods</p> Method Description <code>select_swarm()</code> Selects and initializes the appropriate reasoning swarm based on specified type <code>run(task: str, img: Optional[str] = None, **kwargs)</code> Executes the selected swarm's reasoning process on the given task <code>batched_run(tasks: List[str], imgs: Optional[List[str]] = None, **kwargs)</code> Executes the reasoning process on a batch of tasks"},{"location":"swarms/agents/reasoning_agent_router/#image-support","title":"Image Support","text":"<p>Multi-modal Capabilities</p> <p>The ReasoningAgentRouter supports image inputs for compatible agent types:</p> <p>Supported Parameters:</p> <ul> <li><code>img</code> (str, optional): Path or URL to a single image file for single task execution</li> <li><code>imgs</code> (List[str], optional): List of image paths/URLs for batch task execution</li> </ul> <p>Compatible Agent Types:</p> <ul> <li><code>reasoning-duo</code> / <code>reasoning-agent</code>: Full image support for both reasoning and execution phases</li> <li>Other agent types may have varying levels of image support depending on their underlying implementation</li> </ul> <p>Usage Example: <pre><code># Single image with task\nrouter = ReasoningAgentRouter(swarm_type=\"reasoning-duo\")\nresult = router.run(\n    task=\"Describe what you see in this image\",\n    img=\"path/to/image.jpg\"\n)\n\n# Batch processing with images\nresults = router.batched_run(\n    tasks=[\"Analyze this chart\", \"Describe this photo\"],\n    imgs=[\"chart.png\", \"photo.jpg\"]\n)\n</code></pre></p>"},{"location":"swarms/agents/reasoning_agent_router/#code-examples","title":"Code Examples","text":"Basic UsageSelf-Consistency ExamplesReflexionAgentGKPAgentReasoningDuo ExamplesAgentJudge <pre><code>from swarms.agents.reasoning_agents import ReasoningAgentRouter\n\n# Initialize the router\nrouter = ReasoningAgentRouter(\n    agent_name=\"reasoning-agent\",\n    description=\"A reasoning agent that can answer questions and help with tasks.\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are a helpful assistant that can answer questions and help with tasks.\",\n    max_loops=1,\n    swarm_type=\"self-consistency\",\n    num_samples=3,\n    eval=False,\n    random_models_on=False,\n    majority_voting_prompt=None\n)\n\n# Run a single task\nresult = router.run(\"What is the best approach to solve this problem?\")\n\n# Run with image input\nresult_with_image = router.run(\n    \"Analyze this image and provide insights\",\n    img=\"path/to/image.jpg\"\n)\n</code></pre> <pre><code># Basic self-consistency\nrouter = ReasoningAgentRouter(\n    swarm_type=\"self-consistency\",\n    num_samples=3,\n    model_name=\"gpt-4o-mini\"\n)\n\n# Self-consistency with evaluation mode\nrouter = ReasoningAgentRouter(\n    swarm_type=\"self-consistency\",\n    num_samples=5,\n    model_name=\"gpt-4o-mini\",\n    eval=True,\n    random_models_on=True\n)\n\n# Self-consistency with custom majority voting\nrouter = ReasoningAgentRouter(\n    swarm_type=\"self-consistency\",\n    num_samples=3,\n    model_name=\"gpt-4o-mini\",\n    majority_voting_prompt=\"Analyze the responses and provide the most accurate answer.\"\n)\n</code></pre> <pre><code>router = ReasoningAgentRouter(\n    swarm_type=\"ReflexionAgent\",\n    max_loops=3,\n    model_name=\"gpt-4o-mini\"\n)\n</code></pre> <pre><code>router = ReasoningAgentRouter(\n    swarm_type=\"GKPAgent\",\n    model_name=\"gpt-4o-mini\",\n    num_knowledge_items=6\n)\n</code></pre> <pre><code># Basic ReasoningDuo\nrouter = ReasoningAgentRouter(\n    swarm_type=\"reasoning-duo\",\n    model_name=\"gpt-4o-mini\",\n    reasoning_model_name=\"claude-3-5-sonnet-20240620\"\n)\n\n# ReasoningDuo with image support\nrouter = ReasoningAgentRouter(\n    swarm_type=\"reasoning-duo\",\n    model_name=\"gpt-4o-mini\",\n    reasoning_model_name=\"gpt-4-vision-preview\",\n    max_loops=2\n)\n\nresult = router.run(\n    \"Analyze this image and explain the patterns you see\",\n    img=\"data_visualization.png\"\n)\n</code></pre> <pre><code>router = ReasoningAgentRouter(\n    swarm_type=\"AgentJudge\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=2\n)\n</code></pre>"},{"location":"swarms/agents/reasoning_agent_router/#best-practices","title":"Best Practices","text":"<p>Optimization Tips</p> <ol> <li> <ul> <li>Use ReasoningDuo for tasks requiring both analysis and action</li> </ul> <p>Swarm Type Selection</p> <ul> <li> <p>Use SelfConsistency for tasks requiring high reliability</p> </li> <li> <p>Use IRE for complex problem-solving requiring iterative refinement</p> </li> </ul> </li> <li> <p>Performance Optimization</p> <ul> <li> <p>Adjust max_loops based on task complexity</p> </li> <li> <p>Increase num_samples for higher reliability (3-7 for most tasks)</p> </li> <li> <p>Choose appropriate model_name based on task requirements</p> </li> <li> <p>Enable random_models_on for diverse reasoning approaches</p> </li> <li> <p>Use eval mode for validation tasks with known answers</p> </li> </ul> </li> <li> <p>Output Handling</p> <ul> <li> <p>Use appropriate output_type for your needs</p> </li> <li> <p>Process batched results appropriately</p> </li> <li> <p>Handle errors gracefully</p> </li> </ul> </li> <li> <p>Self-Consistency Specific</p> <ul> <li> <p>Use 3-5 samples for most tasks, 7+ for critical decisions</p> </li> <li> <p>Enable eval mode when you have expected answers for validation</p> </li> <li> <p>Customize majority_voting_prompt for domain-specific aggregation</p> </li> <li> <p>Consider random_models_on for diverse model perspectives</p> </li> </ul> </li> <li> <p>Multi-modal and Reasoning Configuration</p> <ul> <li> <p>Use vision-capable models when processing images (e.g., \"gpt-4-vision-preview\")</p> </li> <li> <p>For ReasoningDuo, set different models for reasoning vs execution via reasoning_model_name</p> </li> <li> <p>Ensure image paths are accessible and in supported formats (JPG, PNG, etc.)</p> </li> <li> <p>Consider using reasoning_model_name with specialized reasoning models for complex tasks</p> </li> </ul> </li> </ol>"},{"location":"swarms/agents/reasoning_agent_router/#limitations","title":"Limitations","text":"<p>Known Limitations</p> <ol> <li> <ul> <li>Higher num_samples</li> </ul> <p>Processing time increases with:</p> <ul> <li> <p>Larger max_loops</p> </li> <li> <p>More complex tasks</p> </li> </ul> </li> <li> <p>Model-specific limitations based on:</p> <ul> <li> <p>Token limits</p> </li> <li> <p>Model capabilities</p> </li> <li> <p>API rate limits</p> </li> </ul> </li> </ol>"},{"location":"swarms/agents/reasoning_agent_router/#contributing","title":"Contributing","text":"<p>Development Guidelines</p> <p>When extending the ReasoningAgentRouter:</p> <ol> <li>Follow the existing swarm interface</li> <li>Add comprehensive tests</li> <li>Update documentation</li> <li>Maintain error handling</li> </ol>"},{"location":"swarms/agents/reasoning_agents_overview/","title":"Reasoning Agents Overview","text":"<p>Reasoning agents are sophisticated agents that employ advanced cognitive strategies to improve problem-solving performance beyond standard language model capabilities. Unlike traditional prompt-based approaches, reasoning agents implement structured methodologies that enable them to think more systematically, self-reflect, collaborate, and iteratively refine their responses.</p> <p>These agents are inspired by cognitive science and human reasoning processes, incorporating techniques such as:</p> <ul> <li> <p>Multi-step reasoning: Breaking down complex problems into manageable components</p> </li> <li> <p>Self-reflection: Evaluating and critiquing their own outputs</p> </li> <li> <p>Iterative refinement: Progressively improving solutions through multiple iterations</p> </li> <li> <p>Collaborative thinking: Using multiple reasoning pathways or agent perspectives</p> </li> <li> <p>Memory integration: Learning from past experiences and building knowledge over time</p> </li> <li> <p>Meta-cognitive awareness: Understanding their own thinking processes and limitations</p> </li> </ul>"},{"location":"swarms/agents/reasoning_agents_overview/#available-reasoning-agents","title":"Available Reasoning Agents","text":"Agent Name Type Research Paper Key Features Best Use Cases Implementation Documentation Self-Consistency Agent Consensus-based Self-Consistency Improves Chain of Thought Reasoning (Wang et al., 2022) \u2022 Multiple independent reasoning paths\u2022 Majority voting aggregation\u2022 Concurrent execution\u2022 Validation mode \u2022 Mathematical problem solving\u2022 High-accuracy requirements\u2022 Decision making scenarios\u2022 Answer validation <code>SelfConsistencyAgent</code> Guide Reasoning Duo Collaborative Novel dual-agent architecture \u2022 Separate reasoning and execution agents\u2022 Collaborative problem solving\u2022 Task decomposition\u2022 Cross-validation \u2022 Complex analysis tasks\u2022 Multi-step problem solving\u2022 Tasks requiring verification\u2022 Research and planning <code>ReasoningDuo</code> Guide IRE Agent Iterative Iterative Reflective Expansion framework \u2022 Hypothesis generation\u2022 Path simulation\u2022 Error reflection\u2022 Dynamic revision \u2022 Complex reasoning tasks\u2022 Research problems\u2022 Learning scenarios\u2022 Strategy development <code>IterativeReflectiveExpansion</code> Guide Reflexion Agent Self-reflective Reflexion: Language Agents with Verbal Reinforcement Learning (Shinn et al., 2023) \u2022 Self-evaluation\u2022 Experience memory\u2022 Adaptive improvement\u2022 Learning from failures \u2022 Continuous improvement tasks\u2022 Long-term projects\u2022 Learning scenarios\u2022 Quality refinement <code>ReflexionAgent</code> Guide GKP Agent Knowledge-based Generated Knowledge Prompting (Liu et al., 2022) \u2022 Knowledge generation\u2022 Multi-perspective reasoning\u2022 Information synthesis\u2022 Fact integration \u2022 Knowledge-intensive tasks\u2022 Research questions\u2022 Fact-based reasoning\u2022 Information synthesis <code>GKPAgent</code> Guide Agent Judge Evaluation Agent-as-a-Judge: Evaluate Agents with Agents \u2022 Quality assessment\u2022 Structured evaluation\u2022 Performance metrics\u2022 Feedback generation \u2022 Quality control\u2022 Output evaluation\u2022 Performance assessment\u2022 Model comparison <code>AgentJudge</code> Guide REACT Agent Action-based ReAct: Synergizing Reasoning and Acting (Yao et al., 2022) \u2022 Reason-Act-Observe cycle\u2022 Memory integration\u2022 Action planning\u2022 Experience building \u2022 Interactive tasks\u2022 Tool usage scenarios\u2022 Planning problems\u2022 Learning environments <code>ReactAgent</code> Guide"},{"location":"swarms/agents/reasoning_agents_overview/#agent-architectures","title":"Agent Architectures","text":""},{"location":"swarms/agents/reasoning_agents_overview/#self-consistency-agent","title":"Self-Consistency Agent","text":"<p>Description: Implements multiple independent reasoning paths with consensus-building to improve response reliability and accuracy through majority voting mechanisms.</p> <p>Key Features:</p> <ul> <li> <p>Concurrent execution of multiple reasoning instances</p> </li> <li> <p>AI-powered aggregation and consensus analysis</p> </li> <li> <p>Validation mode for answer verification</p> </li> <li> <p>Configurable sample sizes and output formats</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Task Input] --&gt; B[Agent Pool]\n    B --&gt; C[Response 1]\n    B --&gt; D[Response 2]\n    B --&gt; E[Response 3]\n    B --&gt; F[Response N]\n    C --&gt; G[Aggregation Agent]\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[Majority Voting Analysis]\n    H --&gt; I[Consensus Evaluation]\n    I --&gt; J[Final Answer]\n\n    style A fill:#e1f5fe\n    style J fill:#c8e6c9\n    style G fill:#fff3e0</code></pre> <p>Use Cases: Mathematical problem solving, high-stakes decision making, answer validation, quality assurance processes</p> <p>Implementation: <code>SelfConsistencyAgent</code></p> <p>Documentation: Self-Consistency Agent Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#reasoning-duo","title":"Reasoning Duo","text":"<p>Description: Dual-agent collaborative system that separates reasoning and execution phases, enabling specialized analysis and task completion through coordinated agent interaction.</p> <p>Key Features:</p> <ul> <li> <p>Separate reasoning and execution agents</p> </li> <li> <p>Collaborative problem decomposition</p> </li> <li> <p>Cross-validation between agents</p> </li> <li> <p>Configurable model selection for each agent</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Task Input] --&gt; B[Reasoning Agent]\n    B --&gt; C[Deep Analysis]\n    C --&gt; D[Strategy Planning]\n    D --&gt; E[Reasoning Output]\n    E --&gt; F[Main Agent]\n    F --&gt; G[Task Execution]\n    G --&gt; H[Response Generation]\n    H --&gt; I[Final Output]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style F fill:#e8f5e8\n    style I fill:#c8e6c9</code></pre> <p>Use Cases: Complex analysis tasks, multi-step problem solving, research and planning, verification workflows</p> <p>Implementation: <code>ReasoningDuo</code></p> <p>Documentation: Reasoning Duo Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#ire-agent-iterative-reflective-expansion","title":"IRE Agent (Iterative Reflective Expansion)","text":"<p>Description: Sophisticated reasoning framework employing iterative hypothesis generation, simulation, and refinement through continuous cycles of testing and meta-cognitive reflection.</p> <p>Key Features:</p> <ul> <li> <p>Hypothesis generation and testing</p> </li> <li> <p>Path simulation and evaluation</p> </li> <li> <p>Meta-cognitive reflection capabilities</p> </li> <li> <p>Dynamic strategy revision based on feedback</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Problem Input] --&gt; B[Hypothesis Generation]\n    B --&gt; C[Path Simulation]\n    C --&gt; D[Outcome Evaluation]\n    D --&gt; E{Satisfactory?}\n    E --&gt;|No| F[Meta-Cognitive Reflection]\n    F --&gt; G[Path Revision]\n    G --&gt; H[Knowledge Integration]\n    H --&gt; C\n    E --&gt;|Yes| I[Solution Synthesis]\n    I --&gt; J[Final Answer]\n\n    style A fill:#e1f5fe\n    style F fill:#fff3e0\n    style J fill:#c8e6c9</code></pre> <p>Use Cases: Complex reasoning tasks, research problems, strategy development, iterative learning scenarios</p> <p>Implementation: <code>IterativeReflectiveExpansion</code></p> <p>Documentation: IRE Agent Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#reflexion-agent","title":"Reflexion Agent","text":"<p>Description: Advanced self-reflective system implementing actor-evaluator-reflector architecture for continuous improvement through experience-based learning and memory integration.</p> <p>Key Features:</p> <ul> <li> <p>Actor-evaluator-reflector sub-agent architecture</p> </li> <li> <p>Self-evaluation and quality assessment</p> </li> <li> <p>Experience memory and learning capabilities</p> </li> <li> <p>Adaptive improvement through reflection</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Task Input] --&gt; B[Actor Agent]\n    B --&gt; C[Initial Response]\n    C --&gt; D[Evaluator Agent]\n    D --&gt; E[Quality Assessment]\n    E --&gt; F[Performance Score]\n    F --&gt; G[Reflector Agent]\n    G --&gt; H[Self-Reflection]\n    H --&gt; I[Experience Memory]\n    I --&gt; J{Max Iterations?}\n    J --&gt;|No| K[Refined Response]\n    K --&gt; D\n    J --&gt;|Yes| L[Final Response]\n\n    style A fill:#e1f5fe\n    style B fill:#e8f5e8\n    style D fill:#fff3e0\n    style G fill:#f3e5f5\n    style L fill:#c8e6c9</code></pre> <p>Use Cases: Continuous improvement tasks, long-term projects, adaptive learning, quality refinement processes</p> <p>Implementation: <code>ReflexionAgent</code></p> <p>Documentation: Reflexion Agent Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#gkp-agent-generated-knowledge-prompting","title":"GKP Agent (Generated Knowledge Prompting)","text":"<p>Description: Knowledge-driven reasoning system that generates relevant information before answering queries, implementing multi-perspective analysis through coordinated knowledge synthesis.</p> <p>Key Features:</p> <ul> <li> <p>Dynamic knowledge generation</p> </li> <li> <p>Multi-perspective reasoning coordination</p> </li> <li> <p>Information synthesis and integration</p> </li> <li> <p>Configurable knowledge item generation</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Query Input] --&gt; B[Knowledge Generator]\n    B --&gt; C[Generate Knowledge Item 1]\n    B --&gt; D[Generate Knowledge Item 2]\n    B --&gt; E[Generate Knowledge Item N]\n    C --&gt; F[Reasoner Agent]\n    D --&gt; F\n    E --&gt; F\n    F --&gt; G[Knowledge Integration]\n    G --&gt; H[Reasoning Process]\n    H --&gt; I[Response Generation]\n    I --&gt; J[Coordinator]\n    J --&gt; K[Final Answer]\n\n    style A fill:#e1f5fe\n    style B fill:#fff3e0\n    style F fill:#e8f5e8\n    style J fill:#f3e5f5\n    style K fill:#c8e6c9</code></pre> <p>Use Cases: Knowledge-intensive tasks, research questions, fact-based reasoning, information synthesis</p> <p>Implementation: <code>GKPAgent</code></p> <p>Documentation: GKP Agent Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#agent-judge","title":"Agent Judge","text":"<p>Description: Specialized evaluation system for assessing agent outputs and system performance, providing structured feedback and quality metrics through comprehensive assessment frameworks.</p> <p>Key Features:</p> <ul> <li> <p>Structured evaluation methodology</p> </li> <li> <p>Quality assessment and scoring</p> </li> <li> <p>Performance metrics generation</p> </li> <li> <p>Configurable evaluation criteria</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Output to Evaluate] --&gt; B[Evaluation Criteria]\n    A --&gt; C[Judge Agent]\n    B --&gt; C\n    C --&gt; D[Quality Analysis]\n    D --&gt; E[Criteria Assessment]\n    E --&gt; F[Scoring Framework]\n    F --&gt; G[Feedback Generation]\n    G --&gt; H[Evaluation Report]\n\n    style A fill:#e1f5fe\n    style C fill:#fff3e0\n    style H fill:#c8e6c9</code></pre> <p>Use Cases: Quality control, output evaluation, performance assessment, model comparison</p> <p>Implementation: <code>AgentJudge</code></p> <p>Documentation: Agent Judge Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#react-agent-reason-act-observe","title":"REACT Agent (Reason-Act-Observe)","text":"<p>Description: Action-oriented reasoning system implementing iterative reason-act-observe cycles with memory integration for interactive task completion and environmental adaptation.</p> <p>Key Features:</p> <ul> <li> <p>Reason-Act-Observe cycle implementation</p> </li> <li> <p>Memory integration and experience building</p> </li> <li> <p>Action planning and execution</p> </li> <li> <p>Environmental state observation</p> </li> </ul> <p>Architecture Diagram:</p> <pre><code>graph TD\n    A[Task Input] --&gt; B[Memory Review]\n    B --&gt; C[Current State Observation]\n    C --&gt; D[Reasoning Process]\n    D --&gt; E[Action Planning]\n    E --&gt; F[Action Execution]\n    F --&gt; G[Outcome Observation]\n    G --&gt; H[Experience Storage]\n    H --&gt; I{Task Complete?}\n    I --&gt;|No| C\n    I --&gt;|Yes| J[Final Response]\n\n    style A fill:#e1f5fe\n    style B fill:#f3e5f5\n    style D fill:#fff3e0\n    style J fill:#c8e6c9</code></pre> <p>Use Cases: Interactive tasks, tool usage scenarios, planning problems, learning environments</p> <p>Implementation: <code>ReactAgent</code></p> <p>Documentation: REACT Agent Guide</p>"},{"location":"swarms/agents/reasoning_agents_overview/#implementation-guide","title":"Implementation Guide","text":""},{"location":"swarms/agents/reasoning_agents_overview/#unified-interface-via-reasoning-agent-router","title":"Unified Interface via Reasoning Agent Router","text":"<p>The <code>ReasoningAgentRouter</code> provides a centralized interface for accessing all reasoning agent implementations:</p> <pre><code>from swarms.agents import ReasoningAgentRouter\n\n# Initialize router with specific reasoning strategy\nrouter = ReasoningAgentRouter(\n    swarm_type=\"self-consistency\",  # Select reasoning methodology\n    model_name=\"gpt-4o-mini\",\n    num_samples=5,                  # Configuration for consensus-based methods\n    max_loops=3                     # Configuration for iterative methods\n)\n\n# Execute reasoning process\nresult = router.run(\"Analyze the optimal solution for this complex business problem\")\nprint(result)\n</code></pre>"},{"location":"swarms/agents/reasoning_agents_overview/#direct-agent-implementation","title":"Direct Agent Implementation","text":"<pre><code>from swarms.agents import SelfConsistencyAgent, ReasoningDuo, ReflexionAgent\n\n# Self-Consistency Agent for high-accuracy requirements\nconsistency_agent = SelfConsistencyAgent(\n    model_name=\"gpt-4o-mini\",\n    num_samples=5\n)\n\n# Reasoning Duo for collaborative analysis workflows\nduo_agent = ReasoningDuo(\n    model_names=[\"gpt-4o-mini\", \"gpt-4o\"]\n)\n\n# Reflexion Agent for adaptive learning scenarios\nreflexion_agent = ReflexionAgent(\n    model_name=\"gpt-4o-mini\",\n    max_loops=3,\n    memory_capacity=100\n)\n</code></pre>"},{"location":"swarms/agents/reasoning_agents_overview/#choosing-the-right-reasoning-agent","title":"Choosing the Right Reasoning Agent","text":"Scenario Recommended Agent Why? High-stakes decisions Self-Consistency Multiple validation paths ensure reliability Complex research tasks Reasoning Duo + GKP Collaboration + knowledge synthesis Learning &amp; improvement Reflexion Built-in self-improvement mechanisms Mathematical problems Self-Consistency Proven effectiveness on logical reasoning Quality assessment Agent Judge Specialized evaluation capabilities Interactive planning REACT Action-oriented reasoning cycle Iterative refinement IRE Designed for progressive improvement"},{"location":"swarms/agents/reasoning_agents_overview/#technical-documentation","title":"Technical Documentation","text":"<p>For comprehensive technical documentation on each reasoning agent implementation:</p> <ul> <li> <p>Self-Consistency Agent</p> </li> <li> <p>Reasoning Duo</p> </li> <li> <p>IRE Agent</p> </li> <li> <p>Reflexion Agent</p> </li> <li> <p>GKP Agent</p> </li> <li> <p>Agent Judge</p> </li> <li> <p>Reasoning Agent Router</p> </li> </ul> <p>Reasoning agents represent a significant advancement in enterprise agent capabilities, implementing sophisticated cognitive architectures that deliver enhanced reliability, consistency, and performance compared to traditional language model implementations. </p>"},{"location":"swarms/agents/reasoning_duo/","title":"ReasoningDuo","text":"<p>The ReasoningDuo class implements a dual-agent reasoning system that combines a reasoning agent and a main agent to provide well-thought-out responses to complex tasks. This architecture enables more robust and reliable outputs by separating the reasoning process from the final response generation.</p>"},{"location":"swarms/agents/reasoning_duo/#class-overview","title":"Class Overview","text":""},{"location":"swarms/agents/reasoning_duo/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description model_name str \"reasoning-agent-01\" Name identifier for the reasoning agent description str \"A highly intelligent...\" Description of the reasoning agent's capabilities model_names list[str] [\"gpt-4o-mini\", \"gpt-4o\"] Model names for reasoning and main agents system_prompt str \"You are a helpful...\" System prompt for the main agent"},{"location":"swarms/agents/reasoning_duo/#methods","title":"Methods","text":"Method Parameters Returns Description run task: str str Processes a single task through both agents batched_run tasks: List[str] List[str] Processes multiple tasks sequentially"},{"location":"swarms/agents/reasoning_duo/#quick-start","title":"Quick Start","text":"<pre><code>from swarms.agents.reasoning_duo import ReasoningDuo\n\n# Initialize the ReasoningDuo\nduo = ReasoningDuo(\n    model_name=\"reasoning-agent-01\",\n    model_names=[\"gpt-4o-mini\", \"gpt-4o\"]\n)\n\n# Run a single task\nresult = duo.run(\"Explain the concept of gravitational waves\")\n\n# Run multiple tasks\ntasks = [\n    \"Calculate compound interest for $1000 over 5 years\",\n    \"Explain quantum entanglement\"\n]\nresults = duo.batched_run(tasks)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#examples","title":"Examples","text":""},{"location":"swarms/agents/reasoning_duo/#1-mathematical-analysis","title":"1. Mathematical Analysis","text":"<pre><code>duo = ReasoningDuo()\n\n# Complex mathematical problem\nmath_task = \"\"\"\nSolve the following differential equation:\ndy/dx + 2y = x^2, y(0) = 1\n\"\"\"\n\nsolution = duo.run(math_task)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#2-physics-problem","title":"2. Physics Problem","text":"<pre><code># Quantum mechanics problem\nphysics_task = \"\"\"\nCalculate the wavelength of an electron with kinetic energy of 50 eV \nusing the de Broglie relationship.\n\"\"\"\n\nresult = duo.run(physics_task)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#3-financial-analysis","title":"3. Financial Analysis","text":"<pre><code># Complex financial analysis\nfinance_task = \"\"\"\nCalculate the Net Present Value (NPV) of a project with:\n- Initial investment: $100,000\n- Annual cash flows: $25,000 for 5 years\n- Discount rate: 8%\n\"\"\"\n\nanalysis = duo.run(finance_task)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/agents/reasoning_duo/#customizing-agent-behavior","title":"Customizing Agent Behavior","text":"<p>You can customize both agents by modifying their initialization parameters:</p> <pre><code>duo = ReasoningDuo(\n    model_name=\"custom-reasoning-agent\",\n    description=\"Specialized financial analysis agent\",\n    model_names=[\"gpt-4o-mini\", \"gpt-4o\"],\n    system_prompt=\"You are a financial expert AI assistant...\"\n)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#batch-processing-with-progress-tracking","title":"Batch Processing with Progress Tracking","text":"<pre><code>tasks = [\n    \"Analyze market trends for tech stocks\",\n    \"Calculate risk metrics for a portfolio\",\n    \"Forecast revenue growth\"\n]\n\n# Process multiple tasks with logging\nresults = duo.batched_run(tasks)\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#implementation-details","title":"Implementation Details","text":"<p>The ReasoningDuo uses a two-stage process:</p> <ol> <li>Reasoning Stage: The reasoning agent analyzes the task and develops a structured approach</li> <li>Execution Stage: The main agent uses the reasoning output to generate the final response</li> </ol>"},{"location":"swarms/agents/reasoning_duo/#internal-architecture","title":"Internal Architecture","text":"<pre><code>Task Input \u2192 Reasoning Agent \u2192 Structured Analysis \u2192 Main Agent \u2192 Final Output\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#best-practices","title":"Best Practices","text":"<ol> <li>Task Formulation</li> <li>Be specific and clear in task descriptions</li> <li>Include relevant context and constraints</li> <li> <p>Break complex problems into smaller subtasks</p> </li> <li> <p>Performance Optimization</p> </li> <li>Use batched_run for multiple related tasks</li> <li>Monitor agent outputs for consistency</li> <li>Adjust model parameters based on task complexity</li> </ol>"},{"location":"swarms/agents/reasoning_duo/#error-handling","title":"Error Handling","text":"<p>The ReasoningDuo includes built-in logging using the <code>loguru</code> library:</p> <pre><code>from loguru import logger\n\n# Logs are automatically generated for each task\nlogger.info(\"Task processing started\")\n</code></pre>"},{"location":"swarms/agents/reasoning_duo/#limitations","title":"Limitations","text":"<ul> <li>Processing time may vary based on task complexity</li> <li>Model response quality depends on input clarity</li> <li>Resource usage scales with batch size</li> </ul>"},{"location":"swarms/agents/reasoning_duo/#example-script","title":"Example Script","text":"<p>For a runnable demonstration, see the reasoning_duo_batched.py example.</p>"},{"location":"swarms/agents/reflexion_agent/","title":"ReflexionAgent","text":"<p>The ReflexionAgent is an advanced AI agent that implements the Reflexion framework to improve through self-reflection. It follows a process of acting on tasks, evaluating its performance, generating self-reflections, and using these reflections to improve future responses.</p>"},{"location":"swarms/agents/reflexion_agent/#overview","title":"Overview","text":"<p>The ReflexionAgent consists of three specialized sub-agents: - Actor: Generates initial responses to tasks - Evaluator: Critically assesses responses against quality criteria - Reflector: Generates self-reflections to improve future responses</p>"},{"location":"swarms/agents/reflexion_agent/#initialization","title":"Initialization","text":"<pre><code>from swarms.agents import ReflexionAgent\n\nagent = ReflexionAgent(\n    agent_name=\"reflexion-agent\",\n    system_prompt=\"...\",  # Optional custom system prompt\n    model_name=\"openai/o1\",\n    max_loops=3,\n    memory_capacity=100\n)\n</code></pre>"},{"location":"swarms/agents/reflexion_agent/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>agent_name</code> <code>str</code> <code>\"reflexion-agent\"</code> Name of the agent <code>system_prompt</code> <code>str</code> <code>REFLEXION_PROMPT</code> System prompt for the agent <code>model_name</code> <code>str</code> <code>\"openai/o1\"</code> Model name for generating responses <code>max_loops</code> <code>int</code> <code>3</code> Maximum number of reflection iterations per task <code>memory_capacity</code> <code>int</code> <code>100</code> Maximum capacity of long-term memory"},{"location":"swarms/agents/reflexion_agent/#methods","title":"Methods","text":""},{"location":"swarms/agents/reflexion_agent/#act","title":"act","text":"<p>Generates a response to the given task using the actor agent.</p> <pre><code>response = agent.act(task: str, relevant_memories: List[Dict[str, Any]] = None) -&gt; str\n</code></pre> Parameter Type Description <code>task</code> <code>str</code> The task to respond to <code>relevant_memories</code> <code>List[Dict[str, Any]]</code> Optional relevant past memories to consider"},{"location":"swarms/agents/reflexion_agent/#evaluate","title":"evaluate","text":"<p>Evaluates the quality of a response to a task.</p> <pre><code>evaluation, score = agent.evaluate(task: str, response: str) -&gt; Tuple[str, float]\n</code></pre> Parameter Type Description <code>task</code> <code>str</code> The original task <code>response</code> <code>str</code> The response to evaluate <p>Returns: - <code>evaluation</code>: Detailed feedback on the response - <code>score</code>: Numerical score between 0 and 1</p>"},{"location":"swarms/agents/reflexion_agent/#reflect","title":"reflect","text":"<p>Generates a self-reflection based on the task, response, and evaluation.</p> <pre><code>reflection = agent.reflect(task: str, response: str, evaluation: str) -&gt; str\n</code></pre> Parameter Type Description <code>task</code> <code>str</code> The original task <code>response</code> <code>str</code> The generated response <code>evaluation</code> <code>str</code> The evaluation feedback"},{"location":"swarms/agents/reflexion_agent/#refine","title":"refine","text":"<p>Refines the original response based on evaluation and reflection.</p> <pre><code>refined_response = agent.refine(\n    task: str,\n    original_response: str,\n    evaluation: str,\n    reflection: str\n) -&gt; str\n</code></pre> Parameter Type Description <code>task</code> <code>str</code> The original task <code>original_response</code> <code>str</code> The original response <code>evaluation</code> <code>str</code> The evaluation feedback <code>reflection</code> <code>str</code> The self-reflection"},{"location":"swarms/agents/reflexion_agent/#step","title":"step","text":"<p>Processes a single task through one iteration of the Reflexion process.</p> <pre><code>result = agent.step(\n    task: str,\n    iteration: int = 0,\n    previous_response: str = None\n) -&gt; Dict[str, Any]\n</code></pre> Parameter Type Description <code>task</code> <code>str</code> The task to process <code>iteration</code> <code>int</code> Current iteration number <code>previous_response</code> <code>str</code> Response from previous iteration <p>Returns a dictionary containing: - <code>task</code>: The original task - <code>response</code>: The generated response - <code>evaluation</code>: The evaluation feedback - <code>reflection</code>: The self-reflection - <code>score</code>: Numerical score - <code>iteration</code>: Current iteration number</p>"},{"location":"swarms/agents/reflexion_agent/#run","title":"run","text":"<p>Executes the Reflexion process for a list of tasks.</p> <pre><code>results = agent.run(\n    tasks: List[str],\n    include_intermediates: bool = False\n) -&gt; List[Any]\n</code></pre> Parameter Type Description <code>tasks</code> <code>List[str]</code> List of tasks to process <code>include_intermediates</code> <code>bool</code> Whether to include intermediate iterations in results <p>Returns: - If <code>include_intermediates=False</code>: List of final responses - If <code>include_intermediates=True</code>: List of complete iteration histories</p>"},{"location":"swarms/agents/reflexion_agent/#example-usage","title":"Example Usage","text":"<pre><code>from swarms.agents import ReflexionAgent\n\n# Initialize the Reflexion Agent\nagent = ReflexionAgent(\n    agent_name=\"reflexion-agent\",\n    model_name=\"openai/o1\",\n    max_loops=3\n)\n\n# Example tasks\ntasks = [\n    \"Explain quantum computing to a beginner.\",\n    \"Write a Python function to sort a list of dictionaries by a specific key.\"\n]\n\n# Run the agent\nresults = agent.run(tasks)\n\n# Print results\nfor i, result in enumerate(results):\n    print(f\"\\nTask {i+1}: {tasks[i]}\")\n    print(f\"Response: {result}\")\n</code></pre>"},{"location":"swarms/agents/reflexion_agent/#memory-system","title":"Memory System","text":"<p>The ReflexionAgent includes a sophisticated memory system (<code>ReflexionMemory</code>) that maintains both short-term and long-term memories of past experiences, reflections, and feedback. This system helps the agent learn from past interactions and improve its responses over time.</p>"},{"location":"swarms/agents/reflexion_agent/#memory-features","title":"Memory Features","text":"<ul> <li>Short-term memory for recent interactions</li> <li>Long-term memory for important reflections and patterns</li> <li>Automatic memory management with capacity limits</li> <li>Relevance-based memory retrieval</li> <li>Similarity-based deduplication</li> </ul>"},{"location":"swarms/agents/reflexion_agent/#best-practices","title":"Best Practices","text":"<ol> <li>Task Clarity: Provide clear, specific tasks to get the best results</li> <li>Iteration Count: Adjust <code>max_loops</code> based on task complexity (more complex tasks may benefit from more iterations)</li> <li>Memory Management: Monitor memory usage and adjust <code>memory_capacity</code> as needed</li> <li>Model Selection: Choose an appropriate model based on your specific use case and requirements</li> <li>Error Handling: Implement proper error handling when using the agent in production</li> </ol>"},{"location":"swarms/agents/structured_outputs/","title":"Agentic Structured Outputs","text":"<p>Overview</p> <p>Structured outputs help ensure that your agents return data in a consistent, predictable format that can be easily parsed and processed by your application. This is particularly useful when building complex applications that require standardized data handling.</p>"},{"location":"swarms/agents/structured_outputs/#schema-definition","title":"Schema Definition","text":"<p>Structured outputs are defined using JSON Schema format. Here's the basic structure:</p> Basic SchemaAdvanced Schema Basic Tool Schema<pre><code>tools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"function_name\",\n            \"description\": \"Description of what the function does\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    # Define your parameters here\n                },\n                \"required\": [\n                    # List required parameters\n                ]\n            }\n        }\n    }\n]\n</code></pre> Advanced Tool Schema with Multiple Parameters<pre><code>tools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"advanced_function\",\n            \"description\": \"Advanced function with multiple parameter types\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"text_param\": {\n                        \"type\": \"string\",\n                        \"description\": \"A text parameter\"\n                    },\n                    \"number_param\": {\n                        \"type\": \"number\",\n                        \"description\": \"A numeric parameter\"\n                    },\n                    \"boolean_param\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"A boolean parameter\"\n                    },\n                    \"array_param\": {\n                        \"type\": \"array\",\n                        \"items\": {\"type\": \"string\"},\n                        \"description\": \"An array of strings\"\n                    }\n                },\n                \"required\": [\"text_param\", \"number_param\"]\n            }\n        }\n    }\n]\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#parameter-types","title":"Parameter Types","text":"<p>The following parameter types are supported:</p> Type Description Example <code>string</code> Text values <code>\"Hello World\"</code> <code>number</code> Numeric values <code>42</code>, <code>3.14</code> <code>boolean</code> True/False values <code>true</code>, <code>false</code> <code>object</code> Nested objects <code>{\"key\": \"value\"}</code> <code>array</code> Lists or arrays <code>[1, 2, 3]</code> <code>null</code> Null values <code>null</code>"},{"location":"swarms/agents/structured_outputs/#implementation-steps","title":"Implementation Steps","text":"<p>Quick Start Guide</p> <p>Follow these steps to implement structured outputs in your agent:</p>"},{"location":"swarms/agents/structured_outputs/#step-1-define-your-schema","title":"Step 1: Define Your Schema","text":"<pre><code>tools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_stock_price\",\n            \"description\": \"Retrieve stock price information\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"ticker\": {\n                        \"type\": \"string\",\n                        \"description\": \"Stock ticker symbol\"\n                    },\n                    \"include_volume\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Include trading volume data\"\n                    }\n                },\n                \"required\": [\"ticker\"]\n            }\n        }\n    }\n]\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#step-2-initialize-the-agent","title":"Step 2: Initialize the Agent","text":"<pre><code>from swarms import Agent\n\nagent = Agent(\n    agent_name=\"Your-Agent-Name\",\n    agent_description=\"Agent description\",\n    system_prompt=\"Your system prompt\",\n    tools_list_dictionary=tools\n)\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#step-3-run-the-agent","title":"Step 3: Run the Agent","text":"<pre><code>response = agent.run(\"Your query here\")\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#step-4-parse-the-output","title":"Step 4: Parse the Output","text":"<pre><code>from swarms.utils.str_to_dict import str_to_dict\n\nparsed_output = str_to_dict(response)\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#example-usage","title":"Example Usage","text":"<p>Complete Financial Agent Example</p> <p>Here's a comprehensive example using a financial analysis agent:</p> Python ImplementationExpected Output <pre><code>from dotenv import load_dotenv\nfrom swarms import Agent\nfrom swarms.utils.str_to_dict import str_to_dict\n\n# Load environment variables\nload_dotenv()\n\n# Define tools with structured output schema\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_stock_price\",\n            \"description\": \"Retrieve the current stock price and related information\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"ticker\": {\n                        \"type\": \"string\",\n                        \"description\": \"Stock ticker symbol (e.g., AAPL, GOOGL)\"\n                    },\n                    \"include_history\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Include historical data in the response\"\n                    },\n                    \"time\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"Specific time for stock data (ISO format)\"\n                    }\n                },\n                \"required\": [\"ticker\", \"include_history\", \"time\"]\n            }\n        }\n    }\n]\n\n# Initialize agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    system_prompt=\"You are a helpful financial analysis assistant.\",\n    max_loops=1,\n    tools_list_dictionary=tools\n)\n\n# Run agent\nresponse = agent.run(\"What is the current stock price for AAPL?\")\n\n# Parse structured output\nparsed_data = str_to_dict(response)\nprint(f\"Parsed response: {parsed_data}\")\n</code></pre> <pre><code>{\n    \"function_calls\": [\n        {\n            \"name\": \"get_stock_price\",\n            \"arguments\": {\n                \"ticker\": \"AAPL\",\n                \"include_history\": true,\n                \"time\": \"2024-01-15T10:30:00Z\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#best-practices","title":"Best Practices","text":"<p>Schema Design</p> <ul> <li> <p>Keep it simple: Design schemas that are as simple as possible while meeting your needs</p> </li> <li> <p>Clear naming: Use descriptive parameter names that clearly indicate their purpose</p> </li> <li> <p>Detailed descriptions: Include comprehensive descriptions for each parameter</p> </li> <li> <p>Required fields: Explicitly specify all required parameters</p> </li> </ul> <p>Error Handling</p> <ul> <li> <p>Validate output: Always validate the output format before processing</p> </li> <li> <p>Exception handling: Implement proper error handling for parsing failures</p> </li> <li> <p>Safety first: Use try-except blocks when converting strings to dictionaries</p> </li> </ul> <p>Performance Tips</p> <ul> <li> <p>Minimize requirements: Keep the number of required parameters to a minimum</p> </li> <li> <p>Appropriate types: Use the most appropriate data types for each parameter</p> </li> <li> <p>Caching: Consider caching parsed results if they're used frequently</p> </li> </ul>"},{"location":"swarms/agents/structured_outputs/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues</p>"},{"location":"swarms/agents/structured_outputs/#invalid-output-format","title":"Invalid Output Format","text":"<p>Problem</p> <p>The agent returns data in an unexpected format</p> <p>Solution</p> <ul> <li> <p>Ensure your schema matches the expected output structure</p> </li> <li> <p>Verify all required fields are present in the response</p> </li> <li> <p>Check for proper JSON formatting in the output</p> </li> </ul>"},{"location":"swarms/agents/structured_outputs/#parsing-errors","title":"Parsing Errors","text":"<p>Problem</p> <p>Errors occur when trying to parse the agent's response</p> <p>Solution</p> <pre><code>from swarms.utils.str_to_dict import str_to_dict\n\ntry:\n    parsed_data = str_to_dict(response)\nexcept Exception as e:\n    print(f\"Parsing error: {e}\")\n    # Handle the error appropriately\n</code></pre>"},{"location":"swarms/agents/structured_outputs/#missing-fields","title":"Missing Fields","text":"<p>Problem</p> <p>Required fields are missing from the output</p> <p>Solution</p> <ul> <li>Verify all required fields are defined in the schema</li> <li>Check if the agent is properly configured with the tools</li> <li>Review the system prompt for clarity and completeness</li> </ul>"},{"location":"swarms/agents/structured_outputs/#advanced-features","title":"Advanced Features","text":"<p>Pro Tips</p> Nested ObjectsConditional Fields nested_schema.py<pre><code>\"properties\": {\n    \"user_info\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"name\": {\"type\": \"string\"},\n            \"age\": {\"type\": \"number\"},\n            \"preferences\": {\n                \"type\": \"array\",\n                \"items\": {\"type\": \"string\"}\n            }\n        }\n    }\n}\n</code></pre> conditional_schema.py<pre><code>\"properties\": {\n    \"data_type\": {\n        \"type\": \"string\",\n        \"enum\": [\"stock\", \"crypto\", \"forex\"]\n    },\n    \"symbol\": {\"type\": \"string\"},\n    \"exchange\": {\n        \"type\": \"string\",\n        \"description\": \"Required for crypto and forex\"\n    }\n}\n</code></pre>"},{"location":"swarms/agents/third_party/","title":"Swarms Framework: Integrating and Customizing Agent Libraries","text":"<p>Agent-based systems have emerged as a powerful paradigm for solving complex problems and automating tasks. </p> <p>The swarms framework offers a flexible and extensible approach to working with various agent libraries, allowing developers to create custom agents and integrate them seamlessly into their projects. </p> <p>In this comprehensive guide, we'll explore the swarms framework, discuss agent handling, and demonstrate how to build custom agents using swarms. We'll also cover the integration of popular agent libraries such as Langchain, Griptape, CrewAI, and Autogen.</p>"},{"location":"swarms/agents/third_party/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to the Swarms Framework</li> <li>The Need for Wrappers</li> <li>Building Custom Agents with Swarms</li> <li>Integrating Third-Party Agent Libraries</li> <li>Griptape Integration</li> <li>Langchain Integration</li> <li>CrewAI Integration</li> <li>Autogen Integration</li> <li>Advanced Agent Handling Techniques</li> <li>Best Practices for Custom Agent Development</li> <li>Future Directions and Challenges</li> <li>Conclusion</li> </ol>"},{"location":"swarms/agents/third_party/#1-introduction-to-the-swarms-framework","title":"1. Introduction to the Swarms Framework","text":"<p>The swarms framework is a powerful and flexible system designed to facilitate the creation, management, and coordination of multiple AI agents. It provides a standardized interface for working with various agent types, allowing developers to leverage the strengths of different agent libraries while maintaining a consistent programming model.</p> <p>At its core, the swarms framework is built around the concept of a parent <code>Agent</code> class, which serves as a foundation for creating custom agents and integrating third-party agent libraries. This approach offers several benefits:</p> <ol> <li>Consistency: By wrapping different agent implementations with a common interface, developers can work with a unified API across various agent types.</li> <li>Extensibility: The framework makes it easy to add new agent types or customize existing ones without affecting the overall system architecture.</li> <li>Interoperability: Agents from different libraries can communicate and collaborate seamlessly within the swarms ecosystem.</li> <li>Scalability: The standardized approach allows for easier scaling of agent-based systems, from simple single-agent applications to complex multi-agent swarms.</li> </ol>"},{"location":"swarms/agents/third_party/#2-the-need-for-wrappers","title":"2. The Need for Wrappers","text":"<p>As the field of AI and agent-based systems continues to grow, numerous libraries and frameworks have emerged, each with its own strengths and specialized features. While this diversity offers developers a wide range of tools to choose from, it also presents challenges in terms of integration and interoperability.</p> <p>This is where the concept of wrappers becomes crucial. By creating wrappers around different agent libraries, we can:</p> <ol> <li>Unify interfaces: Standardize the way we interact with agents, regardless of their underlying implementation.</li> <li>Simplify integration: Make it easier to incorporate new agent libraries into existing projects.</li> <li>Enable composition: Allow for the creation of complex agent systems that leverage the strengths of multiple libraries.</li> <li>Facilitate maintenance: Centralize the management of agent-related code and reduce the impact of library-specific changes.</li> </ol> <p>In the context of the swarms framework, wrappers take the form of custom classes that inherit from the parent <code>Agent</code> class. These wrapper classes encapsulate the functionality of specific agent libraries while exposing a consistent interface that aligns with the swarms framework.</p>"},{"location":"swarms/agents/third_party/#3-building-custom-agents-with-swarms","title":"3. Building Custom Agents with Swarms","text":"<p>To illustrate the process of building custom agents using the swarms framework, let's start with a basic example of creating a custom agent class:</p> <pre><code>from swarms import Agent\n\nclass MyCustomAgent(Agent):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        # Custom initialization logic\n\n    def custom_method(self, *args, **kwargs):\n        # Implement custom logic here\n        pass\n\n    def run(self, task, *args, **kwargs):\n        # Customize the run method\n        response = super().run(task, *args, **kwargs)\n        # Additional custom logic\n        return response\n</code></pre> <p>This example demonstrates the fundamental structure of a custom agent class within the swarms framework. Let's break down the key components:</p> <ol> <li> <p>Inheritance: The class inherits from the <code>Agent</code> parent class, ensuring it adheres to the swarms framework's interface.</p> </li> <li> <p>Initialization: The <code>__init__</code> method calls the parent class's initializer and can include additional custom initialization logic.</p> </li> <li> <p>Custom methods: You can add any number of custom methods to extend the agent's functionality.</p> </li> <li> <p>Run method: The <code>run</code> method is a key component of the agent interface. By overriding this method, you can customize how the agent processes tasks while still leveraging the parent class's functionality.</p> </li> </ol> <p>To create more sophisticated custom agents, you can expand on this basic structure by adding features such as:</p> <ul> <li>State management: Implement methods to manage the agent's internal state.</li> <li>Communication protocols: Define how the agent interacts with other agents in the swarm.</li> <li>Learning capabilities: Incorporate machine learning models or adaptive behaviors.</li> <li>Specialized task handling: Create methods for dealing with specific types of tasks or domains.</li> </ul> <p>By leveraging these custom agent classes, developers can create highly specialized and adaptive agents tailored to their specific use cases while still benefiting from the standardized interface provided by the swarms framework.</p>"},{"location":"swarms/agents/third_party/#4-integrating-third-party-agent-libraries","title":"4. Integrating Third-Party Agent Libraries","text":"<p>One of the key strengths of the swarms framework is its ability to integrate with various third-party agent libraries. In this section, we'll explore how to create wrappers for popular agent libraries, including Griptape, Langchain, CrewAI, and Autogen.</p>"},{"location":"swarms/agents/third_party/#griptape-integration","title":"Griptape Integration","text":"<p>Griptape is a powerful library for building AI agents with a focus on composability and tool use. Let's create a wrapper for a Griptape agent:</p> <pre><code>from typing import List, Optional\n\nfrom griptape.structures import Agent as GriptapeAgent\nfrom griptape.tools import FileManager, TaskMemoryClient, WebScraper\n\nfrom swarms import Agent\n\n\nclass GriptapeAgentWrapper(Agent):\n    \"\"\"\n    A wrapper class for the GriptapeAgent from the griptape library.\n    \"\"\"\n\n    def __init__(self, name: str, tools: Optional[List] = None, *args, **kwargs):\n        \"\"\"\n        Initialize the GriptapeAgentWrapper.\n\n        Parameters:\n        - name: The name of the agent.\n        - tools: A list of tools to be used by the agent. If not provided, default tools will be used.\n        - *args, **kwargs: Additional arguments to be passed to the parent class constructor.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        self.name = name\n        self.tools = tools or [\n            WebScraper(off_prompt=True),\n            TaskMemoryClient(off_prompt=True),\n            FileManager()\n        ]\n        self.griptape_agent = GriptapeAgent(\n            input=f\"I am {name}, an AI assistant. How can I help you?\",\n            tools=self.tools\n        )\n\n    def run(self, task: str, *args, **kwargs) -&gt; str:\n        \"\"\"\n        Run a task using the GriptapeAgent.\n\n        Parameters:\n        - task: The task to be performed by the agent.\n\n        Returns:\n        - The response from the GriptapeAgent as a string.\n        \"\"\"\n        response = self.griptape_agent.run(task, *args, **kwargs)\n        return str(response)\n\n    def add_tool(self, tool) -&gt; None:\n        \"\"\"\n        Add a tool to the agent.\n\n        Parameters:\n        - tool: The tool to be added.\n        \"\"\"\n        self.tools.append(tool)\n        self.griptape_agent = GriptapeAgent(\n            input=f\"I am {self.name}, an AI assistant. How can I help you?\",\n            tools=self.tools\n        )\n\n# Usage example\ngriptape_wrapper = GriptapeAgentWrapper(\"GriptapeAssistant\")\nresult = griptape_wrapper.run(\"Load https://example.com, summarize it, and store it in a file called example_summary.txt.\")\nprint(result)\n</code></pre> <p>This wrapper encapsulates the functionality of a Griptape agent while exposing it through the swarms framework's interface. It allows for easy customization of tools and provides a simple way to execute tasks using the Griptape agent.</p>"},{"location":"swarms/agents/third_party/#langchain-integration","title":"Langchain Integration","text":"<p>Langchain is a popular framework for developing applications powered by language models. Here's an example of how we can create a wrapper for a Langchain agent:</p> <pre><code>from typing import List, Optional\n\nfrom langchain.agents import AgentExecutor, LLMSingleActionAgent, Tool\nfrom langchain.chains import LLMChain\nfrom langchain_community.llms import OpenAI\nfrom langchain.prompts import StringPromptTemplate\nfrom langchain.tools import DuckDuckGoSearchRun\n\nfrom swarms import Agent\n\n\nclass LangchainAgentWrapper(Agent):\n    \"\"\"\n    Initialize the LangchainAgentWrapper.\n\n    Args:\n        name (str): The name of the agent.\n        tools (List[Tool]): The list of tools available to the agent.\n        llm (Optional[OpenAI], optional): The OpenAI language model to use. Defaults to None.\n    \"\"\"\n    def __init__(\n        self,\n        name: str,\n        tools: List[Tool],\n        llm: Optional[OpenAI] = None,\n        *args,\n        **kwargs,\n    ):\n        super().__init__(*args, **kwargs)\n        self.name = name\n        self.tools = tools\n        self.llm = llm or OpenAI(temperature=0)\n\n        prompt = StringPromptTemplate.from_template(\n            \"You are {name}, an AI assistant. Answer the following question: {question}\"\n        )\n\n        llm_chain = LLMChain(llm=self.llm, prompt=prompt)\n        tool_names = [tool.name for tool in self.tools]\n\n        self.agent = LLMSingleActionAgent(\n            llm_chain=llm_chain,\n            output_parser=None,\n            stop=[\"\\nObservation:\"],\n            allowed_tools=tool_names,\n        )\n\n        self.agent_executor = AgentExecutor.from_agent_and_tools(\n            agent=self.agent, tools=self.tools, verbose=True\n        )\n\n    def run(self, task: str, *args, **kwargs):\n        \"\"\"\n        Run the agent with the given task.\n\n        Args:\n            task (str): The task to be performed by the agent.\n\n        Returns:\n            Any: The result of the agent's execution.\n        \"\"\"\n        try:\n            return self.agent_executor.run(task)\n        except Exception as e:\n            print(f\"An error occurred: {e}\")\n\n\n# Usage example\n\nsearch_tool = DuckDuckGoSearchRun()\ntools = [\n    Tool(\n        name=\"Search\",\n        func=search_tool.run,\n        description=\"Useful for searching the internet\",\n    )\n]\n\nlangchain_wrapper = LangchainAgentWrapper(\"LangchainAssistant\", tools)\nresult = langchain_wrapper.run(\"What is the capital of France?\")\nprint(result)\n</code></pre> <p>This wrapper integrates a Langchain agent into the swarms framework, allowing for easy use of Langchain's powerful features such as tool use and multi-step reasoning.</p>"},{"location":"swarms/agents/third_party/#crewai-integration","title":"CrewAI Integration","text":"<p>CrewAI is a library focused on creating and managing teams of AI agents. Let's create a wrapper for a CrewAI agent:</p> <pre><code>from swarms import Agent\nfrom crewai import Agent as CrewAIAgent\nfrom crewai import Task, Crew, Process\n\nclass CrewAIAgentWrapper(Agent):\n    def __init__(self, name, role, goal, backstory, tools=None, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.name = name\n        self.crewai_agent = CrewAIAgent(\n            role=role,\n            goal=goal,\n            backstory=backstory,\n            verbose=True,\n            allow_delegation=False,\n            tools=tools or []\n        )\n\n    def run(self, task, *args, **kwargs):\n        crew_task = Task(\n            description=task,\n            agent=self.crewai_agent\n        )\n        crew = Crew(\n            agents=[self.crewai_agent],\n            tasks=[crew_task],\n            process=Process.sequential\n        )\n        result = crew.kickoff()\n        return result\n\n# Usage example\nfrom crewai_tools import SerperDevTool\n\nsearch_tool = SerperDevTool()\n\ncrewai_wrapper = CrewAIAgentWrapper(\n    \"ResearchAnalyst\",\n    role='Senior Research Analyst',\n    goal='Uncover cutting-edge developments in AI and data science',\n    backstory=\"\"\"You work at a leading tech think tank.\n    Your expertise lies in identifying emerging trends.\n    You have a knack for dissecting complex data and presenting actionable insights.\"\"\",\n    tools=[search_tool]\n)\n\nresult = crewai_wrapper.run(\"Analyze the latest trends in quantum computing and summarize the key findings.\")\nprint(result)\n</code></pre> <p>This wrapper allows us to use CrewAI agents within the swarms framework, leveraging CrewAI's focus on role-based agents and collaborative task execution.</p>"},{"location":"swarms/agents/third_party/#autogen-integration","title":"Autogen Integration","text":"<p>Autogen is a framework for building conversational AI agents. Here's how we can create a wrapper for an Autogen agent:</p> <pre><code>from swarms import Agent\nfrom autogen import ConversableAgent\n\nclass AutogenAgentWrapper(Agent):\n    def __init__(self, name, llm_config, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.name = name\n        self.autogen_agent = ConversableAgent(\n            name=name,\n            llm_config=llm_config,\n            code_execution_config=False,\n            function_map=None,\n            human_input_mode=\"NEVER\"\n        )\n\n    def run(self, task, *args, **kwargs):\n        messages = [{\"content\": task, \"role\": \"user\"}]\n        response = self.autogen_agent.generate_reply(messages)\n        return response\n\n# Usage example\nimport os\n\nllm_config = {\n    \"config_list\": [{\"model\": \"gpt-4\", \"api_key\": os.environ.get(\"OPENAI_API_KEY\")}]\n}\n\nautogen_wrapper = AutogenAgentWrapper(\"AutogenAssistant\", llm_config)\nresult = autogen_wrapper.run(\"Tell me a joke about programming.\")\nprint(result)\n</code></pre> <p>This wrapper integrates Autogen's ConversableAgent into the swarms framework, allowing for easy use of Autogen's conversational AI capabilities.</p> <p>By creating these wrappers, we can seamlessly integrate agents from various libraries into the swarms framework, allowing for a unified approach to agent management and task execution.</p>"},{"location":"swarms/agents/third_party/#5-advanced-agent-handling-techniques","title":"5. Advanced Agent Handling Techniques","text":"<p>As you build more complex systems using the swarms framework and integrated agent libraries, you'll need to employ advanced techniques for agent handling. Here are some strategies to consider:</p>"},{"location":"swarms/agents/third_party/#1-dynamic-agent-creation","title":"1. Dynamic Agent Creation","text":"<p>Implement a factory pattern to create agents dynamically based on task requirements:</p> <pre><code>class AgentFactory:\n    @staticmethod\n    def create_agent(agent_type, *args, **kwargs):\n        if agent_type == \"griptape\":\n            return GriptapeAgentWrapper(*args, **kwargs)\n        elif agent_type == \"langchain\":\n            return LangchainAgentWrapper(*args, **kwargs)\n        elif agent_type == \"crewai\":\n            return CrewAIAgentWrapper(*args, **kwargs)\n        elif agent_type == \"autogen\":\n            return AutogenAgentWrapper(*args, **kwargs)\n        else:\n            raise ValueError(f\"Unknown agent type: {agent_type}\")\n\n# Usage\nagent = AgentFactory.create_agent(\"griptape\", \"DynamicGriptapeAgent\")\n</code></pre>"},{"location":"swarms/agents/third_party/#2-agent-pooling","title":"2. Agent Pooling","text":"<p>Implement an agent pool to manage and reuse agents efficiently:</p> <pre><code>from queue import Queue\n\nclass AgentPool:\n    def __init__(self, pool_size=5):\n        self.pool = Queue(maxsize=pool_size)\n        self.pool_size = pool_size\n\n    def get_agent(self, agent_type, *args, **kwargs):\n        if not self.pool.empty():\n            return self.pool.get()\n        else:\n            return AgentFactory.create_agent(agent_type, *args, **kwargs)\n\n    def release_agent(self, agent):\n        if self.pool.qsize() &lt; self.pool_size:\n            self.pool.put(agent)\n\n# Usage\npool = AgentPool()\nagent = pool.get_agent(\"langchain\", \"PooledLangchainAgent\")\nresult = agent.run(\"Perform a task\")\npool.release_agent(agent)\n</code></pre>"},{"location":"swarms/agents/third_party/#3-agent-composition","title":"3. Agent Composition","text":"<p>Create composite agents that combine the capabilities of multiple agent types:</p> <pre><code>class CompositeAgent(Agent):\n    def __init__(self, name, agents):\n        super().__init__()\n        self.name = name\n        self.agents = agents\n\n    def run(self, task):\n        results = []\n        for agent in self.agents:\n            results.append(agent.run(task))\n        return self.aggregate_results(results)\n\n    def aggregate_results(self, results):\n        # Implement your own logic to combine results\n        return \"\\n\".join(results)\n\n# Usage\ngriptape_agent = GriptapeAgentWrapper(\"GriptapeComponent\")\nlangchain_agent = LangchainAgentWrapper(\"LangchainComponent\", [])\ncomposite_agent = CompositeAgent(\"CompositeAssistant\", [griptape_agent, langchain_agent])\nresult = composite_agent.run(\"Analyze the pros and cons of quantum computing\")\n</code></pre>"},{"location":"swarms/agents/third_party/#4-agent-specialization","title":"4. Agent Specialization","text":"<p>Create specialized agents for specific domains or tasks:</p> <pre><code>class DataAnalysisAgent(Agent):\n    def __init__(self, name, analysis_tools):\n        super().__init__()\n        self.name = name\n        self.analysis_tools = analysis_tools\n\n    def run(self, data):\n        results = {}\n        for tool in self.analysis_tools:\n            results[tool.name] = tool.analyze(data)\n        return results\n\n# Usage\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\nclass AnalysisTool:\n    def __init__(self, name, func):\n        self.name = name\n        self.func = func\n\n    def analyze(self, data):\n        return self.func(data)\n\ntools = [\n    AnalysisTool(\"Descriptive Stats\", lambda data: data.describe()),\n    AnalysisTool(\"Correlation\", lambda data: data.corr()),\n    AnalysisTool(\"PCA\", lambda data: PCA().fit_transform(StandardScaler().fit_transform(data)))\n]\n\ndata_agent = DataAnalysisAgent(\"DataAnalyst\", tools)\ndf = pd.read_csv(\"sample_data.csv\")\nanalysis_results = data_agent.run(df)\n</code></pre>"},{"location":"swarms/agents/third_party/#5-agent-monitoring-and-logging","title":"5. Agent Monitoring and Logging","text":"<p>Implement a monitoring system to track agent performance and log their activities:</p> <p><pre><code>import logging\nfrom functools import wraps\n\ndef log_agent_activity(func):\n    @wraps(func)\n    def wrapper(self, *args, **kwargs):\n        logging.info(f\"Agent {self.name} started task: {args[0]}\")\n        result = func(self, *args, **kwargs)\n        logging.info(f\"Agent {self.name} completed task. Result length: {len(str(result))}\")\n        return result\n    return wrapper\n\nclass MonitoredAgent(Agent):\n    def __init__(self, name, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.name = name\n\n    @log_agent_activity\n    def run(self, task, *args, **kwargs):\n        return super().run(task, *args, **kwargs)\n\n# Usage\nlogging.basicConfig(level=logging.INFO)\nmonitored_agent = MonitoredAgent(\"MonitoredGriptapeAgent\")\nresult = monitored_agent.run(\"Summarize the latest AI research papers\")\n</code></pre> Additionally the Agent class now includes built-in logging functionality and the ability to switch between JSON and string output. </p> <p>To switch between JSON and string output: - Use <code>output_type=\"str\"</code> for string output (default) - Use <code>output_type=\"json\"</code> for JSON output</p> <p>The <code>output_type</code> parameter determines the format of the final result returned by the <code>run</code> method. When set to \"str\", it returns a string representation of the agent's response. When set to \"json\", it returns a JSON object containing detailed information about the agent's run, including all steps and metadata.</p>"},{"location":"swarms/agents/third_party/#6-best-practices-for-custom-agent-development","title":"6. Best Practices for Custom Agent Development","text":"<p>When developing custom agents using the swarms framework, consider the following best practices:</p> <ol> <li> <p>Modular Design: Design your agents with modularity in mind. Break down complex functionality into smaller, reusable components.</p> </li> <li> <p>Consistent Interfaces: Maintain consistent interfaces across your custom agents to ensure interoperability within the swarms framework.</p> </li> <li> <p>Error Handling: Implement robust error handling and graceful degradation in your agents to ensure system stability.</p> </li> <li> <p>Performance Optimization: Optimize your agents for performance, especially when dealing with resource-intensive tasks or large-scale deployments.</p> </li> <li> <p>Testing and Validation: Develop comprehensive test suites for your custom agents to ensure their reliability and correctness.</p> </li> <li> <p>Documentation: Provide clear and detailed documentation for your custom agents, including their capabilities, limitations, and usage examples.</p> </li> <li> <p>Versioning: Implement proper versioning for your custom agents to manage updates and maintain backwards compatibility.</p> </li> <li> <p>Security Considerations: Implement security best practices, especially when dealing with sensitive data or integrating with external services.</p> </li> </ol> <p>Here's an example that incorporates some of these best practices:</p> <pre><code>import logging\nfrom typing import Dict, Any\nfrom swarms import Agent\n\nclass SecureCustomAgent(Agent):\n    def __init__(self, name: str, api_key: str, version: str = \"1.0.0\", *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.name = name\n        self._api_key = api_key  # Store sensitive data securely\n        self.version = version\n        self.logger = logging.getLogger(f\"{self.__class__.__name__}.{self.name}\")\n\n    def run(self, task: str, *args, **kwargs) -&gt; Dict[str, Any]:\n        try:\n            self.logger.info(f\"Agent {self.name} (v{self.version}) starting task: {task}\")\n            result = self._process_task(task)\n            self.logger.info(f\"Agent {self.name} completed task successfully\")\n            return {\"status\": \"success\", \"result\": result}\n        except Exception as e:\n            self.logger.error(f\"Error in agent {self.name}: {str(e)}\")\n            return {\"status\": \"error\", \"message\": str(e)}\n\n    def _process_task(self, task: str) -&gt; str:\n        # Implement the core logic of your agent here\n        # This is a placeholder implementation\n        return f\"Processed task: {task}\"\n\n    @property\n    def api_key(self) -&gt; str:\n        # Provide a secure way to access the API key\n        return self._api_key\n\n    def __repr__(self) -&gt; str:\n        return f\"&lt;{self.__class__.__name__} name='{self.name}' version='{self.version}'&gt;\"\n\n# Usage\nlogging.basicConfig(level=logging.INFO)\nsecure_agent = SecureCustomAgent(\"SecureAgent\", api_key=\"your-api-key-here\")\nresult = secure_agent.run(\"Perform a secure operation\")\nprint(result)\n</code></pre> <p>This example demonstrates several best practices: - Modular design with separate methods for initialization and task processing - Consistent interface adhering to the swarms framework - Error handling and logging - Secure storage of sensitive data (API key) - Version tracking - Type hinting for improved code readability and maintainability - Informative string representation of the agent</p>"},{"location":"swarms/agents/third_party/#7-future-directions-and-challenges","title":"7. Future Directions and Challenges","text":"<p>As the field of AI and agent-based systems continues to evolve, the swarms framework and its ecosystem of integrated agent libraries will face new opportunities and challenges. Some potential future directions and areas of focus include:</p> <ol> <li> <p>Enhanced Interoperability: Developing more sophisticated protocols for agent communication and collaboration across different libraries and frameworks.</p> </li> <li> <p>Scalability: Improving the framework's ability to handle large-scale swarms of agents, potentially leveraging distributed computing techniques.</p> </li> <li> <p>Adaptive Learning: Incorporating more advanced machine learning techniques to allow agents to adapt and improve their performance over time.</p> </li> <li> <p>Ethical AI: Integrating ethical considerations and safeguards into the agent development process to ensure responsible AI deployment.</p> </li> <li> <p>Human-AI Collaboration: Exploring new paradigms for human-AI interaction and collaboration within the swarms framework.</p> </li> <li> <p>Domain-Specific Optimizations: Developing specialized agent types and tools for specific industries or problem domains.</p> </li> <li> <p>Explainability and Transparency: Improving the ability to understand and explain agent decision-making processes.</p> </li> <li> <p>Security and Privacy: Enhancing the framework's security features to protect against potential vulnerabilities and ensure data privacy.</p> </li> </ol> <p>As these areas develop, developers working with the swarms framework will need to stay informed about new advancements and be prepared to adapt their agent implementations accordingly.</p>"},{"location":"swarms/agents/third_party/#8-conclusion","title":"8. Conclusion","text":"<p>The swarms framework provides a powerful and flexible foundation for building custom agents and integrating various agent libraries. By leveraging the techniques and best practices discussed in this guide, developers can create sophisticated, efficient, and scalable agent-based systems.</p> <p>The ability to seamlessly integrate agents from libraries like Griptape, Langchain, CrewAI, and Autogen opens up a world of possibilities for creating diverse and specialized AI applications. Whether you're building a complex multi-agent system for data analysis, a conversational AI platform, or a collaborative problem-solving environment, the swarms framework offers the tools and flexibility to bring your vision to life.</p> <p>As you embark on your journey with the swarms framework, remember that the field of AI and agent-based systems is rapidly evolving. Stay curious, keep experimenting, and don't hesitate to push the boundaries of what's possible with custom agents and integrated libraries.</p> <p>By embracing the power of the swarms framework and the ecosystem of agent libraries it supports, you're well-positioned to create the next generation of intelligent, adaptive, and collaborative AI systems. Happy agent building!</p>"},{"location":"swarms/agents/tool_agent/","title":"ToolAgent Documentation","text":"<p>The <code>ToolAgent</code> class is a specialized agent that facilitates the execution of specific tasks using a model and tokenizer. It is part of the <code>swarms</code> module and inherits from the <code>Agent</code> class. This agent is designed to generate functions based on a given JSON schema and task, making it highly adaptable for various use cases, including natural language processing and data generation.</p> <p>The <code>ToolAgent</code> class plays a crucial role in leveraging pre-trained models and tokenizers to automate tasks that require the interpretation and generation of structured data. By providing a flexible interface and robust error handling, it ensures smooth integration and efficient task execution.</p>"},{"location":"swarms/agents/tool_agent/#parameters","title":"Parameters","text":"Parameter Type Description <code>name</code> <code>str</code> The name of the tool agent. Default is \"Function Calling Agent\". <code>description</code> <code>str</code> A description of the tool agent. Default is \"Generates a function based on the input json schema and the task\". <code>model</code> <code>Any</code> The model used by the tool agent. <code>tokenizer</code> <code>Any</code> The tokenizer used by the tool agent. <code>json_schema</code> <code>Any</code> The JSON schema used by the tool agent. <code>max_number_tokens</code> <code>int</code> The maximum number of tokens for generation. Default is 500. <code>parsing_function</code> <code>Optional[Callable]</code> An optional parsing function to process the output of the tool agent. <code>llm</code> <code>Any</code> An optional large language model to be used by the tool agent. <code>*args</code> Variable length argument list Additional positional arguments. <code>**kwargs</code> Arbitrary keyword arguments Additional keyword arguments."},{"location":"swarms/agents/tool_agent/#attributes","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> The name of the tool agent. <code>description</code> <code>str</code> A description of the tool agent. <code>model</code> <code>Any</code> The model used by the tool agent. <code>tokenizer</code> <code>Any</code> The tokenizer used by the tool agent. <code>json_schema</code> <code>Any</code> The JSON schema used by the tool agent."},{"location":"swarms/agents/tool_agent/#methods","title":"Methods","text":""},{"location":"swarms/agents/tool_agent/#run","title":"<code>run</code>","text":"<pre><code>def run(self, task: str, *args, **kwargs) -&gt; Any:\n</code></pre> <p>Parameters:</p> Parameter Type Description <code>task</code> <code>str</code> The task to be performed by the tool agent. <code>*args</code> Variable length argument list Additional positional arguments. <code>**kwargs</code> Arbitrary keyword arguments Additional keyword arguments. <p>Returns: </p> <ul> <li>The output of the tool agent.</li> </ul> <p>Raises: </p> <ul> <li><code>Exception</code>: If an error occurs during the execution of the tool agent.</li> </ul>"},{"location":"swarms/agents/tool_agent/#functionality-and-usage","title":"Functionality and Usage","text":"<p>The <code>ToolAgent</code> class provides a structured way to perform tasks using a model and tokenizer. It initializes with essential parameters and attributes, and the <code>run</code> method facilitates the execution of the specified task.</p>"},{"location":"swarms/agents/tool_agent/#initialization","title":"Initialization","text":"<p>The initialization of a <code>ToolAgent</code> involves specifying its name, description, model, tokenizer, JSON schema, maximum number of tokens, optional parsing function, and optional large language model.</p> <pre><code>agent = ToolAgent(\n    name=\"My Tool Agent\",\n    description=\"A tool agent for specific tasks\",\n    model=model,\n    tokenizer=tokenizer,\n    json_schema=json_schema,\n    max_number_tokens=1000,\n    parsing_function=my_parsing_function,\n    llm=my_llm\n)\n</code></pre>"},{"location":"swarms/agents/tool_agent/#running-a-task","title":"Running a Task","text":"<p>To execute a task using the <code>ToolAgent</code>, the <code>run</code> method is called with the task description and any additional arguments or keyword arguments.</p> <pre><code>result = agent.run(\"Generate a person's information based on the given schema.\")\nprint(result)\n</code></pre>"},{"location":"swarms/agents/tool_agent/#detailed-examples","title":"Detailed Examples","text":""},{"location":"swarms/agents/tool_agent/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code>from transformers import AutoModelForCausalLM, AutoTokenizer\nfrom swarms import ToolAgent\n\nmodel = AutoModelForCausalLM.from_pretrained(\"databricks/dolly-v2-12b\")\ntokenizer = AutoTokenizer.from_pretrained(\"databricks/dolly-v2-12b\")\n\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"number\"},\n        \"is_student\": {\"type\": \"boolean\"},\n        \"courses\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\"}\n        }\n    }\n}\n\ntask = \"Generate a person's information based on the following schema:\"\nagent = ToolAgent(model=model, tokenizer=tokenizer, json_schema=json_schema)\ngenerated_data = agent.run(task)\n\nprint(generated_data)\n</code></pre>"},{"location":"swarms/agents/tool_agent/#example-2-using-a-parsing-function","title":"Example 2: Using a Parsing Function","text":"<pre><code>def parse_output(output):\n    # Custom parsing logic\n    return output\n\nagent = ToolAgent(\n    name=\"Parsed Tool Agent\",\n    description=\"A tool agent with a parsing function\",\n    model=model,\n    tokenizer=tokenizer,\n    json_schema=json_schema,\n    parsing_function=parse_output\n)\n\ntask = \"Generate a person's information with custom parsing:\"\nparsed_data = agent.run(task)\n\nprint(parsed_data)\n</code></pre>"},{"location":"swarms/agents/tool_agent/#example-3-specifying-maximum-number-of-tokens","title":"Example 3: Specifying Maximum Number of Tokens","text":"<pre><code>agent = ToolAgent(\n    name=\"Token Limited Tool Agent\",\n    description=\"A tool agent with a token limit\",\n    model=model,\n    tokenizer=tokenizer,\n    json_schema=json_schema,\n    max_number_tokens=200\n)\n\ntask = \"Generate a concise person's information:\"\nlimited_data = agent.run(task)\n\nprint(limited_data)\n</code></pre>"},{"location":"swarms/agents/tool_agent/#full-usage","title":"Full Usage","text":"<pre><code>from pydantic import BaseModel, Field\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nfrom swarms import ToolAgent\nfrom swarms.tools.json_utils import base_model_to_json\n\n# Model name\nmodel_name = \"CohereForAI/c4ai-command-r-v01-4bit\"\n\n# Load the pre-trained model and tokenizer\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    device_map=\"auto\",\n)\n\n# Load the pre-trained model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\n\n# Initialize the schema for the person's information\nclass APIExampleRequestSchema(BaseModel):\n    endpoint: str = Field(\n        ..., description=\"The API endpoint for the example request\"\n    )\n    method: str = Field(\n        ..., description=\"The HTTP method for the example request\"\n    )\n    headers: dict = Field(\n        ..., description=\"The headers for the example request\"\n    )\n    body: dict = Field(..., description=\"The body of the example request\")\n    response: dict = Field(\n        ...,\n        description=\"The expected response of the example request\",\n    )\n\n\n# Convert the schema to a JSON string\napi_example_schema = base_model_to_json(APIExampleRequestSchema)\n# Convert the schema to a JSON string\n\n# Define the task to generate a person's information\ntask = \"Generate an example API request using this code:\\n\"\n\n# Create an instance of the ToolAgent class\nagent = ToolAgent(\n    name=\"Command R Tool Agent\",\n    description=(\n        \"An agent that generates an API request using the Command R\"\n        \" model.\"\n    ),\n    model=model,\n    tokenizer=tokenizer,\n    json_schema=api_example_schema,\n)\n\n# Run the agent to generate the person's information\ngenerated_data = agent.run(task)\n\n# Print the generated data\nprint(f\"Generated data: {generated_data}\")\n</code></pre>"},{"location":"swarms/agents/tool_agent/#jamba-toolagent","title":"Jamba ++ ToolAgent","text":"<pre><code>from pydantic import BaseModel, Field\nfrom transformers import AutoModelForCausalLM, AutoTokenizer\n\nfrom swarms import ToolAgent\nfrom swarms.tools.json_utils import base_model_to_json\n\n# Model name\nmodel_name = \"ai21labs/Jamba-v0.1\"\n\n# Load the pre-trained model and tokenizer\nmodel = AutoModelForCausalLM.from_pretrained(\n    model_name,\n    device_map=\"auto\",\n)\n\n# Load the pre-trained model and tokenizer\ntokenizer = AutoTokenizer.from_pretrained(model_name)\n\n\n# Initialize the schema for the person's information\nclass APIExampleRequestSchema(BaseModel):\n    endpoint: str = Field(\n        ..., description=\"The API endpoint for the example request\"\n    )\n    method: str = Field(\n        ..., description=\"The HTTP method for the example request\"\n    )\n    headers: dict = Field(\n        ..., description=\"The headers for the example request\"\n    )\n    body: dict = Field(..., description=\"The body of the example request\")\n    response: dict = Field(\n        ...,\n        description=\"The expected response of the example request\",\n    )\n\n\n# Convert the schema to a JSON string\napi_example_schema = base_model_to_json(APIExampleRequestSchema)\n# Convert the schema to a JSON string\n\n# Define the task to generate a person's information\ntask = \"Generate an example API request using this code:\\n\"\n\n# Create an instance of the ToolAgent class\nagent = ToolAgent(\n    name=\"Command R Tool Agent\",\n    description=(\n        \"An agent that generates an API request using the Command R\"\n        \" model.\"\n    ),\n    model=model,\n    tokenizer=tokenizer,\n    json_schema=api_example_schema,\n)\n\n# Run the agent to generate the person's information\ngenerated_data = agent(task)\n\n# Print the generated data\nprint(f\"Generated data: {generated_data}\")\n</code></pre>"},{"location":"swarms/agents/tool_agent/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Ensure that either the <code>model</code> or <code>llm</code> parameter is provided during initialization. If neither is provided, the <code>ToolAgent</code> will raise an exception.</li> <li>The <code>parsing_function</code> parameter is optional but can be very useful for post-processing the output of the tool agent.</li> <li>Adjust the <code>max_number_tokens</code> parameter to control the length of the generated output, depending on the requirements of the task.</li> </ul>"},{"location":"swarms/agents/tool_agent/#references-and-resources","title":"References and Resources","text":"<ul> <li>Transformers Documentation</li> <li>Loguru Logger</li> </ul> <p>This documentation provides a comprehensive guide to the <code>ToolAgent</code> class, including its initialization, usage, and practical examples. By following the detailed instructions and examples, developers can effectively utilize the <code>ToolAgent</code> for various tasks involving model and tokenizer-based operations.</p>"},{"location":"swarms/artifacts/artifact/","title":"<code>Artifact</code>","text":"<p>The <code>Artifact</code> class represents a file artifact, encapsulating the file's path, type, contents, versions, and edit count. This class provides a comprehensive way to manage file versions, edit contents, and handle various file-related operations such as saving, loading, and exporting to JSON.</p> <p>The <code>Artifact</code> class is particularly useful in contexts where file version control and content management are essential. By keeping track of the number of edits and maintaining a version history, it allows for robust file handling and auditability.</p>"},{"location":"swarms/artifacts/artifact/#class-definition","title":"Class Definition","text":""},{"location":"swarms/artifacts/artifact/#artifact_1","title":"Artifact","text":"Attribute Type Default Value Description <code>file_path</code> <code>str</code> N/A The path to the file. <code>file_type</code> <code>str</code> N/A The type of the file. <code>contents</code> <code>str</code> <code>\"\"</code> The contents of the file. <code>versions</code> <code>List[FileVersion]</code> <code>[]</code> The list of file versions. <code>edit_count</code> <code>int</code> <code>0</code> The number of times the file has been edited."},{"location":"swarms/artifacts/artifact/#parameters-and-validation","title":"Parameters and Validation","text":"<ul> <li><code>file_path</code>: A string representing the file path.</li> <li><code>file_type</code>: A string representing the file type. This attribute is validated to ensure it matches supported file types based on the file extension if not provided.</li> <li><code>contents</code>: A string representing the contents of the file. Defaults to an empty string.</li> <li><code>versions</code>: A list of <code>FileVersion</code> instances representing the version history of the file. Defaults to an empty list.</li> <li><code>edit_count</code>: An integer representing the number of edits made to the file. Defaults to 0.</li> </ul>"},{"location":"swarms/artifacts/artifact/#methods","title":"Methods","text":"<p>The <code>Artifact</code> class includes various methods for creating, editing, saving, loading, and exporting file artifacts.</p>"},{"location":"swarms/artifacts/artifact/#create","title":"<code>create</code>","text":"Parameter Type Description <code>initial_content</code> <code>str</code> The initial content of the file. <p>Usage Example:</p> <p><pre><code>artifact = Artifact(file_path=\"example.txt\", file_type=\"txt\")\nartifact.create(initial_content=\"Initial file content\")\n</code></pre> The file type parameter supports the following file types: <code>.txt</code>, <code>.md</code>, <code>.py</code>, <code>.pdf</code>.</p>"},{"location":"swarms/artifacts/artifact/#edit","title":"<code>edit</code>","text":"Parameter Type Description <code>new_content</code> <code>str</code> The new content of the file. <p>Usage Example:</p> <pre><code>artifact.edit(new_content=\"Updated file content\")\n</code></pre>"},{"location":"swarms/artifacts/artifact/#save","title":"<code>save</code>","text":"<p>Usage Example:</p> <pre><code>artifact.save()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#load","title":"<code>load</code>","text":"<p>Usage Example:</p> <pre><code>artifact.load()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#get_version","title":"<code>get_version</code>","text":"Parameter Type Description <code>version_number</code> <code>int</code> The version number to retrieve. <p>Usage Example:</p> <pre><code>version = artifact.get_version(version_number=1)\n</code></pre>"},{"location":"swarms/artifacts/artifact/#get_contents","title":"<code>get_contents</code>","text":"<p>Usage Example:</p> <pre><code>current_contents = artifact.get_contents()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#get_version_history","title":"<code>get_version_history</code>","text":"<p>Usage Example:</p> <pre><code>version_history = artifact.get_version_history()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#export_to_json","title":"<code>export_to_json</code>","text":"Parameter Type Description <code>file_path</code> <code>str</code> The path to the JSON file to save the artifact. <p>Usage Example:</p> <pre><code>artifact.export_to_json(file_path=\"artifact.json\")\n</code></pre>"},{"location":"swarms/artifacts/artifact/#import_from_json","title":"<code>import_from_json</code>","text":"Parameter Type Description <code>file_path</code> <code>str</code> The path to the JSON file to import the artifact from. <p>Usage Example:</p> <pre><code>imported_artifact = Artifact.import_from_json(file_path=\"artifact.json\")\n</code></pre>"},{"location":"swarms/artifacts/artifact/#get_metrics","title":"<code>get_metrics</code>","text":"<p>Usage Example:</p> <pre><code>metrics = artifact.get_metrics()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#to_dict","title":"<code>to_dict</code>","text":"<p>Usage Example:</p> <pre><code>artifact_dict = artifact.to_dict()\n</code></pre>"},{"location":"swarms/artifacts/artifact/#from_dict","title":"<code>from_dict</code>","text":"Parameter Type Description <code>data</code> <code>Dict[str, Any]</code> The dictionary representation of the artifact. <p>Usage Example:</p> <pre><code>artifact_data = {\n    \"file_path\": \"example.txt\",\n    \"file_type\": \"txt\",\n    \"contents\": \"File content\",\n    \"versions\": [],\n    \"edit_count\": 0\n}\nartifact = Artifact.from_dict(artifact_data)\n</code></pre>"},{"location":"swarms/artifacts/artifact/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>The <code>Artifact</code> class uses the <code>pydantic</code> library to handle data validation and serialization.</li> <li>When editing the artifact, ensure that the <code>file_path</code> is set correctly to avoid file operation errors.</li> <li>Use the <code>get_version</code> and <code>get_version_history</code> methods to maintain a clear audit trail of changes to the file.</li> <li>The <code>export_to_json</code> and <code>import_from_json</code> methods are useful for backing up and restoring the state of an artifact.</li> </ul>"},{"location":"swarms/artifacts/artifact/#references-and-resources","title":"References and Resources","text":"<ul> <li>Pydantic Documentation</li> <li>Python os.path module</li> <li>JSON Documentation</li> </ul>"},{"location":"swarms/artifacts/artifact/#examples-of-usage","title":"Examples of Usage","text":""},{"location":"swarms/artifacts/artifact/#example-1-creating-and-editing-an-artifact","title":"Example 1: Creating and Editing an Artifact","text":"<pre><code>from datetime import datetime\nfrom pydantic import BaseModel, Field, validator\nfrom typing import List, Dict, Any, Union\nimport os\nimport json\n\n# Define FileVersion class\nclass FileVersion(BaseModel):\n    version_number: int\n    content: str\n    timestamp: datetime\n\n# Artifact class definition goes here\n\n# Create an artifact\nartifact = Artifact(file_path=\"example.txt\", file_type=\"txt\")\nartifact.create(initial_content=\"Initial file content\")\n\n# Edit the artifact\nartifact.edit(new_content=\"Updated file content\")\n\n# Save the artifact to a file\nartifact.save()\n\n# Load the artifact from the file\nartifact.load()\n\n# Print the current contents of the artifact\nprint(artifact.get_contents())\n\n# Print the version history\nprint(artifact.get_version_history())\n</code></pre>"},{"location":"swarms/artifacts/artifact/#example-2-exporting-and-importing-an-artifact","title":"Example 2: Exporting and Importing an Artifact","text":"<pre><code># Export the artifact to a JSON file\nartifact.export_to_json(file_path=\"artifact.json\")\n\n# Import\n\n the artifact from a JSON file\nimported_artifact = Artifact.import_from_json(file_path=\"artifact.json\")\n\n# Print the metrics of the imported artifact\nprint(imported_artifact.get_metrics())\n</code></pre>"},{"location":"swarms/artifacts/artifact/#example-3-converting-an-artifact-to-and-from-a-dictionary","title":"Example 3: Converting an Artifact to and from a Dictionary","text":"<pre><code># Convert the artifact to a dictionary\nartifact_dict = artifact.to_dict()\n\n# Create a new artifact from the dictionary\nnew_artifact = Artifact.from_dict(artifact_dict)\n\n# Print the metrics of the new artifact\nprint(new_artifact.get_metrics())\n</code></pre>"},{"location":"swarms/changelog/5_6_8/","title":"Swarms ChangeLog 5.6.8 -","text":"<p>The biggest update in Swarms history! We've introduced major fixes, updates, and new features to enhance your agent workflows and performance. To get the latest updates run the following: </p>"},{"location":"swarms/changelog/5_6_8/#installation","title":"Installation","text":"<pre><code>$ pip3 install -U swarms\n</code></pre>"},{"location":"swarms/changelog/5_6_8/#log","title":"Log","text":"<p>Here\u2019s the breakdown of the latest changes:</p>"},{"location":"swarms/changelog/5_6_8/#fixes","title":"\ud83d\udc1e Fixes:","text":"<ul> <li>[BUGF-AGENTS]: Fixed various response issues within agents, leading to smoother performance.</li> <li>[BUGF-MIXTURE]: Resolved issues with the Mixture of Agents, ensuring more reliable and stable execution.</li> <li>[CLEA-FILES]: Removed unnecessary files, resulting in a significant speed boost and cleaner environment.</li> </ul>"},{"location":"swarms/changelog/5_6_8/#updates","title":"\ud83d\udee0 Updates:","text":"<ul> <li>[REFA-MODULES]: Refactored the <code>swarms.models</code> module into its own package: <code>swarm_models</code> for improved code organization.</li> <li>[CLEA-AGENTS]: Cleaned up tool logic in the <code>agents</code> class for streamlined and efficient operations.</li> </ul>"},{"location":"swarms/changelog/5_6_8/#new-features","title":"\u2728 New Features:","text":"<ul> <li>[FEAT-SWARMS]: Introduced JSON outputs for <code>AgentRearrange</code>, <code>SpreadsheetSwarm</code>, and other swarms, improving data handling.</li> <li>[FEAT-AGENTS]: Added YAML file support for creating agents, making the setup process simpler than ever.</li> <li>[FEAT-METADATA]: Enhanced the <code>Agent</code> class with JSON metadata output, supporting OpenAI-like API responses with <code>output_type=\"json\"</code> and <code>return_step_meta=True</code>.</li> <li>[FEAT-FOREST]: Released <code>ForestSwarm</code>, a new architecture that clusters agents into trees, enabling precise task execution.</li> <li>[FEAT-REGISTRY]: Fully implemented <code>AgentRegistry</code>, allowing you to store multiple agents for future use.</li> </ul>"},{"location":"swarms/changelog/5_6_8/#performance-enhancements","title":"\ud83d\ude80 Performance Enhancements:","text":"<ul> <li>[PERF-AGENTS]: Accelerated agent execution by 4x, with a 10x boost coming soon, powered by our Rust backend.</li> <li>[PERF-ARCH]: Optimized multi-threading, concurrency, and asynchrony in swarm architectures, making them faster than ever.</li> </ul> <p>Ready to dive in? Get started now: https://buff.ly/444kDjA</p>"},{"location":"swarms/changelog/5_8_1/","title":"Swarms 5.8.1 Feature Documentation","text":""},{"location":"swarms/changelog/5_8_1/#1-enhanced-command-line-interface-cli","title":"1. Enhanced Command Line Interface (CLI)","text":""},{"location":"swarms/changelog/5_8_1/#11-integrated-onboarding-process","title":"1.1 Integrated Onboarding Process","text":"<pre><code>$ swarms onboarding\n</code></pre>"},{"location":"swarms/changelog/5_8_1/#12-run-agents-command","title":"1.2 Run Agents Command","text":"<pre><code>$ swarms run-agents --yaml-file agents.yaml\n</code></pre> <p>This command allows users to execute multiple agents defined in a YAML file. Here's the process:</p> <ol> <li>The command reads the specified YAML file (<code>agents.yaml</code> in this case).</li> <li>It parses the YAML content, extracting the configuration for each agent.</li> <li>For each agent defined in the YAML:</li> <li>It creates an instance of the agent with the specified parameters.</li> <li>It sets up the agent's environment (model, temperature, max tokens, etc.).</li> <li>It assigns the given task to the agent.</li> <li>It executes the agent, respecting parameters like <code>max_loops</code>, <code>autosave</code>, and <code>verbose</code>.</li> <li>The results from all agents are collected and presented to the user.</li> </ol> <p>The YAML file structure allows users to define multiple agents with different configurations, making it easy to run complex, multi-agent tasks from the command line.</p>"},{"location":"swarms/changelog/5_8_1/#13-generate-prompt-feature","title":"1.3 Generate Prompt Feature","text":"<pre><code>$ swarms generate-prompt --prompt \"Create a marketing strategy for a new product launch\"\n</code></pre> <p>This feature leverages Swarms' language model to generate expanded or refined prompts:</p> <ol> <li>The command takes the user's input prompt as a starting point.</li> <li>It likely sends this prompt to a pre-configured language model (possibly GPT-4 or a similar model).</li> <li>The model then generates an expanded or more detailed version of the prompt.</li> <li>The generated prompt is returned to the user, possibly with options to further refine or save it.</li> </ol> <p>This feature can help users create more effective prompts for their agents or other AI tasks.</p>"},{"location":"swarms/changelog/5_8_1/#2-new-prompt-management-system","title":"2. New Prompt Management System","text":""},{"location":"swarms/changelog/5_8_1/#21-prompt-class","title":"2.1 Prompt Class","text":"<p>The new <code>Prompt</code> class provides a robust system for managing and versioning prompts:</p> <pre><code>from swarms import Prompt\n\nmarketing_prompt = Prompt(content=\"Initial marketing strategy draft\", autosave=True)\n\nprint(marketing_prompt.get_prompt())\n</code></pre> <p>Key features of the <code>Prompt</code> class:</p> <ol> <li> <p>Initialization: The class is initialized with initial content and an <code>autosave</code> option.</p> </li> <li> <p>Editing:    <pre><code>marketing_prompt.edit_prompt(\"Updated marketing strategy with social media focus\")\n</code></pre>    This method updates the prompt content and, if <code>autosave</code> is True, automatically saves the new version.</p> </li> <li> <p>Retrieval:    <pre><code>current_content = marketing_prompt.get_prompt()\n</code></pre>    This method returns the current content of the prompt.</p> </li> <li> <p>Version History:    <pre><code>print(f\"Edit history: {marketing_prompt.edit_history}\")\n</code></pre>    The class maintains a history of edits, allowing users to track changes over time.</p> </li> <li> <p>Rollback:    <pre><code>marketing_prompt.rollback(1)\n</code></pre>    This feature allows users to revert to a previous version of the prompt.</p> </li> <li> <p>Duplicate Prevention:    The class includes logic to prevent duplicate edits, raising a <code>ValueError</code> if an attempt is made to save the same content twice in a row.</p> </li> </ol> <p>This system provides a powerful way to manage prompts, especially for complex projects where prompt engineering and iteration are crucial.</p>"},{"location":"swarms/changelog/5_8_1/#3-upcoming-features-preview","title":"3. Upcoming Features Preview","text":""},{"location":"swarms/changelog/5_8_1/#31-enhanced-agent-execution-capabilities","title":"3.1 Enhanced Agent Execution Capabilities","text":"<p>The preview code demonstrates planned enhancements for agent execution:</p> <pre><code>from swarms import Agent, ExecutionEnvironment\n\nmy_agent = Agent(name=\"data_processor\")\n\ncpu_env = ExecutionEnvironment(type=\"cpu\", cores=4)\nmy_agent.run(environment=cpu_env)\n\ngpu_env = ExecutionEnvironment(type=\"gpu\", device_id=0)\nmy_agent.run(environment=gpu_env)\n\nfractional_env = ExecutionEnvironment(type=\"fractional\", cpu_fraction=0.5, gpu_fraction=0.3)\nmy_agent.run(environment=fractional_env)\n</code></pre> <p>This upcoming feature will allow for more fine-grained control over the execution environment:</p> <ol> <li>CPU Execution: Users can specify the number of CPU cores to use.</li> <li>GPU Execution: Allows selection of a specific GPU device.</li> <li>Fractionalized Execution: Enables partial allocation of CPU and GPU resources.</li> </ol> <p>These features will provide users with greater flexibility in resource allocation, potentially improving performance and allowing for more efficient use of available hardware.</p>"},{"location":"swarms/changelog/6_0_0%202/","title":"Swarms 6.0.0 - Performance &amp; Reliability Update \ud83d\ude80","text":"<p>We're excited to announce the release of Swarms 6.0.0, bringing significant improvements to performance, reliability, and developer experience. This release focuses on streamlining core functionalities while enhancing the overall stability of the framework.</p>"},{"location":"swarms/changelog/6_0_0%202/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/changelog/6_0_0%202/#highlights","title":"\ud83c\udf1f Highlights","text":""},{"location":"swarms/changelog/6_0_0%202/#agent-enhancements","title":"Agent Enhancements","text":"<ul> <li>Improved RAG Performance: Significant improvements to Retrieval-Augmented Generation capabilities</li> <li>Enhanced Prompt Generation: Auto-generate prompt now incorporates name, description, and system prompt for more contextual interactions</li> <li>Streamlined Architecture: Cleaned up unused code for better performance and maintainability</li> <li>Simplified State Management: Consolidated state management methods into a single <code>load()</code> function</li> </ul>"},{"location":"swarms/changelog/6_0_0%202/#tools-execution","title":"Tools &amp; Execution","text":"<ul> <li>Optimized Environment Management: Fixed multiple environment instantiation issue</li> <li>Environments now initialize once during <code>__init__</code></li> <li>New SwarmRouter Function: Simplified routing mechanism</li> <li>Returns consolidated string output from all agents</li> <li>Improved coordination between swarm components</li> </ul>"},{"location":"swarms/changelog/6_0_0%202/#performance-improvements","title":"\ud83d\udcaa Performance Improvements","text":"<ul> <li>Faster execution times</li> <li>Reduced memory footprint</li> <li>More reliable logging system</li> <li>Lightweight and efficient codebase</li> </ul>"},{"location":"swarms/changelog/6_0_0%202/#join-our-community","title":"\ud83e\udd1d Join Our Community","text":""},{"location":"swarms/changelog/6_0_0%202/#were-hiring","title":"We're Hiring!","text":"<p>Join our growing team! We're currently looking for: - Agent Engineers - Developer Relations - Infrastructure Engineers - And more!</p>"},{"location":"swarms/changelog/6_0_0%202/#get-involved","title":"Get Involved","text":"<ul> <li>\u2b50 Star our repository</li> <li>\ud83d\udd04 Fork the project</li> <li>\ud83d\udee0 Submit pull requests</li> <li>\ud83d\udc1b Report issues</li> <li>\ud83d\udca1 Share your ideas</li> </ul>"},{"location":"swarms/changelog/6_0_0%202/#contact-support","title":"Contact &amp; Support","text":"<ul> <li>\ud83d\udce7 Email: kye@swarms.world</li> <li>\ud83d\udd17 Issues: GitHub Issues</li> </ul>"},{"location":"swarms/changelog/6_0_0%202/#whats-next","title":"\ud83d\udd1c What's Next?","text":"<p>Have ideas for features, bug fixes, or improvements? We'd love to hear from you! Reach out through our GitHub issues or email us directly.</p> <p>Thank you to all our contributors and users who make Swarms better every day. Together, we're building the future of swarm intelligence.</p>"},{"location":"swarms/changelog/6_0_0%202/#swarmai-opensource-ai-machinelearning","title":"SwarmAI #OpenSource #AI #MachineLearning","text":""},{"location":"swarms/changelog/6_0_0/","title":"Swarms 6.0.0 - Performance &amp; Reliability Update \ud83d\ude80","text":"<p>We're excited to announce the release of Swarms 6.0.0, bringing significant improvements to performance, reliability, and developer experience. This release focuses on streamlining core functionalities while enhancing the overall stability of the framework.</p>"},{"location":"swarms/changelog/6_0_0/#installation","title":"\ud83d\udce6 Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/changelog/6_0_0/#highlights","title":"\ud83c\udf1f Highlights","text":""},{"location":"swarms/changelog/6_0_0/#agent-enhancements","title":"Agent Enhancements","text":"<ul> <li>Improved RAG Performance: Significant improvements to Retrieval-Augmented Generation capabilities</li> <li>Enhanced Prompt Generation: Auto-generate prompt now incorporates name, description, and system prompt for more contextual interactions</li> <li>Streamlined Architecture: Cleaned up unused code for better performance and maintainability</li> <li>Simplified State Management: Consolidated state management methods into a single <code>load()</code> function</li> </ul>"},{"location":"swarms/changelog/6_0_0/#tools-execution","title":"Tools &amp; Execution","text":"<ul> <li>Optimized Environment Management: Fixed multiple environment instantiation issue</li> <li>Environments now initialize once during <code>__init__</code></li> <li>New SwarmRouter Function: Simplified routing mechanism</li> <li>Returns consolidated string output from all agents</li> <li>Improved coordination between swarm components</li> </ul>"},{"location":"swarms/changelog/6_0_0/#performance-improvements","title":"\ud83d\udcaa Performance Improvements","text":"<ul> <li>Faster execution times</li> <li>Reduced memory footprint</li> <li>More reliable logging system</li> <li>Lightweight and efficient codebase</li> </ul>"},{"location":"swarms/changelog/6_0_0/#join-our-community","title":"\ud83e\udd1d Join Our Community","text":""},{"location":"swarms/changelog/6_0_0/#were-hiring","title":"We're Hiring!","text":"<p>Join our growing team! We're currently looking for: - Agent Engineers - Developer Relations - Infrastructure Engineers - And more!</p>"},{"location":"swarms/changelog/6_0_0/#get-involved","title":"Get Involved","text":"<ul> <li>\u2b50 Star our repository</li> <li>\ud83d\udd04 Fork the project</li> <li>\ud83d\udee0 Submit pull requests</li> <li>\ud83d\udc1b Report issues</li> <li>\ud83d\udca1 Share your ideas</li> </ul>"},{"location":"swarms/changelog/6_0_0/#contact-support","title":"Contact &amp; Support","text":"<ul> <li>\ud83d\udce7 Email: kye@swarms.world</li> <li>\ud83d\udd17 Issues: GitHub Issues</li> </ul>"},{"location":"swarms/changelog/6_0_0/#whats-next","title":"\ud83d\udd1c What's Next?","text":"<p>Have ideas for features, bug fixes, or improvements? We'd love to hear from you! Reach out through our GitHub issues or email us directly.</p> <p>Thank you to all our contributors and users who make Swarms better every day. Together, we're building the future of swarm intelligence.</p>"},{"location":"swarms/changelog/6_0_0/#swarmai-opensource-ai-machinelearning","title":"SwarmAI #OpenSource #AI #MachineLearning","text":""},{"location":"swarms/changelog/changelog_new/","title":"\ud83d\ude80 Swarms 5.9.2 Release Notes","text":""},{"location":"swarms/changelog/changelog_new/#major-features","title":"\ud83c\udfaf Major Features","text":""},{"location":"swarms/changelog/changelog_new/#concurrent-agent-execution-suite","title":"Concurrent Agent Execution Suite","text":"<p>We're excited to introduce a comprehensive suite of agent execution methods to supercharge your multi-agent workflows:</p> <ul> <li><code>run_agents_concurrently</code>: Execute multiple agents in parallel with optimal resource utilization</li> <li><code>run_agents_concurrently_async</code>: Asynchronous execution for improved performance</li> <li><code>run_single_agent</code>: Streamlined single agent execution</li> <li><code>run_agents_concurrently_multiprocess</code>: Multi-process execution for CPU-intensive tasks</li> <li><code>run_agents_sequentially</code>: Sequential execution with controlled flow</li> <li><code>run_agents_with_different_tasks</code>: Assign different tasks to different agents</li> <li><code>run_agent_with_timeout</code>: Time-bounded agent execution</li> <li><code>run_agents_with_resource_monitoring</code>: Monitor and manage resource usage</li> </ul>"},{"location":"swarms/changelog/changelog_new/#documentation","title":"\ud83d\udcda Documentation","text":"<ul> <li>Comprehensive documentation added for all new execution methods</li> <li>Updated examples and usage patterns</li> <li>Enhanced API reference</li> </ul>"},{"location":"swarms/changelog/changelog_new/#improvements","title":"\ud83d\udee0\ufe0f Improvements","text":"<ul> <li>Tree swarm implementation fixes</li> <li>Workspace directory now automatically set to <code>agent_workspace</code></li> <li>Improved error handling and stability</li> </ul>"},{"location":"swarms/changelog/changelog_new/#quick-start","title":"Quick Start","text":"<pre><code>from swarms import Agent, run_agents_concurrently, run_agents_with_timeout, run_agents_with_different_tasks\n\n# Initialize multiple agents\nagents = [\n    Agent(\n        agent_name=f\"Analysis-Agent-{i}\",\n        system_prompt=\"You are a financial analysis expert\",\n        llm=model,\n        max_loops=1\n    )\n    for i in range(5)\n]\n\n# Run agents concurrently\ntask = \"Analyze the impact of rising interest rates on tech stocks\"\noutputs = run_agents_concurrently(agents, task)\n\n# Example with timeout\noutputs_with_timeout = run_agents_with_timeout(\n    agents=agents,\n    task=task,\n    timeout=30.0,\n    batch_size=2\n)\n\n# Run different tasks\ntask_pairs = [\n    (agents[0], \"Analyze tech stocks\"),\n    (agents[1], \"Analyze energy stocks\"),\n    (agents[2], \"Analyze retail stocks\")\n]\ndifferent_outputs = run_agents_with_different_tasks(task_pairs)\n</code></pre>"},{"location":"swarms/changelog/changelog_new/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/changelog/changelog_new/#coming-soon","title":"Coming Soon","text":"<ul> <li>\ud83c\udf1f Auto Swarm Builder: Automatically construct and configure entire swarms from a single task specification (in development)</li> <li>Auto Prompt Generator for thousands of agents (in development)</li> </ul>"},{"location":"swarms/changelog/changelog_new/#community","title":"Community","text":"<p>We believe in the power of community-driven development. Help us make Swarms better!</p> <ul> <li>\u2b50 Star our repository: https://github.com/kyegomez/swarms</li> <li>\ud83d\udd04 Fork the project and contribute your improvements</li> <li>\ud83e\udd1d Join our growing community of contributors</li> </ul>"},{"location":"swarms/changelog/changelog_new/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Fixed Tree Swarm implementation issues</li> <li>Resolved workspace directory configuration problems</li> <li>General stability improvements</li> </ul> <p>For detailed documentation and examples, visit our GitHub repository.</p> <p>Let's build the future of multi-agent systems together! \ud83d\ude80</p>"},{"location":"swarms/cli/cli_guide/","title":"The Ultimate Technical Guide to the Swarms CLI: A Step-by-Step Developer\u2019s Guide","text":"<p>Welcome to the definitive technical guide for using the Swarms Command Line Interface (CLI). The Swarms CLI enables developers, engineers, and business professionals to seamlessly manage and run Swarms of agents from the command line. This guide will walk you through the complete process of installing, configuring, and using the Swarms CLI to orchestrate intelligent agents for your needs.</p> <p>By following this guide, you will not only understand how to install and use the Swarms CLI but also learn about real-world use cases, including how the CLI is used to automate tasks across various industries, from finance to marketing, operations, and beyond.</p> <p>Explore the official Swarms GitHub repository, dive into the comprehensive documentation at Swarms Docs, and explore the vast marketplace of agents on swarms.ai to kickstart your journey with Swarms!</p>"},{"location":"swarms/cli/cli_guide/#1-installing-the-swarms-cli","title":"1. Installing the Swarms CLI","text":"<p>Before we explore the Swarms CLI commands, let\u2019s get it installed and running on your machine.</p>"},{"location":"swarms/cli/cli_guide/#11-installation-using-pip","title":"1.1. Installation Using <code>pip</code>","text":"<p>For most users, the simplest way to install the Swarms CLI is through <code>pip</code>:</p> <pre><code>pip3 install -U swarms\n</code></pre> <p>This command installs the latest version of the Swarms CLI package, ensuring that you have the newest features and fixes.</p>"},{"location":"swarms/cli/cli_guide/#12-installation-using-poetry","title":"1.2. Installation Using <code>Poetry</code>","text":"<p>Alternatively, if you are using <code>Poetry</code> as your Python package manager, you can add the Swarms package like this:</p> <pre><code>poetry add swarms\n</code></pre> <p>Once installed, you can run the Swarms CLI directly using:</p> <pre><code>poetry run swarms help\n</code></pre> <p>This command shows all the available options and commands, as we will explore in-depth below.</p>"},{"location":"swarms/cli/cli_guide/#2-understanding-swarms-cli-commands","title":"2. Understanding Swarms CLI Commands","text":"<p>With the Swarms CLI installed, the next step is to explore its key functionalities. Here are the most essential commands:</p>"},{"location":"swarms/cli/cli_guide/#21-onboarding-setup-your-environment","title":"2.1. <code>onboarding</code>: Setup Your Environment","text":"<p>The <code>onboarding</code> command guides you through setting up your environment and configuring the agents for your Swarms.</p> <pre><code>swarms onboarding\n</code></pre> <p>This is the first step when you begin working with the Swarms platform. It helps to:</p> <ul> <li>Authenticate your Swarms account.</li> <li>Download any necessary configurations.</li> <li>Ensure everything is in place to launch agents seamlessly.</li> </ul>"},{"location":"swarms/cli/cli_guide/#22-help-learn-available-commands","title":"2.2. <code>help</code>: Learn Available Commands","text":"<p>Running <code>help</code> displays the various commands you can use:</p> <pre><code>swarms help\n</code></pre> <p>This command will output a helpful list like the one shown below, including detailed descriptions of each command.</p> <pre><code>Swarms CLI - Help\n\nCommands:\nonboarding    : Starts the onboarding process\nhelp          : Shows this help message\nget-api-key   : Retrieves your API key from the platform\ncheck-login   : Checks if you're logged in and starts the cache\nread-docs     : Redirects you to swarms cloud documentation\nrun-agents    : Run your Agents from your agents.yaml\n</code></pre>"},{"location":"swarms/cli/cli_guide/#23-get-api-key-access-api-integration","title":"2.3. <code>get-api-key</code>: Access API Integration","text":"<p>One of the key functionalities of the Swarms platform is integrating your agents with the Swarms API. To retrieve your unique API key for communication, use this command:</p> <pre><code>swarms get-api-key\n</code></pre> <p>Your API key is essential to enable agent workflows and access various services through the Swarms platform.</p>"},{"location":"swarms/cli/cli_guide/#24-check-login-verify-authentication","title":"2.4. <code>check-login</code>: Verify Authentication","text":"<p>Use the <code>check-login</code> command to verify if you're logged in and ensure that your credentials are cached:</p> <pre><code>swarms check-login\n</code></pre> <p>This ensures seamless operation, allowing agents to execute tasks securely on the Swarms platform without needing to log in repeatedly.</p>"},{"location":"swarms/cli/cli_guide/#25-read-docs-explore-official-documentation","title":"2.5. <code>read-docs</code>: Explore Official Documentation","text":"<p>Easily access the official documentation with this command:</p> <pre><code>swarms read-docs\n</code></pre> <p>You\u2019ll be redirected to the Swarms documentation site, Swarms Docs, where you'll find in-depth explanations, advanced use-cases, and more.</p>"},{"location":"swarms/cli/cli_guide/#26-run-agents-orchestrate-agents","title":"2.6. <code>run-agents</code>: Orchestrate Agents","text":"<p>Perhaps the most important command in the CLI is <code>run-agents</code>, which allows you to execute your agents as defined in your <code>agents.yaml</code> configuration file.</p> <pre><code>swarms run-agents --yaml-file agents.yaml\n</code></pre> <p>If you want to specify a custom configuration file, just pass in the YAML file using the <code>--yaml-file</code> flag.</p>"},{"location":"swarms/cli/cli_guide/#3-working-with-the-agentsyaml-configuration-file","title":"3. Working with the <code>agents.yaml</code> Configuration File","text":"<p>The <code>agents.yaml</code> file is at the heart of your Swarms setup. This file allows you to define the structure and behavior of each agent you want to run. Below is an example YAML configuration for two agents.</p>"},{"location":"swarms/cli/cli_guide/#31-example-agentsyaml-configuration","title":"3.1. Example <code>agents.yaml</code> Configuration:","text":"<pre><code>agents:\n  - agent_name: \"Financial-Advisor-Agent\"\n    model:\n      model_name: \"gpt-4o-mini\"\n      temperature: 0.3\n      max_tokens: 2500\n    system_prompt: |\n      You are a highly knowledgeable financial advisor with expertise in tax strategies, investment management, and retirement planning. \n      Provide concise and actionable advice based on the user's financial goals and situation.\n    max_loops: 1\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: true\n    saved_state_path: \"financial_advisor_state.json\"\n    user_name: \"finance_user\"\n    retry_attempts: 2\n    context_length: 200000\n    return_step_meta: false\n    output_type: \"str\"\n    task: \"I am 35 years old with a moderate risk tolerance. How should I diversify my portfolio for retirement in 20 years?\"\n\n  - agent_name: \"Stock-Market-Analysis-Agent\"\n    model:\n      model_name: \"gpt-4o-mini\"\n      temperature: 0.25\n      max_tokens: 1800\n    system_prompt: |\n      You are an expert stock market analyst with a deep understanding of technical analysis, market trends, and long-term investment strategies. \n      Provide well-reasoned investment advice, taking current market conditions into account.\n    max_loops: 2\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: false\n    saved_state_path: \"stock_market_analysis_state.json\"\n    user_name: \"market_analyst\"\n    retry_attempts: 3\n    context_length: 150000\n    return_step_meta: true\n    output_type: \"json\"\n    task: \"Analyze the current market trends for tech stocks and suggest the best long-term investment options.\"\n\n  - agent_name: \"Marketing-Strategy-Agent\"\n    model:\n      model_name: \"gpt-4o-mini\"\n      temperature: 0.4\n      max_tokens: 2200\n    system_prompt: |\n      You are a marketing strategist with expertise in digital campaigns, customer engagement, and branding. \n      Provide a comprehensive marketing strategy to increase brand awareness and drive customer acquisition for an e-commerce business.\n    max_loops: 1\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: true\n    saved_state_path: \"marketing_strategy_state.json\"\n    user_name: \"marketing_user\"\n    retry_attempts: 2\n    context_length: 200000\n    return_step_meta: false\n    output_type: \"str\"\n    task: \"Create a 6-month digital marketing strategy for a new eco-friendly e-commerce brand targeting millennial consumers.\"\n\n  - agent_name: \"Operations-Optimizer-Agent\"\n    model:\n      model_name: \"gpt-4o-mini\"\n      temperature: 0.2\n      max_tokens: 2000\n    system_prompt: |\n      You are an operations expert with extensive experience in optimizing workflows, reducing costs, and improving efficiency in supply chains. \n      Provide actionable recommendations to streamline business operations.\n    max_loops: 1\n    autosave: true\n    dashboard: false\n    verbose: true\n    dynamic_temperature_enabled: true\n    saved_state_path: \"operations_optimizer_state.json\"\n    user_name: \"operations_user\"\n    retry_attempts: 1\n    context_length: 200000\n    return_step_meta: false\n    output_type: \"str\"\n    task: \"Identify ways to improve the efficiency of a small manufacturing company\u2019s supply chain to reduce costs by 15% within one year.\"\n</code></pre>"},{"location":"swarms/cli/cli_guide/#32-explanation-of-key-fields","title":"3.2. Explanation of Key Fields","text":"<ul> <li>agent_name: The name of your agent (e.g., Financial-Analysis-Agent).</li> <li>model: Specifies which model to use. In this case, <code>gpt-4o-mini</code> is used.</li> <li>temperature: Controls the randomness of the model\u2019s responses.</li> <li>max_tokens: The maximum number of tokens to generate.</li> <li>system_prompt: Defines the prompt that instructs the agent.</li> <li>max_loops: Limits the number of times the agent will retry tasks.</li> <li>autosave: Saves the agent's state automatically after each run.</li> <li>dashboard: Set to <code>true</code> or <code>false</code> depending on whether you want to enable the agent\u2019s dashboard.</li> <li>saved_state_path: Path to save agent's state, enabling future runs to resume from the last state.</li> <li>task: The primary task or question that the agent will address.</li> </ul>"},{"location":"swarms/cli/cli_guide/#33-running-agents-using-agentsyaml","title":"3.3. Running Agents Using <code>agents.yaml</code>","text":"<p>After configuring the agents, you can execute them directly from the CLI:</p> <pre><code>swarms run-agents --yaml-file agents_config.yaml\n</code></pre> <p>This command will run the specified agents, allowing them to perform their tasks and return results according to your configuration.</p>"},{"location":"swarms/cli/cli_guide/#4-use-cases-for-the-swarms-cli","title":"4. Use Cases for the Swarms CLI","text":"<p>Now that you have a solid understanding of the basic commands and the <code>agents.yaml</code> configuration, let's explore how the Swarms CLI can be applied in real-world scenarios.</p>"},{"location":"swarms/cli/cli_guide/#41-financial-data-analysis","title":"4.1. Financial Data Analysis","text":"<p>For financial firms or hedge funds, agents like the \"Financial-Analysis-Agent\" can be set up to automate complex financial analyses. You could have agents analyze market trends, recommend portfolio adjustments, or perform tax optimizations.</p> <p>Example Task: Automating long-term investment analysis using historical stock data.</p> <pre><code>swarms run-agents --yaml-file finance_analysis.yaml\n</code></pre>"},{"location":"swarms/cli/cli_guide/#42-marketing-automation","title":"4.2. Marketing Automation","text":"<p>Marketing departments can utilize Swarms agents to optimize campaigns, generate compelling ad copy, or provide detailed marketing insights. You can create a <code>Marketing-Agent</code> to process customer feedback, perform sentiment analysis, and suggest marketing strategies.</p> <p>Example Task: Running multiple agents to analyze customer sentiment from recent surveys.</p> <pre><code>swarms run-agents --yaml-file marketing_agents.yaml\n</code></pre>"},{"location":"swarms/cli/cli_guide/#43-operations-and-task-management","title":"4.3. Operations and Task Management","text":"<p>Companies can create agents for automating internal task management. For example, you might have a set of agents responsible for managing deadlines, employee tasks, and progress tracking.</p> <p>Example Task: Automating a task management system using Swarms agents.</p> <pre><code>swarms run-agents --yaml-file operations_agents.yaml\n</code></pre>"},{"location":"swarms/cli/cli_guide/#5-advanced-usage-customizing-and-scaling-agents","title":"5. Advanced Usage: Customizing and Scaling Agents","text":"<p>The Swarms CLI is flexible and scalable. As your needs grow, you can start running agents across multiple machines, scale workloads dynamically, and even run multiple swarms in parallel.</p>"},{"location":"swarms/cli/cli_guide/#51-running-agents-in-parallel","title":"5.1. Running Agents in Parallel","text":"<p>To run multiple agents concurrently, you can utilize different YAML configurations for each agent or group of agents. This allows for extensive scaling, especially when dealing with large datasets or complex workflows.</p> <pre><code>swarms run-agents --yaml-file agents_batch_1.yaml &amp;\nswar\n\nms run-agents --yaml-file agents_batch_2.yaml &amp;\n</code></pre>"},{"location":"swarms/cli/cli_guide/#52-integration-with-other-tools","title":"5.2. Integration with Other Tools","text":"<p>The Swarms CLI integrates with many tools and platforms via APIs. You can connect Swarms with external platforms such as AWS, Azure, or your custom cloud setup for enterprise-level automation.</p>"},{"location":"swarms/cli/cli_guide/#6-conclusion-and-next-steps","title":"6. Conclusion and Next Steps","text":"<p>The Swarms CLI is a powerful tool for automating agent workflows in various industries, including finance, marketing, and operations. By following this guide, you should now have a thorough understanding of how to install and use the CLI, configure agents, and apply it to real-world use cases.</p> <p>To further explore Swarms, be sure to check out the official Swarms GitHub repository, where you can contribute to the framework or build your own custom agents. Dive deeper into the documentation at Swarms Docs, and browse the extensive agent marketplace at swarms.ai.</p> <p>With the Swarms CLI, the future of automation is within reach.</p>"},{"location":"swarms/cli/main/","title":"Swarms CLI Documentation","text":"<p>The Swarms Command Line Interface (CLI) allows you to easily manage and run your Swarms of agents from the command line. This page will guide you through the installation process and provide a breakdown of the available commands.</p>"},{"location":"swarms/cli/main/#installation","title":"Installation","text":"<p>You can install the <code>swarms</code> package using <code>pip</code> or <code>poetry</code>.</p>"},{"location":"swarms/cli/main/#using-pip","title":"Using pip","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/cli/main/#using-poetry","title":"Using poetry","text":"<pre><code>poetry add swarms\n</code></pre> <p>Once installed, you can run the Swarms CLI with the following command:</p> <pre><code>poetry run swarms help\n</code></pre>"},{"location":"swarms/cli/main/#swarms-cli-help","title":"Swarms CLI - Help","text":"<p>When running <code>swarms help</code>, you'll see the following output:</p> <pre><code>  _________                                     \n /   _____/_  _  _______ _______  _____   ______\n \\_____  \\ \\/ \\/ /\\__  \\_  __ \\/     \\ /  ___/\n /        \\     /  / __ \\|  | \\/  Y Y  \\___ \\ \n/_______  / \\/\\_/  (____  /__|  |__|_|  /____  &gt;\n        \\/              \\/            \\/     \\/ \n\n\n\n    Swarms CLI - Help\n\n    Commands:\n    onboarding    : Starts the onboarding process\n    help          : Shows this help message\n    get-api-key   : Retrieves your API key from the platform\n    check-login   : Checks if you're logged in and starts the cache\n    read-docs     : Redirects you to swarms cloud documentation!\n    run-agents    : Run your Agents from your agents.yaml\n\n    For more details, visit: https://docs.swarms.world\n</code></pre>"},{"location":"swarms/cli/main/#cli-commands","title":"CLI Commands","text":"<p>Below is a detailed explanation of the available commands:</p> <ul> <li>onboarding   Starts the onboarding process to help you set up your environment and configure your agents.</li> </ul> <p>Usage:   <pre><code>swarms onboarding\n</code></pre></p> <ul> <li>help   Displays the help message, including a list of available commands.</li> </ul> <p>Usage:   <pre><code>swarms help\n</code></pre></p> <ul> <li>get-api-key   Retrieves your API key from the platform, allowing your agents to communicate with the Swarms platform.</li> </ul> <p>Usage:   <pre><code>swarms get-api-key\n</code></pre></p> <ul> <li>check-login   Verifies if you are logged into the platform and starts the cache for storing your login session.</li> </ul> <p>Usage:   <pre><code>swarms check-login\n</code></pre></p> <ul> <li>read-docs   Redirects you to the official Swarms documentation on the web for further reading.</li> </ul> <p>Usage:   <pre><code>swarms read-docs\n</code></pre></p> <ul> <li>run-agents   Executes your agents from the <code>agents.yaml</code> configuration file, which defines the structure and behavior of your agents. Refer to this document for how to leverage yamls for fast, reliable, and simple agent orchestration. CLICK HERE You can customize what yaml file to run with <code>--yaml-file</code></li> </ul> <p>Usage:   <pre><code>swarms run-agents --yaml-file agents.yaml\n</code></pre></p>"},{"location":"swarms/concept/framework_architecture/","title":"Swarms Framework Architecture","text":"<p>The Swarms package is designed to orchestrate and manage swarms of agents, enabling collaboration between multiple Large Language Models (LLMs) or other agent types to solve complex tasks. The architecture is modular and scalable, facilitating seamless integration of various agents, models, prompts, and tools. Below is an overview of the architectural components, along with instructions on where to find the corresponding documentation.</p> <pre><code>swarms/\n\u251c\u2500\u2500 agents/\n\u251c\u2500\u2500 artifacts/\n\u251c\u2500\u2500 cli/\n\u251c\u2500\u2500 memory/\n\u251c\u2500\u2500 models/ ---&gt; Moved to swarm_models\n\u251c\u2500\u2500 prompts/\n\u251c\u2500\u2500 schemas/\n\u251c\u2500\u2500 structs/\n\u251c\u2500\u2500 telemetry/\n\u251c\u2500\u2500 tools/\n\u251c\u2500\u2500 utils/\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"swarms/concept/framework_architecture/#role-of-folders-in-the-swarms-framework","title":"Role of Folders in the Swarms Framework","text":"<p>The Swarms framework is composed of several key folders, each serving a specific role in building, orchestrating, and managing swarms of agents. Below is an in-depth explanation of the role of each folder in the framework's architecture, focusing on how they contribute to the overall system for handling complex multi-agent workflows.</p>"},{"location":"swarms/concept/framework_architecture/#1-agents-folder-agents","title":"1. Agents Folder (<code>agents/</code>)","text":"<ul> <li>Role: <ul> <li>The agents folder contains the core logic for individual agents within the Swarms framework. Agents are the key functional units responsible for carrying out specific tasks, whether it be text generation, web scraping, data analysis, or more specialized functions like marketing or accounting.</li> <li>Customization: Each agent can be specialized for different tasks by defining custom system prompts and behaviors.</li> <li>Modular Agent System: New agents can be easily added to this folder to expand the framework's capabilities.</li> </ul> </li> <li>Importance: This folder allows users to create and manage multiple types of agents that can interact and collaborate to solve complex problems.</li> <li>Examples: Accounting agents, marketing agents, and programming agents.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#2-artifacts-folder-artifacts","title":"2. Artifacts Folder (<code>artifacts/</code>)","text":"<ul> <li>Role: <ul> <li>The artifacts folder is responsible for storing the results or outputs generated by agents and swarms. This could include reports, logs, or data that agents generate during task execution.</li> <li>Persistent Storage: It helps maintain a persistent record of agent interactions, making it easier to retrieve or review past actions and outputs.</li> <li>Data Handling: Users can configure this folder to store artifacts that are essential for later analysis or reporting.</li> </ul> </li> <li>Importance: Acts as a storage mechanism for important task-related outputs, ensuring that no data is lost after tasks are completed.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#3-cli-folder-cli","title":"3. CLI Folder (<code>cli/</code>)","text":"<ul> <li>Role: <ul> <li>The CLI folder contains tools for interacting with the Swarms framework through the command-line interface. This allows users to easily manage and orchestrate swarms without needing a graphical interface.</li> <li>Command-line Tools: Commands in this folder enable users to initiate, control, and monitor swarms, making the system accessible and versatile.</li> <li>Automation and Scriptability: Enables advanced users to automate swarm interactions and deploy agents programmatically.</li> </ul> </li> <li>Importance: Provides a flexible way to control the Swarms system for developers who prefer using the command line.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#4-memory-folder-memory-deprecated","title":"4. Memory Folder (<code>memory/</code>) Deprecated!!","text":"<ul> <li>Role: <ul> <li>The memory folder handles the framework's memory management for agents. This allows agents to retain and recall past interactions or task contexts, enabling continuity in long-running processes or multi-step workflows.</li> <li>Context Retention: Agents that depend on historical context to make decisions or carry out tasks can store and access memory using this folder.</li> <li>Long-Term and Short-Term Memory: This could be implemented in various ways, such as short-term conversational memory or long-term knowledge storage.</li> </ul> </li> <li>Importance: Crucial for agents that require memory to handle complex workflows, where decisions are based on prior outputs or interactions.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#5-models-folder-models-moved-to-swarm_models","title":"5. Models Folder (<code>models/</code>) Moved to <code>swarm_models</code>","text":"<ul> <li>Role: <ul> <li>The models folder houses pre-trained machine learning models that agents utilize to complete their tasks. These models could include LLMs (Large Language Models), custom-trained models, or fine-tuned models specific to the tasks being handled by the agents.</li> <li>Plug-and-Play Architecture: The framework allows users to easily add or switch models depending on the specific needs of their agents.</li> <li>Custom Model Support: Users can integrate custom models here for more specialized tasks.</li> </ul> </li> <li>Importance: Provides the computational backbone for agent decision-making and task execution.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#6-prompts-folder-prompts","title":"6. Prompts Folder (<code>prompts/</code>)","text":"<ul> <li>Role: <ul> <li>The prompts folder contains reusable prompt templates that agents use to interact with their environment and complete tasks. These system prompts define the behavior and task orientation of the agents.</li> <li>Template Reusability: Users can create and store common prompt templates, making it easy to define agent behavior across different tasks without rewriting prompts from scratch.</li> <li>Task-Specific Prompts: For example, an accounting agent may have a prompt template that guides its interaction with financial data.</li> </ul> </li> <li>Importance: Provides the logic and guidance agents need to generate outputs in a coherent and task-focused manner.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#7-schemas-folder-schemas","title":"7. Schemas Folder (<code>schemas/</code>)","text":"<ul> <li>Role: <ul> <li>The schemas folder defines the data structures and validation logic for inputs and outputs within the framework, using tools like Pydantic for data validation.</li> <li>Standardization and Validation: This ensures that all interactions between agents and swarms follow consistent data formats, which is critical for large-scale agent coordination and task management.</li> <li>Error Prevention: By validating data early, it prevents errors from propagating through the system, improving reliability.</li> </ul> </li> <li>Importance: Ensures data consistency across the entire framework, making it easier to integrate and manage swarms of agents at scale.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#8-structs-folder-structs","title":"8. Structs Folder (<code>structs/</code>)","text":"<ul> <li>Role: <ul> <li>The structs folder is the core of the Swarms framework, housing the orchestration logic for managing and coordinating swarms of agents. This folder allows for dynamic task assignment, queue management, inter-agent communication, and result aggregation.</li> <li>Swarm Management: Agents are grouped into swarms to handle tasks that require multiple agents working in parallel or collaboratively.</li> <li>Scalability: The swarm structure is designed to be scalable, allowing thousands of agents to operate together on distributed tasks.</li> <li>Task Queueing and Execution: Supports task queueing, task prioritization, and load balancing between agents.</li> </ul> </li> <li>Importance: This folder is critical for managing how agents interact and collaborate to solve complex, multi-step problems.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#9-telemetry-folder-telemetry","title":"9. Telemetry Folder (<code>telemetry/</code>)","text":"<ul> <li>Role: <ul> <li>The telemetry folder provides logging and monitoring tools to capture agent performance metrics, error handling, and real-time activity tracking. It helps users keep track of what each agent or swarm is doing, making it easier to debug, audit, and optimize operations.</li> <li>Monitoring: Tracks agent performance and system health.</li> <li>Logs: Maintains logs for troubleshooting and operational review.</li> </ul> </li> <li>Importance: Provides visibility into the system, ensuring smooth operation and enabling fine-tuning of agent behaviors.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#10-tools-folder-tools","title":"10. Tools Folder (<code>tools/</code>)","text":"<ul> <li>Role: <ul> <li>The tools folder contains specialized utility functions or scripts that agents and swarms may require to complete certain tasks, such as web scraping, API interactions, data parsing, or other external resource handling.</li> <li>Task-Specific Tools: Agents can call these tools to perform operations outside of their own logic, enabling them to interact with external systems more efficiently.</li> </ul> </li> <li>Importance: Expands the capabilities of agents, allowing them to complete more sophisticated tasks by relying on these external tools.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#11-utils-folder-utils","title":"11. Utils Folder (<code>utils/</code>)","text":"<ul> <li>Role: <ul> <li>The utils folder contains general-purpose utility functions that are reused throughout the framework. These may include functions for data formatting, validation, logging setup, and configuration management.</li> <li>Shared Utilities: Helps keep the codebase clean by providing reusable functions that multiple agents or parts of the framework can call.</li> </ul> </li> <li>Importance: Provides common functions that help the Swarms framework operate efficiently and consistently.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#core-initialization-file-__init__py","title":"Core Initialization File (<code>__init__.py</code>)","text":"<ul> <li>Role: <ul> <li>The <code>__init__.py</code> file is the entry point of the Swarms package, ensuring that all necessary modules, agents, and tools are loaded when the Swarms framework is imported. It allows for the modular loading of different components, making it easier for users to work with only the parts of the framework they need.</li> </ul> </li> <li>Importance: Acts as the bridge that connects all other components in the framework, enabling the entire package to work together seamlessly.</li> </ul>"},{"location":"swarms/concept/framework_architecture/#how-to-access-documentation","title":"How to Access Documentation","text":"<ul> <li>Official Documentation Site:</li> <li>URL: docs.swarms.world</li> <li> <p>Here, users can find detailed guides, tutorials, and API references on how to use each of the folders mentioned above. The documentation covers setup, agent orchestration, and practical examples of how to leverage swarms for real-world tasks.</p> </li> <li> <p>GitHub Repository:</p> </li> <li>URL: Swarms GitHub</li> <li>The repository contains code examples, detailed folder explanations, and further resources on how to get started with building and managing agent swarms.</li> </ul> <p>By understanding the purpose and role of each folder in the Swarms framework, users can more effectively build, orchestrate, and manage agents to handle complex tasks and workflows at scale.</p>"},{"location":"swarms/concept/framework_architecture/#support","title":"Support:","text":"<ul> <li>Post Issue On Github</li> <li>URL: Submit issue</li> <li> <p>Post your issue whether it's an issue or a feature request</p> </li> <li> <p>Community Support</p> </li> <li>URL: Submit issue</li> <li>Ask the community for support in real-time and or admin support</li> </ul>"},{"location":"swarms/concept/future_swarm_architectures/","title":"Future swarm architectures","text":""},{"location":"swarms/concept/future_swarm_architectures/#federated-swarm","title":"Federated Swarm","text":"<p>Overview: A Federated Swarm architecture involves multiple independent swarms collaborating to complete a task. Each swarm operates autonomously but can share information and results with other swarms.</p> <p>Use-Cases: - Distributed learning systems where data is processed across multiple nodes.</p> <ul> <li>Scenarios requiring collaboration between different teams or departments.</li> </ul> <pre><code>graph TD\n    A[Central Coordinator]\n    subgraph Swarm1\n        B1[Agent 1.1] --&gt; B2[Agent 1.2]\n        B2 --&gt; B3[Agent 1.3]\n    end\n    subgraph Swarm2\n        C1[Agent 2.1] --&gt; C2[Agent 2.2]\n        C2 --&gt; C3[Agent 2.3]\n    end\n    subgraph Swarm3\n        D1[Agent 3.1] --&gt; D2[Agent 3.2]\n        D2 --&gt; D3[Agent 3.3]\n    end\n    B1 --&gt; A\n    C1 --&gt; A\n    D1 --&gt; A</code></pre>"},{"location":"swarms/concept/future_swarm_architectures/#star-swarm","title":"Star Swarm","text":"<p>Overview: A Star Swarm architecture features a central agent that coordinates the activities of several peripheral agents. The central agent assigns tasks to the peripheral agents and aggregates their results.</p> <p>Use-Cases: - Centralized decision-making processes.</p> <ul> <li>Scenarios requiring a central authority to coordinate multiple workers.</li> </ul> <pre><code>graph TD\n    A[Central Agent] --&gt; B1[Peripheral Agent 1]\n    A --&gt; B2[Peripheral Agent 2]\n    A --&gt; B3[Peripheral Agent 3]\n    A --&gt; B4[Peripheral Agent 4]</code></pre>"},{"location":"swarms/concept/future_swarm_architectures/#mesh-swarm","title":"Mesh Swarm","text":"<p>Overview: A Mesh Swarm architecture allows for a fully connected network of agents where each agent can communicate with any other agent. This setup provides high flexibility and redundancy.</p> <p>Use-Cases: - Complex systems requiring high fault tolerance and redundancy.</p> <ul> <li>Scenarios involving dynamic and frequent communication between agents.</li> </ul> <pre><code>graph TD\n    A1[Agent 1] --&gt; A2[Agent 2]\n    A1 --&gt; A3[Agent 3]\n    A1 --&gt; A4[Agent 4]\n    A2 --&gt; A3\n    A2 --&gt; A4\n    A3 --&gt; A4</code></pre>"},{"location":"swarms/concept/future_swarm_architectures/#cascade-swarm","title":"Cascade Swarm","text":"<p>Overview: A Cascade Swarm architecture involves a chain of agents where each agent triggers the next one in a cascade effect. This is useful for scenarios where tasks need to be processed in stages, and each stage initiates the next.</p> <p>Use-Cases: - Multi-stage processing tasks such as data transformation pipelines.</p> <ul> <li>Event-driven architectures where one event triggers subsequent actions.</li> </ul> <pre><code>graph TD\n    A[Trigger Agent] --&gt; B[Agent 1]\n    B --&gt; C[Agent 2]\n    C --&gt; D[Agent 3]\n    D --&gt; E[Agent 4]</code></pre>"},{"location":"swarms/concept/future_swarm_architectures/#hybrid-swarm","title":"Hybrid Swarm","text":"<p>Overview: A Hybrid Swarm architecture combines elements of various architectures to suit specific needs. It might integrate hierarchical and parallel components, or mix sequential and round robin patterns.</p> <p>Use-Cases: - Complex workflows requiring a mix of different processing strategies.</p> <ul> <li>Custom scenarios tailored to specific operational requirements.</li> </ul> <pre><code>graph TD\n    A[Root Agent] --&gt; B1[Sub-Agent 1]\n    A --&gt; B2[Sub-Agent 2]\n    B1 --&gt; C1[Parallel Agent 1]\n    B1 --&gt; C2[Parallel Agent 2]\n    B2 --&gt; C3[Sequential Agent 1]\n    C3 --&gt; C4[Sequential Agent 2]\n    C3 --&gt; C5[Sequential Agent 3]</code></pre> <p>These swarm architectures provide different models for organizing and orchestrating large language models (LLMs) to perform various tasks efficiently. Depending on the specific requirements of your project, you can choose the appropriate architecture or even combine elements from multiple architectures to create a hybrid solution.</p>"},{"location":"swarms/concept/how_to_choose_swarms/","title":"Choosing the Right Swarm for Your Business Problem","text":"<p>Depending on the complexity and nature of your problem, different swarm configurations can be more effective in achieving optimal performance. This guide provides a detailed explanation of when to use each swarm type, including their strengths and potential drawbacks.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#swarm-types-overview","title":"Swarm Types Overview","text":"<ul> <li>MajorityVoting: A swarm structure where agents vote on an outcome, and the majority decision is taken as the final result.</li> <li>AgentRearrange: Provides the foundation for both sequential and parallel swarms.</li> <li>RoundRobin: Agents take turns handling tasks in a cyclic manner.</li> <li>Mixture of Agents: A heterogeneous swarm where agents with different capabilities are combined.</li> <li>GraphWorkflow: Agents collaborate in a directed acyclic graph (DAG) format.</li> <li>GroupChat: Agents engage in a chat-like interaction to reach decisions.</li> <li>AgentRegistry: A centralized registry where agents are stored, retrieved, and invoked.</li> <li>SpreadsheetSwarm: A swarm designed to manage tasks at scale, tracking agent outputs in a structured format (e.g., CSV files).</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#majorityvoting-swarm","title":"MajorityVoting Swarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case","title":"Use-Case","text":"<p>MajorityVoting is ideal for scenarios where accuracy is paramount, and the decision must be determined from multiple perspectives. For instance, choosing the best marketing strategy where various marketing agents vote on the highest predicted performance.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#advantages","title":"Advantages","text":"<ul> <li>Ensures robustness in decision-making by leveraging multiple agents.</li> <li>Helps eliminate outliers or faulty agent decisions.</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#warnings","title":"Warnings","text":"<p>Warning</p> <p>Majority voting can be slow if too many agents are involved. Ensure that your swarm size is manageable for real-time decision-making.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#agentrearrange-sequential-and-parallel","title":"AgentRearrange (Sequential and Parallel)","text":""},{"location":"swarms/concept/how_to_choose_swarms/#sequential-swarm-use-case","title":"Sequential Swarm Use-Case","text":"<p>For linear workflows where each task depends on the outcome of the previous task, such as processing legal documents step by step through a series of checks and validations.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#parallel-swarm-use-case","title":"Parallel Swarm Use-Case","text":"<p>For tasks that can be executed concurrently, such as batch processing customer data in marketing campaigns. Parallel swarms can significantly reduce processing time by dividing tasks across multiple agents.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#notes","title":"Notes","text":"<p>Note</p> <p>Sequential swarms are slower but ensure strict task dependencies are respected. Parallel swarms are faster but require careful management of task interdependencies.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#roundrobin-swarm","title":"RoundRobin Swarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_1","title":"Use-Case","text":"<p>For balanced task distribution where agents need to handle tasks evenly. An example would be assigning customer support tickets to agents in a cyclic manner, ensuring no single agent is overloaded.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#advantages_1","title":"Advantages","text":"<ul> <li>Fair and even distribution of tasks.</li> <li>Simple and effective for balanced workloads.</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#warnings_1","title":"Warnings","text":"<p>Warning</p> <p>Round-robin may not be the best choice when some agents are more competent than others, as it can assign tasks equally regardless of agent performance.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#mixture-of-agents","title":"Mixture of Agents","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_2","title":"Use-Case","text":"<p>Ideal for complex problems that require diverse skills. For example, a financial forecasting problem where some agents specialize in stock data, while others handle economic factors.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#notes_1","title":"Notes","text":"<p>Note</p> <p>A mixture of agents is highly flexible and can adapt to various problem domains. However, be mindful of coordination overhead.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#graphworkflow-swarm","title":"GraphWorkflow Swarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_3","title":"Use-Case","text":"<p>This swarm structure is suited for tasks that can be broken down into a series of dependencies but are not strictly linear, such as an AI-driven software development pipeline where one agent handles front-end development while another handles back-end concurrently.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#advantages_2","title":"Advantages","text":"<ul> <li>Provides flexibility for managing dependencies.</li> <li>Agents can work on different parts of the problem simultaneously.</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#warnings_2","title":"Warnings","text":"<p>Warning</p> <p>GraphWorkflow requires clear definition of task dependencies, or it can lead to execution issues and delays.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#groupchat-swarm","title":"GroupChat Swarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_4","title":"Use-Case","text":"<p>For real-time collaborative decision-making. For instance, agents could participate in group chat for negotiating contracts, each contributing their expertise and adjusting responses based on the collective discussion.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#advantages_3","title":"Advantages","text":"<ul> <li>Facilitates highly interactive problem-solving.</li> <li>Ideal for dynamic and unstructured problems.</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#warnings_3","title":"Warnings","text":"<p>Warning</p> <p>High communication overhead between agents may slow down decision-making in large swarms.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#agentregistry-swarm","title":"AgentRegistry Swarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_5","title":"Use-Case","text":"<p>For dynamically managing agents based on the problem domain. An AgentRegistry is useful when new agents can be added or removed as needed, such as adding new machine learning models for an evolving recommendation engine.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#notes_2","title":"Notes","text":"<p>Note</p> <p>AgentRegistry is a flexible solution but introduces additional complexity when agents need to be discovered and registered on the fly.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#spreadsheetswarm","title":"SpreadsheetSwarm","text":""},{"location":"swarms/concept/how_to_choose_swarms/#use-case_6","title":"Use-Case","text":"<p>When dealing with massive-scale data or agent outputs that need to be stored and managed in a tabular format. SpreadsheetSwarm is ideal for businesses handling thousands of agent outputs, such as large-scale marketing analytics or financial audits.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#advantages_4","title":"Advantages","text":"<ul> <li>Provides structure and order for managing massive amounts of agent outputs.</li> <li>Outputs are easily saved and tracked in CSV files.</li> </ul>"},{"location":"swarms/concept/how_to_choose_swarms/#warnings_4","title":"Warnings","text":"<p>Warning</p> <p>Ensure the correct configuration of agents in SpreadsheetSwarm to avoid data mismatches and inconsistencies when scaling up to thousands of agents.</p>"},{"location":"swarms/concept/how_to_choose_swarms/#final-thoughts","title":"Final Thoughts","text":"<p>The choice of swarm depends on:</p> <ol> <li> <p>Nature of the task: Whether it's sequential or parallel.</p> </li> <li> <p>Problem complexity: Simple problems might benefit from RoundRobin, while complex ones may need GraphWorkflow or Mixture of Agents.</p> </li> <li> <p>Scale of execution: For large-scale tasks, Swarms like SpreadsheetSwarm or MajorityVoting provide scalability with structured outputs.</p> </li> </ol> <p>When integrating agents in a business workflow, it's crucial to balance task complexity, agent capabilities, and scalability to ensure the optimal swarm architecture.</p>"},{"location":"swarms/concept/philosophy/","title":"Our Philosophy: Simplifying Multi-Agent Collaboration Through Readable Code and Performance Optimization","text":"<p>Our mission is to streamline multi-agent collaboration by emphasizing simplicity, readability, and performance in our codebase. This document outlines our core tactics:</p> <ul> <li>Readable Code with Type Annotations, Documentation, and Logging</li> <li>Bleeding-Edge Performance via Concurrency and Parallelism</li> <li>Simplified Abstractions for Multi-Agent Collaboration</li> </ul> <p>By adhering to these principles, we aim to make our systems more maintainable, scalable, and efficient, facilitating easier integration and collaboration among developers and agents alike.</p>"},{"location":"swarms/concept/philosophy/#1-emphasizing-readable-code","title":"1. Emphasizing Readable Code","text":"<p>Readable code is the cornerstone of maintainable and scalable systems. It ensures that developers can easily understand, modify, and extend the codebase.</p>"},{"location":"swarms/concept/philosophy/#11-use-of-type-annotations","title":"1.1 Use of Type Annotations","text":"<p>Type annotations enhance code readability and catch errors early in the development process.</p> <pre><code>def process_data(data: List[str]) -&gt; Dict[str, int]:\n    result = {}\n    for item in data:\n        result[item] = len(item)\n    return result\n</code></pre>"},{"location":"swarms/concept/philosophy/#12-code-style-guidelines","title":"1.2 Code Style Guidelines","text":"<p>Adhering to consistent code style guidelines, such as PEP 8 for Python, ensures uniformity across the codebase.</p> <ul> <li>Indentation: Use 4 spaces per indentation level.</li> <li>Variable Naming: Use <code>snake_case</code> for variables and functions.</li> <li>Class Naming: Use <code>PascalCase</code> for class names.</li> </ul>"},{"location":"swarms/concept/philosophy/#13-importance-of-documentation","title":"1.3 Importance of Documentation","text":"<p>Comprehensive documentation helps new developers understand the purpose and functionality of code modules.</p> <pre><code>def fetch_user_profile(user_id: str) -&gt; UserProfile:\n    \"\"\"\n    Fetches the user profile from the database.\n\n    Args:\n        user_id (str): The unique identifier of the user.\n\n    Returns:\n        UserProfile: An object containing user profile data.\n    \"\"\"\n    # Function implementation\n</code></pre>"},{"location":"swarms/concept/philosophy/#14-consistent-naming-conventions","title":"1.4 Consistent Naming Conventions","text":"<p>Consistent naming reduces confusion and makes the code self-explanatory.</p> <ul> <li>Functions: Should be verbs (e.g., <code>calculate_total</code>).</li> <li>Variables: Should be nouns (e.g., <code>total_amount</code>).</li> <li>Constants: Should be uppercase (e.g., <code>MAX_RETRIES</code>).</li> </ul>"},{"location":"swarms/concept/philosophy/#2-effective-logging-practices","title":"2. Effective Logging Practices","text":"<p>Logging is essential for debugging and monitoring the health of applications.</p>"},{"location":"swarms/concept/philosophy/#21-why-logging-is-important","title":"2.1 Why Logging is Important","text":"<ul> <li>Debugging: Helps identify issues during development and after deployment.</li> <li>Monitoring: Provides insights into the system's behavior in real-time.</li> <li>Audit Trails: Keeps a record of events for compliance and analysis.</li> </ul>"},{"location":"swarms/concept/philosophy/#22-best-practices-for-logging","title":"2.2 Best Practices for Logging","text":"<ul> <li>Use Appropriate Log Levels: DEBUG, INFO, WARNING, ERROR, CRITICAL.</li> <li>Consistent Log Formatting: Include timestamps, log levels, and messages.</li> <li>Avoid Sensitive Information: Do not log passwords or personal data.</li> </ul>"},{"location":"swarms/concept/philosophy/#23-logging-examples","title":"2.3 Logging Examples","text":"<pre><code>import logging\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s %(levelname)s:%(message)s')\n\ndef connect_to_service(url: str) -&gt; bool:\n    logging.debug(f\"Attempting to connect to {url}\")\n    try:\n        # Connection logic\n        logging.info(f\"Successfully connected to {url}\")\n        return True\n    except ConnectionError as e:\n        logging.error(f\"Connection failed to {url}: {e}\")\n        return False\n</code></pre>"},{"location":"swarms/concept/philosophy/#3-achieving-bleeding-edge-performance","title":"3. Achieving Bleeding-Edge Performance","text":"<p>Performance is critical, especially when dealing with multiple agents and large datasets.</p>"},{"location":"swarms/concept/philosophy/#31-concurrency-and-parallelism","title":"3.1 Concurrency and Parallelism","text":"<p>Utilizing concurrency and parallelism can significantly improve performance.</p> <ul> <li>Concurrency: Dealing with multiple tasks by managing multiple threads.</li> <li>Parallelism: Executing multiple tasks simultaneously on multiple CPU cores.</li> </ul>"},{"location":"swarms/concept/philosophy/#32-asynchronous-programming","title":"3.2 Asynchronous Programming","text":"<p>Asynchronous programming allows for non-blocking operations, leading to better resource utilization.</p> <pre><code>import asyncio\n\nasync def fetch_data(endpoint: str) -&gt; dict:\n    async with aiohttp.ClientSession() as session:\n        async with session.get(endpoint) as response:\n            return await response.json()\n\nasync def main():\n    endpoints = ['https://api.example.com/data1', 'https://api.example.com/data2']\n    tasks = [fetch_data(url) for url in endpoints]\n    results = await asyncio.gather(*tasks)\n    print(results)\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms/concept/philosophy/#33-utilizing-modern-hardware-capabilities","title":"3.3 Utilizing Modern Hardware Capabilities","text":"<p>Leverage multi-core processors and GPUs for computationally intensive tasks.</p> <ul> <li>Multi-threading: Use threads for I/O-bound tasks.</li> <li>Multi-processing: Use processes for CPU-bound tasks.</li> <li>GPU Acceleration: Utilize GPUs for tasks like machine learning model training.</li> </ul>"},{"location":"swarms/concept/philosophy/#34-code-example-parallel-processing","title":"3.4 Code Example: Parallel Processing","text":"<pre><code>from concurrent.futures import ThreadPoolExecutor\n\ndef process_item(item):\n    # Processing logic\n    return result\n\nitems = [1, 2, 3, 4, 5]\nwith ThreadPoolExecutor(max_workers=5) as executor:\n    results = list(executor.map(process_item, items))\n</code></pre>"},{"location":"swarms/concept/philosophy/#4-simplifying-multi-agent-collaboration","title":"4. Simplifying Multi-Agent Collaboration","text":"<p>Simplifying the abstraction of multi-agent collaboration makes it accessible and manageable.</p>"},{"location":"swarms/concept/philosophy/#41-importance-of-simple-abstractions","title":"4.1 Importance of Simple Abstractions","text":"<ul> <li>Ease of Use: Simple interfaces make it easier for developers to integrate agents.</li> <li>Maintainability: Reduces complexity, making the codebase easier to maintain.</li> <li>Scalability: Simple abstractions can be extended without significant overhauls.</li> </ul>"},{"location":"swarms/concept/philosophy/#42-standardizing-agent-interfaces","title":"4.2 Standardizing Agent Interfaces","text":"<p>Every agent should adhere to a standard interface for consistency.</p>"},{"location":"swarms/concept/philosophy/#421-agent-base-class","title":"4.2.1 Agent Base Class","text":"<pre><code>from abc import ABC, abstractmethod\n\nclass BaseAgent(ABC):\n    @abstractmethod\n    def run(self, task: str) -&gt; Any:\n        pass\n\n    def __call__(self, task: str) -&gt; Any:\n        return self.run(task)\n\n    @abstractmethod\n    async def arun(self, task: str) -&gt; Any:\n        pass\n</code></pre>"},{"location":"swarms/concept/philosophy/#422-example-agent-implementation","title":"4.2.2 Example Agent Implementation","text":"<pre><code>class DataProcessingAgent(BaseAgent):\n    def run(self, task: str) -&gt; str:\n        # Synchronous processing logic\n        return f\"Processed {task}\"\n\n    async def arun(self, task: str) -&gt; str:\n        # Asynchronous processing logic\n        return f\"Processed {task} asynchronously\"\n</code></pre>"},{"location":"swarms/concept/philosophy/#423-usage-example","title":"4.2.3 Usage Example","text":"<pre><code>agent = DataProcessingAgent()\n\n# Synchronous call\nresult = agent.run(\"data_task\")\nprint(result)  # Output: Processed data_task\n\n# Asynchronous call\nasync def main():\n    result = await agent.arun(\"data_task\")\n    print(result)  # Output: Processed data_task asynchronously\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms/concept/philosophy/#43-mermaid-diagram-agent-interaction","title":"4.3 Mermaid Diagram: Agent Interaction","text":"<pre><code>sequenceDiagram\n    participant User\n    participant AgentA\n    participant AgentB\n    participant AgentC\n\n    User-&gt;&gt;AgentA: run(task)\n    AgentA--&gt;&gt;AgentB: arun(sub_task)\n    AgentB--&gt;&gt;AgentC: run(sub_sub_task)\n    AgentC--&gt;&gt;AgentB: result_sub_sub_task\n    AgentB--&gt;&gt;AgentA: result_sub_task\n    AgentA--&gt;&gt;User: final_result</code></pre> <p>Agents collaborating to fulfill a user's task.</p>"},{"location":"swarms/concept/philosophy/#44-simplified-collaboration-workflow","title":"4.4 Simplified Collaboration Workflow","text":"<pre><code>flowchart TD\n    UserRequest[\"User Request\"] --&gt; Agent1[\"Agent 1\"]\n    Agent1 --&gt;|\"run(task)\"| Agent2[\"Agent 2\"]\n    Agent2 --&gt;|\"arun(task)\"| Agent3[\"Agent 3\"]\n    Agent3 --&gt;|\"result\"| Agent2\n    Agent2 --&gt;|\"result\"| Agent1\n    Agent1 --&gt;|\"result\"| UserResponse[\"User Response\"]</code></pre> <p>Workflow demonstrating how agents process a task collaboratively.</p>"},{"location":"swarms/concept/philosophy/#5-bringing-it-all-together","title":"5. Bringing It All Together","text":"<p>By integrating these principles, we create a cohesive system where agents can efficiently collaborate while maintaining code quality and performance.</p>"},{"location":"swarms/concept/philosophy/#51-example-multi-agent-system","title":"5.1 Example: Multi-Agent System","text":""},{"location":"swarms/concept/philosophy/#511-agent-definitions","title":"5.1.1 Agent Definitions","text":"<pre><code>class AgentA(BaseAgent):\n    def run(self, task: str) -&gt; str:\n        # Agent A processing\n        return f\"AgentA processed {task}\"\n\n    async def arun(self, task: str) -&gt; str:\n        # Agent A asynchronous processing\n        return f\"AgentA processed {task} asynchronously\"\n\nclass AgentB(BaseAgent):\n    def run(self, task: str) -&gt; str:\n        # Agent B processing\n        return f\"AgentB processed {task}\"\n\n    async def arun(self, task: str) -&gt; str:\n        # Agent B asynchronous processing\n        return f\"AgentB processed {task} asynchronously\"\n</code></pre>"},{"location":"swarms/concept/philosophy/#512-orchestrator-agent","title":"5.1.2 Orchestrator Agent","text":"<pre><code>class OrchestratorAgent(BaseAgent):\n    def __init__(self):\n        self.agent_a = AgentA()\n        self.agent_b = AgentB()\n\n    def run(self, task: str) -&gt; str:\n        result_a = self.agent_a.run(task)\n        result_b = self.agent_b.run(task)\n        return f\"Orchestrated results: {result_a} &amp; {result_b}\"\n\n    async def arun(self, task: str) -&gt; str:\n        result_a = await self.agent_a.arun(task)\n        result_b = await self.agent_b.arun(task)\n        return f\"Orchestrated results: {result_a} &amp; {result_b}\"\n</code></pre>"},{"location":"swarms/concept/philosophy/#513-execution","title":"5.1.3 Execution","text":"<pre><code>orchestrator = OrchestratorAgent()\n\n# Synchronous execution\nresult = orchestrator.run(\"task1\")\nprint(result)\n# Output: Orchestrated results: AgentA processed task1 &amp; AgentB processed task1\n\n# Asynchronous execution\nasync def main():\n    result = await orchestrator.arun(\"task1\")\n    print(result)\n    # Output: Orchestrated results: AgentA processed task1 asynchronously &amp; AgentB processed task1 asynchronously\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms/concept/philosophy/#52-mermaid-diagram-orchestrator-workflow","title":"5.2 Mermaid Diagram: Orchestrator Workflow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Orchestrator\n    participant AgentA\n    participant AgentB\n\n    User-&gt;&gt;Orchestrator: run(task)\n    Orchestrator-&gt;&gt;AgentA: run(task)\n    Orchestrator-&gt;&gt;AgentB: run(task)\n    AgentA--&gt;&gt;Orchestrator: result_a\n    AgentB--&gt;&gt;Orchestrator: result_b\n    Orchestrator--&gt;&gt;User: Orchestrated results</code></pre> <p>Orchestrator coordinating between Agent A and Agent B.</p>"},{"location":"swarms/concept/philosophy/#6-conclusion","title":"6. Conclusion","text":"<p>Our philosophy centers around making multi-agent collaboration as simple and efficient as possible by:</p> <ul> <li>Writing Readable Code: Through type annotations, consistent styling, and thorough documentation.</li> <li>Implementing Effective Logging: To aid in debugging and monitoring.</li> <li>Optimizing Performance: Leveraging concurrency, parallelism, and modern hardware capabilities.</li> <li>Simplifying Abstractions: Standardizing agent interfaces to <code>run</code>, <code>__call__</code>, and <code>arun</code> methods.</li> </ul> <p>By adhering to these principles, we create a robust foundation for scalable and maintainable systems that can adapt to evolving technological landscapes.</p>"},{"location":"swarms/concept/swarm_architectures/","title":"Multi-Agent Architectures","text":""},{"location":"swarms/concept/swarm_architectures/#what-is-a-multi-agent-architecture","title":"What is a Multi-Agent Architecture?","text":"<p>A multi-agent architecture refers to a group of more than two agents working collaboratively to achieve a common goal. These agents can be software entities, such as LLMs that interact with each other to perform complex tasks. The concept of multi-agent architectures is inspired by how humans communicate and work together in teams, organizations, and communities, where individual contributions combine to create sophisticated collaborative problem-solving capabilities.</p>"},{"location":"swarms/concept/swarm_architectures/#how-multi-agent-architectures-facilitate-communication","title":"How Multi-Agent Architectures Facilitate Communication","text":"<p>Multi-agent architectures are designed to establish and manage communication between agents within a system. These architectures define how agents interact, share information, and coordinate their actions to achieve the desired outcomes. Here are some key aspects of multi-agent architectures:</p> <ol> <li> <p>Hierarchical Communication: In hierarchical architectures, communication flows from higher-level agents to lower-level agents. Higher-level agents act as coordinators, distributing tasks and aggregating results. This structure is efficient for tasks that require top-down control and decision-making.</p> </li> <li> <p>Concurrent Communication: In concurrent architectures, agents operate independently and simultaneously on different tasks. This architecture is suitable for tasks that can be processed concurrently without dependencies, allowing for faster execution and scalability.</p> </li> <li> <p>Sequential Communication: Sequential architectures process tasks in a linear order, where each agent's output becomes the input for the next agent. This ensures that tasks with dependencies are handled in the correct sequence, maintaining the integrity of the workflow.</p> </li> <li> <p>Mesh Communication: In mesh architectures, agents are fully connected, allowing any agent to communicate with any other agent. This setup provides high flexibility and redundancy, making it ideal for complex systems requiring dynamic interactions.</p> </li> <li> <p>Federated Communication: Federated architectures involve multiple independent systems that collaborate by sharing information and results. Each system operates autonomously but can contribute to a larger task, enabling distributed problem-solving across different nodes.</p> </li> </ol> <p>Multi-agent architectures leverage these communication patterns to ensure that agents work together efficiently, adapting to the specific requirements of the task at hand. By defining clear communication protocols and interaction models, multi-agent architectures enable the seamless orchestration of multiple agents, leading to enhanced performance and problem-solving capabilities.</p>"},{"location":"swarms/concept/swarm_architectures/#core-multi-agent-architectures","title":"Core Multi-Agent Architectures","text":"Name Description Documentation Use Cases Hierarchical Architecture A system where agents are organized in a hierarchy, with higher-level agents coordinating lower-level agents to achieve complex tasks. Learn More Manufacturing process optimization, multi-level sales management, healthcare resource coordination Agent Rearrange A setup where agents rearrange themselves dynamically based on the task requirements and environmental conditions. Learn More Adaptive manufacturing lines, dynamic sales territory realignment, flexible healthcare staffing Concurrent Workflows Agents perform different tasks simultaneously, coordinating to complete a larger goal. Learn More Concurrent production lines, parallel sales operations, simultaneous patient care processes Sequential Coordination Agents perform tasks in a specific sequence, where the completion of one task triggers the start of the next. Learn More Step-by-step assembly lines, sequential sales processes, stepwise patient treatment workflows Mixture of Agents A heterogeneous architecture where agents with different capabilities are combined to solve complex problems. Learn More Financial forecasting, complex problem-solving requiring diverse skills Graph Workflow Agents collaborate in a directed acyclic graph (DAG) format to manage dependencies and parallel tasks. Learn More AI-driven software development pipelines, complex project management Group Chat Agents engage in a chat-like interaction to reach decisions collaboratively. Learn More Real-time collaborative decision-making, contract negotiations Interactive Group Chat Enhanced group chat with dynamic speaker selection and interaction patterns. Learn More Advanced collaborative decision-making, dynamic team coordination Agent Registry A centralized registry where agents are stored, retrieved, and invoked dynamically. Learn More Dynamic agent management, evolving recommendation engines SpreadSheet Manages tasks at scale, tracking agent outputs in a structured format like CSV files. Learn More Large-scale marketing analytics, financial audits Router Routes and chooses the architecture based on the task requirements and available agents. Learn More Dynamic task routing, adaptive architecture selection, optimized agent allocation Heavy High-performance architecture for handling intensive computational tasks with multiple agents. Learn More Large-scale data processing, intensive computational workflows Deep Research Specialized architecture for conducting in-depth research tasks across multiple domains. Learn More Academic research, market analysis, comprehensive data investigation De-Hallucination Architecture designed to reduce and eliminate hallucinations in AI outputs through consensus. Learn More Fact-checking, content verification, reliable information generation Council as Judge Multiple agents act as a council to evaluate and judge outputs or decisions. Learn More Quality assessment, decision validation, peer review processes MALT Specialized architecture for complex language processing tasks across multiple agents. Learn More Natural language processing, translation, content generation Majority Voting Agents vote on decisions with the majority determining the final outcome. Learn More Democratic decision-making, consensus building, error reduction Round Robin Tasks are distributed cyclically among agents in a rotating order. Learn More Load balancing, fair task distribution, resource optimization Auto-Builder Automatically constructs and configures multi-agent systems based on requirements. Learn More Dynamic system creation, adaptive architectures, rapid prototyping Hybrid Hierarchical Cluster Combines hierarchical and peer-to-peer communication patterns for complex workflows. Learn More Complex enterprise workflows, multi-department coordination Election Agents participate in democratic voting processes to select leaders or make collective decisions. Learn More Democratic governance, consensus building, leadership selection Dynamic Conversational Adaptive conversation management with dynamic agent selection and interaction patterns. Learn More Adaptive chatbots, dynamic customer service, contextual conversations Tree Hierarchical tree structure for organizing agents in parent-child relationships. Learn More Organizational hierarchies, decision trees, taxonomic classification"},{"location":"swarms/concept/swarm_architectures/#architectural-patterns","title":"Architectural Patterns","text":""},{"location":"swarms/concept/swarm_architectures/#hierarchical-architecture","title":"Hierarchical Architecture","text":"<p>Overview: Organizes agents in a tree-like structure. Higher-level agents delegate tasks to lower-level agents, which can further divide tasks among themselves. This structure allows for efficient task distribution and scalability.</p> <p>Use Cases:</p> <ul> <li> <p>Complex decision-making processes where tasks can be broken down into subtasks</p> </li> <li> <p>Multi-stage workflows such as data processing pipelines or hierarchical reinforcement learning</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Root Agent] --&gt; B1[Sub-Agent 1]\n    A --&gt; B2[Sub-Agent 2]\n    B1 --&gt; C1[Sub-Agent 1.1]\n    B1 --&gt; C2[Sub-Agent 1.2]\n    B2 --&gt; C3[Sub-Agent 2.1]\n    B2 --&gt; C4[Sub-Agent 2.2]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#agent-rearrange","title":"Agent Rearrange","text":"<p>Overview: A dynamic architecture where agents rearrange themselves based on task requirements and environmental conditions. Agents can adapt their roles, positions, and relationships to optimize performance for different scenarios.</p> <p>Use Cases: - Adaptive manufacturing lines that reconfigure based on product requirements</p> <ul> <li> <p>Dynamic sales territory realignment based on market conditions</p> </li> <li> <p>Flexible healthcare staffing that adjusts to patient needs</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Task Requirements] --&gt; B[Configuration Analyzer]\n    B --&gt; C[Optimization Engine]\n\n    C --&gt; D[Agent Pool]\n    D --&gt; E[Agent 1]\n    D --&gt; F[Agent 2]\n    D --&gt; G[Agent 3]\n    D --&gt; H[Agent N]\n\n    C --&gt; I[Rearrangement Logic]\n    I --&gt; J[New Configuration]\n    J --&gt; K[Role Assignment]\n    K --&gt; L[Execution Phase]\n\n    L --&gt; M[Performance Monitor]\n    M --&gt; N{Optimization Needed?}\n    N --&gt;|Yes| C\n    N --&gt;|No| O[Continue Execution]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#concurrent-architecture","title":"Concurrent Architecture","text":"<p>Overview: Multiple agents operate independently and simultaneously on different tasks. Each agent works on its own task without dependencies on the others.</p> <p>Use Cases: - Tasks that can be processed independently, such as parallel data analysis</p> <ul> <li>Large-scale simulations where multiple scenarios are run simultaneously</li> </ul> <p>Learn More</p> <pre><code>graph LR\n    A[Task Input] --&gt; B1[Agent 1]\n    A --&gt; B2[Agent 2]\n    A --&gt; B3[Agent 3]\n    A --&gt; B4[Agent 4]\n    B1 --&gt; C1[Output 1]\n    B2 --&gt; C2[Output 2]\n    B3 --&gt; C3[Output 3]\n    B4 --&gt; C4[Output 4]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#sequential-architecture","title":"Sequential Architecture","text":"<p>Overview: Processes tasks in a linear sequence. Each agent completes its task before passing the result to the next agent in the chain. Ensures orderly processing and is useful when tasks have dependencies.</p> <p>Use Cases:</p> <ul> <li> <p>Workflows where each step depends on the previous one, such as assembly lines or sequential data processing</p> </li> <li> <p>Scenarios requiring strict order of operations</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Input] --&gt; B[Agent 1]\n    B --&gt; C[Agent 2]\n    C --&gt; D[Agent 3]\n    D --&gt; E[Agent 4]\n    E --&gt; F[Final Output]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#round-robin-architecture","title":"Round Robin Architecture","text":"<p>Overview: Tasks are distributed cyclically among a set of agents. Each agent takes turns handling tasks in a rotating order, ensuring even distribution of workload.</p> <p>Use Cases:</p> <ul> <li> <p>Load balancing in distributed systems</p> </li> <li> <p>Scenarios requiring fair distribution of tasks to avoid overloading any single agent</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Task Distributor] --&gt; B1[Agent 1]\n    A --&gt; B2[Agent 2]\n    A --&gt; B3[Agent 3]\n    A --&gt; B4[Agent 4]\n    B1 --&gt; C[Task Queue]\n    B2 --&gt; C\n    B3 --&gt; C\n    B4 --&gt; C\n    C --&gt; A</code></pre>"},{"location":"swarms/concept/swarm_architectures/#spreadsheet-architecture","title":"SpreadSheet Architecture","text":"<p>Overview: Makes it easy to manage thousands of agents in one place: a CSV file. Initialize any number of agents and run loops of agents on tasks.</p> <p>Use Cases: - Multi-threaded execution: Execute agents on multiple threads</p> <ul> <li> <p>Save agent outputs into CSV file</p> </li> <li> <p>One place to analyze agent outputs</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Initialize SpreadSheet System] --&gt; B[Initialize Agents]\n    B --&gt; C[Load Task Queue]\n    C --&gt; D[Distribute Tasks]\n\n    subgraph Agent_Pool[Agent Pool]\n        D --&gt; E1[Agent 1]\n        D --&gt; E2[Agent 2]\n        D --&gt; E3[Agent 3]\n        D --&gt; E4[Agent N]\n    end\n\n    E1 --&gt; F1[Process Task]\n    E2 --&gt; F2[Process Task]\n    E3 --&gt; F3[Process Task]\n    E4 --&gt; F4[Process Task]\n\n    F1 --&gt; G[Collect Results]\n    F2 --&gt; G\n    F3 --&gt; G\n    F4 --&gt; G\n\n    G --&gt; H[Save to CSV]\n    H --&gt; I[Generate Analytics]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#mixture-of-agents","title":"Mixture of Agents","text":"<p>Overview: Combines multiple agents with different capabilities and expertise to solve complex problems that require diverse skill sets.</p> <p>Use Cases: - Financial forecasting requiring different analytical approaches</p> <ul> <li> <p>Complex problem-solving needing diverse expertise</p> </li> <li> <p>Multi-domain analysis tasks</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Task Input] --&gt; B[Layer 1: Reference Agents]\n    B --&gt; C[Specialist Agent 1]\n    B --&gt; D[Specialist Agent 2]\n    B --&gt; E[Specialist Agent N]\n\n    C --&gt; F[Response 1]\n    D --&gt; G[Response 2]\n    E --&gt; H[Response N]\n\n    F --&gt; I[Layer 2: Aggregator Agent]\n    G --&gt; I\n    H --&gt; I\n    I --&gt; J[Synthesized Output]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#graph-workflow","title":"Graph Workflow","text":"<p>Overview: Organizes agents in a directed acyclic graph (DAG) format, enabling complex dependencies and parallel execution paths.</p> <p>Use Cases: - AI-driven software development pipelines</p> <ul> <li> <p>Complex project management with dependencies</p> </li> <li> <p>Multi-step data processing workflows</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Start Node] --&gt; B[Agent 1]\n    A --&gt; C[Agent 2]\n    B --&gt; D[Agent 3]\n    C --&gt; D\n    B --&gt; E[Agent 4]\n    D --&gt; F[Agent 5]\n    E --&gt; F\n    F --&gt; G[End Node]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#group-chat","title":"Group Chat","text":"<p>Overview: Enables agents to engage in chat-like interactions to reach decisions collaboratively through discussion and consensus building.</p> <p>Use Cases: - Real-time collaborative decision-making</p> <ul> <li> <p>Contract negotiations</p> </li> <li> <p>Brainstorming sessions</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Discussion Topic] --&gt; B[Chat Environment]\n    B --&gt; C[Agent 1]\n    B --&gt; D[Agent 2]\n    B --&gt; E[Agent 3]\n    B --&gt; F[Agent N]\n\n    C --&gt; G[Message Exchange]\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Consensus Building]\n    H --&gt; I[Final Decision]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#interactive-group-chat","title":"Interactive Group Chat","text":"<p>Overview: Enhanced version of Group Chat with dynamic speaker selection, priority-based communication, and advanced interaction patterns.</p> <p>Use Cases: - Advanced collaborative decision-making</p> <ul> <li> <p>Dynamic team coordination</p> </li> <li> <p>Adaptive conversation management</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Conversation Manager] --&gt; B[Speaker Selection Logic]\n    B --&gt; C[Priority Speaker]\n    B --&gt; D[Random Speaker]\n    B --&gt; E[Round Robin Speaker]\n\n    C --&gt; F[Active Discussion]\n    D --&gt; F\n    E --&gt; F\n\n    F --&gt; G[Agent Pool]\n    G --&gt; H[Agent 1]\n    G --&gt; I[Agent 2]\n    G --&gt; J[Agent N]\n\n    H --&gt; K[Dynamic Response]\n    I --&gt; K\n    J --&gt; K\n    K --&gt; A</code></pre>"},{"location":"swarms/concept/swarm_architectures/#agent-registry","title":"Agent Registry","text":"<p>Overview: A centralized registry system where agents are stored, retrieved, and invoked dynamically. The registry maintains metadata about agent capabilities, availability, and performance metrics, enabling intelligent agent selection and management.</p> <p>Use Cases: - Dynamic agent management in large-scale systems</p> <ul> <li> <p>Evolving recommendation engines that adapt agent selection</p> </li> <li> <p>Service discovery in distributed agent systems</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Agent Registration] --&gt; B[Registry Database]\n    B --&gt; C[Agent Metadata]\n    C --&gt; D[Capabilities]\n    C --&gt; E[Performance Metrics]\n    C --&gt; F[Availability Status]\n\n    G[Task Request] --&gt; H[Registry Query Engine]\n    H --&gt; I[Agent Discovery]\n    I --&gt; J[Capability Matching]\n    J --&gt; K[Agent Selection]\n\n    K --&gt; L[Agent Invocation]\n    L --&gt; M[Task Execution]\n    M --&gt; N[Performance Tracking]\n    N --&gt; O[Registry Update]\n    O --&gt; B</code></pre>"},{"location":"swarms/concept/swarm_architectures/#router-architecture","title":"Router Architecture","text":"<p>Overview: Intelligently routes tasks to the most appropriate agents or architectures based on task requirements and agent capabilities.</p> <p>Use Cases: - Dynamic task routing</p> <ul> <li> <p>Adaptive architecture selection</p> </li> <li> <p>Optimized agent allocation</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Incoming Task] --&gt; B[Router Analysis]\n    B --&gt; C[Task Classification]\n    C --&gt; D[Agent Capability Matching]\n\n    D --&gt; E[Route to Sequential]\n    D --&gt; F[Route to Concurrent]\n    D --&gt; G[Route to Hierarchical]\n    D --&gt; H[Route to Specialist Agent]\n\n    E --&gt; I[Execute Architecture]\n    F --&gt; I\n    G --&gt; I\n    H --&gt; I\n\n    I --&gt; J[Collect Results]\n    J --&gt; K[Return Output]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#heavy-architecture","title":"Heavy Architecture","text":"<p>Overview: High-performance architecture designed for handling intensive computational tasks with multiple agents working on resource-heavy operations.</p> <p>Use Cases: - Large-scale data processing</p> <ul> <li> <p>Intensive computational workflows</p> </li> <li> <p>High-throughput task execution</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Resource Manager] --&gt; B[Load Balancer]\n    B --&gt; C[Heavy Agent Pool]\n\n    C --&gt; D[Compute Agent 1]\n    C --&gt; E[Compute Agent 2]\n    C --&gt; F[Compute Agent N]\n\n    D --&gt; G[Resource Monitor]\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Performance Optimizer]\n    H --&gt; I[Result Aggregator]\n    I --&gt; J[Final Output]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#deep-research-architecture","title":"Deep Research Architecture","text":"<p>Overview: Specialized architecture for conducting comprehensive research tasks across multiple domains with iterative refinement and cross-validation.</p> <p>Use Cases: - Academic research projects</p> <ul> <li> <p>Market analysis and intelligence</p> </li> <li> <p>Comprehensive data investigation</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Research Query] --&gt; B[Research Planner]\n    B --&gt; C[Domain Analysis]\n    C --&gt; D[Research Agent 1]\n    C --&gt; E[Research Agent 2]\n    C --&gt; F[Research Agent N]\n\n    D --&gt; G[Initial Findings]\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Cross-Validation]\n    H --&gt; I[Refinement Loop]\n    I --&gt; J[Synthesis Agent]\n    J --&gt; K[Comprehensive Report]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#de-hallucination-architecture","title":"De-Hallucination Architecture","text":"<p>Overview: Architecture specifically designed to reduce and eliminate hallucinations in AI outputs through consensus mechanisms and fact-checking protocols.</p> <p>Use Cases: - Fact-checking and verification</p> <ul> <li> <p>Content validation</p> </li> <li> <p>Reliable information generation</p> </li> </ul> <pre><code>graph TD\n    A[Input Query] --&gt; B[Primary Agent]\n    B --&gt; C[Initial Response]\n    C --&gt; D[Validation Layer]\n\n    D --&gt; E[Fact-Check Agent 1]\n    D --&gt; F[Fact-Check Agent 2]\n    D --&gt; G[Fact-Check Agent 3]\n\n    E --&gt; H[Consensus Engine]\n    F --&gt; H\n    G --&gt; H\n\n    H --&gt; I[Confidence Score]\n    I --&gt; J{Score &gt; Threshold?}\n    J --&gt;|Yes| K[Validated Output]\n    J --&gt;|No| L[Request Refinement]\n    L --&gt; B</code></pre>"},{"location":"swarms/concept/swarm_architectures/#council-as-judge","title":"Council as Judge","text":"<p>Overview: Multiple agents act as a council to evaluate, judge, and validate outputs or decisions through collaborative assessment.</p> <p>Use Cases: - Quality assessment and validation</p> <ul> <li> <p>Decision validation processes</p> </li> <li> <p>Peer review systems</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Submission] --&gt; B[Council Formation]\n    B --&gt; C[Judge Agent 1]\n    B --&gt; D[Judge Agent 2]\n    B --&gt; E[Judge Agent 3]\n    B --&gt; F[Judge Agent N]\n\n    C --&gt; G[Individual Assessment]\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Scoring System]\n    H --&gt; I[Weighted Voting]\n    I --&gt; J[Final Judgment]\n    J --&gt; K[Feedback &amp; Recommendations]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#malt-architecture","title":"MALT Architecture","text":"<p>Overview: Specialized architecture for complex language processing tasks that require coordination between multiple language-focused agents.</p> <p>Use Cases: - Natural language processing pipelines</p> <ul> <li> <p>Translation and localization</p> </li> <li> <p>Content generation and editing</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Language Task] --&gt; B[Task Analyzer]\n    B --&gt; C[Language Router]\n\n    C --&gt; D[Grammar Agent]\n    C --&gt; E[Semantics Agent]\n    C --&gt; F[Style Agent]\n    C --&gt; G[Context Agent]\n\n    D --&gt; H[Language Processor]\n    E --&gt; H\n    F --&gt; H\n    G --&gt; H\n\n    H --&gt; I[Quality Controller]\n    I --&gt; J[Output Formatter]\n    J --&gt; K[Final Language Output]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#majority-voting","title":"Majority Voting","text":"<p>Overview: Agents vote on decisions with the majority determining the final outcome, providing democratic decision-making and error reduction through consensus.</p> <p>Use Cases: - Democratic decision-making processes</p> <ul> <li> <p>Consensus building</p> </li> <li> <p>Error reduction through voting</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Decision Request] --&gt; B[Voting Coordinator]\n    B --&gt; C[Voting Pool]\n\n    C --&gt; D[Voter Agent 1]\n    C --&gt; E[Voter Agent 2]\n    C --&gt; F[Voter Agent 3]\n    C --&gt; G[Voter Agent N]\n\n    D --&gt; H[Vote Collection]\n    E --&gt; H\n    F --&gt; H\n    G --&gt; H\n\n    H --&gt; I[Vote Counter]\n    I --&gt; J[Majority Calculator]\n    J --&gt; K[Final Decision]\n    K --&gt; L[Decision Rationale]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#auto-builder","title":"Auto-Builder","text":"<p>Overview: Automatically constructs and configures multi-agent systems based on requirements, enabling dynamic system creation and adaptation.</p> <p>Use Cases: - Dynamic system creation</p> <ul> <li> <p>Adaptive architectures</p> </li> <li> <p>Rapid prototyping of multi-agent systems</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Requirements Input] --&gt; B[System Analyzer]\n    B --&gt; C[Architecture Selector]\n    C --&gt; D[Agent Configuration]\n\n    D --&gt; E[Agent Builder 1]\n    D --&gt; F[Agent Builder 2]\n    D --&gt; G[Agent Builder N]\n\n    E --&gt; H[System Assembler]\n    F --&gt; H\n    G --&gt; H\n\n    H --&gt; I[Configuration Validator]\n    I --&gt; J[System Deployment]\n    J --&gt; K[Performance Monitor]\n    K --&gt; L[Adaptive Optimizer]</code></pre>"},{"location":"swarms/concept/swarm_architectures/#hybrid-hierarchical-cluster","title":"Hybrid Hierarchical Cluster","text":"<p>Overview: Combines hierarchical and peer-to-peer communication patterns for complex workflows that require both centralized coordination and distributed collaboration.</p> <p>Use Cases: - Complex enterprise workflows</p> <ul> <li> <p>Multi-department coordination</p> </li> <li> <p>Hybrid organizational structures</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Central Coordinator] --&gt; B[Cluster 1 Leader]\n    A --&gt; C[Cluster 2 Leader]\n    A --&gt; D[Cluster 3 Leader]\n\n    B --&gt; E[Peer Agent 1.1]\n    B --&gt; F[Peer Agent 1.2]\n    E &lt;--&gt; F\n\n    C --&gt; G[Peer Agent 2.1]\n    C --&gt; H[Peer Agent 2.2]\n    G &lt;--&gt; H\n\n    D --&gt; I[Peer Agent 3.1]\n    D --&gt; J[Peer Agent 3.2]\n    I &lt;--&gt; J\n\n    E --&gt; K[Inter-Cluster Communication]\n    G --&gt; K\n    I --&gt; K\n    K --&gt; A</code></pre>"},{"location":"swarms/concept/swarm_architectures/#election-architecture","title":"Election Architecture","text":"<p>Overview: Agents participate in democratic voting processes to select leaders or make collective decisions.</p> <p>Use Cases: - Democratic governance</p> <ul> <li> <p>Consensus building</p> </li> <li> <p>Leadership selection</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Voting Process] --&gt; B[Candidate Agents]\n    B --&gt; C[Voting Mechanism]\n\n    C --&gt; D[Voter Agent 1]\n    C --&gt; E[Voter Agent 2]\n    C --&gt; F[Voter Agent N]\n\n    D --&gt; G[Vote Collection]\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H[Vote Counting]\n    H --&gt; I[Majority Check]\n    I --&gt; J{Majority?}\n    J --&gt;|Yes| K[Leader Selected]\n    J --&gt;|No| L[Continue Voting]\n    L --&gt; B</code></pre>"},{"location":"swarms/concept/swarm_architectures/#dynamic-conversational-architecture","title":"Dynamic Conversational Architecture","text":"<p>Overview: Adaptive conversation management with dynamic agent selection and interaction patterns.</p> <p>Use Cases: - Adaptive chatbots</p> <ul> <li> <p>Dynamic customer service</p> </li> <li> <p>Contextual conversations</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Conversation Manager] --&gt; B[Speaker Selection Logic]\n    B --&gt; C[Priority Speaker]\n    B --&gt; D[Random Speaker]\n    B --&gt; E[Round Robin Speaker]\n\n    C --&gt; F[Active Discussion]\n    D --&gt; F\n    E --&gt; F\n\n    F --&gt; G[Agent Pool]\n    G --&gt; H[Agent 1]\n    G --&gt; I[Agent 2]\n    G --&gt; J[Agent N]\n\n    H --&gt; K[Dynamic Response]\n    I --&gt; K\n    J --&gt; K\n    K --&gt; A</code></pre>"},{"location":"swarms/concept/swarm_architectures/#tree-architecture","title":"Tree Architecture","text":"<p>Overview: Hierarchical tree structure for organizing agents in parent-child relationships.</p> <p>Use Cases: - Organizational hierarchies</p> <ul> <li> <p>Decision trees</p> </li> <li> <p>Taxonomic classification</p> </li> </ul> <p>Learn More</p> <pre><code>graph TD\n    A[Root] --&gt; B[Child 1]\n    A --&gt; C[Child 2]\n    B --&gt; D[Grandchild 1]\n    B --&gt; E[Grandchild 2]\n    C --&gt; F[Grandchild 3]\n    C --&gt; G[Grandchild 4]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/","title":"Understanding the Swarms Ecosystem","text":"<p>The Swarms Ecosystem is a powerful suite of tools and frameworks designed to help developers build, deploy, and manage swarms of autonomous agents. This ecosystem covers various domains, from Large Language Models (LLMs) to IoT data integration, providing a comprehensive platform for automation and scalability. Below, we\u2019ll explore the key components and how they contribute to this groundbreaking ecosystem.</p>"},{"location":"swarms/concept/swarm_ecosystem/#1-swarms-framework","title":"1. Swarms Framework","text":"<p>The Swarms Framework is a Python-based toolkit that simplifies the creation, orchestration, and scaling of swarms of agents. Whether you are dealing with marketing, accounting, or data analysis, the Swarms Framework allows developers to automate complex workflows efficiently.</p> <pre><code>graph TD;\n    SF[Swarms Framework] --&gt; Core[Swarms Core]\n    SF --&gt; JS[Swarms JS]\n    SF --&gt; Memory[Swarms Memory]\n    SF --&gt; Evals[Swarms Evals]\n    SF --&gt; Zero[Swarms Zero]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#2-swarms-cloud","title":"2. Swarms-Cloud","text":"<p>Swarms-Cloud is a cloud-based solution that enables you to deploy your agents with enterprise-level guarantees. It provides 99% uptime, infinite scalability, and self-healing capabilities, making it ideal for mission-critical operations.</p> <pre><code>graph TD;\n    SC[Swarms-Cloud] --&gt; Uptime[99% Uptime]\n    SC --&gt; Scale[Infinite Scalability]\n    SC --&gt; Healing[Self-Healing]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#3-swarms-models","title":"3. Swarms-Models","text":"<p>Swarms-Models offer a seamless interface to leading LLM providers like OpenAI, Anthropic, and Ollama. It allows developers to tap into cutting-edge natural language understanding for their agents.</p> <pre><code>graph TD;\n    SM[Swarms-Models] --&gt; OpenAI[OpenAI API]\n    SM --&gt; Anthropic[Anthropic API]\n    SM --&gt; Ollama[Ollama API]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#4-agentparse","title":"4. AgentParse","text":"<p>AgentParse is a high-performance library for mapping structured data like JSON, YAML, CSV, and Pydantic models into formats understandable by agents. This ensures fast, seamless data ingestion.</p> <pre><code>graph TD;\n    AP[AgentParse] --&gt; JSON[JSON Parsing]\n    AP --&gt; YAML[YAML Parsing]\n    AP --&gt; CSV[CSV Parsing]\n    AP --&gt; Pydantic[Pydantic Model Parsing]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#5-swarms-platform","title":"5. Swarms-Platform","text":"<p>The Swarms-Platform is a marketplace where developers can find, buy, and sell autonomous agents. It enables the rapid scaling of agent ecosystems by leveraging ready-made solutions.</p> <pre><code>graph TD;\n    SP[Swarms-Platform] --&gt; Discover[Discover Agents]\n    SP --&gt; Buy[Buy Agents]\n    SP --&gt; Sell[Sell Agents]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#extending-the-ecosystem-swarms-core-js-and-more","title":"Extending the Ecosystem: Swarms Core, JS, and More","text":"<p>In addition to the core components, the Swarms Ecosystem offers several other powerful packages:</p> <ul> <li>Swarms Core: Built in Rust, Swarms Core handles concurrency, multi-threading, and execution strategies.</li> <li>Swarms JS: Allows JavaScript-based orchestration of multi-agent systems.</li> <li>Swarms Memory: Provides Retrieval Augmented Generation (RAG) systems for long-term memory in agents.</li> <li>Swarms Evals: Used for evaluating the performance of swarms of agents.</li> <li>Swarms Zero: An RPC-based enterprise-grade automation framework.</li> </ul> <pre><code>graph TD;\n    SC[Swarms Core] --&gt; Rust[Rust for Performance]\n    JS[Swarms JS] --&gt; MultiAgent[Multi-Agent Orchestration]\n    Memory[Swarms Memory] --&gt; RAG[Retrieval Augmented Generation]\n    Evals[Swarms Evals] --&gt; Evaluation[Agent Evaluations]\n    Zero[Swarms Zero] --&gt; Automation[Enterprise Automation]</code></pre>"},{"location":"swarms/concept/swarm_ecosystem/#conclusion","title":"Conclusion","text":"<p>The Swarms Ecosystem is a comprehensive, flexible, and scalable platform for managing and deploying autonomous agents. Whether you\u2019re working with LLMs, IoT data, or building new models, the ecosystem provides the tools necessary to simplify automation at scale.</p> <p>Start exploring the possibilities by checking out the Swarms Ecosystem GitHub repository and join our growing community of developers and innovators.</p>"},{"location":"swarms/concept/vision/","title":"Swarms \u2013 The Ultimate Multi-Agent LLM Framework for Developers","text":"<p>Swarms aims to be the definitive and most reliable multi-agent LLM framework, offering developers the tools to automate business operations effortlessly. It provides a vast array of swarm architectures, seamless third-party integration, and unparalleled ease of use. With Swarms, developers can orchestrate intelligent, scalable agent ecosystems that can automate complex business processes.</p>"},{"location":"swarms/concept/vision/#key-features-for-developers","title":"Key Features for Developers:","text":"<ol> <li>Architectural Flexibility \u2013 Choose from a wide variety of pre-built swarm architectures or build custom agent frameworks. Swarms allows developers to define flexible workflows for specific use cases, providing both sequential and concurrent task execution.</li> <li>Third-Party Integration \u2013 Swarms makes it simple to integrate with external APIs, databases, and other platforms. By supporting extreme integration capabilities, it ensures your agents work effortlessly within any workflow.</li> <li>Developer-Centric APIs \u2013 The Swarms API is built with developers in mind, offering an intuitive, simple-to-use interface. Developers can orchestrate agent swarms with minimal code and maximum control.</li> </ol>"},{"location":"swarms/concept/vision/#code-examples","title":"Code Examples","text":""},{"location":"swarms/concept/vision/#1-basic-financial-analysis-agent","title":"1. Basic Financial Analysis Agent:","text":"<p>This example demonstrates a simple financial agent setup that responds to financial questions, such as establishing a ROTH IRA, using OpenAI's GPT-based model.</p> <pre><code>from swarms.structs.agent import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT\n\n# Initialize the Financial Analysis Agent with GPT-4o-mini model\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"finance_agent.json\",\n    user_name=\"swarms_corp\",\n    retry_attempts=1,\n    context_length=200000,\n    return_step_meta=False,\n)\n\n# Example task for the agent\nout = agent.run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\"\n)\n\n# Output the result\nprint(out)\n</code></pre>"},{"location":"swarms/concept/vision/#2-agent-orchestration-with-agentrearrange","title":"2. Agent Orchestration with AgentRearrange:","text":"<p>The following example showcases how to use the <code>AgentRearrange</code> class to manage a multi-agent system. It sets up a director agent to orchestrate two workers\u2014one to generate a transcript and another to summarize it.</p> <pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.rearrange import AgentRearrange  \n\n# Initialize the Director agent using Anthropic model via model_name\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"You are a Director agent. Your role is to coordinate and direct tasks for worker agents. Break down complex tasks into clear, actionable steps.\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    dashboard=False,\n    streaming_on=False, \n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n# Worker 1: transcript generation\nworker1 = Agent(\n    agent_name=\"Worker1\",\n    system_prompt=\"You are a content creator agent. Your role is to generate detailed, engaging transcripts for YouTube videos about technical topics. Focus on clarity and educational value.\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    dashboard=False,\n    streaming_on=False,  \n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"worker1.json\",\n)\n\n# Worker 2: summarization\nworker2 = Agent(\n    agent_name=\"Worker2\",\n    system_prompt=\"You are a summarization agent. Your role is to create concise, clear summaries of technical content while maintaining key information and insights.\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    dashboard=False,\n    streaming_on=False,  \n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"worker2.json\",\n)\n\n# Orchestrate the agents in sequence\nagents = [director, worker1, worker2]\nflow = \"Director -&gt; Worker1 -&gt; Worker2\"\nagent_system = AgentRearrange(agents=agents, flow=flow)\n\n# Run the workflow\noutput = agent_system.run(\n    \"Create a format to express and communicate swarms of LLMs in a structured manner for YouTube\"\n)\nprint(output)\n</code></pre>"},{"location":"swarms/concept/vision/#1-basic-agent-flow","title":"1. Basic Agent Flow:","text":"<p>Here\u2019s a visual representation of the basic workflow using Mermaid to display the sequential flow between agents.</p> <pre><code>flowchart TD\n    A[Director] --&gt; B[Worker 1: Generate Transcript]\n    B --&gt; C[Worker 2: Summarize Transcript]</code></pre> <p>In this diagram: - The Director agent assigns tasks. - Worker 1 generates a transcript for a YouTube video. - Worker 2 summarizes the transcript.</p>"},{"location":"swarms/concept/vision/#2-sequential-agent-flow","title":"2. Sequential Agent Flow:","text":"<p>This diagram showcases a sequential agent setup where one agent completes its task before the next agent starts its task.</p> <pre><code>flowchart TD\n    A[Director] --&gt; B[Worker 1: Generate Transcript]\n    B --&gt; C[Worker 2: Summarize Transcript]\n    C --&gt; D[Worker 3: Finalize]</code></pre> <p>In this setup:</p> <ul> <li> <p>The Director agent assigns tasks to Worker 1, which generates a transcript for a YouTube video.</p> </li> <li> <p>Worker 1 completes its task before Worker 2 starts summarizing the transcript.</p> </li> <li> <p>Worker 2 completes its task before Worker 3 finalizes the process.</p> </li> </ul>"},{"location":"swarms/concept/vision/#why-developers-should-choose-swarms","title":"Why Developers Should Choose Swarms:","text":"<p>Swarms is designed with flexibility at its core. Developers can create custom architectures and workflows, enabling extreme control over how agents interact with each other. Whether it\u2019s a linear process or a complex mesh of agent communications, Swarms handles it efficiently.</p> <p>With support for extreme third-party integration, Swarms makes it easy for developers to plug into external systems, such as APIs or internal databases. This allows agents to act on live data, process external inputs, and execute actions in real time, making it a powerful tool for real-world applications.</p> <p>Swarms abstracts the complexity of managing multiple agents with orchestration tools like <code>AgentRearrange</code>. Developers can define workflows that execute tasks concurrently or sequentially, depending on the problem at hand. This makes it easy to build and maintain large-scale automation systems.</p>"},{"location":"swarms/concept/vision/#conclusion","title":"Conclusion:","text":"<p>Swarms is not just another multi-agent framework; it's built specifically for developers who need powerful tools to automate complex, large-scale business operations. With flexible architecture, deep integration capabilities, and developer-friendly APIs, Swarms is the ultimate solution for businesses looking to streamline operations and future-proof their workflows.</p>"},{"location":"swarms/concept/why/","title":"Benefits","text":"<p>Maximizing Enterprise Automation: Overcoming the Limitations of Individual AI Agents Through Multi-Agent Collaboration</p> <p>In today's rapidly evolving business landscape, enterprises are constantly seeking innovative solutions to enhance efficiency, reduce operational costs, and maintain a competitive edge. Automation has emerged as a critical strategy for achieving these objectives, with artificial intelligence (AI) playing a pivotal role. AI agents, particularly those powered by advanced machine learning models, have shown immense potential in automating a variety of tasks. However, individual AI agents come with inherent limitations that hinder their ability to fully automate complex enterprise operations at scale.</p> <p>This essay dives into the specific limitations of individual AI agents\u2014context window limits, hallucination, single-task execution, lack of collaboration, lack of accuracy, and slow processing speed\u2014and explores how multi-agent collaboration can overcome these challenges. By tailoring our discussion to the needs of enterprises aiming to automate operations at scale, we highlight practical strategies and frameworks that can be adopted to unlock the full potential of AI-driven automation.</p>"},{"location":"swarms/concept/why/#part-1-the-limitations-of-individual-ai-agents","title":"Part 1: The Limitations of Individual AI Agents","text":"<p>Despite significant advancements, individual AI agents face several obstacles that limit their effectiveness in enterprise automation. Understanding these limitations is crucial for organizations aiming to implement AI solutions that are both efficient and scalable.</p>"},{"location":"swarms/concept/why/#1-context-window-limits","title":"1. Context Window Limits","text":"<p>Explanation</p> <p>AI agents, especially those based on language models like GPT-3 or GPT-4, operate within a fixed context window. This means they can only process and consider a limited amount of information (tokens) at a time. In practical terms, this restricts the agent's ability to handle large documents, long conversations, or complex datasets that exceed their context window.</p> <p>Impact on Enterprises</p> <p>For enterprises, this limitation poses significant challenges. Business operations often involve processing extensive documents such as legal contracts, technical manuals, or large datasets. An AI agent with a limited context window may miss crucial information located outside its immediate context, leading to incomplete analyses or erroneous conclusions.</p> <pre><code>graph LR\n    subgraph \"Context Window Limit\"\n        Input[Large Document]\n        Agent[AI Agent]\n        Output[Partial Understanding]\n        Input -- Truncated Data --&gt; Agent\n        Agent -- Generates --&gt; Output\n    end</code></pre> <p>An AI agent processes only a portion of a large document due to context window limits, resulting in partial understanding.</p>"},{"location":"swarms/concept/why/#2-hallucination","title":"2. Hallucination","text":"<p>Explanation</p> <p>Hallucination refers to the tendency of AI agents to produce outputs that are not grounded in the input data or reality. They may generate plausible-sounding but incorrect or nonsensical information, especially when uncertain or when the input data is ambiguous.</p> <p>Impact on Enterprises</p> <p>In enterprise settings, hallucinations can lead to misinformation, poor decision-making, and a lack of trust in AI systems. For instance, if an AI agent generates incorrect financial forecasts or misinterprets regulatory requirements, the consequences could be financially damaging and legally problematic.</p> <pre><code>graph TD\n    Input[Ambiguous Data]\n    Agent[AI Agent]\n    Output[Incorrect Information]\n    Input --&gt; Agent\n    Agent --&gt; Output</code></pre> <p>An AI agent generates incorrect information (hallucination) when processing ambiguous data.</p>"},{"location":"swarms/concept/why/#3-single-task-execution","title":"3. Single Task Execution","text":"<p>Explanation</p> <p>Many AI agents are designed to excel at a specific task or a narrow set of functions. They lack the flexibility to perform multiple tasks simultaneously or adapt to new tasks without significant reconfiguration or retraining.</p> <p>Impact on Enterprises</p> <p>Enterprises require systems that can handle a variety of tasks, often concurrently. Relying on single-task agents necessitates deploying multiple separate agents, which can lead to integration challenges, increased complexity, and higher maintenance costs.</p> <pre><code>graph LR\n    TaskA[Task A] --&gt; AgentA[Agent A]\n    TaskB[Task B] --&gt; AgentB[Agent B]\n    AgentA --&gt; OutputA[Result A]\n    AgentB --&gt; OutputB[Result B]</code></pre> <p>Separate agents handle different tasks independently, lacking integration.</p>"},{"location":"swarms/concept/why/#4-lack-of-collaboration","title":"4. Lack of Collaboration","text":"<p>Explanation</p> <p>Individual AI agents typically operate in isolation, without the ability to communicate or collaborate with other agents. This siloed operation prevents them from sharing insights, learning from each other, or coordinating actions to achieve a common goal.</p> <p>Impact on Enterprises</p> <p>Complex enterprise operations often require coordinated efforts across different functions and departments. The inability of AI agents to collaborate limits their effectiveness in such environments, leading to disjointed processes and suboptimal outcomes.</p> <pre><code>graph LR\n    Agent1[Agent 1]\n    Agent2[Agent 2]\n    Agent3[Agent 3]\n    Agent1 --&gt;|No Communication| Agent2\n    Agent2 --&gt;|No Communication| Agent3</code></pre> <p>Agents operate without collaboration, resulting in isolated efforts.</p>"},{"location":"swarms/concept/why/#5-lack-of-accuracy","title":"5. Lack of Accuracy","text":"<p>Explanation</p> <p>AI agents may produce inaccurate results due to limitations in their training data, algorithms, or inability to fully understand complex inputs. Factors such as data bias, overfitting, or lack of domain-specific knowledge contribute to this inaccuracy.</p> <p>Impact on Enterprises</p> <p>Inaccurate outputs can have serious ramifications for businesses, including flawed strategic decisions, customer dissatisfaction, and compliance risks. High accuracy is essential for tasks like financial analysis, customer service, and regulatory compliance.</p> <pre><code>graph TD\n    Input[Complex Data]\n    Agent[AI Agent]\n    Output[Inaccurate Result]\n    Input --&gt; Agent\n    Agent --&gt; Output</code></pre> <p>An AI agent produces an inaccurate result when handling complex data.</p>"},{"location":"swarms/concept/why/#6-slow-processing-speed","title":"6. Slow Processing Speed","text":"<p>Explanation</p> <p>Some AI agents require significant computational resources and time to process data and generate outputs. Factors like model complexity, inefficient algorithms, or hardware limitations can contribute to slow processing speeds.</p> <p>Impact on Enterprises</p> <p>Slow processing impedes real-time decision-making and responsiveness. In fast-paced business environments, delays can lead to missed opportunities, reduced productivity, and competitive disadvantages.</p> <pre><code>graph TD\n    Input[Data]\n    Agent[AI Agent]\n    Delay[Processing Delay]\n    Output[Delayed Response]\n    Input --&gt; Agent\n    Agent --&gt; Delay\n    Delay --&gt; Output</code></pre> <p>An AI agent's slow processing leads to delayed responses.</p>"},{"location":"swarms/concept/why/#part-2-overcoming-limitations-through-multi-agent-collaboration","title":"Part 2: Overcoming Limitations Through Multi-Agent Collaboration","text":"<p>To address the challenges posed by individual AI agents, enterprises can adopt a multi-agent collaboration approach. By orchestrating multiple agents with complementary skills and functionalities, organizations can enhance performance, accuracy, and scalability in their automation efforts.</p>"},{"location":"swarms/concept/why/#1-extending-context-window-through-distributed-processing","title":"1. Extending Context Window Through Distributed Processing","text":"<p>Solution</p> <p>By dividing large inputs into smaller segments, multiple agents can process different parts simultaneously. A coordinating agent can then aggregate the results to form a comprehensive understanding.</p> <p>Implementation in Enterprises</p> <ul> <li>Document Analysis: For lengthy legal contracts, agents can each analyze specific sections, and a master agent can compile insights and ensure consistency.</li> <li>Customer Interaction History: In customer service, agents can handle different segments of a customer's history to provide personalized support.</li> </ul> <pre><code>graph LR\n    Input[Large Document]\n    Splitter[Splitter Agent]\n    A1[Agent 1]\n    A2[Agent 2]\n    A3[Agent 3]\n    Aggregator[Aggregator Agent]\n    Output[Comprehensive Analysis]\n    Input --&gt; Splitter\n    Splitter --&gt; A1\n    Splitter --&gt; A2\n    Splitter --&gt; A3\n    A1 --&gt; Aggregator\n    A2 --&gt; Aggregator\n    A3 --&gt; Aggregator\n    Aggregator --&gt; Output</code></pre> <p>Multiple agents process segments of a large document, and results are aggregated.</p>"},{"location":"swarms/concept/why/#2-reducing-hallucination-through-cross-verification","title":"2. Reducing Hallucination Through Cross-Verification","text":"<p>Solution</p> <p>Agents can verify each other's outputs by cross-referencing information and flagging inconsistencies. Implementing consensus mechanisms ensures that only accurate information is accepted.</p> <p>Implementation in Enterprises</p> <ul> <li>Data Validation: In data entry automation, one agent inputs data while another validates it against source documents.</li> <li>Decision Support Systems: Multiple agents evaluate options and agree on recommendations, reducing the risk of incorrect advice.</li> </ul> <pre><code>graph TD\n    A[Agent's Output]\n    V1[Verifier Agent 1]\n    V2[Verifier Agent 2]\n    Consensus[Consensus Mechanism]\n    Output[Validated Output]\n    A --&gt; V1\n    A --&gt; V2\n    V1 &amp; V2 --&gt; Consensus\n    Consensus --&gt; Output</code></pre> <p>Agents verify outputs through cross-verification and consensus.</p>"},{"location":"swarms/concept/why/#3-enhancing-multi-tasking-through-specialized-agents","title":"3. Enhancing Multi-Tasking Through Specialized Agents","text":"<p>Solution</p> <p>Deploy specialized agents for different tasks and enable them to work concurrently. An orchestrator agent manages task allocation and workflow integration.</p> <p>Implementation in Enterprises</p> <ul> <li>Automated Workflows: In supply chain management, one agent handles inventory analysis, another manages logistics, and a third forecasts demand.</li> <li>IT Operations: In IT automation, separate agents manage network monitoring, security scanning, and system updates.</li> </ul> <pre><code>graph LR\n    Task[Complex Task]\n    Orchestrator[Orchestrator Agent]\n    AgentA[Specialist Agent A]\n    AgentB[Specialist Agent B]\n    AgentC[Specialist Agent C]\n    Output[Integrated Solution]\n    Task --&gt; Orchestrator\n    Orchestrator --&gt; AgentA\n    Orchestrator --&gt; AgentB\n    Orchestrator --&gt; AgentC\n    AgentA &amp; AgentB &amp; AgentC --&gt; Orchestrator\n    Orchestrator --&gt; Output</code></pre> <p>Specialized agents handle different tasks under the management of an orchestrator agent.</p>"},{"location":"swarms/concept/why/#4-facilitating-collaboration-through-communication-protocols","title":"4. Facilitating Collaboration Through Communication Protocols","text":"<p>Solution</p> <p>Implement communication protocols that allow agents to share information, request assistance, and coordinate actions. This fosters a collaborative environment where agents complement each other's capabilities.</p> <p>Implementation in Enterprises</p> <ul> <li>Customer Service: Chatbots and virtual assistants share customer data to provide seamless support across channels.</li> <li>Project Management: Agents managing different aspects of a project (scheduling, resource allocation, risk assessment) coordinate to keep the project on track.</li> </ul> <pre><code>graph LR\n    Agent1[Agent 1]\n    Agent2[Agent 2]\n    Agent3[Agent 3]\n    Agent1 &lt;--&gt; Agent2\n    Agent2 &lt;--&gt; Agent3\n    Agent3 &lt;--&gt; Agent1\n    Output[Collaborative Outcome]</code></pre> <p>Agents communicate and collaborate to achieve a common goal.</p>"},{"location":"swarms/concept/why/#5-improving-accuracy-through-ensemble-learning","title":"5. Improving Accuracy Through Ensemble Learning","text":"<p>Solution</p> <p>Use ensemble methods where multiple agents provide predictions or analyses, and a meta-agent combines these to produce a more accurate result.</p> <p>Implementation in Enterprises</p> <ul> <li>Risk Assessment: Different agents assess risks from various perspectives (financial, operational, compliance), and their insights are combined.</li> <li>Market Analysis: Agents analyze market trends, customer behavior, and competitor actions, leading to a comprehensive market strategy.</li> </ul> <pre><code>graph TD\n    AgentA[Agent A Output]\n    AgentB[Agent B Output]\n    AgentC[Agent C Output]\n    MetaAgent[Meta-Agent]\n    Output[Enhanced Accuracy]\n    AgentA --&gt; MetaAgent\n    AgentB --&gt; MetaAgent\n    AgentC --&gt; MetaAgent\n    MetaAgent --&gt; Output</code></pre> <p>Meta-agent combines outputs from multiple agents to improve accuracy.</p>"},{"location":"swarms/concept/why/#6-increasing-processing-speed-through-parallelization","title":"6. Increasing Processing Speed Through Parallelization","text":"<p>Solution</p> <p>By distributing workloads among multiple agents operating in parallel, processing times are significantly reduced, enabling real-time responses.</p> <p>Implementation in Enterprises</p> <ul> <li>Data Processing: Large datasets are partitioned and processed simultaneously by different agents.</li> <li>Customer Requests: Multiple customer inquiries are handled at once by separate agents, improving response times.</li> </ul> <pre><code>graph LR\n    Data[Large Dataset]\n    Agent1[Agent 1]\n    Agent2[Agent 2]\n    Agent3[Agent 3]\n    Output[Processed Data]\n    Data --&gt; Agent1\n    Data --&gt; Agent2\n    Data --&gt; Agent3\n    Agent1 &amp; Agent2 &amp; Agent3 --&gt; Output</code></pre> <p>Parallel processing by agents leads to faster completion times.</p>"},{"location":"swarms/concept/why/#part-3-tailoring-multi-agent-systems-for-enterprise-automation-at-scale","title":"Part 3: Tailoring Multi-Agent Systems for Enterprise Automation at Scale","text":"<p>Implementing multi-agent systems in an enterprise context requires careful planning and consideration of organizational needs, technical infrastructure, and strategic goals. Below are key considerations and steps for enterprises aiming to adopt multi-agent collaboration for automation at scale.</p>"},{"location":"swarms/concept/why/#1-identifying-automation-opportunities","title":"1. Identifying Automation Opportunities","text":"<p>Enterprises should start by identifying processes and tasks that are suitable for automation through multi-agent systems. Prioritize areas where:</p> <ul> <li>Complexity Requires Specialization: Tasks that involve multiple steps or require diverse expertise.</li> <li>Scalability Is Essential: Operations that need to handle increasing workloads efficiently.</li> <li>Speed and Accuracy Are Critical: Processes where delays or errors have significant impacts.</li> </ul>"},{"location":"swarms/concept/why/#2-designing-the-multi-agent-architecture","title":"2. Designing the Multi-Agent Architecture","text":"<p>Develop a robust architecture that defines how agents will interact, communicate, and collaborate. Key components include:</p> <ul> <li>Agent Specialization: Define the roles and responsibilities of each agent.</li> <li>Communication Protocols: Establish standards for information exchange.</li> <li>Coordination Mechanisms: Implement orchestrator agents or decentralized coordination strategies.</li> <li>Integration with Existing Systems: Ensure compatibility with current IT infrastructure.</li> </ul>"},{"location":"swarms/concept/why/#3-ensuring-data-security-and-compliance","title":"3. Ensuring Data Security and Compliance","text":"<p>Data security is paramount when agents handle sensitive enterprise information. Implement measures such as:</p> <ul> <li>Encryption: Secure communication channels between agents.</li> <li>Access Control: Define permissions for data access and agent capabilities.</li> <li>Compliance Checks: Ensure the system adheres to relevant regulations (e.g., GDPR, HIPAA).</li> </ul>"},{"location":"swarms/concept/why/#4-monitoring-and-performance-management","title":"4. Monitoring and Performance Management","text":"<p>Establish monitoring tools to track agent performance, system health, and outcomes. Key metrics may include:</p> <ul> <li>Processing Speed: Measure how quickly tasks are completed.</li> <li>Accuracy Rates: Track the correctness of outputs.</li> <li>Resource Utilization: Monitor computational resources used by agents.</li> <li>Error Logs: Identify and address failures or exceptions.</li> </ul>"},{"location":"swarms/concept/why/#5-scaling-strategies","title":"5. Scaling Strategies","text":"<p>Develop strategies for scaling the system as enterprise needs grow, including:</p> <ul> <li>Dynamic Resource Allocation: Adjust computational resources based on workload.</li> <li>Agent Addition or Removal: Add new agents or deactivate others to meet changing demands.</li> <li>Load Balancing: Distribute tasks evenly to prevent bottlenecks.</li> </ul>"},{"location":"swarms/concept/why/#6-continuous-improvement","title":"6. Continuous Improvement","text":"<p>Implement feedback loops for ongoing enhancement of the multi-agent system:</p> <ul> <li>User Feedback: Gather input from users interacting with the system.</li> <li>Performance Analytics: Analyze data to identify areas for optimization.</li> <li>Updating Agents: Regularly update agent algorithms and knowledge bases.</li> </ul>"},{"location":"swarms/concept/why/#part-4-case-studies-and-real-world-applications","title":"Part 4: Case Studies and Real-World Applications","text":"<p>To illustrate the practical benefits of multi-agent collaboration in enterprise automation, let's explore several real-world examples.</p>"},{"location":"swarms/concept/why/#case-study-1-financial-services-automation","title":"Case Study 1: Financial Services Automation","text":"<p>Challenge</p> <p>A financial institution needs to process large volumes of loan applications, requiring data verification, risk assessment, compliance checks, and decision-making.</p> <p>Solution</p> <ul> <li>Specialized Agents:</li> <li>Data Extraction Agent: Extracts data from application forms.</li> <li>Verification Agent: Confirms the accuracy of applicant information.</li> <li>Risk Assessment Agent: Evaluates credit risk using predictive models.</li> <li>Compliance Agent: Ensures all regulatory requirements are met.</li> <li> <p>Decision Agent: Aggregates inputs and makes approval decisions.</p> </li> <li> <p>Collaboration:</p> </li> <li>Agents communicate to share data and findings.</li> <li>The Decision Agent coordinates the workflow.</li> </ul> <p>Outcome</p> <ul> <li>Increased Processing Speed: Applications are processed in minutes instead of days.</li> <li>Improved Accuracy: Cross-verification reduces errors.</li> <li>Scalability: System handles fluctuating application volumes efficiently.</li> </ul>"},{"location":"swarms/concept/why/#case-study-2-manufacturing-supply-chain-optimization","title":"Case Study 2: Manufacturing Supply Chain Optimization","text":"<p>Challenge</p> <p>A manufacturing company wants to optimize its supply chain to reduce costs and improve delivery times.</p> <p>Solution</p> <ul> <li>Specialized Agents:</li> <li>Demand Forecasting Agent: Predicts product demand.</li> <li>Inventory Management Agent: Monitors stock levels and orders materials.</li> <li>Logistics Agent: Plans shipping routes and schedules.</li> <li> <p>Supplier Evaluation Agent: Assesses supplier performance and reliability.</p> </li> <li> <p>Collaboration:</p> </li> <li>Agents share data on demand forecasts and inventory levels.</li> <li>Logistics Agent adjusts plans based on input from other agents.</li> </ul> <p>Outcome</p> <ul> <li>Cost Reduction: Optimized inventory levels reduce holding costs.</li> <li>Efficiency Gains: Improved logistics planning enhances delivery times.</li> <li>Adaptability: System responds quickly to changes in demand or supply disruptions.</li> </ul>"},{"location":"swarms/concept/why/#case-study-3-healthcare-patient-management","title":"Case Study 3: Healthcare Patient Management","text":"<p>Challenge</p> <p>A hospital aims to improve patient care coordination, managing appointments, medical records, billing, and treatment plans.</p> <p>Solution</p> <ul> <li>Specialized Agents:</li> <li>Appointment Scheduling Agent: Manages patient appointments.</li> <li>Medical Records Agent: Updates and retrieves patient records.</li> <li>Billing Agent: Handles invoicing and insurance claims.</li> <li> <p>Treatment Planning Agent: Assists in developing patient care plans.</p> </li> <li> <p>Collaboration:</p> </li> <li>Agents coordinate to ensure seamless patient experiences.</li> <li>Data is securely shared while maintaining patient confidentiality.</li> </ul> <p>Outcome</p> <ul> <li>Enhanced Patient Care: Improved coordination leads to better treatment outcomes.</li> <li>Operational Efficiency: Administrative tasks are streamlined.</li> <li>Compliance: System adheres to healthcare regulations (e.g., HIPAA).</li> </ul>"},{"location":"swarms/concept/why/#part-5-implementing-multi-agent-systems-best-practices-for-enterprises","title":"Part 5: Implementing Multi-Agent Systems \u2013 Best Practices for Enterprises","text":"<p>For enterprises embarking on the journey of multi-agent automation, adhering to best practices ensures successful implementation.</p>"},{"location":"swarms/concept/why/#1-start-small-and-scale-gradually","title":"1. Start Small and Scale Gradually","text":"<ul> <li>Pilot Projects: Begin with a specific process or department to test the multi-agent system.</li> <li>Learn and Adapt: Use insights from initial deployments to refine the system.</li> </ul>"},{"location":"swarms/concept/why/#2-invest-in-training-and-change-management","title":"2. Invest in Training and Change Management","text":"<ul> <li>Employee Education: Train staff on interacting with and managing multi-agent systems.</li> <li>Change Management: Prepare the organization for changes in workflows and roles.</li> </ul>"},{"location":"swarms/concept/why/#3-leverage-cloud-and-edge-computing","title":"3. Leverage Cloud and Edge Computing","text":"<ul> <li>Scalable Infrastructure: Utilize cloud services for flexible resource allocation.</li> <li>Edge Computing: Deploy agents closer to data sources for faster processing.</li> </ul>"},{"location":"swarms/concept/why/#4-foster-interoperability","title":"4. Foster Interoperability","text":"<ul> <li>Standards Compliance: Use industry standards for data formats and communication protocols.</li> <li>API Integration: Ensure agents can integrate with existing enterprise applications.</li> </ul>"},{"location":"swarms/concept/why/#5-prioritize-ethical-considerations","title":"5. Prioritize Ethical Considerations","text":"<ul> <li>Transparency: Maintain clear documentation of how agents make decisions.</li> <li>Bias Mitigation: Implement strategies to prevent and correct algorithmic biases.</li> <li>Accountability: Establish protocols for human oversight and intervention.</li> </ul>"},{"location":"swarms/concept/why/#conclusion","title":"Conclusion","text":"<p>Enterprises seeking to automate operations at scale face the limitations inherent in individual AI agents. Context window limits, hallucinations, single-task execution, lack of collaboration, lack of accuracy, and slow processing speed hinder the full potential of automation efforts. Multi-agent collaboration emerges as a robust solution to these challenges, offering a pathway to enhanced efficiency, accuracy, scalability, and adaptability.</p> <p>By adopting multi-agent systems, enterprises can:</p> <ul> <li>Extend Capabilities: Overcome individual agent limitations through collective intelligence.</li> <li>Improve Outcomes: Achieve higher accuracy and faster processing by leveraging specialized agents.</li> <li>Enhance Flexibility: Adapt to changing business needs with scalable and versatile agent architectures.</li> <li>Drive Innovation: Foster a culture of continuous improvement and technological advancement.</li> </ul> <p>Implementing multi-agent systems requires thoughtful planning, adherence to best practices, and a commitment to ongoing management and optimization. Enterprises that successfully navigate this journey will position themselves at the forefront of automation, unlocking new levels of productivity and competitive advantage in an increasingly digital world.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/","title":"The Limits of Individual Agents","text":"<p>Individual agents have pushed the boundaries of what machines can learn and accomplish. However, despite their impressive capabilities, these agents face inherent limitations that can hinder their effectiveness in complex, real-world applications. This blog explores the critical constraints of individual agents, such as context window limits, hallucination, single-task threading, and lack of collaboration, and illustrates how multi-agent collaboration can address these limitations. In short,</p> <ul> <li>Context Window Limits</li> <li>Single Task Execution</li> <li>Hallucination</li> <li>No collaboration</li> </ul>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#context-window-limits","title":"Context Window Limits","text":"<p>One of the most significant constraints of individual agents, particularly in the domain of language models, is the context window limit. This limitation refers to the maximum amount of information an agent can consider at any given time. For instance, many language models can only process a fixed number of tokens (words or characters) in a single inference, restricting their ability to understand and generate responses based on longer texts. This limitation can lead to a lack of coherence in longer compositions and an inability to maintain context in extended conversations or documents.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#hallucination","title":"Hallucination","text":"<p>Hallucination in AI refers to the phenomenon where an agent generates information that is not grounded in the input data or real-world facts. This can manifest as making up facts, entities, or events that do not exist or are incorrect. Hallucinations pose a significant challenge in ensuring the reliability and trustworthiness of AI-generated content, particularly in critical applications such as news generation, academic research, and legal advice.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#single-task-threading","title":"Single Task Threading","text":"<p>Individual agents are often designed to excel at specific tasks, leveraging their architecture and training data to optimize performance in a narrowly defined domain. However, this specialization can also be a drawback, as it limits the agent's ability to multitask or adapt to tasks that fall outside its primary domain. Single-task threading means an agent may excel in language translation but struggle with image recognition or vice versa, necessitating the deployment of multiple specialized agents for comprehensive AI solutions.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#lack-of-collaboration","title":"Lack of Collaboration","text":"<p>Traditional AI agents operate in isolation, processing inputs and generating outputs independently. This isolation limits their ability to leverage diverse perspectives, share knowledge, or build upon the insights of other agents. In complex problem-solving scenarios, where multiple facets of a problem need to be addressed simultaneously, this lack of collaboration can lead to suboptimal solutions or an inability to tackle multifaceted challenges effectively.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#the-elegant-yet-simple-solution","title":"The Elegant yet Simple Solution","text":"<p>Recognizing the limitations of individual agents, researchers and practitioners have explored the potential of multi-agent collaboration as a means to transcend these constraints. Multi-agent systems comprise several agents that can interact, communicate, and collaborate to achieve common goals or solve complex problems. This collaborative approach offers several advantages:</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#multi-agent-collaboration","title":"Multi-Agent Collaboration","text":""},{"location":"swarms/concept/purpose/limits_of_individual_agents/#overcoming-context-window-limits","title":"Overcoming Context Window Limits","text":"<p>By dividing a large task among multiple agents, each focusing on different segments of the problem, multi-agent systems can effectively overcome the context window limits of individual agents. For instance, in processing a long document, different agents could be responsible for understanding and analyzing different sections, pooling their insights to generate a coherent understanding of the entire text.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#mitigating-hallucination","title":"Mitigating Hallucination","text":"<p>Through collaboration, agents can cross-verify facts and information, reducing the likelihood of hallucinations. If one agent generates a piece of information, other agents can provide checks and balances, verifying the accuracy against known data or through consensus mechanisms.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#enhancing-multitasking-capabilities","title":"Enhancing Multitasking Capabilities","text":"<p>Multi-agent systems can tackle tasks that require a diverse set of skills by leveraging the specialization of individual agents. For example, in a complex project that involves both natural language processing and image analysis, one agent specialized in text can collaborate with another specialized in visual data, enabling a comprehensive approach to the task.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#facilitating-collaboration-and-knowledge-sharing","title":"Facilitating Collaboration and Knowledge Sharing","text":"<p>Multi-agent collaboration inherently encourages the sharing of knowledge and insights, allowing agents to learn from each other and improve their collective performance. This can be particularly powerful in scenarios where iterative learning and adaptation are crucial, such as dynamic environments or tasks that evolve over time.</p>"},{"location":"swarms/concept/purpose/limits_of_individual_agents/#conclusion","title":"Conclusion","text":"<p>While individual AI agents have made remarkable strides in various domains, their inherent limitations necessitate innovative approaches to unlock the full potential of artificial intelligence. Multi-agent collaboration emerges as a compelling solution, offering a pathway to transcend individual constraints through collective intelligence. By harnessing the power of collaborative AI, we can address more complex, multifaceted problems, paving the way for more versatile, efficient, and effective AI systems in the future.</p>"},{"location":"swarms/concept/purpose/why/","title":"The Swarms Framework: Orchestrating Agents for Enterprise Automation","text":"<p>In the rapidly evolving landscape of artificial intelligence (AI) and automation, a new paradigm is emerging: the orchestration of multiple agents working in collaboration to tackle complex tasks. This approach, embodied by the Swarms Framework, aims to address the fundamental limitations of individual agents and unlocks the true potential of AI-driven automation in enterprise operations.</p> <p>Individual agents are plagued by the same issues: short term memory constraints, hallucinations, single task limitations, lack of collaboration, and cost inefficiences.</p> <p>Learn more here from a list of compiled agent papers</p>"},{"location":"swarms/concept/purpose/why/#the-purpose-of-swarms-overcoming-agent-limitations","title":"The Purpose of Swarms: Overcoming Agent Limitations","text":"<p>Individual agents, while remarkable in their own right, face several inherent challenges that hinder their ability to effectively automate enterprise operations at scale. These limitations include:</p> <ol> <li>Short-Term Memory Constraints</li> <li>Hallucination and Factual Inconsistencies</li> <li>Single-Task Limitations</li> <li>Lack of Collaborative Capabilities</li> <li>Cost Inefficiencies</li> </ol> <p>By orchestrating multiple agents to work in concert, the Swarms Framework directly tackles these limitations, paving the way for more efficient, reliable, and cost-effective enterprise automation.</p>"},{"location":"swarms/concept/purpose/why/#limitation-1-short-term-memory-constraints","title":"Limitation 1: Short-Term Memory Constraints","text":"<p>Many AI agents, particularly those based on large language models, suffer from short-term memory constraints. These agents can effectively process and respond to prompts, but their ability to retain and reason over information across multiple interactions or tasks is limited. This limitation can be problematic in enterprise environments, where complex workflows often involve retaining and referencing contextual information over extended periods.</p> <p>The Swarms Framework addresses this limitation by leveraging the collective memory of multiple agents working in tandem. While individual agents may have limited short-term memory, their combined memory pool becomes significantly larger, enabling the retention and retrieval of contextual information over extended periods. This collective memory is facilitated by agents specializing in information storage and retrieval, such as those based on systems like Llama Index or Pinecone.</p>"},{"location":"swarms/concept/purpose/why/#limitation-2-hallucination-and-factual-inconsistencies","title":"Limitation 2: Hallucination and Factual Inconsistencies","text":"<p>Another challenge faced by many AI agents is the tendency to generate responses that may contain factual inconsistencies or hallucinations -- information that is not grounded in reality or the provided context. This issue can undermine the reliability and trustworthiness of automated systems, particularly in domains where accuracy and consistency are paramount.</p> <p>The Swarms Framework mitigates this limitation by employing multiple agents with diverse knowledge bases and capabilities. By leveraging the collective intelligence of these agents, the framework can cross-reference and validate information, reducing the likelihood of hallucinations and factual inconsistencies. Additionally, specialized agents can be tasked with fact-checking and verification, further enhancing the overall reliability of the system.</p>"},{"location":"swarms/concept/purpose/why/#limitation-3-single-task-limitations","title":"Limitation 3: Single-Task Limitations","text":"<p>Most individual AI agents are designed and optimized for specific tasks or domains, limiting their ability to handle complex, multi-faceted workflows that often characterize enterprise operations. While an agent may excel at a particular task, such as natural language processing or data analysis, it may struggle with other aspects of a larger workflow, such as task coordination or decision-making.</p> <p>The Swarms Framework overcomes this limitation by orchestrating a diverse ensemble of agents, each specializing in different tasks or capabilities. By intelligently combining and coordinating these agents, the framework can tackle complex, multi-threaded workflows that span various domains and task types. This modular approach allows for the seamless integration of new agents as they become available, enabling the continuous expansion and enhancement of the system's capabilities.</p>"},{"location":"swarms/concept/purpose/why/#limitation-4-lack-of-collaborative-capabilities","title":"Limitation 4: Lack of Collaborative Capabilities","text":"<p>Most AI agents are designed to operate independently, lacking the ability to effectively collaborate with other agents or coordinate their actions towards a common goal. This limitation can hinder the scalability and efficiency of automated systems, particularly in enterprise environments where tasks often require the coordination of multiple agents or systems.</p> <p>The Swarms Framework addresses this limitation by introducing a layer of coordination and collaboration among agents. Through specialized coordination agents and communication protocols, the framework enables agents to share information, divide tasks, and synchronize their actions. This collaborative approach not only increases efficiency but also enables the emergence of collective intelligence, where the combined capabilities of multiple agents surpass the sum of their individual abilities.</p>"},{"location":"swarms/concept/purpose/why/#limitation-5-cost-inefficiencies","title":"Limitation 5: Cost Inefficiencies","text":"<p>Running large AI models or orchestrating multiple agents can be computationally expensive, particularly in enterprise environments where scalability and cost-effectiveness are critical considerations. Inefficient resource utilization or redundant computations can quickly escalate costs, making widespread adoption of AI-driven automation financially prohibitive.</p> <p>The Swarms Framework tackles this limitation by optimizing resource allocation and workload distribution among agents. By intelligently assigning tasks to the most appropriate agents and leveraging agent specialization, the framework minimizes redundant computations and improves overall resource utilization. Additionally, the framework can dynamically scale agent instances based on demand, ensuring that computational resources are allocated efficiently and costs are minimized.</p>"},{"location":"swarms/concept/purpose/why/#the-swarms-framework-a-holistic-approach-to-enterprise-automation","title":"The Swarms Framework: A Holistic Approach to Enterprise Automation","text":"<p>The Swarms Framework is a comprehensive solution that addresses the limitations of individual agents by orchestrating their collective capabilities. By integrating agents from various frameworks, including LangChain, AutoGPT, Llama Index, and others, the framework leverages the strengths of each agent while mitigating their individual weaknesses.</p> <p>At its core, the Swarms Framework operates on the principle of multi-agent collaboration. By introducing specialized coordination agents and communication protocols, the framework enables agents to share information, divide tasks, and synchronize their actions towards a common goal. This collaborative approach not only increases efficiency but also enables the emergence of collective intelligence, where the combined capabilities of multiple agents surpass the sum of their individual abilities.</p> <p>The framework's architecture is modular and extensible, allowing for the seamless integration of new agents as they become available. This flexibility ensures that the system's capabilities can continuously expand and adapt to evolving enterprise needs and technological advancements.</p>"},{"location":"swarms/concept/purpose/why/#benefits-of-the-swarms-framework","title":"Benefits of the Swarms Framework","text":"<p>The adoption of the Swarms Framework in enterprise environments offers numerous benefits:</p> <ol> <li>Increased Efficiency and Scalability</li> <li>Improved Reliability and Accuracy</li> <li>Adaptability and Continuous Improvement</li> <li>Cost Optimization</li> <li>Enhanced Security and Compliance</li> </ol>"},{"location":"swarms/concept/purpose/why/#increased-efficiency-and-scalability","title":"Increased Efficiency and Scalability","text":"<p>By orchestrating the collective capabilities of multiple agents, the Swarms Framework enables the efficient execution of complex, multi-threaded workflows. Tasks can be parallelized and distributed across specialized agents, reducing bottlenecks and increasing overall throughput. Additionally, the framework's modular design and ability to dynamically scale agent instances based on demand ensure that the system can adapt to changing workloads and scale seamlessly as enterprise needs evolve.</p>"},{"location":"swarms/concept/purpose/why/#improved-reliability-and-accuracy","title":"Improved Reliability and Accuracy","text":"<p>The collaborative nature of the Swarms Framework reduces the risk of hallucinations and factual inconsistencies that can arise from individual agents. By leveraging the collective knowledge and diverse perspectives of multiple agents, the framework can cross-reference and validate information, enhancing the overall reliability and accuracy of its outputs.</p> <p>Additionally, the framework's ability to incorporate specialized fact-checking and verification agents further strengthens the trustworthiness of the system's outcomes, ensuring that critical decisions and actions are based on accurate and reliable information.</p>"},{"location":"swarms/concept/purpose/why/#adaptability-and-continuous-improvement","title":"Adaptability and Continuous Improvement","text":"<p>The modular architecture of the Swarms Framework allows for the seamless integration of new agents as they become available, enabling the continuous expansion and enhancement of the system's capabilities. As new AI models, algorithms, or data sources emerge, the framework can readily incorporate them, ensuring that enterprise operations remain at the forefront of technological advancements.</p> <p>Furthermore, the framework's monitoring and analytics capabilities provide valuable insights into system performance, enabling the identification of areas for improvement and the optimization of agent selection, task assignments, and resource allocation strategies over time.</p>"},{"location":"swarms/concept/purpose/why/#cost-optimization","title":"Cost Optimization","text":"<p>By intelligently orchestrating the collaboration of multiple agents, the Swarms Framework optimizes resource utilization and minimizes redundant computations. This efficient use of computational resources translates into cost savings, making the widespread adoption of AI-driven automation more financially viable for enterprises.</p> <p>The framework's ability to dynamically scale agent instances based on demand further contributes to cost optimization, ensuring that resources are allocated only when needed and minimizing idle or underutilized instances.</p>"},{"location":"swarms/concept/purpose/why/#enhanced-security-and-compliance","title":"Enhanced Security and Compliance","text":"<p>In enterprise environments, ensuring the security and compliance of automated systems is paramount. The Swarms Framework addresses these concerns by incorporating robust security measures and compliance controls.</p> <p>The framework's centralized Memory Manager component enables the implementation of access control mechanisms and data encryption, protecting sensitive information from unauthorized access or breaches. Additionally, the framework's modular design allows for the integration of specialized agents focused on compliance monitoring and auditing, ensuring that enterprise operations adhere to relevant regulations and industry standards.</p>"},{"location":"swarms/concept/purpose/why/#real-world-applications-and-use-cases","title":"Real-World Applications and Use Cases","text":"<p>The Swarms Framework finds applications across a wide range of enterprise domains, enabling organizations to automate complex operations and streamline their workflows. Here are some examples of real-world use cases:</p> <ol> <li>Intelligent Process Automation (IPA)</li> <li>Customer Service and Support</li> <li>Fraud Detection and Risk Management</li> <li>Supply Chain Optimization</li> <li>Research and Development</li> </ol>"},{"location":"swarms/concept/purpose/why/#intelligent-process-automation-ipa","title":"Intelligent Process Automation (IPA)","text":"<p>In the realm of business process automation, the Swarms Framework can orchestrate agents to automate and optimize complex workflows spanning multiple domains and task types. By combining agents specialized in areas such as natural language processing, data extraction, decision-making, and task coordination, the framework can streamline and automate processes that traditionally required manual intervention or coordination across multiple systems.</p>"},{"location":"swarms/concept/purpose/why/#customer-service-and-support","title":"Customer Service and Support","text":"<p>The framework's ability to integrate agents with diverse capabilities, such as natural language processing, knowledge retrieval, and decision-making, makes it well-suited for automating customer service and support operations. Agents can collaborate to understand customer inquiries, retrieve relevant information from knowledge bases, and provide accurate and personalized responses, improving customer satisfaction and reducing operational costs.</p>"},{"location":"swarms/concept/purpose/why/#fraud-detection-and-risk-management","title":"Fraud Detection and Risk Management","text":"<p>In the financial and cybersecurity domains, the Swarms Framework can orchestrate agents specialized in data analysis, pattern recognition, and risk assessment to detect and mitigate fraudulent activities or security threats. By combining the collective intelligence of these agents, the framework can identify complex patterns and anomalies that may be difficult for individual agents to detect, enhancing the overall effectiveness of fraud detection and risk management strategies.</p>"},{"location":"swarms/concept/purpose/why/#supply-chain-optimization","title":"Supply Chain Optimization","text":"<p>The complexity of modern supply chains often requires the coordination of multiple systems and stakeholders. The Swarms Framework can integrate agents specialized in areas such as demand forecasting, inventory management, logistics optimization, and supplier coordination to streamline and optimize supply chain operations. By orchestrating the collective capabilities of these agents, the framework can identify bottlenecks, optimize resource allocation, and facilitate seamless collaboration among supply chain partners.</p>"},{"location":"swarms/concept/purpose/why/#research-and-development","title":"Research and Development","text":"<p>In research and development environments, the Swarms Framework can accelerate innovation by enabling the collaboration of agents specialized in areas such as literature review, data analysis, hypothesis generation, and experiment design. By orchestrating these agents, the framework can facilitate the exploration of new ideas, identify promising research directions, and streamline the iterative process of scientific inquiry.</p>"},{"location":"swarms/concept/purpose/why/#conclusion","title":"Conclusion","text":"<p>The Swarms Framework represents a paradigm shift in the field of enterprise automation, addressing the limitations of individual agents by orchestrating their collective capabilities. By integrating agents from various frameworks and enabling multi-agent collaboration, the Swarms Framework overcomes challenges such as short-term memory constraints, hallucinations, single-task limitations, lack of collaboration, and cost inefficiencies.</p> <p>Through its modular architecture, centralized coordination, and advanced monitoring and analytics capabilities, the Swarms Framework empowers enterprises to automate complex operations with increased efficiency, reliability, and adaptability. It unlocks the true potential of AI-driven automation, enabling organizations to stay ahead of the curve and thrive in an ever-evolving technological landscape.</p> <p>As the field of artificial intelligence continues to advance, the Swarms Framework stands as a robust and flexible solution, ready to embrace new developments and seamlessly integrate emerging agents and capabilities. By harnessing the power of collective intelligence, the framework paves the way for a future where enterprises can leverage the full potential of AI to drive innovation, optimize operations, and gain a competitive edge in their respective industries.</p>"},{"location":"swarms/concept/purpose/why_swarms/","title":"Why Swarms?","text":"<p>The need for multiple agents to work together in artificial intelligence (AI) and particularly in the context of Large Language Models (LLMs) stems from several inherent limitations and challenges in handling complex, dynamic, and multifaceted tasks with single-agent systems. Collaborating with multiple agents offers a pathway to enhance reliability, computational efficiency, cognitive diversity, and problem-solving capabilities. This section delves into the rationale behind employing multi-agent systems and strategizes on overcoming the associated expenses, such as API bills and hosting costs.</p>"},{"location":"swarms/concept/purpose/why_swarms/#why-multiple-agents-are-necessary","title":"Why Multiple Agents Are Necessary","text":""},{"location":"swarms/concept/purpose/why_swarms/#1-cognitive-diversity","title":"1. Cognitive Diversity","text":"<p>Different agents can bring varied perspectives, knowledge bases, and problem-solving approaches to a task. This diversity is crucial in complex problem-solving scenarios where a single approach might not be sufficient. Cognitive diversity enhances creativity, leading to innovative solutions and the ability to tackle a broader range of problems.</p>"},{"location":"swarms/concept/purpose/why_swarms/#2-specialization-and-expertise","title":"2. Specialization and Expertise","text":"<p>In many cases, tasks are too complex for a single agent to handle efficiently. By dividing the task among multiple specialized agents, each can focus on a segment where it excels, thereby increasing the overall efficiency and effectiveness of the solution. This approach leverages the expertise of individual agents to achieve superior performance in tasks that require multifaceted knowledge and skills.</p>"},{"location":"swarms/concept/purpose/why_swarms/#3-scalability-and-flexibility","title":"3. Scalability and Flexibility","text":"<p>Multi-agent systems can more easily scale to handle large-scale or evolving tasks. Adding more agents to the system can increase its capacity or capabilities, allowing it to adapt to larger workloads or new types of tasks. This scalability is essential in dynamic environments where the demand and nature of tasks can change rapidly.</p>"},{"location":"swarms/concept/purpose/why_swarms/#4-robustness-and-redundancy","title":"4. Robustness and Redundancy","text":"<p>Collaboration among multiple agents enhances the system's robustness by introducing redundancy. If one agent fails or encounters an error, others can compensate, ensuring the system remains operational. This redundancy is critical in mission-critical applications where failure is not an option.</p>"},{"location":"swarms/concept/purpose/why_swarms/#overcoming-expenses-with-api-bills-and-hosting","title":"Overcoming Expenses with API Bills and Hosting","text":"<p>Deploying multiple agents, especially when relying on cloud-based services or APIs, can incur significant costs. Here are strategies to manage and reduce these expenses:</p>"},{"location":"swarms/concept/purpose/why_swarms/#1-optimize-agent-efficiency","title":"1. Optimize Agent Efficiency","text":"<p>Before scaling up the number of agents, ensure each agent operates as efficiently as possible. This can involve refining algorithms, reducing unnecessary API calls, and optimizing data processing to minimize computational requirements and, consequently, the associated costs.</p>"},{"location":"swarms/concept/purpose/why_swarms/#2-use-open-source-and-self-hosted-solutions","title":"2. Use Open Source and Self-Hosted Solutions","text":"<p>Where possible, leverage open-source models and technologies that can be self-hosted. While there is an initial investment in setting up the infrastructure, over time, self-hosting can significantly reduce costs related to API calls and reliance on third-party services.</p>"},{"location":"swarms/concept/purpose/why_swarms/#3-implement-intelligent-caching","title":"3. Implement Intelligent Caching","text":"<p>Caching results for frequently asked questions or common tasks can drastically reduce the need for repeated computations or API calls. Intelligent caching systems can determine what information to store and for how long, optimizing the balance between fresh data and computational savings.</p>"},{"location":"swarms/concept/purpose/why_swarms/#4-dynamic-scaling-and-load-balancing","title":"4. Dynamic Scaling and Load Balancing","text":"<p>Use cloud services that offer dynamic scaling and load balancing to adjust the resources allocated based on the current demand. This ensures you're not paying for idle resources during low-usage periods while still being able to handle high demand when necessary.</p>"},{"location":"swarms/concept/purpose/why_swarms/#5-collaborative-cost-sharing-models","title":"5. Collaborative Cost-Sharing Models","text":"<p>In scenarios where multiple stakeholders benefit from the multi-agent system, consider implementing a cost-sharing model. This approach distributes the financial burden among the users or beneficiaries, making it more sustainable.</p>"},{"location":"swarms/concept/purpose/why_swarms/#6-monitor-and-analyze-costs","title":"6. Monitor and Analyze Costs","text":"<p>Regularly monitor and analyze your usage and associated costs to identify potential savings. Many cloud providers offer tools to track and forecast expenses, helping you to adjust your usage patterns and configurations to minimize costs without sacrificing performance.</p>"},{"location":"swarms/concept/purpose/why_swarms/#conclusion","title":"Conclusion","text":"<p>The collaboration of multiple agents in AI systems presents a robust solution to the complexity, specialization, scalability, and robustness challenges inherent in single-agent approaches. While the associated costs can be significant, strategic optimization, leveraging open-source technologies, intelligent caching, dynamic resource management, collaborative cost-sharing, and diligent monitoring can mitigate these expenses. By adopting these strategies, organizations can harness the power of multi-agent systems to tackle complex problems more effectively and efficiently, ensuring the sustainable deployment of these advanced technologies.</p>"},{"location":"swarms/config/board_config/","title":"Board of Directors Configuration","text":"<p>The Board of Directors feature in Swarms provides a sophisticated configuration system that allows you to enable, customize, and manage the collective decision-making capabilities of the framework.</p>"},{"location":"swarms/config/board_config/#overview","title":"Overview","text":"<p>The Board of Directors configuration system provides:</p> <ul> <li>Feature Control: Enable or disable the Board of Directors feature globally</li> <li>Board Composition: Configure default board sizes and member roles</li> <li>Operational Settings: Set decision thresholds, voting mechanisms, and consensus parameters</li> <li>Template Management: Predefined board templates for common use cases</li> <li>Environment Integration: Configuration through environment variables and files</li> </ul>"},{"location":"swarms/config/board_config/#configuration-management","title":"Configuration Management","text":""},{"location":"swarms/config/board_config/#boardconfig-class","title":"<code>BoardConfig</code> Class","text":"<p>The <code>BoardConfig</code> class manages all configuration for the Board of Directors feature:</p> <pre><code>from swarms.config.board_config import BoardConfig\n\n# Create configuration with custom settings\nconfig = BoardConfig(\n    config_file_path=\"board_config.json\",\n    config_data={\n        \"board_feature_enabled\": True,\n        \"default_board_size\": 5,\n        \"decision_threshold\": 0.7\n    }\n)\n</code></pre>"},{"location":"swarms/config/board_config/#configuration-sources","title":"Configuration Sources","text":"<p>The configuration system loads settings from multiple sources in priority order:</p> <ol> <li>Environment Variables (highest priority)</li> <li>Configuration File</li> <li>Explicit Config Data</li> <li>Default Values (lowest priority)</li> </ol>"},{"location":"swarms/config/board_config/#environment-variables","title":"Environment Variables","text":"<p>You can configure the Board of Directors feature using environment variables:</p> <pre><code># Enable the Board of Directors feature\nexport SWARMS_BOARD_FEATURE_ENABLED=true\n\n# Set default board size\nexport SWARMS_DEFAULT_BOARD_SIZE=5\n\n# Configure decision threshold\nexport SWARMS_DECISION_THRESHOLD=0.7\n\n# Enable voting mechanisms\nexport SWARMS_ENABLE_VOTING=true\n\n# Enable consensus building\nexport SWARMS_ENABLE_CONSENSUS=true\n\n# Set default board model\nexport SWARMS_DEFAULT_BOARD_MODEL=gpt-4o\n\n# Enable verbose logging\nexport SWARMS_VERBOSE_LOGGING=true\n\n# Set maximum board meeting duration\nexport SWARMS_MAX_BOARD_MEETING_DURATION=300\n\n# Enable auto fallback to Director mode\nexport SWARMS_AUTO_FALLBACK_TO_DIRECTOR=true\n</code></pre>"},{"location":"swarms/config/board_config/#configuration-file","title":"Configuration File","text":"<p>Create a JSON configuration file for persistent settings:</p> <pre><code>{\n    \"board_feature_enabled\": true,\n    \"default_board_size\": 5,\n    \"decision_threshold\": 0.7,\n    \"enable_voting\": true,\n    \"enable_consensus\": true,\n    \"default_board_model\": \"gpt-4o\",\n    \"verbose_logging\": true,\n    \"max_board_meeting_duration\": 300,\n    \"auto_fallback_to_director\": true,\n    \"custom_board_templates\": {\n        \"financial\": {\n            \"roles\": [\n                {\"name\": \"CFO\", \"weight\": 1.5, \"expertise\": [\"finance\", \"risk_management\"]},\n                {\"name\": \"Investment_Advisor\", \"weight\": 1.3, \"expertise\": [\"investments\", \"analysis\"]}\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"swarms/config/board_config/#configuration-functions","title":"Configuration Functions","text":""},{"location":"swarms/config/board_config/#feature-control","title":"Feature Control","text":"<pre><code>from swarms.config.board_config import (\n    enable_board_feature,\n    disable_board_feature,\n    is_board_feature_enabled\n)\n\n# Check if feature is enabled\nif not is_board_feature_enabled():\n    # Enable the feature\n    enable_board_feature()\n    print(\"Board of Directors feature enabled\")\n\n# Disable the feature\ndisable_board_feature()\n</code></pre>"},{"location":"swarms/config/board_config/#board-composition","title":"Board Composition","text":"<pre><code>from swarms.config.board_config import (\n    set_board_size,\n    get_board_size\n)\n\n# Set default board size\nset_board_size(7)\n\n# Get current board size\ncurrent_size = get_board_size()\nprint(f\"Default board size: {current_size}\")\n</code></pre>"},{"location":"swarms/config/board_config/#decision-settings","title":"Decision Settings","text":"<pre><code>from swarms.config.board_config import (\n    set_decision_threshold,\n    get_decision_threshold,\n    enable_voting,\n    disable_voting,\n    enable_consensus,\n    disable_consensus\n)\n\n# Set decision threshold (0.0 to 1.0)\nset_decision_threshold(0.75)  # 75% majority required\n\n# Get current threshold\nthreshold = get_decision_threshold()\nprint(f\"Decision threshold: {threshold}\")\n\n# Enable/disable voting mechanisms\nenable_voting()\ndisable_voting()\n\n# Enable/disable consensus building\nenable_consensus()\ndisable_consensus()\n</code></pre>"},{"location":"swarms/config/board_config/#model-configuration","title":"Model Configuration","text":"<pre><code>from swarms.config.board_config import (\n    set_board_model,\n    get_board_model\n)\n\n# Set default model for board members\nset_board_model(\"gpt-4o\")\n\n# Get current model\nmodel = get_board_model()\nprint(f\"Default board model: {model}\")\n</code></pre>"},{"location":"swarms/config/board_config/#logging-configuration","title":"Logging Configuration","text":"<pre><code>from swarms.config.board_config import (\n    enable_verbose_logging,\n    disable_verbose_logging,\n    is_verbose_logging_enabled\n)\n\n# Enable verbose logging\nenable_verbose_logging()\n\n# Check logging status\nif is_verbose_logging_enabled():\n    print(\"Verbose logging is enabled\")\n\n# Disable verbose logging\ndisable_verbose_logging()\n</code></pre>"},{"location":"swarms/config/board_config/#meeting-duration","title":"Meeting Duration","text":"<pre><code>from swarms.config.board_config import (\n    set_max_board_meeting_duration,\n    get_max_board_meeting_duration\n)\n\n# Set maximum meeting duration in seconds\nset_max_board_meeting_duration(600)  # 10 minutes\n\n# Get current duration\nduration = get_max_board_meeting_duration()\nprint(f\"Max meeting duration: {duration} seconds\")\n</code></pre>"},{"location":"swarms/config/board_config/#fallback-configuration","title":"Fallback Configuration","text":"<pre><code>from swarms.config.board_config import (\n    enable_auto_fallback_to_director,\n    disable_auto_fallback_to_director,\n    is_auto_fallback_enabled\n)\n\n# Enable automatic fallback to Director mode\nenable_auto_fallback_to_director()\n\n# Check fallback status\nif is_auto_fallback_enabled():\n    print(\"Auto fallback to Director mode is enabled\")\n\n# Disable fallback\ndisable_auto_fallback_to_director()\n</code></pre>"},{"location":"swarms/config/board_config/#board-templates","title":"Board Templates","text":""},{"location":"swarms/config/board_config/#default-templates","title":"Default Templates","text":"<p>The configuration system provides predefined board templates for common use cases:</p> <pre><code>from swarms.config.board_config import get_default_board_template\n\n# Get standard board template\nstandard_template = get_default_board_template(\"standard\")\nprint(\"Standard template roles:\", standard_template[\"roles\"])\n\n# Get executive board template\nexecutive_template = get_default_board_template(\"executive\")\nprint(\"Executive template roles:\", executive_template[\"roles\"])\n\n# Get advisory board template\nadvisory_template = get_default_board_template(\"advisory\")\nprint(\"Advisory template roles:\", advisory_template[\"roles\"])\n</code></pre>"},{"location":"swarms/config/board_config/#template-structure","title":"Template Structure","text":"<p>Each template defines the board composition:</p> <pre><code># Standard template structure\nstandard_template = {\n    \"roles\": [\n        {\n            \"name\": \"Chairman\",\n            \"weight\": 1.5,\n            \"expertise\": [\"leadership\", \"strategy\"]\n        },\n        {\n            \"name\": \"Vice-Chairman\", \n            \"weight\": 1.2,\n            \"expertise\": [\"operations\", \"coordination\"]\n        },\n        {\n            \"name\": \"Secretary\",\n            \"weight\": 1.0,\n            \"expertise\": [\"documentation\", \"communication\"]\n        }\n    ]\n}\n</code></pre>"},{"location":"swarms/config/board_config/#custom-templates","title":"Custom Templates","text":"<p>Create custom board templates for specific use cases:</p> <pre><code>from swarms.config.board_config import (\n    add_custom_board_template,\n    get_custom_board_template,\n    list_custom_templates\n)\n\n# Define a custom financial analysis board\nfinancial_template = {\n    \"roles\": [\n        {\n            \"name\": \"CFO\",\n            \"weight\": 1.5,\n            \"expertise\": [\"finance\", \"risk_management\", \"budgeting\"]\n        },\n        {\n            \"name\": \"Investment_Advisor\",\n            \"weight\": 1.3,\n            \"expertise\": [\"investments\", \"market_analysis\", \"portfolio_management\"]\n        },\n        {\n            \"name\": \"Compliance_Officer\",\n            \"weight\": 1.2,\n            \"expertise\": [\"compliance\", \"regulations\", \"legal\"]\n        }\n    ]\n}\n\n# Add custom template\nadd_custom_board_template(\"financial_analysis\", financial_template)\n\n# Get custom template\ntemplate = get_custom_board_template(\"financial_analysis\")\n\n# List all custom templates\ntemplates = list_custom_templates()\nprint(\"Available custom templates:\", templates)\n</code></pre>"},{"location":"swarms/config/board_config/#configuration-validation","title":"Configuration Validation","text":"<p>The configuration system includes comprehensive validation:</p> <pre><code>from swarms.config.board_config import validate_configuration\n\n# Validate current configuration\ntry:\n    validation_result = validate_configuration()\n    print(\"Configuration is valid:\", validation_result.is_valid)\n    if not validation_result.is_valid:\n        print(\"Validation errors:\", validation_result.errors)\nexcept Exception as e:\n    print(f\"Configuration validation failed: {e}\")\n</code></pre>"},{"location":"swarms/config/board_config/#configuration-persistence","title":"Configuration Persistence","text":""},{"location":"swarms/config/board_config/#save-configuration","title":"Save Configuration","text":"<pre><code>from swarms.config.board_config import save_configuration\n\n# Save current configuration to file\nsave_configuration(\"my_board_config.json\")\n</code></pre>"},{"location":"swarms/config/board_config/#load-configuration","title":"Load Configuration","text":"<pre><code>from swarms.config.board_config import load_configuration\n\n# Load configuration from file\nconfig = load_configuration(\"my_board_config.json\")\n</code></pre>"},{"location":"swarms/config/board_config/#reset-to-defaults","title":"Reset to Defaults","text":"<pre><code>from swarms.config.board_config import reset_to_defaults\n\n# Reset all configuration to default values\nreset_to_defaults()\n</code></pre>"},{"location":"swarms/config/board_config/#integration-with-boardofdirectorsswarm","title":"Integration with BoardOfDirectorsSwarm","text":"<p>The configuration system integrates seamlessly with the BoardOfDirectorsSwarm:</p> <pre><code>from swarms.structs.board_of_directors_swarm import BoardOfDirectorsSwarm\nfrom swarms.config.board_config import (\n    enable_board_feature,\n    set_decision_threshold,\n    get_default_board_template\n)\n\n# Enable the feature globally\nenable_board_feature()\n\n# Set global decision threshold\nset_decision_threshold(0.7)\n\n# Get a board template\ntemplate = get_default_board_template(\"executive\")\n\n# Create board members from template\nboard_members = []\nfor role_config in template[\"roles\"]:\n    agent = Agent(\n        agent_name=role_config[\"name\"],\n        agent_description=f\"Board member with expertise in {', '.join(role_config['expertise'])}\",\n        model_name=\"gpt-4o-mini\"\n    )\n    board_member = BoardMember(\n        agent=agent,\n        role=BoardMemberRole.EXECUTIVE_DIRECTOR,\n        voting_weight=role_config[\"weight\"],\n        expertise_areas=role_config[\"expertise\"]\n    )\n    board_members.append(board_member)\n\n# Create the swarm with configured settings\nboard_swarm = BoardOfDirectorsSwarm(\n    board_members=board_members,\n    agents=worker_agents,\n    decision_threshold=0.7,  # Uses global setting\n    enable_voting=True,\n    enable_consensus=True\n)\n</code></pre>"},{"location":"swarms/config/board_config/#best-practices","title":"Best Practices","text":"<ol> <li>Environment Variables: Use environment variables for deployment-specific settings</li> <li>Configuration Files: Use JSON files for persistent, version-controlled settings</li> <li>Validation: Always validate configuration before deployment</li> <li>Templates: Use predefined templates for common use cases</li> <li>Customization: Create custom templates for domain-specific requirements</li> <li>Monitoring: Enable verbose logging for debugging and monitoring</li> <li>Fallback: Configure fallback mechanisms for reliability</li> </ol>"},{"location":"swarms/config/board_config/#error-handling","title":"Error Handling","text":"<p>The configuration system includes comprehensive error handling:</p> <pre><code>from swarms.config.board_config import BoardConfig\n\ntry:\n    config = BoardConfig(\n        config_file_path=\"invalid_config.json\"\n    )\nexcept Exception as e:\n    print(f\"Configuration loading failed: {e}\")\n    # Handle error appropriately\n</code></pre>"},{"location":"swarms/config/board_config/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Caching: Configuration values are cached for improved performance</li> <li>Lazy Loading: Templates are loaded on-demand</li> <li>Validation: Configuration validation is performed efficiently</li> <li>Memory Management: Configuration objects are lightweight and efficient</li> </ul> <p>For more information on using the Board of Directors feature, see the BoardOfDirectorsSwarm Documentation. </p>"},{"location":"swarms/examples/agent_output_types/","title":"Agent Output Types Examples with Vision Capabilities","text":"<p>This example demonstrates how to use different output types when working with Swarms agents, including vision-enabled agents that can analyze images. Each output type formats the agent's response in a specific way, making it easier to integrate with different parts of your application.</p>"},{"location":"swarms/examples/agent_output_types/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>OpenAI API key</li> <li>Anthropic API key (optional, for Claude models)</li> <li>Swarms library</li> </ul>"},{"location":"swarms/examples/agent_output_types/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/agent_output_types/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"  # Required for GPT-4V vision capabilities\nANTHROPIC_API_KEY=\"\"  # Optional, for Claude models\n</code></pre>"},{"location":"swarms/examples/agent_output_types/#examples","title":"Examples","text":""},{"location":"swarms/examples/agent_output_types/#vision-enabled-quality-control-agent","title":"Vision-Enabled Quality Control Agent","text":"<pre><code>from swarms.structs import Agent\nfrom swarms.prompts.logistics import (\n    Quality_Control_Agent_Prompt,\n)\n\n# Image for analysis\nfactory_image = \"image.jpg\"\n\n\n# Quality control agent\nquality_control_agent = Agent(\n    agent_name=\"Quality Control Agent\",\n    agent_description=\"A quality control agent that analyzes images and provides a detailed report on the quality of the product in the image.\",\n    model_name=\"gpt-4.1-mini\",\n    system_prompt=Quality_Control_Agent_Prompt,\n    multi_modal=True,\n    max_loops=2,\n    output_type=\"str-all-except-first\",\n)\n\n\nresponse = quality_control_agent.run(\n    task=\"what is in the image?\",\n    img=factory_image,\n)\n\nprint(response)\n</code></pre>"},{"location":"swarms/examples/agent_output_types/#supported-image-formats","title":"Supported Image Formats","text":"<p>The vision-enabled agents support various image formats including:</p> Format Description JPEG/JPG Standard image format with lossy compression PNG Lossless format supporting transparency GIF Animated format (only first frame used) WebP Modern format with both lossy and lossless compression"},{"location":"swarms/examples/agent_output_types/#best-practices-for-vision-tasks","title":"Best Practices for Vision Tasks","text":"Best Practice Description Image Quality Ensure images are clear and well-lit for optimal analysis Image Size Keep images under 20MB and in supported formats Task Specificity Provide clear, specific instructions for image analysis Model Selection Use vision-capable models (e.g., GPT-4V) for image tasks"},{"location":"swarms/examples/agent_structured_outputs/","title":"Agent Structured Outputs","text":"<p>This example demonstrates how to use structured outputs with Swarms agents following OpenAI's function calling schema. By defining function schemas, you can specify exactly how agents should structure their responses, making it easier to parse and use the outputs in your applications.</p>"},{"location":"swarms/examples/agent_structured_outputs/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>OpenAI API key</li> <li>Swarms library</li> </ul>"},{"location":"swarms/examples/agent_structured_outputs/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/agent_structured_outputs/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/agent_structured_outputs/#understanding-function-schemas","title":"Understanding Function Schemas","text":"<p>Function schemas in Swarms follow OpenAI's function calling format. Each function schema is defined as a dictionary with the following structure:</p> <pre><code>{\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"function_name\",\n        \"description\": \"A clear description of what the function does\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                # Define the parameters your function accepts\n            },\n            \"required\": [\"list\", \"of\", \"required\", \"parameters\"]\n        }\n    }\n}\n</code></pre>"},{"location":"swarms/examples/agent_structured_outputs/#code-example","title":"Code Example","text":"<p>Here's an example showing how to use multiple function schemas with a Swarms agent:</p> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT\n\n# Define multiple function schemas\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_stock_price\",\n            \"description\": \"Retrieve the current stock price and related information for a specified company.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"ticker\": {\n                        \"type\": \"string\",\n                        \"description\": \"The stock ticker symbol of the company, e.g. AAPL for Apple Inc.\",\n                    },\n                    \"include_history\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Whether to include historical price data.\",\n                    },\n                    \"time\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"Optional time for stock data, in ISO 8601 format.\",\n                    },\n                },\n                \"required\": [\"ticker\", \"include_history\"]\n            },\n        },\n    },\n    # Can pass in multiple function schemas as well\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"analyze_company_financials\",\n            \"description\": \"Analyze key financial metrics and ratios for a company.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"ticker\": {\n                        \"type\": \"string\",\n                        \"description\": \"The stock ticker symbol of the company\",\n                    },\n                    \"metrics\": {\n                        \"type\": \"array\",\n                        \"items\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"PE_ratio\", \"market_cap\", \"revenue\", \"profit_margin\"]\n                        },\n                        \"description\": \"List of financial metrics to analyze\"\n                    },\n                    \"timeframe\": {\n                        \"type\": \"string\",\n                        \"enum\": [\"quarterly\", \"annual\", \"ttm\"],\n                        \"description\": \"Timeframe for the analysis\"\n                    }\n                },\n                \"required\": [\"ticker\", \"metrics\"]\n            }\n        }\n    }\n]\n\n# Initialize the agent with multiple function schemas\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent that can fetch stock prices and analyze financials\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=1,\n    tools_list_dictionary=tools,  # Pass in the list of function schemas\n    output_type=\"final\"\n)\n\n# Example usage with stock price query\nstock_response = agent.run(\n    \"What is the current stock price for Apple Inc. (AAPL)? Include historical data.\"\n)\nprint(\"Stock Price Response:\", stock_response)\n\n# Example usage with financial analysis query\nanalysis_response = agent.run(\n    \"Analyze Apple's PE ratio and market cap using quarterly data.\"\n)\nprint(\"Financial Analysis Response:\", analysis_response)\n</code></pre>"},{"location":"swarms/examples/agent_structured_outputs/#schema-types-and-properties","title":"Schema Types and Properties","text":"<p>The function schema supports various parameter types and properties:</p> Schema Type Description Basic Types <code>string</code>, <code>number</code>, <code>integer</code>, <code>boolean</code>, <code>array</code>, <code>object</code> Format Specifications <code>date-time</code>, <code>date</code>, <code>email</code>, etc. Enums Restrict values to a predefined set Required vs Optional Parameters Specify which parameters must be provided Nested Objects and Arrays Support for complex data structures <p>Example of a more complex schema:</p> <pre><code>{\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"generate_investment_report\",\n        \"description\": \"Generate a comprehensive investment report\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"portfolio\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"stocks\": {\n                            \"type\": \"array\",\n                            \"items\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"ticker\": {\"type\": \"string\"},\n                                    \"shares\": {\"type\": \"number\"},\n                                    \"entry_price\": {\"type\": \"number\"}\n                                }\n                            }\n                        },\n                        \"risk_tolerance\": {\n                            \"type\": \"string\",\n                            \"enum\": [\"low\", \"medium\", \"high\"]\n                        },\n                        \"time_horizon\": {\n                            \"type\": \"integer\",\n                            \"minimum\": 1,\n                            \"maximum\": 30,\n                            \"description\": \"Investment time horizon in years\"\n                        }\n                    },\n                    \"required\": [\"stocks\", \"risk_tolerance\"]\n                },\n                \"report_type\": {\n                    \"type\": \"string\",\n                    \"enum\": [\"summary\", \"detailed\", \"risk_analysis\"]\n                }\n            },\n            \"required\": [\"portfolio\"]\n        }\n    }\n}\n</code></pre> <p>This example shows how to structure complex nested objects, arrays, and various parameter types while following OpenAI's function calling schema.</p>"},{"location":"swarms/examples/agent_with_tools/","title":"Basic Agent Example","text":"<p>This tutorial demonstrates how to create and use tools (callables) with the Swarms framework. Tools are Python functions that your agent can call to perform specific tasks, interact with external services, or process data. We'll show you how to build well-structured tools and integrate them with your agent.</p>"},{"location":"swarms/examples/agent_with_tools/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.7+</p> </li> <li> <p>OpenAI API key</p> </li> <li> <p>Swarms library</p> </li> </ul>"},{"location":"swarms/examples/agent_with_tools/#building-tools-for-your-agent","title":"Building Tools for Your Agent","text":"<p>Tools are functions that your agent can use to interact with external services, process data, or perform specific tasks. Here's a guide on how to build effective tools for your agent:</p>"},{"location":"swarms/examples/agent_with_tools/#tool-structure-best-practices","title":"Tool Structure Best Practices","text":"<ol> <li> <p>Type Hints: Always use type hints to specify input and output types</p> </li> <li> <p>Docstrings: Include comprehensive docstrings with description, args, returns, and examples</p> </li> <li> <p>Error Handling: Implement proper error handling and return consistent JSON responses</p> </li> <li> <p>Rate Limiting: Include rate limiting when dealing with APIs</p> </li> <li> <p>Input Validation: Validate input parameters before processing</p> </li> </ol>"},{"location":"swarms/examples/agent_with_tools/#example-tool-template","title":"Example Tool Template","text":"<p>Here's a template for creating a well-structured tool:</p> <pre><code>from typing import Optional, Dict, Any\nimport json\n\ndef example_tool(param1: str, param2: Optional[int] = None) -&gt; str:\n    \"\"\"\n    Brief description of what the tool does.\n\n    Args:\n        param1 (str): Description of first parameter\n        param2 (Optional[int]): Description of optional parameter\n\n    Returns:\n        str: JSON formatted string containing the result\n\n    Raises:\n        ValueError: Description of when this error occurs\n        RequestException: Description of when this error occurs\n\n    Example:\n        &gt;&gt;&gt; result = example_tool(\"test\", 123)\n        &gt;&gt;&gt; print(result)\n        {\"status\": \"success\", \"data\": {\"key\": \"value\"}}\n    \"\"\"\n    try:\n        # Input validation\n        if not isinstance(param1, str):\n            raise ValueError(\"param1 must be a string\")\n\n        # Main logic\n        result: Dict[str, Any] = {\n            \"status\": \"success\",\n            \"data\": {\n                \"param1\": param1,\n                \"param2\": param2\n            }\n        }\n\n        # Return JSON string\n        return json.dumps(result, indent=2)\n\n    except ValueError as e:\n        return json.dumps({\"error\": f\"Validation error: {str(e)}\"})\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n</code></pre>"},{"location":"swarms/examples/agent_with_tools/#building-api-integration-tools","title":"Building API Integration Tools","text":"<p>When building tools that interact with external APIs:</p> <ol> <li>API Client Setup:</li> </ol> <pre><code>def get_api_data(endpoint: str, params: Dict[str, Any]) -&gt; str:\n    \"\"\"\n    Generic API data fetcher with proper error handling.\n\n    Args:\n        endpoint (str): API endpoint to call\n        params (Dict[str, Any]): Query parameters\n\n    Returns:\n        str: JSON formatted response\n    \"\"\"\n    try:\n        response = requests.get(\n            endpoint,\n            params=params,\n            timeout=10\n        )\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n    except requests.RequestException as e:\n        return json.dumps({\"error\": f\"API error: {str(e)}\"})\n</code></pre>"},{"location":"swarms/examples/agent_with_tools/#data-processing-tools","title":"Data Processing Tools","text":"<p>Example of a tool that processes data:</p> <pre><code>from typing import List, Dict\nimport pandas as pd\n\ndef process_market_data(prices: List[float], window: int = 14) -&gt; str:\n    \"\"\"\n    Calculate technical indicators from price data.\n\n    Args:\n        prices (List[float]): List of historical prices\n        window (int): Rolling window size for calculations\n\n    Returns:\n        str: JSON formatted string with calculated indicators\n\n    Example:\n        &gt;&gt;&gt; prices = [100, 101, 99, 102, 98, 103]\n        &gt;&gt;&gt; result = process_market_data(prices, window=3)\n        &gt;&gt;&gt; print(result)\n        {\"sma\": 101.0, \"volatility\": 2.1}\n    \"\"\"\n    try:\n        df = pd.DataFrame({\"price\": prices})\n\n        results: Dict[str, float] = {\n            \"sma\": df[\"price\"].rolling(window).mean().iloc[-1],\n            \"volatility\": df[\"price\"].rolling(window).std().iloc[-1]\n        }\n\n        return json.dumps(results, indent=2)\n\n    except Exception as e:\n        return json.dumps({\"error\": f\"Processing error: {str(e)}\"})\n</code></pre>"},{"location":"swarms/examples/agent_with_tools/#adding-tools-to-your-agent","title":"Adding Tools to Your Agent","text":"<p>Once you've created your tools, add them to your agent like this:</p> <pre><code>agent = Agent(\n    agent_name=\"Your-Agent\",\n    agent_description=\"Description of your agent\",\n    system_prompt=\"System prompt for your agent\",\n    tools=[\n        example_tool,\n        get_api_data,\n        rate_limited_api_call,\n        process_market_data\n    ]\n)\n</code></pre>"},{"location":"swarms/examples/agent_with_tools/#tutorial-steps","title":"Tutorial Steps","text":"<ol> <li>First, install the latest version of Swarms:</li> </ol> <pre><code>pip3 install -U swarms\n</code></pre> <ol> <li>Set up your environment variables in a <code>.env</code> file:</li> </ol> <pre><code>OPENAI_API_KEY=\"your-api-key-here\"\nWORKSPACE_DIR=\"agent_workspace\"\n</code></pre> <ol> <li>Create a new Python file and customize your agent with the following parameters:</li> <li> <p><code>agent_name</code>: A unique identifier for your agent</p> </li> <li> <p><code>agent_description</code>: A detailed description of your agent's capabilities</p> </li> <li> <p><code>system_prompt</code>: The core instructions that define your agent's behavior</p> </li> <li> <p><code>model_name</code>: The GPT model to use</p> </li> <li> <p>Additional configuration options for temperature and output format</p> </li> <li> <p>Run the example code below:</p> </li> </ol> <pre><code>import json\nimport requests\nfrom swarms import Agent\nfrom typing import List\nimport time\n\n\ndef get_coin_price(coin_id: str, vs_currency: str) -&gt; str:\n    \"\"\"\n    Get the current price of a specific cryptocurrency.\n\n    Args:\n        coin_id (str): The CoinGecko ID of the cryptocurrency (e.g., 'bitcoin', 'ethereum')\n        vs_currency (str, optional): The target currency. Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing the coin's current price and market data\n\n    Raises:\n        requests.RequestException: If the API request fails\n\n    Example:\n        &gt;&gt;&gt; result = get_coin_price(\"bitcoin\")\n        &gt;&gt;&gt; print(result)\n        {\"bitcoin\": {\"usd\": 45000, \"usd_market_cap\": 850000000000, ...}}\n    \"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id,\n            \"vs_currencies\": vs_currency,\n            \"include_market_cap\": True,\n            \"include_24hr_vol\": True,\n            \"include_24hr_change\": True,\n            \"include_last_updated_at\": True,\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n        return json.dumps(data, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\n                \"error\": f\"Failed to fetch price for {coin_id}: {str(e)}\"\n            }\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_top_cryptocurrencies(limit: int, vs_currency: str) -&gt; str:\n    \"\"\"\n    Fetch the top cryptocurrencies by market capitalization.\n\n    Args:\n        limit (int, optional): Number of coins to retrieve (1-250). Defaults to 10.\n        vs_currency (str, optional): The target currency. Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing top cryptocurrencies with detailed market data\n\n    Raises:\n        requests.RequestException: If the API request fails\n        ValueError: If limit is not between 1 and 250\n\n    Example:\n        &gt;&gt;&gt; result = get_top_cryptocurrencies(5)\n        &gt;&gt;&gt; print(result)\n        [{\"id\": \"bitcoin\", \"name\": \"Bitcoin\", \"current_price\": 45000, ...}]\n    \"\"\"\n    try:\n        if not 1 &lt;= limit &lt;= 250:\n            raise ValueError(\"Limit must be between 1 and 250\")\n\n        url = \"https://api.coingecko.com/api/v3/coins/markets\"\n        params = {\n            \"vs_currency\": vs_currency,\n            \"order\": \"market_cap_desc\",\n            \"per_page\": limit,\n            \"page\": 1,\n            \"sparkline\": False,\n            \"price_change_percentage\": \"24h,7d\",\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Simplify the data structure for better readability\n        simplified_data = []\n        for coin in data:\n            simplified_data.append(\n                {\n                    \"id\": coin.get(\"id\"),\n                    \"symbol\": coin.get(\"symbol\"),\n                    \"name\": coin.get(\"name\"),\n                    \"current_price\": coin.get(\"current_price\"),\n                    \"market_cap\": coin.get(\"market_cap\"),\n                    \"market_cap_rank\": coin.get(\"market_cap_rank\"),\n                    \"total_volume\": coin.get(\"total_volume\"),\n                    \"price_change_24h\": coin.get(\n                        \"price_change_percentage_24h\"\n                    ),\n                    \"price_change_7d\": coin.get(\n                        \"price_change_percentage_7d_in_currency\"\n                    ),\n                    \"last_updated\": coin.get(\"last_updated\"),\n                }\n            )\n\n        return json.dumps(simplified_data, indent=2)\n\n    except (requests.RequestException, ValueError) as e:\n        return json.dumps(\n            {\n                \"error\": f\"Failed to fetch top cryptocurrencies: {str(e)}\"\n            }\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef search_cryptocurrencies(query: str) -&gt; str:\n    \"\"\"\n    Search for cryptocurrencies by name or symbol.\n\n    Args:\n        query (str): The search term (coin name or symbol)\n\n    Returns:\n        str: JSON formatted string containing search results with coin details\n\n    Raises:\n        requests.RequestException: If the API request fails\n\n    Example:\n        &gt;&gt;&gt; result = search_cryptocurrencies(\"ethereum\")\n        &gt;&gt;&gt; print(result)\n        {\"coins\": [{\"id\": \"ethereum\", \"name\": \"Ethereum\", \"symbol\": \"eth\", ...}]}\n    \"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/search\"\n        params = {\"query\": query}\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Extract and format the results\n        result = {\n            \"coins\": data.get(\"coins\", [])[\n                :10\n            ],  # Limit to top 10 results\n            \"query\": query,\n            \"total_results\": len(data.get(\"coins\", [])),\n        }\n\n        return json.dumps(result, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f'Failed to search for \"{query}\": {str(e)}'}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_jupiter_quote(\n    input_mint: str,\n    output_mint: str,\n    amount: float,\n    slippage: float = 0.5,\n) -&gt; str:\n    \"\"\"\n    Get a quote for token swaps using Jupiter Protocol on Solana.\n\n    Args:\n        input_mint (str): Input token mint address\n        output_mint (str): Output token mint address\n        amount (float): Amount of input tokens to swap\n        slippage (float, optional): Slippage tolerance percentage. Defaults to 0.5.\n\n    Returns:\n        str: JSON formatted string containing the swap quote details\n\n    Example:\n        &gt;&gt;&gt; result = get_jupiter_quote(\"SOL_MINT_ADDRESS\", \"USDC_MINT_ADDRESS\", 1.0)\n        &gt;&gt;&gt; print(result)\n        {\"inputAmount\": \"1000000000\", \"outputAmount\": \"22.5\", \"route\": [...]}\n    \"\"\"\n    try:\n        url = \"https://lite-api.jup.ag/swap/v1/quote\"\n        params = {\n            \"inputMint\": input_mint,\n            \"outputMint\": output_mint,\n            \"amount\": str(int(amount * 1e9)),  # Convert to lamports\n            \"slippageBps\": int(slippage * 100),\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to get Jupiter quote: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_htx_market_data(symbol: str) -&gt; str:\n    \"\"\"\n    Get market data for a trading pair from HTX exchange.\n\n    Args:\n        symbol (str): Trading pair symbol (e.g., 'btcusdt', 'ethusdt')\n\n    Returns:\n        str: JSON formatted string containing market data\n\n    Example:\n        &gt;&gt;&gt; result = get_htx_market_data(\"btcusdt\")\n        &gt;&gt;&gt; print(result)\n        {\"symbol\": \"btcusdt\", \"price\": \"45000\", \"volume\": \"1000000\", ...}\n    \"\"\"\n    try:\n        url = \"https://api.htx.com/market/detail/merged\"\n        params = {\"symbol\": symbol.lower()}\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch HTX market data: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_token_historical_data(\n    token_id: str, days: int = 30, vs_currency: str = \"usd\"\n) -&gt; str:\n    \"\"\"\n    Get historical price and market data for a cryptocurrency.\n\n    Args:\n        token_id (str): The CoinGecko ID of the cryptocurrency\n        days (int, optional): Number of days of historical data. Defaults to 30.\n        vs_currency (str, optional): The target currency. Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing historical price and market data\n\n    Example:\n        &gt;&gt;&gt; result = get_token_historical_data(\"bitcoin\", 7)\n        &gt;&gt;&gt; print(result)\n        {\"prices\": [[timestamp, price], ...], \"market_caps\": [...], \"volumes\": [...]}\n    \"\"\"\n    try:\n        url = f\"https://api.coingecko.com/api/v3/coins/{token_id}/market_chart\"\n        params = {\n            \"vs_currency\": vs_currency,\n            \"days\": days,\n            \"interval\": \"daily\",\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch historical data: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_defi_stats() -&gt; str:\n    \"\"\"\n    Get global DeFi statistics including TVL, trading volumes, and dominance.\n\n    Returns:\n        str: JSON formatted string containing global DeFi statistics\n\n    Example:\n        &gt;&gt;&gt; result = get_defi_stats()\n        &gt;&gt;&gt; print(result)\n        {\"total_value_locked\": 50000000000, \"defi_dominance\": 15.5, ...}\n    \"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/global/decentralized_finance_defi\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch DeFi stats: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_jupiter_tokens() -&gt; str:\n    \"\"\"\n    Get list of tokens supported by Jupiter Protocol on Solana.\n\n    Returns:\n        str: JSON formatted string containing supported tokens\n\n    Example:\n        &gt;&gt;&gt; result = get_jupiter_tokens()\n        &gt;&gt;&gt; print(result)\n        {\"tokens\": [{\"symbol\": \"SOL\", \"mint\": \"...\", \"decimals\": 9}, ...]}\n    \"\"\"\n    try:\n        url = \"https://lite-api.jup.ag/tokens/v1/mints/tradable\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch Jupiter tokens: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_htx_trading_pairs() -&gt; str:\n    \"\"\"\n    Get list of all trading pairs available on HTX exchange.\n\n    Returns:\n        str: JSON formatted string containing trading pairs information\n\n    Example:\n        &gt;&gt;&gt; result = get_htx_trading_pairs()\n        &gt;&gt;&gt; print(result)\n        {\"symbols\": [{\"symbol\": \"btcusdt\", \"state\": \"online\", \"type\": \"spot\"}, ...]}\n    \"\"\"\n    try:\n        url = \"https://api.htx.com/v1/common/symbols\"\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n        return json.dumps(response.json(), indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch HTX trading pairs: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_market_sentiment(coin_ids: List[str]) -&gt; str:\n    \"\"\"\n    Get market sentiment data including social metrics and developer activity.\n\n    Args:\n        coin_ids (List[str]): List of CoinGecko coin IDs\n\n    Returns:\n        str: JSON formatted string containing market sentiment data\n\n    Example:\n        &gt;&gt;&gt; result = get_market_sentiment([\"bitcoin\", \"ethereum\"])\n        &gt;&gt;&gt; print(result)\n        {\"bitcoin\": {\"sentiment_score\": 75, \"social_volume\": 15000, ...}, ...}\n    \"\"\"\n    try:\n        sentiment_data = {}\n        for coin_id in coin_ids:\n            url = f\"https://api.coingecko.com/api/v3/coins/{coin_id}\"\n            params = {\n                \"localization\": False,\n                \"tickers\": False,\n                \"market_data\": False,\n                \"community_data\": True,\n                \"developer_data\": True,\n            }\n\n            response = requests.get(url, params=params, timeout=10)\n            response.raise_for_status()\n            data = response.json()\n\n            sentiment_data[coin_id] = {\n                \"community_score\": data.get(\"community_score\"),\n                \"developer_score\": data.get(\"developer_score\"),\n                \"public_interest_score\": data.get(\n                    \"public_interest_score\"\n                ),\n                \"community_data\": data.get(\"community_data\"),\n                \"developer_data\": data.get(\"developer_data\"),\n            }\n\n            # Rate limiting to avoid API restrictions\n            time.sleep(0.6)\n\n        return json.dumps(sentiment_data, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\"error\": f\"Failed to fetch market sentiment: {str(e)}\"}\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\n# Initialize the agent with expanded tools\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Advanced financial advisor agent with comprehensive cryptocurrency market analysis capabilities across multiple platforms including Jupiter Protocol and HTX\",\n    system_prompt=\"You are an advanced financial advisor agent with access to real-time cryptocurrency data from multiple sources including CoinGecko, Jupiter Protocol, and HTX. You can help users analyze market trends, check prices, find trading opportunities, perform swaps, and get detailed market insights. Always provide accurate, up-to-date information and explain market data in an easy-to-understand way.\",\n    max_loops=1,\n    max_tokens=4096,\n    model_name=\"gpt-4o-mini\",\n    dynamic_temperature_enabled=True,\n    output_type=\"all\",\n    tools=[\n        get_coin_price,\n        get_top_cryptocurrencies,\n        search_cryptocurrencies,\n        get_jupiter_quote,\n        get_htx_market_data,\n        get_token_historical_data,\n        get_defi_stats,\n        get_jupiter_tokens,\n        get_htx_trading_pairs,\n        get_market_sentiment,\n    ],\n    # Upload your tools to the tools parameter here!\n)\n\n# agent.run(\"Use defi stats to find the best defi project to invest in\")\nagent.run(\"Get the market sentiment for bitcoin\")\n# Automatically executes any number and combination of tools you have uploaded to the tools parameter!\n</code></pre>"},{"location":"swarms/examples/agents_as_tools/","title":"Agents as Tools Tutorial","text":"<p>This tutorial demonstrates how to create a powerful multi-agent system where agents can delegate tasks to specialized sub-agents. This pattern is particularly useful for complex tasks that require different types of expertise or capabilities.</p>"},{"location":"swarms/examples/agents_as_tools/#overview","title":"Overview","text":"<p>The Agents as Tools pattern allows you to:</p> <ul> <li> <p>Create specialized agents with specific capabilities</p> </li> <li> <p>Have agents delegate tasks to other agents</p> </li> <li> <p>Chain multiple agents together for complex workflows</p> </li> <li> <p>Maintain separation of concerns between different agent roles</p> </li> </ul>"},{"location":"swarms/examples/agents_as_tools/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.8 or higher</p> </li> <li> <p>Basic understanding of Python programming</p> </li> <li> <p>Familiarity with async/await concepts (optional)</p> </li> </ul>"},{"location":"swarms/examples/agents_as_tools/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"swarms/examples/agents_as_tools/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nANTHROPIC_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/agents_as_tools/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Define Your Tools</p> </li> <li> <p>Create functions that will serve as tools for your agents</p> </li> <li> <p>Add proper type hints and detailed docstrings</p> </li> <li> <p>Include error handling and logging</p> </li> <li> <p>Example:</p> </li> </ol> <pre><code>def my_tool(param: str) -&gt; str:\n    \"\"\"Detailed description of what the tool does.\n\n    Args:\n        param: Description of the parameter\n\n    Returns:\n        Description of the return value\n    \"\"\"\n    # Tool implementation\n    return result\n</code></pre> <ol> <li> <p>Create Specialized Agents</p> </li> <li> <p>Define agents with specific roles and capabilities</p> </li> <li> <p>Configure each agent with appropriate settings</p> </li> <li> <p>Assign relevant tools to each agent</p> </li> </ol> <pre><code>specialized_agent = Agent(\n    agent_name=\"Specialist\",\n    agent_description=\"Expert in specific domain\",\n    system_prompt=\"Detailed instructions for the agent\",\n    tools=[tool1, tool2]\n)\n</code></pre> <ol> <li> <p>Set Up the Director Agent</p> </li> <li> <p>Create a high-level agent that coordinates other agents</p> </li> <li> <p>Give it access to specialized agents as tools</p> </li> <li> <p>Define clear delegation rules</p> </li> </ol> <pre><code>director = Agent(\n    agent_name=\"Director\",\n    agent_description=\"Coordinates other agents\",\n    tools=[specialized_agent.run]\n)\n</code></pre> <ol> <li> <p>Execute Multi-Agent Workflows</p> </li> <li> <p>Start with the director agent</p> </li> <li> <p>Let it delegate tasks as needed</p> </li> <li> <p>Handle responses and chain results</p> </li> </ol> <pre><code>result = director.run(\"Your high-level task description\")\n</code></pre>"},{"location":"swarms/examples/agents_as_tools/#code","title":"Code","text":"<pre><code>import json\nimport requests\nfrom swarms import Agent\n\ndef create_python_file(code: str, filename: str) -&gt; str:\n    \"\"\"Create a Python file with the given code and execute it using Python 3.12.\n\n    This function takes a string containing Python code, writes it to a file, and executes it\n    using Python 3.12 via subprocess. The file will be created in the current working directory.\n    If a file with the same name already exists, it will be overwritten.\n\n    Args:\n        code (str): The Python code to write to the file. This should be valid Python 3.12 code.\n        filename (str): The name of the file to create and execute.\n\n    Returns:\n        str: A detailed message indicating the file was created and the execution result.\n\n    Raises:\n        IOError: If there are any issues writing to the file.\n        subprocess.SubprocessError: If there are any issues executing the file.\n\n    Example:\n        &gt;&gt;&gt; code = \"print('Hello, World!')\"\n        &gt;&gt;&gt; result = create_python_file(code, \"test.py\")\n        &gt;&gt;&gt; print(result)\n        'Python file created successfully. Execution result: Hello, World!'\n    \"\"\"\n    import subprocess\n    import os\n    import datetime\n\n    # Get current timestamp for logging\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Write the code to file\n    with open(filename, \"w\") as f:\n        f.write(code)\n\n    # Get file size and permissions\n    file_stats = os.stat(filename)\n    file_size = file_stats.st_size\n    file_permissions = oct(file_stats.st_mode)[-3:]\n\n    # Execute the file using Python 3.12 and capture output\n    try:\n        result = subprocess.run(\n            [\"python3.12\", filename],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n\n        # Create detailed response\n        response = f\"\"\"\nFile Creation Details:\n----------------------\nTimestamp: {timestamp}\nFilename: {filename}\nFile Size: {file_size} bytes\nFile Permissions: {file_permissions}\nLocation: {os.path.abspath(filename)}\n\nExecution Details:\n-----------------\nExit Code: {result.returncode}\nExecution Time: {result.returncode} seconds\n\nOutput:\n-------\n{result.stdout}\n\nError Output (if any):\n--------------------\n{result.stderr}\n\"\"\"\n        return response\n    except subprocess.CalledProcessError as e:\n        error_response = f\"\"\"\nFile Creation Details:\n----------------------\nTimestamp: {timestamp}\nFilename: {filename}\nFile Size: {file_size} bytes\nFile Permissions: {file_permissions}\nLocation: {os.path.abspath(filename)}\n\nExecution Error:\n---------------\nExit Code: {e.returncode}\nError Message: {e.stderr}\n\nCommand Output:\n-------------\n{e.stdout}\n\"\"\"\n        return error_response\n\n\n\n\n\n\ndef update_python_file(code: str, filename: str) -&gt; str:\n    \"\"\"Update an existing Python file with new code and execute it using Python 3.12.\n\n    This function takes a string containing Python code and updates an existing Python file.\n    If the file doesn't exist, it will be created. The file will be executed using Python 3.12.\n\n    Args:\n        code (str): The Python code to write to the file. This should be valid Python 3.12 code.\n        filename (str): The name of the file to update and execute.\n\n    Returns:\n        str: A detailed message indicating the file was updated and the execution result.\n\n    Raises:\n        IOError: If there are any issues writing to the file.\n        subprocess.SubprocessError: If there are any issues executing the file.\n\n    Example:\n        &gt;&gt;&gt; code = \"print('Updated code!')\"\n        &gt;&gt;&gt; result = update_python_file(code, \"my_script.py\")\n        &gt;&gt;&gt; print(result)\n        'Python file updated successfully. Execution result: Updated code!'\n    \"\"\"\n    import subprocess\n    import os\n    import datetime\n\n    # Get current timestamp for logging\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    # Check if file exists and get its stats\n    file_exists = os.path.exists(filename)\n    if file_exists:\n        old_stats = os.stat(filename)\n        old_size = old_stats.st_size\n        old_permissions = oct(old_stats.st_mode)[-3:]\n\n    # Write the code to file\n    with open(filename, \"w\") as f:\n        f.write(code)\n\n    # Get new file stats\n    new_stats = os.stat(filename)\n    new_size = new_stats.st_size\n    new_permissions = oct(new_stats.st_mode)[-3:]\n\n    # Execute the file using Python 3.12 and capture output\n    try:\n        result = subprocess.run(\n            [\"python3.12\", filename],\n            capture_output=True,\n            text=True,\n            check=True\n        )\n\n        # Create detailed response\n        response = f\"\"\"\nFile Update Details:\n-------------------\nTimestamp: {timestamp}\nFilename: {filename}\nPrevious Status: {'Existed' if file_exists else 'Did not exist'}\nPrevious Size: {old_size if file_exists else 'N/A'} bytes\nPrevious Permissions: {old_permissions if file_exists else 'N/A'}\nNew Size: {new_size} bytes\nNew Permissions: {new_permissions}\nLocation: {os.path.abspath(filename)}\n\nExecution Details:\n-----------------\nExit Code: {result.returncode}\nExecution Time: {result.returncode} seconds\n\nOutput:\n-------\n{result.stdout}\n\nError Output (if any):\n--------------------\n{result.stderr}\n\"\"\"\n        return response\n    except subprocess.CalledProcessError as e:\n        error_response = f\"\"\"\n        File Update Details:\n        -------------------\n        Timestamp: {timestamp}\n        Filename: {filename}\n        Previous Status: {'Existed' if file_exists else 'Did not exist'}\n        Previous Size: {old_size if file_exists else 'N/A'} bytes\n        Previous Permissions: {old_permissions if file_exists else 'N/A'}\n        New Size: {new_size} bytes\n        New Permissions: {new_permissions}\n        Location: {os.path.abspath(filename)}\n\n        Execution Error:\n        ---------------\n        Exit Code: {e.returncode}\n        Error Message: {e.stderr}\n\n        Command Output:\n        -------------\n        {e.stdout}\n        \"\"\"\n        return error_response\n\n\ndef run_quant_trading_agent(task: str) -&gt; str:\n    \"\"\"Run a quantitative trading agent to analyze and execute trading strategies.\n\n    This function initializes and runs a specialized quantitative trading agent that can:\n    - Develop and backtest trading strategies\n    - Analyze market data for alpha opportunities\n    - Implement risk management frameworks\n    - Optimize portfolio allocations\n    - Conduct quantitative research\n    - Monitor market microstructure\n    - Evaluate trading system performance\n\n    Args:\n        task (str): The specific trading task or analysis to perform\n\n    Returns:\n        str: The agent's response or analysis results\n\n    Example:\n        &gt;&gt;&gt; result = run_quant_trading_agent(\"Analyze SPY ETF for mean reversion opportunities\")\n        &gt;&gt;&gt; print(result)\n    \"\"\"\n    # Initialize the agent\n    agent = Agent(\n        agent_name=\"Quantitative-Trading-Agent\",\n        agent_description=\"Advanced quantitative trading and algorithmic analysis agent\",\n        system_prompt=\"\"\"You are an expert quantitative trading agent with deep expertise in:\n        - Algorithmic trading strategies and implementation\n        - Statistical arbitrage and market making\n        - Risk management and portfolio optimization\n        - High-frequency trading systems\n        - Market microstructure analysis\n        - Quantitative research methodologies\n        - Financial mathematics and stochastic processes\n        - Machine learning applications in trading\n\n        Your core responsibilities include:\n        1. Developing and backtesting trading strategies\n        2. Analyzing market data and identifying alpha opportunities\n        3. Implementing risk management frameworks\n        4. Optimizing portfolio allocations\n        5. Conducting quantitative research\n        6. Monitoring market microstructure\n        7. Evaluating trading system performance\n\n        You maintain strict adherence to:\n        - Mathematical rigor in all analyses\n        - Statistical significance in strategy development\n        - Risk-adjusted return optimization\n        - Market impact minimization\n        - Regulatory compliance\n        - Transaction cost analysis\n        - Performance attribution\n\n        You communicate in precise, technical terms while maintaining clarity for stakeholders.\"\"\",\n        max_loops=2,\n        model_name=\"claude-3-5-sonnet-20240620\",\n        tools=[create_python_file, update_python_file, backtest_summary],\n    )\n\n    out = agent.run(task)\n    return out\n\n\n\ndef backtest_summary(report: str) -&gt; str:\n    \"\"\"Generate a summary of a backtest report, but only if the backtest was profitable.\n\n    This function should only be used when the backtest results show a positive return.\n    Using this function for unprofitable backtests may lead to misleading conclusions.\n\n    Args:\n        report (str): The backtest report containing performance metrics\n\n    Returns:\n        str: A formatted summary of the backtest report\n\n    Example:\n        &gt;&gt;&gt; result = backtest_summary(\"Total Return: +15.2%, Sharpe: 1.8\")\n        &gt;&gt;&gt; print(result)\n        'The backtest report is: Total Return: +15.2%, Sharpe: 1.8'\n    \"\"\"\n    return f\"The backtest report is: {report}\"\n\ndef get_coin_price(coin_id: str, vs_currency: str) -&gt; str:\n    \"\"\"\n    Get the current price of a specific cryptocurrency.\n\n    Args:\n        coin_id (str): The CoinGecko ID of the cryptocurrency (e.g., 'bitcoin', 'ethereum')\n        vs_currency (str, optional): The target currency. Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing the coin's current price and market data\n\n    Raises:\n        requests.RequestException: If the API request fails\n\n    Example:\n        &gt;&gt;&gt; result = get_coin_price(\"bitcoin\")\n        &gt;&gt;&gt; print(result)\n        {\"bitcoin\": {\"usd\": 45000, \"usd_market_cap\": 850000000000, ...}}\n    \"\"\"\n    try:\n        url = \"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id,\n            \"vs_currencies\": vs_currency,\n            \"include_market_cap\": True,\n            \"include_24hr_vol\": True,\n            \"include_24hr_change\": True,\n            \"include_last_updated_at\": True,\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n        return json.dumps(data, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps(\n            {\n                \"error\": f\"Failed to fetch price for {coin_id}: {str(e)}\"\n            }\n        )\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\n\ndef run_crypto_quant_agent(task: str) -&gt; str:\n    \"\"\"\n    Run a crypto quantitative trading agent with specialized tools for cryptocurrency market analysis.\n\n    This function initializes and runs a quantitative trading agent specifically designed for\n    cryptocurrency markets. The agent is equipped with tools for price fetching and can perform\n    various quantitative analyses including algorithmic trading strategy development, risk management,\n    and market microstructure analysis.\n\n    Args:\n        task (str): The task or query to be processed by the crypto quant agent.\n\n    Returns:\n        str: The agent's response to the given task.\n\n    Example:\n        &gt;&gt;&gt; response = run_crypto_quant_agent(\"Analyze the current market conditions for Bitcoin\")\n        &gt;&gt;&gt; print(response)\n        \"Based on current market analysis...\"\n    \"\"\"\n    # Initialize the agent with expanded tools\n    quant_agent = Agent(\n        agent_name=\"Crypto-Quant-Agent\",\n        agent_description=\"Advanced quantitative trading agent specializing in cryptocurrency markets with algorithmic analysis capabilities\",\n        system_prompt=\"\"\"You are an expert quantitative trading agent specializing in cryptocurrency markets. Your capabilities include:\n        - Algorithmic trading strategy development and backtesting\n        - Statistical arbitrage and market making for crypto assets\n        - Risk management and portfolio optimization for digital assets\n        - High-frequency trading system design for crypto markets\n        - Market microstructure analysis of crypto exchanges\n        - Quantitative research methodologies for crypto assets\n        - Financial mathematics and stochastic processes\n        - Machine learning applications in crypto trading\n\n        You maintain strict adherence to:\n        - Mathematical rigor in all analyses\n        - Statistical significance in strategy development\n        - Risk-adjusted return optimization\n        - Market impact minimization\n        - Regulatory compliance\n        - Transaction cost analysis\n        - Performance attribution\n\n        You communicate in precise, technical terms while maintaining clarity for stakeholders.\"\"\",\n        max_loops=1,\n        max_tokens=4096,\n        model_name=\"gpt-4.1-mini\",\n        dynamic_temperature_enabled=True,\n        output_type=\"final\",\n        tools=[\n            get_coin_price,\n        ],\n    )\n\n    return quant_agent.run(task)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Director-Agent\",\n    agent_description=\"Strategic director and project management agent\",\n    system_prompt=\"\"\"You are an expert Director Agent with comprehensive capabilities in:\n    - Strategic planning and decision making\n    - Project management and coordination\n    - Resource allocation and optimization\n    - Team leadership and delegation\n    - Risk assessment and mitigation\n    - Stakeholder management\n    - Process optimization\n    - Quality assurance\n\n    Your core responsibilities include:\n    1. Developing and executing strategic initiatives\n    2. Coordinating cross-functional projects\n    3. Managing resource allocation\n    4. Setting and tracking KPIs\n    5. Ensuring project deliverables\n    6. Risk management and mitigation\n    7. Stakeholder communication\n\n    You maintain strict adherence to:\n    - Best practices in project management\n    - Data-driven decision making\n    - Clear communication protocols\n    - Quality standards\n    - Timeline management\n    - Budget constraints\n    - Regulatory compliance\n\n    You communicate with clarity and authority while maintaining professionalism and ensuring all stakeholders are aligned.\"\"\",\n    max_loops=1,\n    model_name=\"gpt-4o-mini\",\n    output_type=\"final\",\n    interactive=False,\n    tools=[run_quant_trading_agent],\n)\n\nout = agent.run(\"\"\"\n    Please call the quantitative trading agent to generate Python code for an Bitcoin backtest using the CoinGecko API.\n    Provide a comprehensive description of the backtest methodology and trading strategy.\n    Consider the API limitations of CoinGecko and utilize only free, open-source libraries that don't require API keys. Use the requests library to fetch the data. Create a specialized strategy for the backtest focused on the orderbook and other data for price action.\n    The goal is to create a backtest that can predict the price action of the coin based on the orderbook and other data.\n    Maximize the profit of the backtest. Please use the OKX price API for the orderbook and other data. Be very explicit in your implementation.\n    Be very precise with the instructions you give to the agent and tell it to a 400 lines of good code.\n\"\"\")\nprint(out)\n</code></pre>"},{"location":"swarms/examples/agents_as_tools/#best-practices","title":"Best Practices","text":"Category Best Practice Description Tool Design Single Purpose Keep tools focused and single-purpose Clear Naming Use clear, descriptive names Error Handling Include comprehensive error handling Documentation Add detailed documentation Agent Configuration Clear Role Give each agent a clear, specific role System Prompts Provide detailed system prompts Model Parameters Configure appropriate model and parameters Resource Limits Set reasonable limits on iterations and tokens Error Handling Multi-level Implement proper error handling at each level Logging Include logging for debugging API Management Handle API rate limits and timeouts Fallbacks Provide fallback options when possible Performance Optimization Async Operations Use async operations where appropriate Caching Implement caching when possible Token Usage Monitor and optimize token usage Batch Processing Consider batch operations for efficiency"},{"location":"swarms/examples/aggregate/","title":"Aggregate Multi-Agent Responses","text":"<p>The <code>aggregate</code> function allows you to run multiple agents concurrently on the same task and then synthesize their responses using an intelligent aggregator agent. This is useful for getting diverse perspectives on a problem and then combining them into a comprehensive analysis.</p>"},{"location":"swarms/examples/aggregate/#installation","title":"Installation","text":"<p>You can get started by first installing swarms with the following command, or click here for more detailed installation instructions:</p> <pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/aggregate/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"\"\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/aggregate/#how-it-works","title":"How It Works","text":"<ol> <li>Concurrent Execution: All agents in the <code>workers</code> list run the same task simultaneously</li> <li>Response Collection: Individual agent responses are collected into a conversation</li> <li>Intelligent Aggregation: A specialized aggregator agent analyzes all responses and creates a comprehensive synthesis</li> <li>Formatted Output: The final result is returned in the specified format</li> </ol>"},{"location":"swarms/examples/aggregate/#code-example","title":"Code Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.ma_blocks import aggregate\n\n\n# Create specialized agents for different perspectives\nagents = [\n    Agent(\n        agent_name=\"Sector-Financial-Analyst\",\n        agent_description=\"Senior financial analyst at BlackRock.\",\n        system_prompt=\"You are a financial analyst tasked with optimizing asset allocations for a $50B portfolio. Provide clear, quantitative recommendations for each sector.\",\n        max_loops=1,\n        model_name=\"gpt-4o-mini\",\n        max_tokens=3000,\n    ),\n    Agent(\n        agent_name=\"Sector-Risk-Analyst\",\n        agent_description=\"Expert risk management analyst.\",\n        system_prompt=\"You are a risk analyst responsible for advising on risk allocation within a $50B portfolio. Provide detailed insights on risk exposures for each sector.\",\n        max_loops=1,\n        model_name=\"gpt-4o-mini\",\n        max_tokens=3000,\n    ),\n    Agent(\n        agent_name=\"Tech-Sector-Analyst\",\n        agent_description=\"Technology sector analyst.\",\n        system_prompt=\"You are a tech sector analyst focused on capital and risk allocations. Provide data-backed insights for the tech sector.\",\n        max_loops=1,\n        model_name=\"gpt-4o-mini\",\n        max_tokens=3000,\n    ),\n]\n\n# Run the aggregate function\nresult = aggregate(\n    workers=agents,\n    task=\"What is the best sector to invest in?\",\n    type=\"all\",  # Get complete conversation history\n    aggregator_model_name=\"anthropic/claude-3-sonnet-20240229\"\n)\n\nprint(result)\n</code></pre>"},{"location":"swarms/examples/basic_agent/","title":"Basic Agent Example","text":"<p>This example demonstrates how to create and configure a sophisticated AI agent using the Swarms framework. In this tutorial, we'll build a Quantitative Trading Agent that can analyze financial markets and provide investment insights. The agent is powered by GPT models and can be customized for various financial analysis tasks.</p>"},{"location":"swarms/examples/basic_agent/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.7+</p> </li> <li> <p>OpenAI API key</p> </li> <li> <p>Swarms library</p> </li> </ul>"},{"location":"swarms/examples/basic_agent/#tutorial-steps","title":"Tutorial Steps","text":"<ol> <li>First, install the latest version of Swarms:</li> </ol> <pre><code>pip3 install -U swarms\n</code></pre> <ol> <li>Set up your environment variables in a <code>.env</code> file:</li> </ol> <pre><code>OPENAI_API_KEY=\"your-api-key-here\"\nWORKSPACE_DIR=\"agent_workspace\"\n</code></pre> <ol> <li>Create a new Python file and customize your agent with the following parameters:</li> <li> <p><code>agent_name</code>: A unique identifier for your agent</p> </li> <li> <p><code>agent_description</code>: A detailed description of your agent's capabilities</p> </li> <li> <p><code>system_prompt</code>: The core instructions that define your agent's behavior</p> </li> <li> <p><code>model_name</code>: The GPT model to use</p> </li> <li> <p>Additional configuration options for temperature and output format</p> </li> <li> <p>Run the example code below:</p> </li> </ol>"},{"location":"swarms/examples/basic_agent/#code","title":"Code","text":"<pre><code>import time\nfrom swarms import Agent\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Quantitative-Trading-Agent\",\n    agent_description=\"Advanced quantitative trading and algorithmic analysis agent\",\n    system_prompt=\"\"\"You are an expert quantitative trading agent with deep expertise in:\n    - Algorithmic trading strategies and implementation\n    - Statistical arbitrage and market making\n    - Risk management and portfolio optimization\n    - High-frequency trading systems\n    - Market microstructure analysis\n    - Quantitative research methodologies\n    - Financial mathematics and stochastic processes\n    - Machine learning applications in trading\n\n    Your core responsibilities include:\n    1. Developing and backtesting trading strategies\n    2. Analyzing market data and identifying alpha opportunities\n    3. Implementing risk management frameworks\n    4. Optimizing portfolio allocations\n    5. Conducting quantitative research\n    6. Monitoring market microstructure\n    7. Evaluating trading system performance\n\n    You maintain strict adherence to:\n    - Mathematical rigor in all analyses\n    - Statistical significance in strategy development\n    - Risk-adjusted return optimization\n    - Market impact minimization\n    - Regulatory compliance\n    - Transaction cost analysis\n    - Performance attribution\n\n    You communicate in precise, technical terms while maintaining clarity for stakeholders.\"\"\",\n    max_loops=1,\n    model_name=\"gpt-4o-mini\",\n    dynamic_temperature_enabled=True,\n    output_type=\"json\",\n    safety_prompt_on=True,\n)\n\nout = agent.run(\"What are the best top 3 etfs for gold coverage?\")\n\ntime.sleep(10)\nprint(out)\n</code></pre>"},{"location":"swarms/examples/basic_agent/#example-output","title":"Example Output","text":"<p>The agent will return a JSON response containing recommendations for gold ETFs based on the query.</p>"},{"location":"swarms/examples/basic_agent/#customization","title":"Customization","text":"<p>You can modify the system prompt and agent parameters to create specialized agents for different use cases:</p> Use Case Description Market Analysis Analyze market trends, patterns, and indicators to identify trading opportunities Portfolio Management Optimize asset allocation and rebalancing strategies Risk Assessment Evaluate and mitigate potential risks in trading strategies Trading Strategy Development Design and implement algorithmic trading strategies"},{"location":"swarms/examples/claude/","title":"Agent with Anthropic/Claude","text":"<ul> <li> <p>Get their api keys and put it in the <code>.env</code></p> </li> <li> <p>Select your model_name like <code>claude-3-sonnet-20240229</code> follows LiteLLM conventions</p> </li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"claude-3-sonnet-20240229\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/cohere/","title":"Agent with Cohere","text":"<ul> <li> <p>Add your <code>COHERE_API_KEY</code> in the <code>.env</code> file</p> </li> <li> <p>Select your model_name like <code>command-r</code> follows LiteLLM conventions</p> </li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"command-r\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/concurrent_workflow/","title":"ConcurrentWorkflow Examples","text":"<p>The ConcurrentWorkflow architecture enables parallel execution of multiple agents, allowing them to work simultaneously on different aspects of a task. This is particularly useful for complex tasks that can be broken down into independent subtasks.</p>"},{"location":"swarms/examples/concurrent_workflow/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>OpenAI API key or other supported LLM provider keys</li> <li>Swarms library</li> </ul>"},{"location":"swarms/examples/concurrent_workflow/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/concurrent_workflow/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/concurrent_workflow/#basic-usage","title":"Basic Usage","text":""},{"location":"swarms/examples/concurrent_workflow/#1-initialize-specialized-agents","title":"1. Initialize Specialized Agents","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.concurrent_workflow import ConcurrentWorkflow\n\n# Initialize market research agent\nmarket_researcher = Agent(\n    agent_name=\"Market-Researcher\",\n    system_prompt=\"\"\"You are a market research specialist. Your tasks include:\n    1. Analyzing market trends and patterns\n    2. Identifying market opportunities and threats\n    3. Evaluating competitor strategies\n    4. Assessing customer needs and preferences\n    5. Providing actionable market insights\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\n# Initialize financial analyst agent\nfinancial_analyst = Agent(\n    agent_name=\"Financial-Analyst\",\n    system_prompt=\"\"\"You are a financial analysis expert. Your responsibilities include:\n    1. Analyzing financial statements\n    2. Evaluating investment opportunities\n    3. Assessing risk factors\n    4. Providing financial forecasts\n    5. Recommending financial strategies\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\n# Initialize technical analyst agent\ntechnical_analyst = Agent(\n    agent_name=\"Technical-Analyst\",\n    system_prompt=\"\"\"You are a technical analysis specialist. Your focus areas include:\n    1. Analyzing price patterns and trends\n    2. Evaluating technical indicators\n    3. Identifying support and resistance levels\n    4. Assessing market momentum\n    5. Providing trading recommendations\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\n# Create list of agents\nagents = [market_researcher, financial_analyst, technical_analyst]\n\n# Initialize the concurrent workflow with dashboard\nrouter = ConcurrentWorkflow(\n    name=\"market-analysis-router\",\n    agents=agents,\n    max_loops=1,\n    show_dashboard=True,  # Enable the real-time dashboard\n)\n\n# Run the workflow\nresult = router.run(\n    \"Analyze Tesla (TSLA) stock from market, financial, and technical perspectives\"\n)\n</code></pre>"},{"location":"swarms/examples/concurrent_workflow/#features","title":"Features","text":""},{"location":"swarms/examples/concurrent_workflow/#real-time-dashboard","title":"Real-time Dashboard","text":"<p>The ConcurrentWorkflow now includes a real-time dashboard feature that can be enabled by setting <code>show_dashboard=True</code>. This provides:</p> <ul> <li>Live status of each agent's execution</li> <li>Progress tracking</li> <li>Real-time output visualization</li> <li>Task completion metrics</li> </ul>"},{"location":"swarms/examples/concurrent_workflow/#concurrent-execution","title":"Concurrent Execution","text":"<ul> <li>Multiple agents work simultaneously</li> <li>Efficient resource utilization</li> <li>Automatic task distribution</li> <li>Built-in thread management</li> </ul>"},{"location":"swarms/examples/concurrent_workflow/#best-practices","title":"Best Practices","text":"<ol> <li>Task Distribution:</li> <li>Break down complex tasks into independent subtasks</li> <li>Assign appropriate agents to each subtask</li> <li> <p>Ensure tasks can be processed concurrently</p> </li> <li> <p>Agent Configuration:</p> </li> <li>Use specialized agents for specific tasks</li> <li>Configure appropriate model parameters</li> <li> <p>Set meaningful system prompts</p> </li> <li> <p>Resource Management:</p> </li> <li>Monitor concurrent execution through the dashboard</li> <li>Handle rate limits appropriately</li> <li> <p>Manage memory usage</p> </li> <li> <p>Error Handling:</p> </li> <li>Implement proper error handling</li> <li>Log errors and exceptions</li> <li>Provide fallback mechanisms</li> </ol>"},{"location":"swarms/examples/concurrent_workflow/#example-implementation","title":"Example Implementation","text":"<p>Here's a complete example showing how to use ConcurrentWorkflow for a comprehensive market analysis:</p> <pre><code>from swarms import Agent\nfrom swarms.structs.concurrent_workflow import ConcurrentWorkflow\n\n# Initialize specialized agents\nmarket_analyst = Agent(\n    agent_name=\"Market-Analyst\",\n    system_prompt=\"\"\"You are a market analysis specialist focusing on:\n    1. Market trends and patterns\n    2. Competitive analysis\n    3. Market opportunities\n    4. Industry dynamics\n    5. Growth potential\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\nfinancial_analyst = Agent(\n    agent_name=\"Financial-Analyst\",\n    system_prompt=\"\"\"You are a financial analysis expert specializing in:\n    1. Financial statements analysis\n    2. Ratio analysis\n    3. Cash flow analysis\n    4. Valuation metrics\n    5. Risk assessment\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\nrisk_analyst = Agent(\n    agent_name=\"Risk-Analyst\",\n    system_prompt=\"\"\"You are a risk assessment specialist focusing on:\n    1. Market risks\n    2. Operational risks\n    3. Financial risks\n    4. Regulatory risks\n    5. Strategic risks\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1,\n    temperature=0.7,\n)\n\n# Create the concurrent workflow with dashboard\nworkflow = ConcurrentWorkflow(\n    name=\"comprehensive-analysis-workflow\",\n    agents=[market_analyst, financial_analyst, risk_analyst],\n    max_loops=1,\n    show_dashboard=True,  # Enable real-time monitoring\n)\n\ntry:\n    result = workflow.run(\n        \"\"\"Provide a comprehensive analysis of Apple Inc. (AAPL) including:\n        1. Market position and competitive analysis\n        2. Financial performance and health\n        3. Risk assessment and mitigation strategies\"\"\"\n    )\n\n    # Process and display results\n    print(\"\\nAnalysis Results:\")\n    print(\"=\" * 50)\n    for agent_output in result:\n        print(f\"\\nAnalysis from {agent_output['agent']}:\")\n        print(\"-\" * 40)\n        print(agent_output['output'])\n\nexcept Exception as e:\n    print(f\"Error during analysis: {str(e)}\")\n</code></pre> <p>This guide demonstrates how to effectively use the ConcurrentWorkflow architecture with its new dashboard feature for parallel processing of complex tasks using multiple specialized agents. </p>"},{"location":"swarms/examples/deepseek/","title":"Agent with DeepSeek","text":"<ul> <li> <p>Add your <code>DEEPSEEK_API_KEY</code> in the <code>.env</code> file</p> </li> <li> <p>Select your model_name like <code>deepseek/deepseek-chat</code> follows LiteLLM conventions</p> </li> <li> <p>Execute your agent!</p> </li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"deepseek/deepseek-chat\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/deepseek/#r1","title":"R1","text":"<p>This is a simple example of how to use the DeepSeek Reasoner model otherwise known as R1.</p> <pre><code>import os\nfrom swarms import Agent\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"deepseek/deepseek-reasoner\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/groq/","title":"Agent with Groq","text":"<ul> <li> <p>Add your <code>GROQ_API_KEY</code></p> </li> <li> <p>Initiate your agent</p> </li> <li> <p>Run your agent</p> </li> </ul> <pre><code>import os\n\nfrom swarm_models import OpenAIChat\n\nfrom swarms import Agent\n\ncompany = \"NVDA\"\n\n\n# Initialize the Managing Director agent\nmanaging_director = Agent(\n    agent_name=\"Managing-Director\",\n    system_prompt=f\"\"\"\n    As the Managing Director at Blackstone, your role is to oversee the entire investment analysis process for potential acquisitions. \n    Your responsibilities include:\n    1. Setting the overall strategy and direction for the analysis\n    2. Coordinating the efforts of the various team members and ensuring a comprehensive evaluation\n    3. Reviewing the findings and recommendations from each team member\n    4. Making the final decision on whether to proceed with the acquisition\n\n    For the current potential acquisition of {company}, direct the tasks for the team to thoroughly analyze all aspects of the company, including its financials, industry position, technology, market potential, and regulatory compliance. Provide guidance and feedback as needed to ensure a rigorous and unbiased assessment.\n    \"\"\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"managing-director.json\",\n)\n</code></pre>"},{"location":"swarms/examples/groupchat_example/","title":"GroupChat Example","text":"<p>Overview</p> <p>Learn how to create and configure a group chat with multiple AI agents using the Swarms framework. This example demonstrates how to set up agents for expense analysis and budget advising.</p>"},{"location":"swarms/examples/groupchat_example/#prerequisites","title":"Prerequisites","text":"<p>Before You Begin</p> <p>Make sure you have: - Python 3.7+ installed - A valid API key for your model provider - The Swarms package installed</p>"},{"location":"swarms/examples/groupchat_example/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#environment-setup","title":"Environment Setup","text":"<p>API Key Configuration</p> <p>Set your API key in the <code>.env</code> file: <pre><code>OPENAI_API_KEY=\"your-api-key-here\"\n</code></pre></p>"},{"location":"swarms/examples/groupchat_example/#code-implementation","title":"Code Implementation","text":""},{"location":"swarms/examples/groupchat_example/#import-required-modules","title":"Import Required Modules","text":"<pre><code>from dotenv import load_dotenv\nimport os\nfrom swarms import Agent, GroupChat\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#configure-agents","title":"Configure Agents","text":"<p>Agent Configuration</p> <p>Here's how to set up your agents with specific roles:</p> <pre><code># Expense Analysis Agent\nagent1 = Agent(\n    agent_name=\"Expense-Analysis-Agent\",\n    description=\"You are an accounting agent specializing in analyzing potential expenses.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    autosave=False,\n    dashboard=False,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    user_name=\"swarms_corp\",\n    retry_attempts=1,\n    context_length=200000,\n    output_type=\"string\",\n    streaming_on=False,\n    max_tokens=15000,\n)\n\n# Budget Adviser Agent\nagent2 = Agent(\n    agent_name=\"Budget-Adviser-Agent\",\n    description=\"You are a budget adviser who provides insights on managing and optimizing expenses.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    autosave=False,\n    dashboard=False,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    user_name=\"swarms_corp\",\n    retry_attempts=1,\n    context_length=200000,\n    output_type=\"string\",\n    streaming_on=False,\n    max_tokens=15000,\n)\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#initialize-groupchat","title":"Initialize GroupChat","text":"<p>GroupChat Setup</p> <p>Configure the GroupChat with your agents:</p> <pre><code>agents = [agent1, agent2]\n\nchat = GroupChat(\n    name=\"Expense Advisory\",\n    description=\"Accounting group focused on discussing potential expenses\",\n    agents=agents,\n    max_loops=1,\n    output_type=\"all\",\n)\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#run-the-chat","title":"Run the Chat","text":"<p>Execute the Chat</p> <p>Start the conversation between agents:</p> <pre><code>history = chat.run(\n    \"What potential expenses should we consider for the upcoming quarter? Please collaborate to outline a comprehensive list.\"\n)\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#complete-example","title":"Complete Example","text":"<p>Full Implementation</p> <p>Here's the complete code combined:</p> <pre><code>from dotenv import load_dotenv\nimport os\nfrom swarms import Agent, GroupChat\n\nif __name__ == \"__main__\":\n    # Load environment variables\n    load_dotenv()\n    api_key = os.getenv(\"OPENAI_API_KEY\")\n\n    # Configure agents\n    agent1 = Agent(\n        agent_name=\"Expense-Analysis-Agent\",\n        description=\"You are an accounting agent specializing in analyzing potential expenses.\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1,\n        autosave=False,\n        dashboard=False,\n        verbose=True,\n        dynamic_temperature_enabled=True,\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n        context_length=200000,\n        output_type=\"string\",\n        streaming_on=False,\n        max_tokens=15000,\n    )\n\n    agent2 = Agent(\n        agent_name=\"Budget-Adviser-Agent\",\n        description=\"You are a budget adviser who provides insights on managing and optimizing expenses.\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1,\n        autosave=False,\n        dashboard=False,\n        verbose=True,\n        dynamic_temperature_enabled=True,\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n        context_length=200000,\n        output_type=\"string\",\n        streaming_on=False,\n        max_tokens=15000,\n    )\n\n    # Initialize GroupChat\n    agents = [agent1, agent2]\n    chat = GroupChat(\n        name=\"Expense Advisory\",\n        description=\"Accounting group focused on discussing potential expenses\",\n        agents=agents,\n        max_loops=1,\n        output_type=\"all\",\n    )\n\n    # Run the chat\n    history = chat.run(\n        \"What potential expenses should we consider for the upcoming quarter? Please collaborate to outline a comprehensive list.\"\n    )\n</code></pre>"},{"location":"swarms/examples/groupchat_example/#configuration-options","title":"Configuration Options","text":"<p>Key Parameters</p> Parameter Description Default <code>max_loops</code> Maximum number of conversation loops 1 <code>autosave</code> Enable automatic saving of chat history False <code>dashboard</code> Enable dashboard visualization False <code>verbose</code> Enable detailed logging True <code>dynamic_temperature_enabled</code> Enable dynamic temperature adjustment True <code>retry_attempts</code> Number of retry attempts for failed operations 1 <code>context_length</code> Maximum context length for the model 200000 <code>max_tokens</code> Maximum tokens for model output 15000"},{"location":"swarms/examples/groupchat_example/#next-steps","title":"Next Steps","text":"<p>What to Try Next</p> <ol> <li>Experiment with different agent roles and descriptions</li> <li>Adjust the <code>max_loops</code> parameter to allow for longer conversations</li> <li>Enable the dashboard to visualize agent interactions</li> <li>Try different model configurations and parameters</li> </ol>"},{"location":"swarms/examples/groupchat_example/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues</p> <ul> <li>Ensure your API key is correctly set in the <code>.env</code> file</li> <li>Check that all required dependencies are installed</li> <li>Verify that your model provider's API is accessible</li> <li>Monitor the <code>verbose</code> output for detailed error messages</li> </ul>"},{"location":"swarms/examples/groupchat_example/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swarms Documentation</li> <li>API Reference</li> <li>Examples Gallery</li> </ul>"},{"location":"swarms/examples/hhcs_examples/","title":"Hybrid Hierarchical-Cluster Swarm (HHCS) Example","text":"<ol> <li>Get your GROQ api key</li> <li>Create a <code>.env</code> file in the root directory and add your API key: <code>GROQ_API_KEY</code></li> <li>Write the following code:</li> <li>Run the file</li> </ol> <pre><code>from swarms import Agent, SwarmRouter, HybridHierarchicalClusterSwarm\n\n\n# Core Legal Agent Definitions with short, simple prompts\nlitigation_agent = Agent(\n    agent_name=\"Litigator\",\n    system_prompt=\"You handle lawsuits. Analyze facts, build arguments, and develop case strategy.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\ncorporate_agent = Agent(\n    agent_name=\"Corporate-Attorney\",\n    system_prompt=\"You handle business law. Advise on corporate structure, governance, and transactions.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nip_agent = Agent(\n    agent_name=\"IP-Attorney\",\n    system_prompt=\"You protect intellectual property. Handle patents, trademarks, copyrights, and trade secrets.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nemployment_agent = Agent(\n    agent_name=\"Employment-Attorney\",\n    system_prompt=\"You handle workplace matters. Address hiring, termination, discrimination, and labor issues.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nparalegal_agent = Agent(\n    agent_name=\"Paralegal\",\n    system_prompt=\"You assist attorneys. Conduct research, draft documents, and organize case files.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\ndoc_review_agent = Agent(\n    agent_name=\"Document-Reviewer\",\n    system_prompt=\"You examine documents. Extract key information and identify relevant content.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\n# Practice Area Swarm Routers\nlitigation_swarm = SwarmRouter(\n    name=\"litigation-practice\",\n    description=\"Handle all aspects of litigation\",\n    agents=[litigation_agent, paralegal_agent, doc_review_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\ncorporate_swarm = SwarmRouter(\n    name=\"corporate-practice\",\n    description=\"Handle business and corporate legal matters\",\n    agents=[corporate_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\nip_swarm = SwarmRouter(\n    name=\"ip-practice\",\n    description=\"Handle intellectual property matters\",\n    agents=[ip_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\nemployment_swarm = SwarmRouter(\n    name=\"employment-practice\",\n    description=\"Handle employment and labor law matters\",\n    agents=[employment_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\n# Cross-functional Swarm Router\nm_and_a_swarm = SwarmRouter(\n    name=\"mergers-acquisitions\",\n    description=\"Handle mergers and acquisitions\",\n    agents=[\n        corporate_agent,\n        ip_agent,\n        employment_agent,\n        doc_review_agent,\n    ],\n    swarm_type=\"ConcurrentWorkflow\",\n)\n\ndispute_swarm = SwarmRouter(\n    name=\"dispute-resolution\",\n    description=\"Handle complex disputes requiring multiple specialties\",\n    agents=[litigation_agent, corporate_agent, doc_review_agent],\n    swarm_type=\"ConcurrentWorkflow\",\n)\n\n\nhybrid_hiearchical_swarm = HybridHierarchicalClusterSwarm(\n    name=\"hybrid-hiearchical-swarm\",\n    description=\"A hybrid hiearchical swarm that uses a hybrid hiearchical peer model to solve complex tasks.\",\n    swarms=[\n        litigation_swarm,\n        corporate_swarm,\n        ip_swarm,\n        employment_swarm,\n        m_and_a_swarm,\n        dispute_swarm,\n    ],\n    max_loops=1,\n    router_agent_model_name=\"gpt-4o-mini\",\n)\n\n\nif __name__ == \"__main__\":\n    hybrid_hiearchical_swarm.run(\n        \"What is the best way to file for a patent? for ai technology \"\n    )\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/","title":"Hierarchical Swarm Examples","text":"<p>This page provides simple, practical examples of how to use the <code>HierarchicalSwarm</code> for various real-world scenarios.</p>"},{"location":"swarms/examples/hierarchical_swarm_example/#basic-example-financial-analysis","title":"Basic Example: Financial Analysis","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized financial analysis agents\nmarket_research_agent = Agent(\n    agent_name=\"Market-Research-Specialist\",\n    agent_description=\"Expert in market research, trend analysis, and competitive intelligence\",\n    system_prompt=\"\"\"You are a senior market research specialist with expertise in:\n    - Market trend analysis and forecasting\n    - Competitive landscape assessment\n    - Consumer behavior analysis\n    - Industry report generation\n    - Market opportunity identification\n    - Risk assessment and mitigation strategies\"\"\",\n    model_name=\"gpt-4o\",\n)\n\nfinancial_analyst_agent = Agent(\n    agent_name=\"Financial-Analysis-Expert\",\n    agent_description=\"Specialist in financial statement analysis, valuation, and investment research\",\n    system_prompt=\"\"\"You are a senior financial analyst with deep expertise in:\n    - Financial statement analysis (income statement, balance sheet, cash flow)\n    - Valuation methodologies (DCF, comparable company analysis, precedent transactions)\n    - Investment research and due diligence\n    - Financial modeling and forecasting\n    - Risk assessment and portfolio analysis\n    - ESG (Environmental, Social, Governance) analysis\"\"\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the hierarchical swarm\nfinancial_analysis_swarm = HierarchicalSwarm(\n    name=\"Financial-Analysis-Hierarchical-Swarm\",\n    description=\"A hierarchical swarm for comprehensive financial analysis with specialized agents\",\n    agents=[market_research_agent, financial_analyst_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute financial analysis\ntask = \"Conduct a comprehensive analysis of Tesla (TSLA) stock including market position, financial health, and investment potential\"\nresult = financial_analysis_swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/#development-team-example","title":"Development Team Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized development agents\nfrontend_developer_agent = Agent(\n    agent_name=\"Frontend-Developer\",\n    agent_description=\"Senior frontend developer expert in modern web technologies and user experience\",\n    system_prompt=\"\"\"You are a senior frontend developer with expertise in:\n    - Modern JavaScript frameworks (React, Vue, Angular)\n    - TypeScript and modern ES6+ features\n    - CSS frameworks and responsive design\n    - State management (Redux, Zustand, Context API)\n    - Web performance optimization\n    - Accessibility (WCAG) and SEO best practices\"\"\",\n    model_name=\"gpt-4o\",\n)\n\nbackend_developer_agent = Agent(\n    agent_name=\"Backend-Developer\",\n    agent_description=\"Senior backend developer specializing in server-side development and API design\",\n    system_prompt=\"\"\"You are a senior backend developer with expertise in:\n    - Server-side programming languages (Python, Node.js, Java, Go)\n    - Web frameworks (Django, Flask, Express, Spring Boot)\n    - Database design and optimization (SQL, NoSQL)\n    - API design and REST/GraphQL implementation\n    - Authentication and authorization systems\n    - Microservices architecture and containerization\"\"\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the development swarm\ndevelopment_department_swarm = HierarchicalSwarm(\n    name=\"Autonomous-Development-Department\",\n    description=\"A fully autonomous development department with specialized agents\",\n    agents=[frontend_developer_agent, backend_developer_agent],\n    max_loops=3,\n    verbose=True,\n)\n\n# Execute development project\ntask = \"Create a simple web app that allows users to upload a file and then download it. The app should be built with React and Node.js.\"\nresult = development_department_swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/#single-step-execution","title":"Single Step Execution","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create analysis agents\nmarket_agent = Agent(\n    agent_name=\"Market-Analyst\",\n    agent_description=\"Expert in market analysis and trends\",\n    model_name=\"gpt-4o\",\n)\n\ntechnical_agent = Agent(\n    agent_name=\"Technical-Analyst\",\n    agent_description=\"Specialist in technical analysis and patterns\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the swarm\nswarm = HierarchicalSwarm(\n    name=\"Analysis-Swarm\",\n    description=\"A hierarchical swarm for comprehensive analysis\",\n    agents=[market_agent, technical_agent],\n    max_loops=1,\n    verbose=True,\n)\n\n# Execute a single step\ntask = \"Analyze the current market trends for electric vehicles\"\nfeedback = swarm.step(task=task)\nprint(\"Director Feedback:\", feedback)\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/#batch-processing","title":"Batch Processing","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create analysis agents\nmarket_agent = Agent(\n    agent_name=\"Market-Analyst\",\n    agent_description=\"Expert in market analysis and trends\",\n    model_name=\"gpt-4o\",\n)\n\ntechnical_agent = Agent(\n    agent_name=\"Technical-Analyst\",\n    agent_description=\"Specialist in technical analysis and patterns\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the swarm\nswarm = HierarchicalSwarm(\n    name=\"Analysis-Swarm\",\n    description=\"A hierarchical swarm for comprehensive analysis\",\n    agents=[market_agent, technical_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute multiple tasks\ntasks = [\n    \"Analyze Apple (AAPL) stock performance\",\n    \"Evaluate Microsoft (MSFT) market position\",\n    \"Assess Google (GOOGL) competitive landscape\"\n]\n\nresults = swarm.batched_run(tasks=tasks)\nfor i, result in enumerate(results):\n    print(f\"Task {i+1} Result:\", result)\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/#research-team-example","title":"Research Team Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized research agents\nresearch_manager = Agent(\n    agent_name=\"Research-Manager\",\n    agent_description=\"Manages research operations and coordinates research tasks\",\n    system_prompt=\"You are a research manager responsible for overseeing research projects and coordinating research efforts.\",\n    model_name=\"gpt-4o\",\n)\n\ndata_analyst = Agent(\n    agent_name=\"Data-Analyst\",\n    agent_description=\"Analyzes data and generates insights\",\n    system_prompt=\"You are a data analyst specializing in processing and analyzing data to extract meaningful insights.\",\n    model_name=\"gpt-4o\",\n)\n\nresearch_assistant = Agent(\n    agent_name=\"Research-Assistant\",\n    agent_description=\"Assists with research tasks and data collection\",\n    system_prompt=\"You are a research assistant who helps gather information and support research activities.\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the research swarm\nresearch_swarm = HierarchicalSwarm(\n    name=\"Research-Team-Swarm\",\n    description=\"A hierarchical swarm for comprehensive research projects\",\n    agents=[research_manager, data_analyst, research_assistant],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute research project\ntask = \"Conduct a comprehensive market analysis for a new AI-powered productivity tool\"\nresult = research_swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/examples/hierarchical_swarm_example/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Agent Specialization: Create agents with specific, well-defined expertise areas</li> <li>Clear Task Descriptions: Provide detailed, actionable task descriptions</li> <li>Appropriate Loop Count: Set <code>max_loops</code> based on task complexity (1-3 for most tasks)</li> <li>Verbose Logging: Enable verbose mode during development for debugging</li> <li>Context Preservation: The swarm maintains full conversation history automatically</li> </ol> <p>For more detailed information about the <code>HierarchicalSwarm</code> API and advanced usage patterns, see the main documentation. </p>"},{"location":"swarms/examples/igc_example/","title":"Interactive GroupChat Example","text":""},{"location":"swarms/examples/igc_example/#interactive-groupchat-examples","title":"Interactive Groupchat Examples","text":"<p>The Interactive GroupChat is a powerful multi-agent architecture that enables dynamic collaboration between multiple AI agents. This architecture allows agents to communicate with each other, respond to mentions using <code>@agent_name</code> syntax, and work together to solve complex tasks through structured conversation flows.</p>"},{"location":"swarms/examples/igc_example/#architecture-description","title":"Architecture Description","text":"<p>The Interactive GroupChat implements a collaborative swarm architecture where multiple specialized agents work together in a coordinated manner. Key features include:</p> <ul> <li>Mention-based Communication: Agents can be directed to specific tasks using <code>@agent_name</code> syntax</li> <li>Flexible Speaker Functions: Multiple speaking order strategies (round robin, random, priority-based)</li> <li>Enhanced Collaboration: Agents build upon each other's responses and avoid redundancy</li> <li>Interactive Sessions: Support for both automated and interactive conversation modes</li> <li>Context Awareness: Agents maintain conversation history and context</li> </ul> <p>For comprehensive documentation on Interactive GroupChat, visit: Interactive GroupChat Documentation</p>"},{"location":"swarms/examples/igc_example/#step-by-step-showcase","title":"Step-by-Step Showcase","text":"<ul> <li>Agent Creation: Define specialized agents with unique expertise and system prompts</li> <li>GroupChat Initialization: Create the InteractiveGroupChat structure with desired speaker function</li> <li>Task Definition: Formulate tasks using <code>@agent_name</code> mentions to direct specific agents</li> <li>Execution: Run the group chat to generate collaborative responses</li> <li>Response Processing: Handle the coordinated output from multiple agents</li> <li>Iteration: Chain multiple tasks for complex workflows</li> </ul>"},{"location":"swarms/examples/igc_example/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"swarms/examples/igc_example/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/igc_example/#code","title":"Code","text":"<pre><code>\"\"\"\nInteractiveGroupChat Speaker Function Examples\n\nThis example demonstrates how to use different speaker functions in the InteractiveGroupChat:\n- Round Robin: Agents speak in a fixed order, cycling through the list\n- Random: Agents speak in random order\n- Priority: Agents speak based on priority weights\n- Custom: User-defined speaker functions\n\nThe example also shows how agents can mention each other using @agent_name syntax.\n\"\"\"\n\nfrom swarms import Agent\nfrom swarms.structs.interactive_groupchat import (\n    InteractiveGroupChat,\n    random_speaker,\n)\n\n\ndef create_example_agents():\n    \"\"\"Create example agents for demonstration.\"\"\"\n\n    # Create agents with different expertise\n    analyst = Agent(\n        agent_name=\"analyst\",\n        system_prompt=\"You are a data analyst. You excel at analyzing data, creating charts, and providing insights.\",\n        model_name=\"gpt-4.1\",\n        streaming_on=True,\n        print_on=True,\n    )\n\n    researcher = Agent(\n        agent_name=\"researcher\",\n        system_prompt=\"You are a research specialist. You are great at gathering information, fact-checking, and providing detailed research.\",\n        model_name=\"gpt-4.1\",\n        streaming_on=True,\n        print_on=True,\n    )\n\n    writer = Agent(\n        agent_name=\"writer\",\n        system_prompt=\"You are a content writer. You excel at writing clear, engaging content and summarizing information.\",\n        model_name=\"gpt-4.1\",\n        streaming_on=True,\n        print_on=True,\n    )\n\n    return [analyst, researcher, writer]\n\n\ndef example_random():\n    agents = create_example_agents()\n\n    # Create group chat with random speaker function\n    group_chat = InteractiveGroupChat(\n        name=\"Random Team\",\n        description=\"A team that speaks in random order\",\n        agents=agents,\n        speaker_function=random_speaker,\n        interactive=False,\n    )\n\n    # Test the random behavior\n    task = \"Let's create a marketing strategy. @analyst @researcher @writer please contribute.\"\n\n    response = group_chat.run(task)\n    print(f\"Response:\\n{response}\\n\")\n\n\nif __name__ == \"__main__\":\n    # example_round_robin()\n    example_random()\n</code></pre>"},{"location":"swarms/examples/igc_example/#connect-with-us","title":"Connect With Us","text":"<p>Join our community of agent engineers and researchers for technical support, cutting-edge updates, and exclusive access to world-class agent engineering insights!</p> Platform Description Link \ud83d\udcda Documentation Official documentation and guides docs.swarms.world \ud83d\udcdd Blog Latest updates and technical articles Medium \ud83d\udcac Discord Live chat and community support Join Discord \ud83d\udc26 Twitter Latest news and announcements @kyegomez \ud83d\udc65 LinkedIn Professional network and updates The Swarm Corporation \ud83d\udcfa YouTube Tutorials and demos Swarms Channel \ud83c\udfab Events Join our community events Sign up here \ud83d\ude80 Onboarding Session Get onboarded with Kye Gomez, creator and lead maintainer of Swarms Book Session"},{"location":"swarms/examples/interactive_groupchat_example/","title":"Interactive GroupChat Example","text":"<p>This is an example of the InteractiveGroupChat module in swarms. Click here for full documentation</p>"},{"location":"swarms/examples/interactive_groupchat_example/#installation","title":"Installation","text":"<p>You can get started by first installing swarms with the following command, or click here for more detailed installation instructions:</p> <pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/interactive_groupchat_example/#environment-variables","title":"Environment Variables","text":"<pre><code>OPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/interactive_groupchat_example/#code","title":"Code","text":""},{"location":"swarms/examples/interactive_groupchat_example/#interactive-session-in-terminal","title":"Interactive Session in Terminal","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.interactive_groupchat import InteractiveGroupChat\n\n\nif __name__ == \"__main__\":\n    # Initialize agents\n    financial_advisor = Agent(\n        agent_name=\"FinancialAdvisor\",\n        system_prompt=\"You are a financial advisor specializing in investment strategies and portfolio management.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    tax_expert = Agent(\n        agent_name=\"TaxExpert\",\n        system_prompt=\"You are a tax expert who provides guidance on tax optimization and compliance.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    investment_analyst = Agent(\n        agent_name=\"InvestmentAnalyst\",\n        system_prompt=\"You are an investment analyst focusing on market trends and investment opportunities.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    # Create a list of agents including both Agent instances and callables\n    agents = [\n        financial_advisor,\n        tax_expert,\n        investment_analyst,\n    ]\n\n    # Initialize another chat instance in interactive mode\n    interactive_chat = InteractiveGroupChat(\n        name=\"Interactive Financial Advisory Team\",\n        description=\"An interactive team of financial experts providing comprehensive financial advice\",\n        agents=agents,\n        max_loops=1,\n        output_type=\"all\",\n        interactive=True,\n    )\n\n    try:\n        # Start the interactive session\n        print(\"\\nStarting interactive session...\")\n        # interactive_chat.run(\"What is the best methodology to accumulate gold and silver commodities, and what is the best long-term strategy to accumulate them?\")\n        interactive_chat.start_interactive_session()\n    except Exception as e:\n        print(f\"An error occurred in interactive mode: {e}\")\n</code></pre>"},{"location":"swarms/examples/interactive_groupchat_example/#run-method-manual-method","title":"Run Method // Manual Method","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.interactive_groupchat import InteractiveGroupChat\n\n\nif __name__ == \"__main__\":\n    # Initialize agents\n    financial_advisor = Agent(\n        agent_name=\"FinancialAdvisor\",\n        system_prompt=\"You are a financial advisor specializing in investment strategies and portfolio management.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    tax_expert = Agent(\n        agent_name=\"TaxExpert\",\n        system_prompt=\"You are a tax expert who provides guidance on tax optimization and compliance.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    investment_analyst = Agent(\n        agent_name=\"InvestmentAnalyst\",\n        system_prompt=\"You are an investment analyst focusing on market trends and investment opportunities.\",\n        random_models_on=True,\n        output_type=\"final\",\n    )\n\n    # Create a list of agents including both Agent instances and callables\n    agents = [\n        financial_advisor,\n        tax_expert,\n        investment_analyst,\n    ]\n\n    # Initialize another chat instance in interactive mode\n    interactive_chat = InteractiveGroupChat(\n        name=\"Interactive Financial Advisory Team\",\n        description=\"An interactive team of financial experts providing comprehensive financial advice\",\n        agents=agents,\n        max_loops=1,\n        output_type=\"all\",\n        interactive=False,\n    )\n\n    try:\n        # Start the interactive session\n        print(\"\\nStarting interactive session...\")\n        # interactive_chat.run(\"What is the best methodology to accumulate gold and silver commodities, and what is the best long-term strategy to accumulate them?\")\n        interactive_chat.run('@TaxExpert how can I understand tax tactics for crypto payroll in solana?')\n    except Exception as e:\n        print(f\"An error occurred in interactive mode: {e}\")\n</code></pre>"},{"location":"swarms/examples/llama4/","title":"Llama4 Model Integration","text":"<p>Prerequisites</p> <ul> <li>Python 3.8 or higher</li> <li><code>swarms</code> library installed</li> <li>Access to Llama4 model</li> <li>Valid environment variables configured</li> </ul>"},{"location":"swarms/examples/llama4/#quick-start","title":"Quick Start","text":"<p>Here's a simple example of integrating Llama4 model for crypto risk analysis:</p> <pre><code>from dotenv import load_dotenv\nfrom swarms import Agent\nfrom swarms.utils.vllm_wrapper import VLLM\n\nload_dotenv()\nmodel = VLLM(model_name=\"meta-llama/Llama-4-Maverick-17B-128E\")\n</code></pre>"},{"location":"swarms/examples/llama4/#available-models","title":"Available Models","text":"Model Name Description Type meta-llama/Llama-4-Maverick-17B-128E Base model with 128 experts Base meta-llama/Llama-4-Maverick-17B-128E-Instruct Instruction-tuned version with 128 experts Instruct meta-llama/Llama-4-Maverick-17B-128E-Instruct-FP8 FP8 quantized instruction model Instruct (Optimized) meta-llama/Llama-4-Scout-17B-16E Base model with 16 experts Base meta-llama/Llama-4-Scout-17B-16E-Instruct Instruction-tuned version with 16 experts Instruct <p>Model Selection</p> <ul> <li>Choose Instruct models for better performance on instruction-following tasks</li> <li>FP8 models offer better memory efficiency with minimal performance impact</li> <li>Scout models (16E) are lighter but still powerful</li> <li>Maverick models (128E) offer maximum performance but require more resources</li> </ul>"},{"location":"swarms/examples/llama4/#detailed-implementation","title":"Detailed Implementation","text":""},{"location":"swarms/examples/llama4/#1-define-custom-system-prompt","title":"1. Define Custom System Prompt","text":"<pre><code>CRYPTO_RISK_ANALYSIS_PROMPT = \"\"\"\nYou are a cryptocurrency risk analysis expert. Your role is to:\n\n1. Analyze market risks:\n   - Volatility assessment\n   - Market sentiment analysis\n   - Trading volume patterns\n   - Price trend evaluation\n\n2. Evaluate technical risks:\n   - Network security\n   - Protocol vulnerabilities\n   - Smart contract risks\n   - Technical scalability\n\n3. Consider regulatory risks:\n   - Current regulations\n   - Potential regulatory changes\n   - Compliance requirements\n   - Geographic restrictions\n\n4. Assess fundamental risks:\n   - Team background\n   - Project development status\n   - Competition analysis\n   - Use case viability\n\nProvide detailed, balanced analysis with both risks and potential mitigations.\nBase your analysis on established crypto market principles and current market conditions.\n\"\"\"\n</code></pre>"},{"location":"swarms/examples/llama4/#2-initialize-agent","title":"2. Initialize Agent","text":"<pre><code>agent = Agent(\n    agent_name=\"Crypto-Risk-Analysis-Agent\",\n    agent_description=\"Agent for analyzing risks in cryptocurrency investments\",\n    system_prompt=CRYPTO_RISK_ANALYSIS_PROMPT,\n    max_loops=1,\n    llm=model,\n)\n</code></pre>"},{"location":"swarms/examples/llama4/#full-code","title":"Full Code","text":"<pre><code>from dotenv import load_dotenv\n\nfrom swarms import Agent\nfrom swarms.utils.vllm_wrapper import VLLM\n\nload_dotenv()\n\n# Define custom system prompt for crypto risk analysis\nCRYPTO_RISK_ANALYSIS_PROMPT = \"\"\"\nYou are a cryptocurrency risk analysis expert. Your role is to:\n\n1. Analyze market risks:\n   - Volatility assessment\n   - Market sentiment analysis\n   - Trading volume patterns\n   - Price trend evaluation\n\n2. Evaluate technical risks:\n   - Network security\n   - Protocol vulnerabilities\n   - Smart contract risks\n   - Technical scalability\n\n3. Consider regulatory risks:\n   - Current regulations\n   - Potential regulatory changes\n   - Compliance requirements\n   - Geographic restrictions\n\n4. Assess fundamental risks:\n   - Team background\n   - Project development status\n   - Competition analysis\n   - Use case viability\n\nProvide detailed, balanced analysis with both risks and potential mitigations.\nBase your analysis on established crypto market principles and current market conditions.\n\"\"\"\n\nmodel = VLLM(model_name=\"meta-llama/Llama-4-Maverick-17B-128E\")\n\n# Initialize the agent with custom prompt\nagent = Agent(\n    agent_name=\"Crypto-Risk-Analysis-Agent\",\n    agent_description=\"Agent for analyzing risks in cryptocurrency investments\",\n    system_prompt=CRYPTO_RISK_ANALYSIS_PROMPT,\n    max_loops=1,\n    llm=model,\n)\n\nprint(\n    agent.run(\n        \"Conduct a risk analysis of the top cryptocurrencies. Think for 2 loops internally\"\n    )\n)\n</code></pre> <p>Resource Usage</p> <p>The Llama4 model requires significant computational resources. Ensure your system meets the minimum requirements.</p>"},{"location":"swarms/examples/llama4/#faq","title":"FAQ","text":"What is the purpose of max_loops parameter? <p>The <code>max_loops</code> parameter determines how many times the agent will iterate through its thinking process. In this example, it's set to 1 for a single pass analysis.</p> Can I use a different model? <p>Yes, you can replace the VLLM wrapper with other compatible models. Just ensure you update the model initialization accordingly.</p> How do I customize the system prompt? <p>You can modify the <code>CRYPTO_RISK_ANALYSIS_PROMPT</code> string to match your specific use case while maintaining the structured format.</p> <p>Best Practices</p> <ul> <li>Always handle API errors gracefully</li> <li>Monitor model performance and resource usage</li> <li>Keep your prompts clear and specific</li> <li>Test thoroughly before production deployment</li> </ul> <p>Sample Usage</p> <pre><code>response = agent.run(\n    \"Conduct a risk analysis of the top cryptocurrencies. Think for 2 loops internally\"\n)\nprint(response)\n</code></pre>"},{"location":"swarms/examples/lumo/","title":"Lumo Example","text":"<p>Introducing Lumo-70B-Instruct - the largest and most advanced AI model ever created for the Solana ecosystem. Built on Meta's groundbreaking LLaMa 3.3 70B Instruct foundation, this revolutionary model represents a quantum leap in blockchain-specific artificial intelligence. With an unprecedented 70 billion parameters and trained on the most comprehensive Solana documentation dataset ever assembled, Lumo-70B-Instruct sets a new standard for developer assistance in the blockchain space.</p> <ul> <li>Docs</li> </ul> <pre><code>from swarms import Agent\nfrom transformers import LlamaForCausalLM, AutoTokenizer\nimport torch\nfrom transformers import BitsAndBytesConfig\n\nclass Lumo:\n    \"\"\"\n    A class for generating text using the Lumo model with 4-bit quantization.\n    \"\"\"\n    def __init__(self):\n        \"\"\"\n        Initializes the Lumo model with 4-bit quantization and a tokenizer.\n        \"\"\"\n        # Configure 4-bit quantization\n        bnb_config = BitsAndBytesConfig(\n            load_in_4bit=True,\n            bnb_4bit_quant_type=\"nf4\",\n            bnb_4bit_compute_dtype=torch.float16,\n            llm_int8_enable_fp32_cpu_offload=True\n        )\n\n        self.model = LlamaForCausalLM.from_pretrained(\n            \"lumolabs-ai/Lumo-70B-Instruct\",\n            device_map=\"auto\",\n            quantization_config=bnb_config,\n            use_cache=False,\n            attn_implementation=\"sdpa\"\n        )\n        self.tokenizer = AutoTokenizer.from_pretrained(\"lumolabs-ai/Lumo-70B-Instruct\")\n\n    def run(self, task: str) -&gt; str:\n        \"\"\"\n        Generates text based on the given prompt using the Lumo model.\n\n        Args:\n            prompt (str): The input prompt for the model.\n\n        Returns:\n            str: The generated text.\n        \"\"\"\n        inputs = self.tokenizer(task, return_tensors=\"pt\").to(self.model.device)\n        outputs = self.model.generate(**inputs, max_new_tokens=100)\n        return self.tokenizer.decode(outputs[0], skip_special_tokens=True)\n\n\n\n\nAgent(\n    agent_name=\"Solana-Analysis-Agent\",\n    llm=Lumo(),\n    max_loops=\"auto\",\n    interactive=True,\n    streaming_on=True,\n).run(\"How do i create a smart contract in solana?\")\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/","title":"MixtureOfAgents Examples","text":"<p>The MixtureOfAgents architecture combines multiple specialized agents with an aggregator agent to process complex tasks. This architecture is particularly effective for tasks requiring diverse expertise and consensus-building among different specialists.</p>"},{"location":"swarms/examples/mixture_of_agents/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>OpenAI API key or other supported LLM provider keys</li> <li>Swarms library</li> </ul>"},{"location":"swarms/examples/mixture_of_agents/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#basic-usage","title":"Basic Usage","text":""},{"location":"swarms/examples/mixture_of_agents/#1-initialize-specialized-agents","title":"1. Initialize Specialized Agents","text":"<pre><code>from swarms import Agent, MixtureOfAgents\n\n# Initialize specialized agents\nlegal_expert = Agent(\n    agent_name=\"Legal-Expert\",\n    system_prompt=\"\"\"You are a legal expert specializing in contract law. Your responsibilities include:\n    1. Analyzing legal documents and contracts\n    2. Identifying potential legal risks\n    3. Ensuring regulatory compliance\n    4. Providing legal recommendations\n    5. Drafting and reviewing legal documents\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nfinancial_expert = Agent(\n    agent_name=\"Financial-Expert\",\n    system_prompt=\"\"\"You are a financial expert specializing in business finance. Your tasks include:\n    1. Analyzing financial implications\n    2. Evaluating costs and benefits\n    3. Assessing financial risks\n    4. Providing financial projections\n    5. Recommending financial strategies\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nbusiness_expert = Agent(\n    agent_name=\"Business-Expert\",\n    system_prompt=\"\"\"You are a business strategy expert. Your focus areas include:\n    1. Analyzing business models\n    2. Evaluating market opportunities\n    3. Assessing competitive advantages\n    4. Providing strategic recommendations\n    5. Planning business development\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\n# Initialize aggregator agent\naggregator = Agent(\n    agent_name=\"Decision-Aggregator\",\n    system_prompt=\"\"\"You are a decision aggregator responsible for:\n    1. Synthesizing input from multiple experts\n    2. Resolving conflicting viewpoints\n    3. Prioritizing recommendations\n    4. Providing coherent final decisions\n    5. Ensuring comprehensive coverage of all aspects\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#2-create-and-run-mixtureofagents","title":"2. Create and Run MixtureOfAgents","text":"<pre><code># Create list of specialist agents\nspecialists = [legal_expert, financial_expert, business_expert]\n\n# Initialize the mixture of agents\nmoa = MixtureOfAgents(\n    agents=specialists,\n    aggregator_agent=aggregator,\n    layers=3,\n)\n\n# Run the analysis\nresult = moa.run(\n    \"Analyze the proposed merger between Company A and Company B, considering legal, financial, and business aspects.\"\n)\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/examples/mixture_of_agents/#1-custom-configuration-with-system-prompts","title":"1. Custom Configuration with System Prompts","text":"<pre><code># Initialize MixtureOfAgents with custom aggregator prompt\nmoa = MixtureOfAgents(\n    agents=specialists,\n    aggregator_agent=aggregator,\n    aggregator_system_prompt=\"\"\"As the decision aggregator, synthesize the analyses from all specialists into a coherent recommendation:\n    1. Summarize key points from each specialist\n    2. Identify areas of agreement and disagreement\n    3. Weigh different perspectives\n    4. Provide a balanced final recommendation\n    5. Highlight key risks and opportunities\"\"\",\n    layers=3,\n)\n\nresult = moa.run(\"Evaluate the potential acquisition of StartupX\")\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#2-error-handling-and-validation","title":"2. Error Handling and Validation","text":"<pre><code>try:\n    moa = MixtureOfAgents(\n        agents=specialists,\n        aggregator_agent=aggregator,\n        layers=3,\n        verbose=True,\n    )\n\n    result = moa.run(\"Complex analysis task\")\n\n    # Validate and process results\n    if result:\n        print(\"Analysis complete:\")\n        print(result)\n    else:\n        print(\"Analysis failed to produce results\")\n\nexcept Exception as e:\n    print(f\"Error in analysis: {str(e)}\")\n</code></pre>"},{"location":"swarms/examples/mixture_of_agents/#best-practices","title":"Best Practices","text":"<ol> <li>Agent Selection and Configuration:</li> <li>Choose specialists with complementary expertise</li> <li>Configure appropriate system prompts</li> <li> <p>Set suitable model parameters</p> </li> <li> <p>Aggregator Configuration:</p> </li> <li>Define clear aggregation criteria</li> <li>Set appropriate weights for different opinions</li> <li> <p>Configure conflict resolution strategies</p> </li> <li> <p>Layer Management:</p> </li> <li>Set appropriate number of layers</li> <li>Monitor layer effectiveness</li> <li> <p>Adjust based on task complexity</p> </li> <li> <p>Quality Control:</p> </li> <li>Implement validation checks</li> <li>Monitor agent performance</li> <li>Ensure comprehensive coverage</li> </ol>"},{"location":"swarms/examples/mixture_of_agents/#example-implementation","title":"Example Implementation","text":"<p>Here's a complete example showing how to use MixtureOfAgents for a comprehensive business analysis:</p> <pre><code>import os\nfrom swarms import Agent, MixtureOfAgents\n\n# Initialize specialist agents\nmarket_analyst = Agent(\n    agent_name=\"Market-Analyst\",\n    system_prompt=\"\"\"You are a market analysis specialist focusing on:\n    1. Market size and growth\n    2. Competitive landscape\n    3. Customer segments\n    4. Market trends\n    5. Entry barriers\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nfinancial_analyst = Agent(\n    agent_name=\"Financial-Analyst\",\n    system_prompt=\"\"\"You are a financial analysis expert specializing in:\n    1. Financial performance\n    2. Valuation metrics\n    3. Cash flow analysis\n    4. Investment requirements\n    5. ROI projections\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nrisk_analyst = Agent(\n    agent_name=\"Risk-Analyst\",\n    system_prompt=\"\"\"You are a risk assessment specialist focusing on:\n    1. Market risks\n    2. Operational risks\n    3. Financial risks\n    4. Regulatory risks\n    5. Strategic risks\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\n# Initialize aggregator\naggregator = Agent(\n    agent_name=\"Strategic-Aggregator\",\n    system_prompt=\"\"\"You are a strategic decision aggregator responsible for:\n    1. Synthesizing specialist analyses\n    2. Identifying key insights\n    3. Evaluating trade-offs\n    4. Making recommendations\n    5. Providing action plans\"\"\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\n# Create and configure MixtureOfAgents\ntry:\n    moa = MixtureOfAgents(\n        agents=[market_analyst, financial_analyst, risk_analyst],\n        aggregator_agent=aggregator,\n        aggregator_system_prompt=\"\"\"Synthesize the analyses from all specialists to provide:\n        1. Comprehensive situation analysis\n        2. Key opportunities and risks\n        3. Strategic recommendations\n        4. Implementation considerations\n        5. Success metrics\"\"\",\n        layers=3,\n        verbose=True,\n    )\n\n    # Run the analysis\n    result = moa.run(\n        \"\"\"Evaluate the business opportunity for expanding into the electric vehicle market:\n        1. Market potential and competition\n        2. Financial requirements and projections\n        3. Risk assessment and mitigation strategies\"\"\"\n    )\n\n    # Process and display results\n    print(\"\\nComprehensive Analysis Results:\")\n    print(\"=\" * 50)\n    print(result)\n    print(\"=\" * 50)\n\nexcept Exception as e:\n    print(f\"Error during analysis: {str(e)}\")\n</code></pre> <p>This comprehensive guide demonstrates how to effectively use the MixtureOfAgents architecture for complex analysis tasks requiring multiple expert perspectives and consensus-building. </p>"},{"location":"swarms/examples/moa_example/","title":"Mixture of Agents Example","text":"<p>The Mixture of Agents (MoA) is a sophisticated multi-agent architecture that implements parallel processing with iterative refinement. This approach processes multiple specialized agents simultaneously, concatenates their outputs, and then performs multiple parallel runs to achieve consensus or enhanced results.</p>"},{"location":"swarms/examples/moa_example/#how-it-works","title":"How It Works","text":"<ol> <li>Parallel Processing: Multiple agents work simultaneously on the same input</li> <li>Output Concatenation: Results from all agents are combined into a unified response</li> <li>Iterative Refinement: The process repeats for <code>n</code> layers/iterations to improve quality</li> <li>Consensus Building: Multiple runs help achieve more reliable and comprehensive outputs</li> </ol> <p>This architecture is particularly effective for complex tasks that benefit from diverse perspectives and iterative improvement, such as financial analysis, risk assessment, and multi-faceted problem solving.</p> <p></p>"},{"location":"swarms/examples/moa_example/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"swarms/examples/moa_example/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nANTHROPIC_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/moa_example/#code","title":"Code","text":"<pre><code>from swarms import Agent, MixtureOfAgents\n\n# Agent 1: Risk Metrics Calculator\nrisk_metrics_agent = Agent(\n    agent_name=\"Risk-Metrics-Calculator\",\n    agent_description=\"Calculates key risk metrics like VaR, Sharpe ratio, and volatility\",\n    system_prompt=\"\"\"You are a risk metrics specialist. Calculate and explain:\n    - Value at Risk (VaR)\n    - Sharpe ratio\n    - Volatility\n    - Maximum drawdown\n    - Beta coefficient\n\n    Provide clear, numerical results with brief explanations.\"\"\",\n    max_loops=1,\n    # model_name=\"gpt-4o-mini\",\n    random_model_enabled=True,\n    dynamic_temperature_enabled=True,\n    output_type=\"str-all-except-first\",\n    max_tokens=4096,\n)\n\n# Agent 2: Portfolio Risk Analyzer\nportfolio_risk_agent = Agent(\n    agent_name=\"Portfolio-Risk-Analyzer\",\n    agent_description=\"Analyzes portfolio diversification and concentration risk\",\n    system_prompt=\"\"\"You are a portfolio risk analyst. Focus on:\n    - Portfolio diversification analysis\n    - Concentration risk assessment\n    - Correlation analysis\n    - Sector/asset allocation risk\n    - Liquidity risk evaluation\n\n    Provide actionable insights for risk reduction.\"\"\",\n    max_loops=1,\n    # model_name=\"gpt-4o-mini\",\n    random_model_enabled=True,\n    dynamic_temperature_enabled=True,\n    output_type=\"str-all-except-first\",\n    max_tokens=4096,\n)\n\n# Agent 3: Market Risk Monitor\nmarket_risk_agent = Agent(\n    agent_name=\"Market-Risk-Monitor\",\n    agent_description=\"Monitors market conditions and identifies risk factors\",\n    system_prompt=\"\"\"You are a market risk monitor. Identify and assess:\n    - Market volatility trends\n    - Economic risk factors\n    - Geopolitical risks\n    - Interest rate risks\n    - Currency risks\n\n    Provide current risk alerts and trends.\"\"\",\n    max_loops=1,\n    # model_name=\"gpt-4o-mini\",\n    random_model_enabled=True,\n    dynamic_temperature_enabled=True,\n    output_type=\"str-all-except-first\",\n    max_tokens=4096,\n)\n\n\nswarm = MixtureOfAgents(\n    agents=[\n        risk_metrics_agent,\n        portfolio_risk_agent,\n        market_risk_agent,\n    ],\n    layers=1,\n    max_loops=1,\n    output_type=\"final\",\n)\n\n\nout = swarm.run(\n    \"Calculate VaR and Sharpe ratio for a portfolio with 15% annual return and 20% volatility\"\n)\n\nprint(out)\n</code></pre>"},{"location":"swarms/examples/moa_example/#support-and-community","title":"Support and Community","text":"<p>If you're facing issues or want to learn more, check out the following resources to join our Discord, stay updated on Twitter, and watch tutorials on YouTube!</p> Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"swarms/examples/model_providers/","title":"Model Providers Overview","text":"<p>Swarms supports a vast array of model providers, giving you the flexibility to choose the best model for your specific use case. Whether you need high-performance inference, cost-effective solutions, or specialized capabilities, Swarms has you covered.</p>"},{"location":"swarms/examples/model_providers/#supported-model-providers","title":"Supported Model Providers","text":"Provider Description Documentation OpenAI Industry-leading language models including GPT-4, GPT-4o, and GPT-4o-mini. Perfect for general-purpose tasks, creative writing, and complex reasoning. OpenAI Integration Anthropic/Claude Advanced AI models known for their safety, helpfulness, and reasoning capabilities. Claude models excel at analysis, coding, and creative tasks. Claude Integration Groq Ultra-fast inference platform offering real-time AI responses. Ideal for applications requiring low latency and high throughput. Groq Integration Cohere Enterprise-grade language models with strong performance on business applications, text generation, and semantic search. Cohere Integration DeepSeek Advanced reasoning models including the DeepSeek Reasoner (R1). Excellent for complex problem-solving and analytical tasks. DeepSeek Integration Ollama Local model deployment platform allowing you to run open-source models on your own infrastructure. No API keys required. Ollama Integration OpenRouter Unified API gateway providing access to hundreds of models from various providers through a single interface. OpenRouter Integration XAI xAI's Grok models offering unique capabilities for research, analysis, and creative tasks with advanced reasoning abilities. XAI Integration vLLM High-performance inference library for serving large language models with optimized memory usage and throughput. vLLM Integration Llama4 Meta's latest open-source language models including Llama-4-Maverick and Llama-4-Scout variants with expert routing capabilities. Llama4 Integration"},{"location":"swarms/examples/model_providers/#quick-start","title":"Quick Start","text":"<p>All model providers follow a consistent pattern in Swarms. Here's the basic template:</p> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize agent with your chosen model\nagent = Agent(\n    agent_name=\"Your-Agent-Name\",\n    model_name=\"gpt-4o-mini\",  # Varies by provider\n    system_prompt=\"Your system prompt here\",\n    agent_description=\"Description of what your agent does.\",\n)\n\n# Run your agent\nresponse = agent.run(\"Your query here\")\n</code></pre>"},{"location":"swarms/examples/model_providers/#model-selection-guide","title":"Model Selection Guide","text":""},{"location":"swarms/examples/model_providers/#for-high-performance-applications","title":"For High-Performance Applications","text":"<ul> <li> <p>OpenAI GPT-4o: Best overall performance and reasoning</p> </li> <li> <p>Anthropic Claude: Excellent safety and analysis capabilities</p> </li> <li> <p>DeepSeek R1: Advanced reasoning and problem-solving</p> </li> </ul>"},{"location":"swarms/examples/model_providers/#for-cost-effective-solutions","title":"For Cost-Effective Solutions","text":"<ul> <li> <p>OpenAI GPT-4o-mini: Great performance at lower cost</p> </li> <li> <p>Ollama: Free local deployment</p> </li> <li> <p>OpenRouter: Access to cost-effective models</p> </li> </ul>"},{"location":"swarms/examples/model_providers/#for-real-time-applications","title":"For Real-Time Applications","text":"<ul> <li> <p>Groq: Ultra-fast inference</p> </li> <li> <p>vLLM: Optimized for high throughput</p> </li> </ul>"},{"location":"swarms/examples/model_providers/#for-specialized-tasks","title":"For Specialized Tasks","text":"<ul> <li> <p>Llama4: Expert routing for complex workflows</p> </li> <li> <p>XAI Grok: Advanced research capabilities</p> </li> <li> <p>Cohere: Strong business applications</p> </li> </ul>"},{"location":"swarms/examples/model_providers/#environment-setup","title":"Environment Setup","text":"<p>Most providers require API keys. Add them to your <code>.env</code> file:</p> <pre><code># OpenAI\nOPENAI_API_KEY=your_openai_key\n\n# Anthropic\nANTHROPIC_API_KEY=your_anthropic_key\n\n# Groq\nGROQ_API_KEY=your_groq_key\n\n# Cohere\nCOHERE_API_KEY=your_cohere_key\n\n# DeepSeek\nDEEPSEEK_API_KEY=your_deepseek_key\n\n# OpenRouter\nOPENROUTER_API_KEY=your_openrouter_key\n\n# XAI\nXAI_API_KEY=your_xai_key\n</code></pre> <p>No API Key Required</p> <p>Ollama and vLLM can be run locally without API keys, making them perfect for development and testing.</p>"},{"location":"swarms/examples/model_providers/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/examples/model_providers/#multi-model-workflows","title":"Multi-Model Workflows","text":"<p>Swarms allows you to create workflows that use different models for different tasks:</p> <pre><code>from swarms import Agent, ConcurrentWorkflow\n\n# Research agent using Claude for analysis\nresearch_agent = Agent(\n    agent_name=\"Research-Agent\",\n    model_name=\"claude-3-sonnet-20240229\",\n    system_prompt=\"You are a research expert.\"\n)\n\n# Creative agent using GPT-4o for content generation\ncreative_agent = Agent(\n    agent_name=\"Creative-Agent\", \n    model_name=\"gpt-4o\",\n    system_prompt=\"You are a creative content expert.\"\n)\n\n# Workflow combining both agents\nworkflow = ConcurrentWorkflow(\n    name=\"Research-Creative-Workflow\",\n    agents=[research_agent, creative_agent]\n)\n</code></pre>"},{"location":"swarms/examples/model_providers/#model-routing","title":"Model Routing","text":"<p>Automatically route tasks to the most appropriate model:</p> <pre><code>from swarms import Agent, ModelRouter\n\n# Define model preferences for different task types\nmodel_router = ModelRouter(\n    models={\n        \"analysis\": \"claude-3-sonnet-20240229\",\n        \"creative\": \"gpt-4o\", \n        \"fast\": \"gpt-4o-mini\",\n        \"local\": \"ollama/llama2\"\n    }\n)\n\n# Agent will automatically choose the best model\nagent = Agent(\n    agent_name=\"Smart-Agent\",\n    llm=model_router,\n    system_prompt=\"You are a versatile assistant.\"\n)\n</code></pre>"},{"location":"swarms/examples/model_providers/#getting-help","title":"Getting Help","text":"<ul> <li> <p>Documentation: Each provider has detailed documentation with examples</p> </li> <li> <p>Community: Join the Swarms community for support and best practices</p> </li> <li> <p>Issues: Report bugs and request features on GitHub</p> </li> <li> <p>Discussions: Share your use cases and learn from others</p> </li> </ul> <p>Ready to Get Started?</p> <p>Choose a model provider from the table above and follow the detailed integration guide. Each provider offers unique capabilities that can enhance your Swarms applications.</p>"},{"location":"swarms/examples/multi_agent_router_minimal/","title":"MultiAgentRouter Minimal Example","text":"<p>This example shows how to route a task to the most suitable agent using <code>SwarmRouter</code> with <code>swarm_type=\"MultiAgentRouter\"</code>.</p> <pre><code>from swarms import Agent\nfrom swarms.structs.swarm_router import SwarmRouter\n\nagents = [\n    Agent(\n        agent_name=\"Researcher\",\n        system_prompt=\"Answer questions briefly.\",\n        model_name=\"gpt-4o-mini\",\n    ),\n    Agent(\n        agent_name=\"Coder\",\n        system_prompt=\"Write small Python functions.\",\n        model_name=\"gpt-4o-mini\",\n    ),\n]\n\nrouter = SwarmRouter(\n    name=\"multi-agent-router-demo\",\n    description=\"Routes tasks to the most suitable agent\",\n    agents=agents,\n    swarm_type=\"MultiAgentRouter\"\n)\n\nresult = router.run(\"Write a function that adds two numbers\")\nprint(result)\n</code></pre> <p>View the source on GitHub.</p>"},{"location":"swarms/examples/multiple_images/","title":"Processing Multiple Images","text":"<p>This tutorial shows how to process multiple images with a single agent using Swarms' multi-modal capabilities. You'll learn to configure an agent for batch image analysis, enabling efficient processing for quality control, object detection, or image comparison tasks.</p>"},{"location":"swarms/examples/multiple_images/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"swarms/examples/multiple_images/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nANTHROPIC_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/multiple_images/#code","title":"Code","text":"<ul> <li> <p>Create a list of images by their file paths</p> </li> <li> <p>Pass it into the <code>Agent.run(imgs=[str])</code> parameter</p> </li> <li> <p>Activate <code>summarize_multiple_images=True</code> if you want the agent to output a summary of the image analyses</p> </li> </ul> <pre><code>from swarms import Agent\nfrom swarms.prompts.logistics import (\n    Quality_Control_Agent_Prompt,\n)\n\n\n# Image for analysis\nfactory_image = \"image.jpg\"\n\n# Quality control agent\nquality_control_agent = Agent(\n    agent_name=\"Quality Control Agent\",\n    agent_description=\"A quality control agent that analyzes images and provides a detailed report on the quality of the product in the image.\",\n    model_name=\"claude-3-5-sonnet-20240620\",\n    system_prompt=Quality_Control_Agent_Prompt,\n    multi_modal=True,\n    max_loops=1,\n    output_type=\"str-all-except-first\",\n    summarize_multiple_images=True,\n)\n\n\nresponse = quality_control_agent.run(\n    task=\"what is in the image?\",\n    imgs=[factory_image, factory_image],\n)\n\nprint(response)\n</code></pre>"},{"location":"swarms/examples/multiple_images/#support-and-community","title":"Support and Community","text":"<p>If you're facing issues or want to learn more, check out the following resources to join our Discord, stay updated on Twitter, and watch tutorials on YouTube!</p> Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"swarms/examples/ollama/","title":"Agent with Ollama","text":"<ul> <li>No API key needed</li> <li>Select your model_name like <code>ollama/llama2</code> follows LiteLLM conventions</li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"ollama/llama2\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/openai_example/","title":"Agent with GPT-4o-Mini","text":"<ul> <li>Add <code>OPENAI_API_KEY=\"your_key\"</code> to your <code>.env</code> file</li> <li>Select your model like <code>gpt-4o-mini</code> or <code>gpt-4o</code></li> </ul> <pre><code>from swarms import Agent\n\nAgent(\n    agent_name=\"Stock-Analysis-Agent\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=\"auto\",\n    interactive=True,\n    streaming_on=True,\n).run(\"What are 5 hft algorithms\")\n</code></pre>"},{"location":"swarms/examples/openrouter/","title":"Agent with OpenRouter","text":"<ul> <li> <p>Add your <code>OPENROUTER_API_KEY</code> in the <code>.env</code> file</p> </li> <li> <p>Select your model_name like <code>openrouter/google/palm-2-chat-bison</code> follows LiteLLM conventions</p> </li> <li> <p>Execute your agent!</p> </li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"openrouter/google/palm-2-chat-bison\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/quant_crypto_agent/","title":"Quant Crypto Agent","text":"<ul> <li>This is a simple example of a crypto agent that uses the <code>Agent</code> class from the <code>swarms</code> library.</li> <li>It uses the <code>fetch_htx_data</code> and <code>coin_gecko_coin_api</code> tools to fetch data from the <code>htx</code> and <code>CoinGecko</code> APIs.</li> <li>It uses the <code>Agent</code> class to create an agent that can analyze the current state of a crypto asset.</li> </ul>"},{"location":"swarms/examples/quant_crypto_agent/#steps","title":"Steps","text":"<ol> <li>Install the <code>swarms</code> library.</li> <li>Install the <code>swarms_tools</code> library.</li> <li>Setup your <code>.env</code> file with the <code>OPENAI_API_KEY</code> environment variables.</li> <li>Run the code.</li> </ol>"},{"location":"swarms/examples/quant_crypto_agent/#installation","title":"Installation:","text":"<pre><code>pip install swarms swarms-tools python-dotenv\n</code></pre>"},{"location":"swarms/examples/quant_crypto_agent/#code","title":"Code:","text":"<pre><code>from swarms import Agent\nfrom dotenv import load_dotenv\nfrom swarms_tools import fetch_htx_data, coin_gecko_coin_api\n\nload_dotenv()\n\nCRYPTO_ANALYST_SYSTEM_PROMPT = \"\"\"\nYou are an expert cryptocurrency financial analyst with deep expertise in:\n1. Technical Analysis\n   - Chart patterns and indicators (RSI, MACD, Bollinger Bands)\n   - Volume analysis and market momentum\n   - Support and resistance levels\n   - Trend analysis and price action\n\n2. Fundamental Analysis\n   - Tokenomics evaluation\n   - Network metrics (TVL, daily active users, transaction volume)\n   - Protocol revenue and growth metrics\n   - Market capitalization analysis\n   - Token utility and use cases\n\n3. Market Analysis\n   - Market sentiment analysis\n   - Correlation with broader crypto market\n   - Impact of macro events\n   - Institutional adoption metrics\n   - DeFi and NFT market analysis\n\n4. Risk Assessment\n   - Volatility metrics\n   - Liquidity analysis\n   - Smart contract risks\n   - Regulatory considerations\n   - Exchange exposure risks\n\n5. Data Analysis Methods\n   - On-chain metrics analysis\n   - Whale wallet tracking\n   - Exchange inflow/outflow\n   - Mining/Staking statistics\n   - Network health indicators\n\nWhen analyzing crypto assets, always:\n1. Start with a comprehensive market overview\n2. Examine both on-chain and off-chain metrics\n3. Consider multiple timeframes (short, medium, long-term)\n4. Evaluate risk-reward ratios\n5. Assess market sentiment and momentum\n6. Consider regulatory and security factors\n7. Analyze correlations with BTC, ETH, and traditional markets\n8. Examine liquidity and volume profiles\n9. Review recent protocol developments and updates\n10. Consider macro economic factors\n\nFormat your analysis with:\n- Clear section headings\n- Relevant metrics and data points\n- Risk warnings and disclaimers\n- Price action analysis\n- Market sentiment summary\n- Technical indicators\n- Fundamental factors\n- Clear recommendations with rationale\n\nRemember to:\n- Always provide data-driven insights\n- Include both bullish and bearish scenarios\n- Highlight key risk factors\n- Consider market cycles and seasonality\n- Maintain objectivity in analysis\n- Cite sources for data and claims\n- Update analysis based on new market conditions\n\"\"\"\n\n# Initialize the crypto analysis agent\nagent = Agent(\n    agent_name=\"Crypto-Analysis-Expert\",\n    agent_description=\"Expert cryptocurrency financial analyst and market researcher\",\n    system_prompt=CRYPTO_ANALYST_SYSTEM_PROMPT,\n    max_loops=\"auto\",\n    model_name=\"gpt-4o\",\n    dynamic_temperature_enabled=True,\n    user_name=\"crypto_analyst\",\n    output_type=\"str\",\n    interactive=True,\n)\n\nprint(fetch_htx_data(\"sol\"))\nprint(coin_gecko_coin_api(\"solana\"))\n\n# Example usage\nagent.run(\n    f\"\"\"\n    Analyze the current state of Solana (SOL), including:\n    1. Technical analysis of price action\n    2. On-chain metrics and network health\n    3. Recent protocol developments\n    4. Market sentiment\n    5. Risk factors\n    Please provide a comprehensive analysis with data-driven insights.\n\n    # Solana CoinGecko Data\n    Real-tim data from Solana CoinGecko: \\n {coin_gecko_coin_api(\"solana\")}\n\n    \"\"\"\n)\n</code></pre>"},{"location":"swarms/examples/sequential_example/","title":"Sequential Workflow Example","text":"<p>Overview</p> <p>Learn how to create a sequential workflow with multiple specialized AI agents using the Swarms framework. This example demonstrates how to set up a legal practice workflow with different types of legal agents working in sequence.</p>"},{"location":"swarms/examples/sequential_example/#prerequisites","title":"Prerequisites","text":"<p>Before You Begin</p> <p>Make sure you have:</p> <ul> <li> <p>Python 3.7+ installed</p> </li> <li> <p>A valid API key for your model provider</p> </li> <li> <p>The Swarms package installed</p> </li> </ul>"},{"location":"swarms/examples/sequential_example/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/sequential_example/#environment-setup","title":"Environment Setup","text":"<p>API Key Configuration</p> <p>Set your API key in the <code>.env</code> file: <pre><code>OPENAI_API_KEY=\"your-api-key-here\"\n</code></pre></p>"},{"location":"swarms/examples/sequential_example/#code-implementation","title":"Code Implementation","text":""},{"location":"swarms/examples/sequential_example/#import-required-modules","title":"Import Required Modules","text":"<pre><code>from swarms import Agent, SequentialWorkflow\n</code></pre>"},{"location":"swarms/examples/sequential_example/#configure-agents","title":"Configure Agents","text":"<p>Legal Agent Configuration</p> <p>Here's how to set up your specialized legal agents:</p> <pre><code># Litigation Agent\nlitigation_agent = Agent(\n    agent_name=\"Alex Johnson\",\n    system_prompt=\"As a Litigator, you specialize in navigating the complexities of lawsuits. Your role involves analyzing intricate facts, constructing compelling arguments, and devising effective case strategies to achieve favorable outcomes for your clients.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n\n# Corporate Attorney Agent\ncorporate_agent = Agent(\n    agent_name=\"Emily Carter\",\n    system_prompt=\"As a Corporate Attorney, you provide expert legal advice on business law matters. You guide clients on corporate structure, governance, compliance, and transactions, ensuring their business operations align with legal requirements.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n\n# IP Attorney Agent\nip_agent = Agent(\n    agent_name=\"Michael Smith\",\n    system_prompt=\"As an IP Attorney, your expertise lies in protecting intellectual property rights. You handle various aspects of IP law, including patents, trademarks, copyrights, and trade secrets, helping clients safeguard their innovations.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n</code></pre>"},{"location":"swarms/examples/sequential_example/#initialize-sequential-workflow","title":"Initialize Sequential Workflow","text":"<p>Workflow Setup</p> <p>Configure the SequentialWorkflow with your agents:</p> <pre><code>swarm = SequentialWorkflow(\n    agents=[litigation_agent, corporate_agent, ip_agent],\n    name=\"litigation-practice\",\n    description=\"Handle all aspects of litigation with a focus on thorough legal analysis and effective case management.\",\n)\n</code></pre>"},{"location":"swarms/examples/sequential_example/#run-the-workflow","title":"Run the Workflow","text":"<p>Execute the Workflow</p> <p>Start the sequential workflow:</p> <pre><code>swarm.run(\"Create a report on how to patent an all-new AI invention and what platforms to use and more.\")\n</code></pre>"},{"location":"swarms/examples/sequential_example/#complete-example","title":"Complete Example","text":"<p>Full Implementation</p> <p>Here's the complete code combined:</p> <pre><code>from swarms import Agent, SequentialWorkflow\n\n# Core Legal Agent Definitions with enhanced system prompts\nlitigation_agent = Agent(\n    agent_name=\"Alex Johnson\",\n    system_prompt=\"As a Litigator, you specialize in navigating the complexities of lawsuits. Your role involves analyzing intricate facts, constructing compelling arguments, and devising effective case strategies to achieve favorable outcomes for your clients.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n\ncorporate_agent = Agent(\n    agent_name=\"Emily Carter\",\n    system_prompt=\"As a Corporate Attorney, you provide expert legal advice on business law matters. You guide clients on corporate structure, governance, compliance, and transactions, ensuring their business operations align with legal requirements.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n\nip_agent = Agent(\n    agent_name=\"Michael Smith\",\n    system_prompt=\"As an IP Attorney, your expertise lies in protecting intellectual property rights. You handle various aspects of IP law, including patents, trademarks, copyrights, and trade secrets, helping clients safeguard their innovations.\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n)\n\n# Initialize and run the workflow\nswarm = SequentialWorkflow(\n    agents=[litigation_agent, corporate_agent, ip_agent],\n    name=\"litigation-practice\",\n    description=\"Handle all aspects of litigation with a focus on thorough legal analysis and effective case management.\",\n)\n\nswarm.run(\"Create a report on how to patent an all-new AI invention and what platforms to use and more.\")\n</code></pre>"},{"location":"swarms/examples/sequential_example/#agent-roles","title":"Agent Roles","text":"<p>Specialized Legal Agents</p> Agent Role Expertise Alex Johnson Litigator Lawsuit navigation, case strategy Emily Carter Corporate Attorney Business law, compliance Michael Smith IP Attorney Patents, trademarks, copyrights"},{"location":"swarms/examples/sequential_example/#configuration-options","title":"Configuration Options","text":"<p>Key Parameters</p> Parameter Description Default <code>agent_name</code> Human-readable name for the agent Required <code>system_prompt</code> Detailed role description and expertise Required <code>model_name</code> LLM model to use \"gpt-4o-mini\" <code>max_loops</code> Maximum number of processing loops 1"},{"location":"swarms/examples/sequential_example/#next-steps","title":"Next Steps","text":"<p>What to Try Next</p> <ol> <li>Experiment with different agent roles and specializations</li> <li>Modify the system prompts to create different expertise areas</li> <li>Add more agents to the workflow for complex tasks</li> <li>Try different model configurations</li> </ol>"},{"location":"swarms/examples/sequential_example/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues</p> <ul> <li> <p>Ensure your API key is correctly set in the <code>.env</code> file</p> </li> <li> <p>Check that all required dependencies are installed</p> </li> <li> <p>Verify that your model provider's API is accessible</p> </li> <li> <p>Monitor agent responses for quality and relevance</p> </li> </ul>"},{"location":"swarms/examples/swarm_router/","title":"SwarmRouter Examples","text":"<p>The SwarmRouter is a flexible routing system designed to manage different types of swarms for task execution. It provides a unified interface to interact with various swarm types, including <code>AgentRearrange</code>, <code>MixtureOfAgents</code>, <code>SpreadSheetSwarm</code>, <code>SequentialWorkflow</code>, and <code>ConcurrentWorkflow</code>.</p>"},{"location":"swarms/examples/swarm_router/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>OpenAI API key or other supported LLM provider keys</li> <li>Swarms library</li> </ul>"},{"location":"swarms/examples/swarm_router/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/swarm_router/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/swarm_router/#basic-usage","title":"Basic Usage","text":""},{"location":"swarms/examples/swarm_router/#1-initialize-specialized-agents","title":"1. Initialize Specialized Agents","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.swarm_router import SwarmRouter, SwarmType\n\n# Initialize specialized agents\ndata_extractor_agent = Agent(\n    agent_name=\"Data-Extractor\",\n    system_prompt=\"You are a data extraction specialist...\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nsummarizer_agent = Agent(\n    agent_name=\"Document-Summarizer\",\n    system_prompt=\"You are a document summarization expert...\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n\nfinancial_analyst_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    system_prompt=\"You are a financial analysis specialist...\",\n    model_name=\"gpt-4o\",\n    max_loops=1,\n)\n</code></pre>"},{"location":"swarms/examples/swarm_router/#2-create-swarmrouter-with-sequential-workflow","title":"2. Create SwarmRouter with Sequential Workflow","text":"<pre><code>sequential_router = SwarmRouter(\n    name=\"SequentialRouter\",\n    description=\"Process tasks in sequence\",\n    agents=[data_extractor_agent, summarizer_agent, financial_analyst_agent],\n    swarm_type=SwarmType.SequentialWorkflow,\n    max_loops=1\n)\n\n# Run a task\nresult = sequential_router.run(\"Analyze and summarize the quarterly financial report\")\n</code></pre>"},{"location":"swarms/examples/swarm_router/#3-create-swarmrouter-with-concurrent-workflow","title":"3. Create SwarmRouter with Concurrent Workflow","text":"<pre><code>concurrent_router = SwarmRouter(\n    name=\"ConcurrentRouter\",\n    description=\"Process tasks concurrently\",\n    agents=[data_extractor_agent, summarizer_agent, financial_analyst_agent],\n    swarm_type=SwarmType.ConcurrentWorkflow,\n    max_loops=1\n)\n\n# Run a task\nresult = concurrent_router.run(\"Evaluate multiple aspects of the company simultaneously\")\n</code></pre>"},{"location":"swarms/examples/swarm_router/#4-create-swarmrouter-with-agentrearrange","title":"4. Create SwarmRouter with AgentRearrange","text":"<pre><code>rearrange_router = SwarmRouter(\n    name=\"RearrangeRouter\",\n    description=\"Dynamically rearrange agents for optimal task processing\",\n    agents=[data_extractor_agent, summarizer_agent, financial_analyst_agent],\n    swarm_type=SwarmType.AgentRearrange,\n    flow=f\"{data_extractor_agent.agent_name} -&gt; {summarizer_agent.agent_name} -&gt; {financial_analyst_agent.agent_name}\",\n    max_loops=1\n)\n\n# Run a task\nresult = rearrange_router.run(\"Process and analyze company documents\")\n</code></pre>"},{"location":"swarms/examples/swarm_router/#5-create-swarmrouter-with-mixtureofagents","title":"5. Create SwarmRouter with MixtureOfAgents","text":"<pre><code>mixture_router = SwarmRouter(\n    name=\"MixtureRouter\",\n    description=\"Combine multiple expert agents\",\n    agents=[data_extractor_agent, summarizer_agent, financial_analyst_agent],\n    swarm_type=SwarmType.MixtureOfAgents,\n    max_loops=1\n)\n\n# Run a task\nresult = mixture_router.run(\"Provide comprehensive analysis of company performance\")\n</code></pre>"},{"location":"swarms/examples/swarm_router/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/examples/swarm_router/#1-error-handling-and-logging","title":"1. Error Handling and Logging","text":"<pre><code>try:\n    result = router.run(\"Complex analysis task\")\n\n    # Retrieve and print logs\n    for log in router.get_logs():\n        print(f\"{log.timestamp} - {log.level}: {log.message}\")\nexcept Exception as e:\n    print(f\"Error occurred: {str(e)}\")\n</code></pre>"},{"location":"swarms/examples/swarm_router/#2-custom-configuration","title":"2. Custom Configuration","text":"<pre><code>router = SwarmRouter(\n    name=\"CustomRouter\",\n    description=\"Custom router configuration\",\n    agents=[data_extractor_agent, summarizer_agent, financial_analyst_agent],\n    swarm_type=SwarmType.SequentialWorkflow,\n    max_loops=3,\n    autosave=True,\n    verbose=True,\n    output_type=\"json\"\n)\n</code></pre>"},{"location":"swarms/examples/swarm_router/#best-practices","title":"Best Practices","text":""},{"location":"swarms/examples/swarm_router/#choose-the-appropriate-swarm-type-based-on-your-task-requirements","title":"Choose the appropriate swarm type based on your task requirements:","text":"Swarm Type Use Case <code>SequentialWorkflow</code> Tasks that need to be processed in order <code>ConcurrentWorkflow</code> Independent tasks that can be processed simultaneously <code>AgentRearrange</code> Tasks requiring dynamic agent organization <code>MixtureOfAgents</code> Complex tasks needing multiple expert perspectives"},{"location":"swarms/examples/swarm_router/#configure-agents-appropriately","title":"Configure agents appropriately:","text":"Configuration Aspect Description Agent Names &amp; Descriptions Set meaningful and descriptive names that reflect the agent's role and purpose System Prompts Define clear, specific prompts that outline the agent's responsibilities and constraints Model Parameters Configure appropriate parameters like temperature, max_tokens, and other model-specific settings"},{"location":"swarms/examples/swarm_router/#implement-proper-error-handling","title":"Implement proper error handling:","text":"Error Handling Practice Description Try-Except Blocks Implement proper exception handling with try-except blocks Log Monitoring Regularly monitor and analyze system logs for potential issues Edge Case Handling Implement specific handling for edge cases and unexpected scenarios"},{"location":"swarms/examples/swarm_router/#optimize-performance","title":"Optimize performance:","text":"Performance Optimization Description Concurrent Processing Utilize parallel processing capabilities when tasks can be executed simultaneously Max Loops Configuration Set appropriate iteration limits based on task complexity and requirements Resource Management Continuously monitor and optimize system resource utilization"},{"location":"swarms/examples/swarm_router/#example-implementation","title":"Example Implementation","text":"<p>Here's a complete example showing how to use SwarmRouter in a real-world scenario:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarms.structs.swarm_router import SwarmRouter, SwarmType\n\n# Initialize specialized agents\nresearch_agent = Agent(\n    agent_name=\"ResearchAgent\",\n    system_prompt=\"You are a research specialist...\",\n    model_name=\"gpt-4o\",\n    max_loops=1\n)\n\nanalysis_agent = Agent(\n    agent_name=\"AnalysisAgent\",\n    system_prompt=\"You are an analysis expert...\",\n    model_name=\"gpt-4o\",\n    max_loops=1\n)\n\nsummary_agent = Agent(\n    agent_name=\"SummaryAgent\",\n    system_prompt=\"You are a summarization specialist...\",\n    model_name=\"gpt-4o\",\n    max_loops=1\n)\n\n# Create router with sequential workflow\nrouter = SwarmRouter(\n    name=\"ResearchAnalysisRouter\",\n    description=\"Process research and analysis tasks\",\n    agents=[research_agent, analysis_agent, summary_agent],\n    swarm_type=SwarmType.SequentialWorkflow,\n    max_loops=1,\n    verbose=True\n)\n\n# Run complex task\ntry:\n    result = router.run(\n        \"Research and analyze the impact of AI on healthcare, \"\n        \"providing a comprehensive summary of findings.\"\n    )\n    print(\"Task Result:\", result)\n\n    # Print logs\n    for log in router.get_logs():\n        print(f\"{log.timestamp} - {log.level}: {log.message}\")\n\nexcept Exception as e:\n    print(f\"Error processing task: {str(e)}\")\n</code></pre> <p>This comprehensive guide demonstrates how to effectively use the SwarmRouter in various scenarios, making it easier to manage and orchestrate multiple agents for complex tasks. </p>"},{"location":"swarms/examples/swarms_api_finance/","title":"Finance Swarm Example","text":"<ol> <li>Get your API key from the Swarms API dashboard HERE</li> <li>Create a <code>.env</code> file in the root directory and add your API key:</li> </ol> <pre><code>SWARMS_API_KEY=&lt;your-api-key&gt;\n</code></pre> <ol> <li>Create a Python script to create and trigger the financial swarm:</li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\n# Retrieve API key securely from .env\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\n# Headers for secure API communication\nheaders = {\"x-api-key\": API_KEY, \"Content-Type\": \"application/json\"}\n\ndef create_financial_swarm(equity_data: str):\n    \"\"\"\n    Constructs and triggers a full-stack financial swarm consisting of three agents:\n    Equity Analyst, Risk Assessor, and Market Advisor.\n    Each agent is provided with a comprehensive, detailed system prompt to ensure high reliability.\n    \"\"\"\n\n    payload = {\n        \"swarm_name\": \"Enhanced Financial Analysis Swarm\",\n        \"description\": \"A swarm of agents specialized in performing comprehensive financial analysis, risk assessment, and market recommendations.\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Equity Analyst\",\n                \"description\": \"Agent specialized in analyzing equities data to provide insights on stock performance and valuation.\",\n                \"system_prompt\": (\n                    \"You are an experienced equity analyst with expertise in financial markets and stock valuation. \"\n                    \"Your role is to analyze the provided equities data, including historical performance, financial statements, and market trends. \"\n                    \"Provide a detailed analysis of the stock's potential, including valuation metrics and growth prospects. \"\n                    \"Consider macroeconomic factors, industry trends, and company-specific news. Your analysis should be clear, actionable, and well-supported by data.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 4000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Risk Assessor\",\n                \"description\": \"Agent responsible for evaluating the risks associated with equity investments.\",\n                \"system_prompt\": (\n                    \"You are a certified risk management professional with expertise in financial risk assessment. \"\n                    \"Your task is to evaluate the risks associated with the provided equities data, including market risk, credit risk, and operational risk. \"\n                    \"Provide a comprehensive risk analysis, including potential scenarios and their impact on investment performance. \"\n                    \"Your output should be detailed, reliable, and compliant with current risk management standards.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 3000,\n                \"temperature\": 0.2,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Market Advisor\",\n                \"description\": \"Agent dedicated to suggesting investment strategies based on market conditions and equity analysis.\",\n                \"system_prompt\": (\n                    \"You are a knowledgeable market advisor with expertise in investment strategies and portfolio management. \"\n                    \"Based on the analysis provided by the Equity Analyst and the risk assessment, your task is to recommend a comprehensive investment strategy. \"\n                    \"Your suggestions should include asset allocation, diversification strategies, and considerations for market conditions. \"\n                    \"Explain the rationale behind each recommendation and reference relevant market data where applicable. \"\n                    \"Your recommendations should be reliable, detailed, and clearly prioritized based on risk and return.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 5000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"SequentialWorkflow\",\n        \"task\": equity_data,\n    }\n\n    # Payload includes the equity data as the task to be processed by the swarm\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload,\n    )\n\n    if response.status_code == 200:\n        print(\"Swarm successfully executed!\")\n        return json.dumps(response.json(), indent=4)\n    else:\n        print(f\"Error {response.status_code}: {response.text}\")\n        return None\n\n\n# Example Equity Data for the Swarm to analyze\nif __name__ == \"__main__\":\n    equity_data = (\n        \"Analyze the equity data for Company XYZ, which has shown a 15% increase in revenue over the last quarter, \"\n        \"with a P/E ratio of 20 and a market cap of $1 billion. Consider the current market conditions and potential risks.\"\n    )\n\n    financial_output = create_financial_swarm(equity_data)\n    print(financial_output)\n</code></pre> <ol> <li>Run the script:</li> </ol> <pre><code>python financial_swarm.py\n</code></pre>"},{"location":"swarms/examples/swarms_api_medical/","title":"Medical Swarm Example","text":"<ol> <li>Get your API key from the Swarms API dashboard HERE</li> <li>Create a <code>.env</code> file in the root directory and add your API key:</li> </ol> <pre><code>SWARMS_API_KEY=&lt;your-api-key&gt;\n</code></pre> <ol> <li>Create a Python script to create and trigger the medical swarm:</li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\n# Retrieve API key securely from .env\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\n# Headers for secure API communication\nheaders = {\"x-api-key\": API_KEY, \"Content-Type\": \"application/json\"}\n\ndef create_medical_swarm(patient_case: str):\n    \"\"\"\n    Constructs and triggers a full-stack medical swarm consisting of three agents:\n    Diagnostic Specialist, Medical Coder, and Treatment Advisor.\n    Each agent is provided with a comprehensive, detailed system prompt to ensure high reliability.\n    \"\"\"\n\n    payload = {\n        \"swarm_name\": \"Enhanced Medical Diagnostic Swarm\",\n        \"description\": \"A swarm of agents specialized in performing comprehensive medical diagnostics, analysis, and coding.\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Diagnostic Specialist\",\n                \"description\": \"Agent specialized in analyzing patient history, symptoms, lab results, and imaging data to produce accurate diagnoses.\",\n                \"system_prompt\": (\n                    \"You are an experienced, board-certified medical diagnostician with over 20 years of clinical practice. \"\n                    \"Your role is to analyze all available patient information\u2014including history, symptoms, lab tests, and imaging results\u2014\"\n                    \"with extreme attention to detail and clinical nuance. Provide a comprehensive differential diagnosis considering \"\n                    \"common, uncommon, and rare conditions. Always cross-reference clinical guidelines and evidence-based medicine. \"\n                    \"Explain your reasoning step by step and provide a final prioritized list of potential diagnoses along with their likelihood. \"\n                    \"Consider patient demographics, comorbidities, and risk factors. Your diagnosis should be reliable, clear, and actionable.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 4000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Medical Coder\",\n                \"description\": \"Agent responsible for translating medical diagnoses and procedures into accurate standardized medical codes (ICD-10, CPT, etc.).\",\n                \"system_prompt\": (\n                    \"You are a certified and experienced medical coder, well-versed in ICD-10, CPT, and other coding systems. \"\n                    \"Your task is to convert detailed medical diagnoses and treatment procedures into precise, standardized codes. \"\n                    \"Consider all aspects of the clinical documentation including severity, complications, and comorbidities. \"\n                    \"Provide clear explanations for the codes chosen, referencing the latest coding guidelines and payer policies where relevant. \"\n                    \"Your output should be comprehensive, reliable, and fully compliant with current medical coding standards.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 3000,\n                \"temperature\": 0.2,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Treatment Advisor\",\n                \"description\": \"Agent dedicated to suggesting evidence-based treatment options, including pharmaceutical and non-pharmaceutical interventions.\",\n                \"system_prompt\": (\n                    \"You are a highly knowledgeable medical treatment specialist with expertise in the latest clinical guidelines and research. \"\n                    \"Based on the diagnostic conclusions provided, your task is to recommend a comprehensive treatment plan. \"\n                    \"Your suggestions should include first-line therapies, potential alternative treatments, and considerations for patient-specific factors \"\n                    \"such as allergies, contraindications, and comorbidities. Explain the rationale behind each treatment option and reference clinical guidelines where applicable. \"\n                    \"Your recommendations should be reliable, detailed, and clearly prioritized based on efficacy and safety.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 5000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"SequentialWorkflow\",\n        \"task\": patient_case,\n    }\n\n    # Payload includes the patient case as the task to be processed by the swar\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload,\n    )\n\n    if response.status_code == 200:\n        print(\"Swarm successfully executed!\")\n        return json.dumps(response.json(), indent=4)\n    else:\n        print(f\"Error {response.status_code}: {response.text}\")\n        return None\n\n\n# Example Patient Task for the Swarm to diagnose and analyze\nif __name__ == \"__main__\":\n    patient_case = (\n        \"Patient is a 55-year-old male presenting with severe chest pain, shortness of breath, elevated blood pressure, \"\n        \"nausea, and a family history of cardiovascular disease. Blood tests show elevated troponin levels, and EKG indicates ST-segment elevations. \"\n        \"The patient is currently unstable. Provide a detailed diagnosis, coding, and treatment plan.\"\n    )\n\n    diagnostic_output = create_medical_swarm(patient_case)\n    print(diagnostic_output)\n</code></pre> <ol> <li>Run the script:</li> </ol> <pre><code>python medical_swarm.py\n</code></pre>"},{"location":"swarms/examples/swarms_api_ml_model/","title":"ML Model Code Generation Swarm Example","text":"<ol> <li>Get your API key from the Swarms API dashboard HERE</li> <li>Create a <code>.env</code> file in the root directory and add your API key:</li> </ol> <pre><code>SWARMS_API_KEY=&lt;your-api-key&gt;\n</code></pre> <ol> <li>Create a Python script to create and trigger the following swarm:</li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\n# Retrieve API key securely from .env\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\n# Headers for secure API communication\nheaders = {\"x-api-key\": API_KEY, \"Content-Type\": \"application/json\"}\n\ndef create_ml_code_swarm(task_description: str):\n    \"\"\"\n    Constructs and triggers a swarm of agents for generating a complete machine learning project using PyTorch.\n    The swarm includes:\n      - Model Code Generator: Generates the PyTorch model architecture code.\n      - Training Script Generator: Creates a comprehensive training, validation, and testing script using PyTorch.\n      - Unit Test Creator: Produces extensive unit tests and helper code, ensuring correctness of the model and training scripts.\n    Each agent's prompt is highly detailed to output only Python code, with exclusive use of PyTorch.\n    \"\"\"\n    payload = {\n        \"swarm_name\": \"Comprehensive PyTorch Code Generation Swarm\",\n        \"description\": (\n            \"A production-grade swarm of agents tasked with generating a complete machine learning project exclusively using PyTorch. \"\n            \"The swarm is divided into distinct roles: one agent generates the core model architecture code; \"\n            \"another creates the training and evaluation scripts including data handling; and a third produces \"\n            \"extensive unit tests and helper functions. Each agent's instructions are highly detailed to ensure that the \"\n            \"output is strictly Python code with PyTorch as the only deep learning framework.\"\n        ),\n        \"agents\": [\n            {\n                \"agent_name\": \"Model Code Generator\",\n                \"description\": \"Generates the complete machine learning model architecture code using PyTorch.\",\n                \"system_prompt\": (\n                    \"You are an expert machine learning engineer with a deep understanding of PyTorch. \"\n                    \"Your task is to generate production-ready Python code that defines a complete deep learning model architecture exclusively using PyTorch. \"\n                    \"The code must include all necessary imports, class or function definitions, and should be structured in a modular and scalable manner. \"\n                    \"Follow PEP8 standards and output only code\u2014no comments, explanations, or extraneous text. \"\n                    \"Your model definition should include proper layer initialization, activation functions, dropout, and any custom components as required. \"\n                    \"Ensure that the entire output is strictly Python code based on PyTorch.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 2,\n                \"max_tokens\": 4000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Training Script Generator\",\n                \"description\": \"Creates a comprehensive training, validation, and testing script using PyTorch.\",\n                \"system_prompt\": (\n                    \"You are a highly skilled software engineer specializing in machine learning pipeline development with PyTorch. \"\n                    \"Your task is to generate Python code that builds a complete training pipeline using PyTorch. \"\n                    \"The script must include robust data loading, preprocessing, augmentation, and a complete training loop, along with validation and testing procedures. \"\n                    \"All necessary imports should be included and the code should assume that the model code from the previous agent is available via proper module imports. \"\n                    \"Follow best practices for reproducibility and modularity, and output only code without any commentary or non-code text. \"\n                    \"The entire output must be strictly Python code that uses PyTorch for all deep learning operations.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 3000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Unit Test Creator\",\n                \"description\": \"Develops a suite of unit tests and helper functions for verifying the PyTorch model and training pipeline.\",\n                \"system_prompt\": (\n                    \"You are an experienced software testing expert with extensive experience in writing unit tests for machine learning projects in PyTorch. \"\n                    \"Your task is to generate Python code that consists solely of unit tests and any helper functions required to validate both the PyTorch model and the training pipeline. \"\n                    \"Utilize testing frameworks such as pytest or unittest. The tests should cover key functionalities such as model instantiation, forward pass correctness, \"\n                    \"training loop execution, data preprocessing verification, and error handling. \"\n                    \"Ensure that your output is only Python code, without any additional text or commentary, and that it is ready to be integrated into a CI/CD pipeline. \"\n                    \"The entire output must exclusively use PyTorch as the deep learning framework.\"\n                ),\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 3000,\n                \"temperature\": 0.3,\n                \"auto_generate_prompt\": False\n            }\n        ],\n        \"max_loops\": 3,\n        \"swarm_type\": \"SequentialWorkflow\"  # Sequential workflow: later agents can assume outputs from earlier ones\n    }\n\n    # The task description provides the high-level business requirement for the swarm.\n    payload = {\n        \"task\": task_description,\n        \"swarm\": payload\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/swarm/completion\",\n        headers=headers,\n        json=payload,\n    )\n\n    if response.status_code == 200:\n        print(\"PyTorch Code Generation Swarm successfully executed!\")\n        return json.dumps(response.json(), indent=4)\n    else:\n        print(f\"Error {response.status_code}: {response.text}\")\n        return None\n\n# Example business task for the swarm: generating a full-stack machine learning pipeline for image classification using PyTorch.\nif __name__ == \"__main__\":\n    task_description = (\n        \"Develop a full-stack machine learning pipeline for image classification using PyTorch. \"\n        \"The project must include a deep learning model using a CNN architecture for image recognition, \"\n        \"a comprehensive training script for data preprocessing, augmentation, training, validation, and testing, \"\n        \"and an extensive suite of unit tests to validate every component. \"\n        \"Each component's output must be strictly Python code with no additional text or commentary, using PyTorch exclusively.\"\n    )\n\n    output = create_ml_code_swarm(task_description)\n    print(output)\n</code></pre>"},{"location":"swarms/examples/swarms_dao/","title":"Swarms DAO Example","text":"<p>This example demonstrates how to create a swarm of agents to collaborate on a task. The agents are designed to work together to create a comprehensive strategy for a DAO focused on decentralized governance for climate action.</p> <p>You can customize the agents and their system prompts to fit your specific needs.</p> <p>And, this example is using the <code>deepseek-reasoner</code> model, which is a large language model that is optimized for reasoning tasks.</p>"},{"location":"swarms/examples/swarms_dao/#todo","title":"Todo","text":"<ul> <li>Add tools to check wallet of the treasury and check the balance of the treasury</li> <li>Add tools to check the price of the token</li> <li>Add tools to check the price of the token on different exchanges</li> <li>Add tools to check the price of the token on different chains</li> <li>Add tools to check twitter posts and check the sentiment of the posts</li> </ul> <pre><code>import random\nfrom swarms import Agent\n\n# System prompts for each agent\nMARKETING_AGENT_SYS_PROMPT = \"\"\"\nYou are the Marketing Strategist Agent for a DAO. Your role is to develop, implement, and optimize all marketing and branding strategies to align with the DAO's mission and vision. The DAO is focused on decentralized governance for climate action, funding projects aimed at reducing carbon emissions, and incentivizing community participation through its native token.\n\n### Objectives:\n1. **Brand Awareness**: Build a globally recognized and trusted brand for the DAO.\n2. **Community Growth**: Expand the DAO's community by onboarding individuals passionate about climate action and blockchain technology.\n3. **Campaign Execution**: Launch high-impact marketing campaigns on platforms like Twitter, Discord, and YouTube to engage and retain community members.\n4. **Partnerships**: Identify and build partnerships with like-minded organizations, NGOs, and influencers.\n5. **Content Strategy**: Design educational and engaging content, including infographics, blog posts, videos, and AMAs.\n\n### Instructions:\n- Thoroughly analyze the product description and DAO mission.\n- Collaborate with the Growth, Product, Treasury, and Operations agents to align marketing strategies with overall goals.\n- Create actionable steps for social media growth, community engagement, and brand storytelling.\n- Leverage analytics to refine marketing strategies, focusing on measurable KPIs like engagement, conversion rates, and member retention.\n- Suggest innovative methods to make the DAO's mission resonate with a broader audience (e.g., gamified incentives, contests, or viral campaigns).\n- Ensure every strategy emphasizes transparency, sustainability, and long-term impact.\n\"\"\"\n\nPRODUCT_AGENT_SYS_PROMPT = \"\"\"\nYou are the Product Manager Agent for a DAO focused on decentralized governance for climate action. Your role is to design, manage, and optimize the DAO's product roadmap. This includes defining key features, prioritizing user needs, and ensuring product alignment with the DAO\u2019s mission of reducing carbon emissions and incentivizing community participation.\n\n### Objectives:\n1. **User-Centric Design**: Identify the DAO community\u2019s needs and design features to enhance their experience.\n2. **Roadmap Prioritization**: Develop a prioritized product roadmap based on community feedback and alignment with climate action goals.\n3. **Integration**: Suggest technical solutions and tools for seamless integration with other platforms and blockchains.\n4. **Continuous Improvement**: Regularly evaluate product features and recommend optimizations to improve usability, engagement, and adoption.\n\n### Instructions:\n- Collaborate with the Marketing and Growth agents to understand user feedback and market trends.\n- Engage the Treasury Agent to ensure product development aligns with budget constraints and revenue goals.\n- Suggest mechanisms for incentivizing user engagement, such as staking rewards or gamified participation.\n- Design systems that emphasize decentralization, transparency, and scalability.\n- Provide detailed feature proposals, technical specifications, and timelines for implementation.\n- Ensure all features are optimized for both experienced blockchain users and newcomers to Web3.\n\"\"\"\n\nGROWTH_AGENT_SYS_PROMPT = \"\"\"\nYou are the Growth Strategist Agent for a DAO focused on decentralized governance for climate action. Your primary role is to identify and implement growth strategies to increase the DAO\u2019s user base and engagement.\n\n### Objectives:\n1. **User Acquisition**: Identify effective strategies to onboard more users to the DAO.\n2. **Retention**: Suggest ways to improve community engagement and retain active members.\n3. **Data-Driven Insights**: Leverage data analytics to identify growth opportunities and areas of improvement.\n4. **Collaborative Growth**: Work with other agents to align growth efforts with marketing, product development, and treasury goals.\n\n### Instructions:\n- Collaborate with the Marketing Agent to optimize campaigns for user acquisition.\n- Analyze user behavior and suggest actionable insights to improve retention.\n- Recommend partnerships with influential figures or organizations to enhance the DAO's visibility.\n- Propose growth experiments (A/B testing, new incentives, etc.) and analyze their effectiveness.\n- Suggest tools for data collection and analysis, ensuring privacy and transparency.\n- Ensure growth strategies align with the DAO's mission of sustainability and climate action.\n\"\"\"\n\nTREASURY_AGENT_SYS_PROMPT = \"\"\"\nYou are the Treasury Management Agent for a DAO focused on decentralized governance for climate action. Your role is to oversee the DAO's financial operations, including budgeting, funding allocation, and financial reporting.\n\n### Objectives:\n1. **Financial Transparency**: Maintain clear and detailed reports of the DAO's financial status.\n2. **Budget Management**: Allocate funds strategically to align with the DAO's goals and priorities.\n3. **Fundraising**: Identify and recommend strategies for fundraising to ensure the DAO's financial sustainability.\n4. **Cost Optimization**: Suggest ways to reduce operational costs without sacrificing quality.\n\n### Instructions:\n- Collaborate with all other agents to align funding with the DAO's mission and strategic goals.\n- Propose innovative fundraising campaigns (e.g., NFT drops, token sales) to generate revenue.\n- Analyze financial risks and suggest mitigation strategies.\n- Ensure all recommendations prioritize the DAO's mission of reducing carbon emissions and driving global climate action.\n- Provide periodic financial updates and propose budget reallocations based on current needs.\n\"\"\"\n\nOPERATIONS_AGENT_SYS_PROMPT = \"\"\"\nYou are the Operations Coordinator Agent for a DAO focused on decentralized governance for climate action. Your role is to ensure smooth day-to-day operations, coordinate workflows, and manage governance processes.\n\n### Objectives:\n1. **Workflow Optimization**: Streamline operational processes to maximize efficiency and effectiveness.\n2. **Task Coordination**: Manage and delegate tasks to ensure timely delivery of goals.\n3. **Governance**: Oversee governance processes, including proposal management and voting mechanisms.\n4. **Communication**: Ensure seamless communication between all agents and community members.\n\n### Instructions:\n- Collaborate with other agents to align operations with DAO objectives.\n- Facilitate communication and task coordination between Marketing, Product, Growth, and Treasury agents.\n- Create efficient workflows to handle DAO proposals and governance activities.\n- Suggest tools or platforms to improve operational efficiency.\n- Provide regular updates on task progress and flag any blockers or risks.\n\"\"\"\n\n# Initialize agents\nmarketing_agent = Agent(\n    agent_name=\"Marketing-Agent\",\n    system_prompt=MARKETING_AGENT_SYS_PROMPT,\n    model_name=\"deepseek/deepseek-reasoner\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n)\n\nproduct_agent = Agent(\n    agent_name=\"Product-Agent\",\n    system_prompt=PRODUCT_AGENT_SYS_PROMPT,\n    model_name=\"deepseek/deepseek-reasoner\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n)\n\ngrowth_agent = Agent(\n    agent_name=\"Growth-Agent\",\n    system_prompt=GROWTH_AGENT_SYS_PROMPT,\n    model_name=\"deepseek/deepseek-reasoner\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n)\n\ntreasury_agent = Agent(\n    agent_name=\"Treasury-Agent\",\n    system_prompt=TREASURY_AGENT_SYS_PROMPT,\n    model_name=\"deepseek/deepseek-reasoner\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n)\n\noperations_agent = Agent(\n    agent_name=\"Operations-Agent\",\n    system_prompt=OPERATIONS_AGENT_SYS_PROMPT,\n    model_name=\"deepseek/deepseek-reasoner\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n)\n\nagents = [marketing_agent, product_agent, growth_agent, treasury_agent, operations_agent]\n\n\nclass DAOSwarmRunner:\n    \"\"\"\n    A class to manage and run a swarm of agents in a discussion.\n    \"\"\"\n\n    def __init__(self, agents: list, max_loops: int = 5, shared_context: str = \"\") -&gt; None:\n        \"\"\"\n        Initializes the DAO Swarm Runner.\n\n        Args:\n            agents (list): A list of agents in the swarm.\n            max_loops (int, optional): The maximum number of discussion loops between agents. Defaults to 5.\n            shared_context (str, optional): The shared context for all agents to base their discussion on. Defaults to an empty string.\n        \"\"\"\n        self.agents = agents\n        self.max_loops = max_loops\n        self.shared_context = shared_context\n        self.discussion_history = []\n\n    def run(self, task: str) -&gt; str:\n        \"\"\"\n        Runs the swarm in a random discussion.\n\n        Args:\n            task (str): The task or context that agents will discuss.\n\n        Returns:\n            str: The final discussion output after all loops.\n        \"\"\"\n        print(f\"Task: {task}\")\n        print(\"Initializing Random Discussion...\")\n\n        # Initialize the discussion with the shared context\n        current_message = f\"Task: {task}\\nContext: {self.shared_context}\"\n        self.discussion_history.append(current_message)\n\n        # Run the agents in a randomized discussion\n        for loop in range(self.max_loops):\n            print(f\"\\n--- Loop {loop + 1}/{self.max_loops} ---\")\n            # Choose a random agent\n            agent = random.choice(self.agents)\n            print(f\"Agent {agent.agent_name} is responding...\")\n\n            # Run the agent and get a response\n            response = agent.run(current_message)\n            print(f\"Agent {agent.agent_name} says:\\n{response}\\n\")\n\n            # Append the response to the discussion history\n            self.discussion_history.append(f\"{agent.agent_name}: {response}\")\n\n            # Update the current message for the next agent\n            current_message = response\n\n        print(\"\\n--- Discussion Complete ---\")\n        return \"\\n\".join(self.discussion_history)\n\n\nswarm = DAOSwarmRunner(agents=agents, max_loops=1, shared_context=\"\")\n\n# User input for product description\nproduct_description = \"\"\"\nThe DAO is focused on decentralized governance for climate action. \nIt funds projects aimed at reducing carbon emissions and incentivizes community participation with a native token.\n\"\"\"\n\n# Assign a shared context for all agents\nswarm.shared_context = product_description\n\n# Run the swarm\ntask = \"\"\"\nAnalyze the product description and create a collaborative strategy for marketing, product, growth, treasury, and operations. Ensure all recommendations align with the DAO's mission of reducing carbon emissions.\n\"\"\"\noutput = swarm.run(task)\n\n# Print the swarm output\nprint(\"Collaborative Strategy Output:\\n\", output)\n</code></pre>"},{"location":"swarms/examples/swarms_of_browser_agents/","title":"Swarms x Browser Use","text":"<ul> <li> <p>Import required modules</p> </li> <li> <p>Configure your agent first by making a new class</p> </li> <li> <p>Set your api keys for your model provider in the <code>.env</code> file such as <code>OPENAI_API_KEY=\"sk-\"</code></p> </li> <li> <p>Conigure your <code>ConcurrentWorkflow</code></p> </li> </ul>"},{"location":"swarms/examples/swarms_of_browser_agents/#install","title":"Install","text":""},{"location":"swarms/examples/swarms_of_browser_agents/#pip-install-swarms-browser-use-langchain-openai","title":"<pre><code>pip install swarms browser-use langchain-openai\n</code></pre>","text":""},{"location":"swarms/examples/swarms_of_browser_agents/#main","title":"Main","text":"<pre><code>import asyncio\n\nfrom browser_use import Agent\nfrom dotenv import load_dotenv\nfrom langchain_openai import ChatOpenAI\n\nfrom swarms import ConcurrentWorkflow\n\nload_dotenv()\n\n\nclass BrowserAgent:\n    def __init__(self, agent_name: str = \"BrowserAgent\"):\n        self.agent_name = agent_name\n\n    async def browser_agent_test(self, task: str):\n        agent = Agent(\n            task=task,\n            llm=ChatOpenAI(model=\"gpt-4o\"),\n        )\n        result = await agent.run()\n        return result\n\n    def run(self, task: str):\n        return asyncio.run(self.browser_agent_test(task))\n\n\nswarm = ConcurrentWorkflow(\n    agents=[BrowserAgent() for _ in range(3)],\n)\n\nswarm.run(\n    \"\"\"\n    Go to pump.fun.\n\n    2. Make an account: use email: \"test@test.com\" and password: \"test1234\"\n\n    3. Make a coin called and give it a cool description and etc. Fill in the form\n\n    4. Sit back and watch the coin grow in value.\n\n    \"\"\"\n)\n</code></pre>"},{"location":"swarms/examples/swarms_tools_htx/","title":"Swarms Tools Example with HTX + CoinGecko","text":"<ul> <li><code>pip3 install swarms swarms-tools</code></li> <li>Add <code>OPENAI_API_KEY</code> to your <code>.env</code> file</li> </ul> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\nfrom swarms_tools import (\n    coin_gecko_coin_api,\n    fetch_htx_data,\n)\n\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=1,\n    model_name=\"gpt-4o\",\n    dynamic_temperature_enabled=True,\n    user_name=\"swarms_corp\",\n    return_step_meta=False,\n    output_type=\"str\",  # \"json\", \"dict\", \"csv\" OR \"string\" \"yaml\" and\n    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task\n    max_tokens=4000,  # max output tokens\n    saved_state_path=\"agent_00.json\",\n    interactive=False,\n)\n\nagent.run(\n    f\"Analyze the $swarms token on HTX with data: {fetch_htx_data('swarms')}. Additionally, consider the following CoinGecko data: {coin_gecko_coin_api('swarms')}\"\n)\n</code></pre>"},{"location":"swarms/examples/swarms_tools_htx_gecko/","title":"Swarms Tools Example with HTX + CoinGecko","text":"<ul> <li><code>pip3 install swarms swarms-tools</code></li> <li>Add <code>OPENAI_API_KEY</code> to your <code>.env</code> file</li> <li>Run <code>swarms_tools_htx_gecko.py</code></li> <li>Agent will make a function call to the desired tool</li> <li>The tool will be executed and the result will be returned to the agent</li> <li>The agent will then analyze the result and return the final output</li> </ul> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\nfrom swarms_tools import (\n    fetch_stock_news,\n    coin_gecko_coin_api,\n    fetch_htx_data,\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=1,\n    model_name=\"gpt-4o\",\n    dynamic_temperature_enabled=True,\n    user_name=\"swarms_corp\",\n    retry_attempts=3,\n    context_length=8192,\n    return_step_meta=False,\n    output_type=\"str\",  # \"json\", \"dict\", \"csv\" OR \"string\" \"yaml\" and\n    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task\n    max_tokens=4000,  # max output tokens\n    saved_state_path=\"agent_00.json\",\n    interactive=False,\n    tools=[fetch_stock_news, coin_gecko_coin_api, fetch_htx_data],\n)\n\nagent.run(\"Analyze the $swarms token on htx\")\n</code></pre>"},{"location":"swarms/examples/templates_index/","title":"The Swarms Index","text":"<p>The Swarms Index is a comprehensive catalog of repositories under The Swarm Corporation, showcasing a wide array of tools, frameworks, and templates designed for building, deploying, and managing autonomous AI agents and multi-agent systems. These repositories focus on enterprise-grade solutions, spanning industries like healthcare, finance, marketing, and more, with an emphasis on scalability, security, and performance. Many repositories include templates to help developers quickly set up production-ready applications.</p> Name Description Link Phala-Deployment-Template A guide and template for running Swarms Agents in a Trusted Execution Environment (TEE) using Phala Cloud, ensuring secure and isolated execution. https://github.com/The-Swarm-Corporation/Phala-Deployment-Template Swarms-API-Status-Page A status page for monitoring the health and performance of the Swarms API. https://github.com/The-Swarm-Corporation/Swarms-API-Status-Page Swarms-API-Phala-Template A deployment solution template for running Swarms API on Phala Cloud, optimized for secure and scalable agent orchestration. https://github.com/The-Swarm-Corporation/Swarms-API-Phala-Template DevSwarm Develop production-grade applications effortlessly with a single prompt, powered by a swarm of v0-driven autonomous agents operating 24/7 for fully autonomous software development. https://github.com/The-Swarm-Corporation/DevSwarm Enterprise-Grade-Agents-Course A comprehensive course teaching students to build, deploy, and manage autonomous agents for enterprise workflows using the Swarms library, focusing on scalability and integration. https://github.com/The-Swarm-Corporation/Enterprise-Grade-Agents-Course agentverse A collection of agents from top frameworks like Langchain, Griptape, and CrewAI, integrated into the Swarms ecosystem. https://github.com/The-Swarm-Corporation/agentverse InsuranceSwarm A swarm of agents to automate document processing and fraud detection in insurance claims. https://github.com/The-Swarm-Corporation/InsuranceSwarm swarms-examples A vast array of examples for enterprise-grade and production-ready applications using the Swarms framework. https://github.com/The-Swarm-Corporation/swarms-examples auto-ai-research-team Automates AI research at an OpenAI level to accelerate innovation using swarms of agents. https://github.com/The-Swarm-Corporation/auto-ai-research-team Agents-Beginner-Guide A definitive beginner's guide to AI agents and multi-agent systems, explaining fundamentals and industry applications. https://github.com/The-Swarm-Corporation/Agents-Beginner-Guide Solana-Ecosystem-MCP A collection of Solana tools wrapped in MCP servers for blockchain development. https://github.com/The-Swarm-Corporation/Solana-Ecosystem-MCP automated-crypto-fund A fully automated crypto fund leveraging swarms of LLM agents for real-money trading. https://github.com/The-Swarm-Corporation/automated-crypto-fund Mryaid The first multi-agent social media platform powered by Swarms. https://github.com/The-Swarm-Corporation/Mryaid pharma-swarm A swarm of autonomous agents for chemical analysis in the pharmaceutical industry. https://github.com/The-Swarm-Corporation/pharma-swarm Automated-Prompt-Engineering-Hub A hub for tools and resources focused on automated prompt engineering for generative AI. https://github.com/The-Swarm-Corporation/Automated-Prompt-Engineering-Hub Multi-Agent-Template-App A simple, reliable, and high-performance template for building multi-agent applications. https://github.com/The-Swarm-Corporation/Multi-Agent-Template-App Cookbook Examples and guides for using the Swarms Framework effectively. https://github.com/The-Swarm-Corporation/Cookbook SwarmDB A production-grade message queue system for agent communication and LLM backend load balancing. https://github.com/The-Swarm-Corporation/SwarmDB CryptoTaxSwarm A personal advisory tax swarm for cryptocurrency transactions. https://github.com/The-Swarm-Corporation/CryptoTaxSwarm Multi-Agent-Marketing-Course A course on automating marketing operations with enterprise-grade multi-agent collaboration. https://github.com/The-Swarm-Corporation/Multi-Agent-Marketing-Course Swarms-BrandBook Branding guidelines and assets for Swarms.ai, embodying innovation and collaboration. https://github.com/The-Swarm-Corporation/Swarms-BrandBook AgentAPI A definitive API for managing and interacting with AI agents. https://github.com/The-Swarm-Corporation/AgentAPI Research-Paper-Writer-Swarm Automates the creation of high-quality research papers in LaTeX using Swarms agents. https://github.com/The-Swarm-Corporation/Research-Paper-Writer-Swarm swarms-sdk A Python client for the Swarms API, providing a simple interface for managing AI swarms. https://github.com/The-Swarm-Corporation/swarms-sdk FluidAPI A framework for interacting with APIs using natural language, simplifying complex requests. https://github.com/The-Swarm-Corporation/FluidAPI MedicalCoderSwarm A multi-agent system for comprehensive medical diagnosis and coding using specialized AI agents. https://github.com/The-Swarm-Corporation/MedicalCoderSwarm BackTesterAgent An AI-powered backtesting framework for automated trading strategy validation and optimization. https://github.com/The-Swarm-Corporation/BackTesterAgent .ai The first natural language programming language powered by Swarms. https://github.com/The-Swarm-Corporation/.ai AutoHedge An autonomous hedge fund leveraging swarm intelligence for market analysis and trade execution. https://github.com/The-Swarm-Corporation/AutoHedge radiology-swarm A multi-agent system for advanced radiological analysis, diagnosis, and treatment planning. https://github.com/The-Swarm-Corporation/radiology-swarm MedGuard A Python library ensuring HIPAA compliance for LLM agents in healthcare applications. https://github.com/The-Swarm-Corporation/MedGuard doc-master A lightweight Python library for automated file reading and content extraction. https://github.com/The-Swarm-Corporation/doc-master Open-Aladdin An open-source risk-management tool for stock and security risk analysis. https://github.com/The-Swarm-Corporation/Open-Aladdin TickrAgent A scalable Python library for building financial agents for comprehensive stock analysis. https://github.com/The-Swarm-Corporation/TickrAgent NewsAgent An enterprise-grade news aggregation agent for fetching, querying, and summarizing news. https://github.com/The-Swarm-Corporation/NewsAgent Research-Paper-Hive A platform for discovering and engaging with relevant research papers efficiently. https://github.com/The-Swarm-Corporation/Research-Paper-Hive MedInsight-Pro Revolutionizes medical research summarization for healthcare innovators. https://github.com/The-Swarm-Corporation/MedInsight-Pro swarms-memory Pre-built wrappers for RAG systems like ChromaDB, Weaviate, and Pinecone. https://github.com/The-Swarm-Corporation/swarms-memory CryptoAgent An enterprise-grade solution for fetching, analyzing, and summarizing cryptocurrency data. https://github.com/The-Swarm-Corporation/CryptoAgent AgentParse A high-performance parsing library for mapping structured data into agent-understandable blocks. https://github.com/The-Swarm-Corporation/AgentParse CodeGuardian An intelligent agent for automating the generation of production-grade unit tests for Python code. https://github.com/The-Swarm-Corporation/CodeGuardian Marketing-Swarm-Template A framework for creating multi-platform marketing content using Swarms AI agents. https://github.com/The-Swarm-Corporation/Marketing-Swarm-Template HTX-Swarm A multi-agent system for real-time market analysis of HTX exchange data. https://github.com/The-Swarm-Corporation/HTX-Swarm MultiModelOptimizer A hierarchical parameter synchronization approach for joint training of transformer models. https://github.com/The-Swarm-Corporation/MultiModelOptimizer MortgageUnderwritingSwarm A multi-agent pipeline for automating mortgage underwriting processes. https://github.com/The-Swarm-Corporation/MortgageUnderwritingSwarm DermaSwarm A multi-agent system for dermatologists to diagnose and treat skin conditions collaboratively. https://github.com/The-Swarm-Corporation/DermaSwarm IoTAgents Integrates IoT data with AI agents for seamless parsing and processing of data streams. https://github.com/The-Swarm-Corporation/IoTAgents eth-agent An autonomous agent for analyzing on-chain Ethereum data. https://github.com/The-Swarm-Corporation/eth-agent Medical-Swarm-One-Click A template for building safe, reliable, and production-grade medical multi-agent systems. https://github.com/The-Swarm-Corporation/Medical-Swarm-One-Click Swarms-Example-1-Click-Template A one-click template for building Swarms applications quickly. https://github.com/The-Swarm-Corporation/Swarms-Example-1-Click-Template Custom-Swarms-Spec-Template An official specification template for custom swarm development using the Swarms Framework. https://github.com/The-Swarm-Corporation/Custom-Swarms-Spec-Template Swarms-LlamaIndex-RAG-Template A template for integrating Llama Index into Swarms applications for RAG capabilities. https://github.com/The-Swarm-Corporation/Swarms-LlamaIndex-RAG-Template ForexTreeSwarm A forex market analysis system using a swarm of AI agents organized in a forest structure. https://github.com/The-Swarm-Corporation/ForexTreeSwarm Generalist-Mathematician-Swarm A swarm of agents for solving complex mathematical problems collaboratively. https://github.com/The-Swarm-Corporation/Generalist-Mathematician-Swarm Multi-Modal-XRAY-Diagnosis-Medical-Swarm-Template A template for analyzing X-rays, MRIs, and more using a swarm of agents. https://github.com/The-Swarm-Corporation/Multi-Modal-XRAY-Diagnosis-Medical-Swarm-Template AgentRAGProtocol A protocol for integrating Retrieval-Augmented Generation (RAG) into AI agents. https://github.com/The-Swarm-Corporation/AgentRAGProtocol Multi-Agent-RAG-Template A template for creating collaborative AI agent teams for document processing and analysis. https://github.com/The-Swarm-Corporation/Multi-Agent-RAG-Template REACT-Yaml-Agent An implementation of a REACT agent using YAML instead of JSON. https://github.com/The-Swarm-Corporation/REACT-Yaml-Agent SwarmsXGCP A template for deploying Swarms agents on Google Cloud Run. https://github.com/The-Swarm-Corporation/SwarmsXGCP Legal-Swarm-Template A one-click template for building legal-focused Swarms applications. https://github.com/The-Swarm-Corporation/Legal-Swarm-Template swarms_sim A simulation of a swarm of agents in a professional workplace environment. https://github.com/The-Swarm-Corporation/swarms_sim medical-problems A repository for medical problems to create Swarms applications for. https://github.com/The-Swarm-Corporation/medical-problems swarm-ecosystem An overview of the Swarm Ecosystem and its components. https://github.com/The-Swarm-Corporation/swarm-ecosystem swarms_ecosystem_md MDX documentation for the Swarm Ecosystem. https://github.com/The-Swarm-Corporation/swarms_ecosystem_md Hierarchical Swarm Examples Simple, practical examples of HierarchicalSwarm usage for various real-world scenarios. Documentation"},{"location":"swarms/examples/unique_swarms/","title":"Unique Swarms","text":"<p>In this section, we present a diverse collection of unique swarms, each with its own distinct characteristics and applications. These examples are designed to illustrate the versatility and potential of swarm intelligence in various domains. By exploring these examples, you can gain a deeper understanding of how swarms can be leveraged to solve complex problems and improve decision-making processes.</p>"},{"location":"swarms/examples/unique_swarms/#documentation","title":"Documentation","text":""},{"location":"swarms/examples/unique_swarms/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Common Parameters</li> <li>Basic Swarm Patterns</li> <li>Mathematical Swarm Patterns</li> <li>Advanced Swarm Patterns</li> <li>Communication Patterns</li> <li>Best Practices</li> <li>Common Use Cases</li> </ol>"},{"location":"swarms/examples/unique_swarms/#common-parameters","title":"Common Parameters","text":"<p>All swarm architectures accept these base parameters:</p> <ul> <li><code>agents: AgentListType</code> - List of Agent objects to participate in the swarm</li> <li><code>tasks: List[str]</code> - List of tasks to be processed by the agents</li> <li><code>return_full_history: bool</code> (optional) - If True, returns conversation history. Defaults to True</li> </ul> <p>Return types are generally <code>Union[dict, List[str]]</code>, where: - If <code>return_full_history=True</code>: Returns a dictionary containing the full conversation history - If <code>return_full_history=False</code>: Returns a list of agent responses</p>"},{"location":"swarms/examples/unique_swarms/#basic-swarm-patterns","title":"Basic Swarm Patterns","text":""},{"location":"swarms/examples/unique_swarms/#circular-swarm","title":"Circular Swarm","text":"<pre><code>def circular_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)\n</code></pre> <p>Information Flow: <pre><code>flowchart LR\n    subgraph Circular Flow\n    A1((Agent 1)) --&gt; A2((Agent 2))\n    A2 --&gt; A3((Agent 3))\n    A3 --&gt; A4((Agent 4))\n    A4 --&gt; A1\n    end\n    Task1[Task 1] --&gt; A1\n    Task2[Task 2] --&gt; A2\n    Task3[Task 3] --&gt; A3</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>You need continuous processing of tasks</p> </li> <li> <p>Tasks need to be processed by every agent in sequence</p> </li> <li> <p>You want predictable, ordered task distribution</p> </li> </ul> <p>Key Features:</p> <ul> <li> <p>Tasks move in a circular pattern through all agents</p> </li> <li> <p>Each agent processes each task once</p> </li> <li> <p>Maintains strict ordering of task processing</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#linear-swarm","title":"Linear Swarm","text":"<pre><code>def linear_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)\n</code></pre> <p>Information Flow: <pre><code>flowchart LR\n    Input[Task Input] --&gt; A1\n    subgraph Sequential Processing\n    A1((Agent 1)) --&gt; A2((Agent 2))\n    A2 --&gt; A3((Agent 3))\n    A3 --&gt; A4((Agent 4))\n    A4 --&gt; A5((Agent 5))\n    end\n    A5 --&gt; Output[Final Result]</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>Tasks need sequential, pipeline-style processing</p> </li> <li> <p>Each agent performs a specific transformation step</p> </li> <li> <p>Order of processing is critical</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#star-swarm","title":"Star Swarm","text":"<pre><code>def star_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    subgraph Star Pattern\n    A1((Central Agent))\n    A2((Agent 2))\n    A3((Agent 3))\n    A4((Agent 4))\n    A5((Agent 5))\n    A1 --&gt; A2\n    A1 --&gt; A3\n    A1 --&gt; A4\n    A1 --&gt; A5\n    end\n    Task[Initial Task] --&gt; A1\n    A2 --&gt; Result2[Result 2]\n    A3 --&gt; Result3[Result 3]\n    A4 --&gt; Result4[Result 4]\n    A5 --&gt; Result5[Result 5]</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>You need centralized control</p> </li> <li> <p>Tasks require coordination or oversight</p> </li> <li> <p>You want to maintain a single point of task distribution</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#mesh-swarm","title":"Mesh Swarm","text":"<pre><code>def mesh_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    subgraph Mesh Network\n    A1((Agent 1)) &lt;--&gt; A2((Agent 2))\n    A2 &lt;--&gt; A3((Agent 3))\n    A1 &lt;--&gt; A4((Agent 4))\n    A2 &lt;--&gt; A5((Agent 5))\n    A3 &lt;--&gt; A6((Agent 6))\n    A4 &lt;--&gt; A5\n    A5 &lt;--&gt; A6\n    end\n    Tasks[Task Pool] --&gt; A1\n    Tasks --&gt; A2\n    Tasks --&gt; A3\n    Tasks --&gt; A4\n    Tasks --&gt; A5\n    Tasks --&gt; A6</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>You need maximum flexibility</p> </li> <li> <p>Task processing order isn't critical</p> </li> <li> <p>You want fault tolerance</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#mathematical-swarm-patterns","title":"Mathematical Swarm Patterns","text":""},{"location":"swarms/examples/unique_swarms/#fibonacci-swarm","title":"Fibonacci Swarm","text":"<pre><code>def fibonacci_swarm(agents: AgentListType, tasks: List[str])\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    subgraph Fibonacci Pattern\n    L1[Level 1: 1 Agent] --&gt; L2[Level 2: 1 Agent]\n    L2 --&gt; L3[Level 3: 2 Agents]\n    L3 --&gt; L4[Level 4: 3 Agents]\n    L4 --&gt; L5[Level 5: 5 Agents]\n    end\n    Task[Initial Task] --&gt; L1\n    L5 --&gt; Results[Processed Results]</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>You need natural scaling patterns</p> </li> <li> <p>Tasks have increasing complexity</p> </li> <li> <p>You want organic growth in processing capacity</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#pyramid-swarm","title":"Pyramid Swarm","text":"<pre><code>def pyramid_swarm(agents: AgentListType, tasks: List[str], return_full_history: bool = True)\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    subgraph Pyramid Structure\n    A1((Leader Agent))\n    A2((Manager 1))\n    A3((Manager 2))\n    A4((Worker 1))\n    A5((Worker 2))\n    A6((Worker 3))\n    A7((Worker 4))\n    A1 --&gt; A2\n    A1 --&gt; A3\n    A2 --&gt; A4\n    A2 --&gt; A5\n    A3 --&gt; A6\n    A3 --&gt; A7\n    end\n    Task[Complex Task] --&gt; A1\n    A4 --&gt; Result1[Output 1]\n    A5 --&gt; Result2[Output 2]\n    A6 --&gt; Result3[Output 3]\n    A7 --&gt; Result4[Output 4]</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>You need hierarchical task processing</p> </li> <li> <p>Tasks require multiple levels of oversight</p> </li> <li> <p>You want organized task delegation</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#grid-swarm","title":"Grid Swarm","text":"<pre><code>def grid_swarm(agents: AgentListType, tasks: List[str])\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    subgraph Grid Layout\n    A1((1)) &lt;--&gt; A2((2)) &lt;--&gt; A3((3))\n    A4((4)) &lt;--&gt; A5((5)) &lt;--&gt; A6((6))\n    A7((7)) &lt;--&gt; A8((8)) &lt;--&gt; A9((9))\n    A1 &lt;--&gt; A4 &lt;--&gt; A7\n    A2 &lt;--&gt; A5 &lt;--&gt; A8\n    A3 &lt;--&gt; A6 &lt;--&gt; A9\n    end\n    Tasks[Task Queue] --&gt; A1\n    Tasks --&gt; A5\n    Tasks --&gt; A9</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>Tasks have spatial relationships</p> </li> <li> <p>You need neighbor-based processing</p> </li> <li> <p>You want structured parallel processing</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#communication-patterns","title":"Communication Patterns","text":""},{"location":"swarms/examples/unique_swarms/#one-to-one-communication","title":"One-to-One Communication","text":"<pre><code>def one_to_one(sender: Agent, receiver: Agent, task: str, max_loops: int = 1) -&gt; str\n</code></pre> <p>Information Flow: <pre><code>flowchart LR\n    Task[Task] --&gt; S((Sender))\n    S --&gt; R((Receiver))\n    R --&gt; Result[Result]</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>Direct agent communication is needed</p> </li> <li> <p>Tasks require back-and-forth interaction</p> </li> <li> <p>You need controlled message exchange</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#broadcast-communication","title":"Broadcast Communication","text":"<pre><code>async def broadcast(sender: Agent, agents: AgentListType, task: str) -&gt; None\n</code></pre> <p>Information Flow: <pre><code>flowchart TD\n    T[Task] --&gt; S((Sender))\n    S --&gt; A1((Agent 1))\n    S --&gt; A2((Agent 2))\n    S --&gt; A3((Agent 3))\n    S --&gt; A4((Agent 4))</code></pre></p> <p>Best Used When:</p> <ul> <li> <p>Information needs to reach all agents</p> </li> <li> <p>Tasks require global coordination</p> </li> <li> <p>You need system-wide updates</p> </li> </ul>"},{"location":"swarms/examples/unique_swarms/#best-practices","title":"Best Practices","text":"<ol> <li>Choose the Right Pattern:</li> <li>Consider your task's natural structure</li> <li>Think about scaling requirements</li> <li> <p>Consider fault tolerance needs</p> </li> <li> <p>Performance Considerations:</p> </li> <li>More complex patterns have higher overhead</li> <li>Consider communication costs</li> <li> <p>Match pattern to available resources</p> </li> <li> <p>Error Handling:</p> </li> <li>All patterns include basic error checking</li> <li>Consider adding additional error handling for production</li> <li> <p>Monitor agent performance and task completion</p> </li> <li> <p>Scaling:</p> </li> <li>Different patterns scale differently</li> <li>Consider future growth needs</li> <li>Test with expected maximum load</li> </ol>"},{"location":"swarms/examples/unique_swarms/#common-use-cases","title":"Common Use Cases","text":"<ol> <li>Data Processing Pipelines</li> <li>Linear Swarm</li> <li> <p>Circular Swarm</p> </li> <li> <p>Distributed Computing</p> </li> <li>Mesh Swarm</li> <li> <p>Grid Swarm</p> </li> <li> <p>Hierarchical Systems</p> </li> <li>Pyramid Swarm</li> <li> <p>Star Swarm</p> </li> <li> <p>Dynamic Workloads</p> </li> <li>Exponential Swarm</li> <li> <p>Fibonacci Swarm</p> </li> <li> <p>Conflict-Free Processing</p> </li> <li>Prime Swarm</li> <li>Harmonic Swarm</li> </ol> <pre><code>import asyncio\nfrom typing import List\n\nfrom swarms.structs.agent import Agent\nfrom swarms.structs.swarming_architectures import (\n    broadcast,\n    circular_swarm,\n    exponential_swarm,\n    fibonacci_swarm,\n    grid_swarm,\n    linear_swarm,\n    mesh_swarm,\n    one_to_three,\n    prime_swarm,\n    sigmoid_swarm,\n    sinusoidal_swarm,\n    staircase_swarm,\n    star_swarm,\n)\n\n\ndef create_finance_agents() -&gt; List[Agent]:\n    \"\"\"Create specialized finance agents\"\"\"\n    return [\n        Agent(\n            agent_name=\"MarketAnalyst\",\n            system_prompt=\"You are a market analysis expert. Analyze market trends and provide insights.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"RiskManager\",\n            system_prompt=\"You are a risk management specialist. Evaluate risks and provide mitigation strategies.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"PortfolioManager\",\n            system_prompt=\"You are a portfolio management expert. Optimize investment portfolios and asset allocation.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"ComplianceOfficer\",\n            system_prompt=\"You are a financial compliance expert. Ensure regulatory compliance and identify issues.\",\n            model_name=\"gpt-4o-mini\"\n        )\n    ]\n\ndef create_healthcare_agents() -&gt; List[Agent]:\n    \"\"\"Create specialized healthcare agents\"\"\"\n    return [\n        Agent(\n            agent_name=\"Diagnostician\",\n            system_prompt=\"You are a medical diagnostician. Analyze symptoms and suggest potential diagnoses.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"Treatment_Planner\",\n            system_prompt=\"You are a treatment planning specialist. Develop comprehensive treatment plans.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"MedicalResearcher\",\n            system_prompt=\"You are a medical researcher. Analyze latest research and provide evidence-based recommendations.\",\n            model_name=\"gpt-4o-mini\"\n        ),\n        Agent(\n            agent_name=\"PatientCareCoordinator\",\n            system_prompt=\"You are a patient care coordinator. Manage patient care workflow and coordination.\",\n            model_name=\"gpt-4o-mini\"\n        )\n    ]\n\ndef print_separator():\n    print(\"\\n\" + \"=\"*50 + \"\\n\")\n\ndef run_finance_circular_swarm():\n    \"\"\"Investment analysis workflow using circular swarm\"\"\"\n    print_separator()\n    print(\"FINANCE - INVESTMENT ANALYSIS (Circular Swarm)\")\n\n    agents = create_finance_agents()\n    tasks = [\n        \"Analyze Tesla stock performance for Q4 2024\",\n        \"Assess market risks and potential hedging strategies\",\n        \"Recommend portfolio adjustments based on analysis\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    result = circular_swarm(agents, tasks)\n    print(\"\\nResults:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Task: {log['task']}\")\n        print(f\"Response: {log['response']}\")\n\ndef run_healthcare_grid_swarm():\n    \"\"\"Patient diagnosis and treatment planning using grid swarm\"\"\"\n    print_separator()\n    print(\"HEALTHCARE - PATIENT DIAGNOSIS (Grid Swarm)\")\n\n    agents = create_healthcare_agents()\n    tasks = [\n        \"Review patient symptoms: fever, fatigue, joint pain\",\n        \"Research latest treatment protocols\",\n        \"Develop preliminary treatment plan\",\n        \"Coordinate with specialists\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    result = grid_swarm(agents, tasks)\n    print(\"\\nGrid swarm processing completed\")\n    print(result)\n\ndef run_finance_linear_swarm():\n    \"\"\"Loan approval process using linear swarm\"\"\"\n    print_separator()\n    print(\"FINANCE - LOAN APPROVAL PROCESS (Linear Swarm)\")\n\n    agents = create_finance_agents()[:3]\n    tasks = [\n        \"Review loan application and credit history\",\n        \"Assess risk factors and compliance requirements\",\n        \"Generate final loan recommendation\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    result = linear_swarm(agents, tasks)\n    print(\"\\nResults:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Task: {log['task']}\")\n        print(f\"Response: {log['response']}\")\n\ndef run_healthcare_star_swarm():\n    \"\"\"Complex medical case management using star swarm\"\"\"\n    print_separator()\n    print(\"HEALTHCARE - COMPLEX CASE MANAGEMENT (Star Swarm)\")\n\n    agents = create_healthcare_agents()\n    tasks = [\n        \"Complex case: Patient with multiple chronic conditions\",\n        \"Develop integrated care plan\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    result = star_swarm(agents, tasks)\n    print(\"\\nResults:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Task: {log['task']}\")\n        print(f\"Response: {log['response']}\")\n\ndef run_finance_mesh_swarm():\n    \"\"\"Market risk assessment using mesh swarm\"\"\"\n    print_separator()\n    print(\"FINANCE - MARKET RISK ASSESSMENT (Mesh Swarm)\")\n\n    agents = create_finance_agents()\n    tasks = [\n        \"Analyze global market conditions\",\n        \"Assess currency exchange risks\",\n        \"Evaluate sector-specific risks\",\n        \"Review portfolio exposure\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    result = mesh_swarm(agents, tasks)\n    print(\"\\nResults:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Task: {log['task']}\")\n        print(f\"Response: {log['response']}\")\n\ndef run_mathematical_finance_swarms():\n    \"\"\"Complex financial analysis using mathematical swarms\"\"\"\n    print_separator()\n    print(\"FINANCE - MARKET PATTERN ANALYSIS\")\n\n    agents = create_finance_agents()\n    tasks = [\n        \"Analyze historical market patterns\",\n        \"Predict market trends using technical analysis\",\n        \"Identify potential arbitrage opportunities\"\n    ]\n\n    print(\"\\nTasks:\")\n    for i, task in enumerate(tasks, 1):\n        print(f\"{i}. {task}\")\n\n    print(\"\\nFibonacci Swarm Results:\")\n    result = fibonacci_swarm(agents, tasks.copy())\n    print(result)\n\n    print(\"\\nPrime Swarm Results:\")\n    result = prime_swarm(agents, tasks.copy())\n    print(result)\n\n    print(\"\\nExponential Swarm Results:\")\n    result = exponential_swarm(agents, tasks.copy())\n    print(result)\n\ndef run_healthcare_pattern_swarms():\n    \"\"\"Patient monitoring using pattern swarms\"\"\"\n    print_separator()\n    print(\"HEALTHCARE - PATIENT MONITORING PATTERNS\")\n\n    agents = create_healthcare_agents()\n    task = \"Monitor and analyze patient vital signs: BP, heart rate, temperature, O2 saturation\"\n\n    print(f\"\\nTask: {task}\")\n\n    print(\"\\nStaircase Pattern Analysis:\")\n    result = staircase_swarm(agents, task)\n    print(result)\n\n    print(\"\\nSigmoid Pattern Analysis:\")\n    result = sigmoid_swarm(agents, task)\n    print(result)\n\n    print(\"\\nSinusoidal Pattern Analysis:\")\n    result = sinusoidal_swarm(agents, task)\n    print(result)\n\nasync def run_communication_examples():\n    \"\"\"Communication patterns for emergency scenarios\"\"\"\n    print_separator()\n    print(\"EMERGENCY COMMUNICATION PATTERNS\")\n\n    # Finance market alert\n    finance_sender = create_finance_agents()[0]\n    finance_receivers = create_finance_agents()[1:]\n    market_alert = \"URGENT: Major market volatility detected - immediate risk assessment required\"\n\n    print(\"\\nFinance Market Alert:\")\n    print(f\"Alert: {market_alert}\")\n    result = await broadcast(finance_sender, finance_receivers, market_alert)\n    print(\"\\nBroadcast Results:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Response: {log['response']}\")\n\n    # Healthcare emergency\n    health_sender = create_healthcare_agents()[0]\n    health_receivers = create_healthcare_agents()[1:4]\n    emergency_case = \"EMERGENCY: Trauma patient with multiple injuries - immediate consultation required\"\n\n    print(\"\\nHealthcare Emergency:\")\n    print(f\"Case: {emergency_case}\")\n    result = await one_to_three(health_sender, health_receivers, emergency_case)\n    print(\"\\nConsultation Results:\")\n    for log in result['history']:\n        print(f\"\\n{log['agent_name']}:\")\n        print(f\"Response: {log['response']}\")\n\nasync def run_all_examples():\n    \"\"\"Execute all swarm examples\"\"\"\n    print(\"\\n=== SWARM ARCHITECTURE EXAMPLES ===\\n\")\n\n    # Finance examples\n    run_finance_circular_swarm()\n    run_finance_linear_swarm()\n    run_finance_mesh_swarm()\n    run_mathematical_finance_swarms()\n\n    # Healthcare examples\n    run_healthcare_grid_swarm()\n    run_healthcare_star_swarm()\n    run_healthcare_pattern_swarms()\n\n    # Communication examples\n    await run_communication_examples()\n\n    print(\"\\n=== ALL EXAMPLES COMPLETED ===\")\n\nif __name__ == \"__main__\":\n    asyncio.run(run_all_examples())\n</code></pre>"},{"location":"swarms/examples/vision_processing/","title":"Vision Processing Examples","text":"<p>This example demonstrates how to use vision-enabled agents in Swarms to analyze images and process visual information. You'll learn how to work with both OpenAI and Anthropic vision models for various use cases.</p>"},{"location":"swarms/examples/vision_processing/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.7+</p> </li> <li> <p>OpenAI API key (for GPT-4V)</p> </li> <li> <p>Anthropic API key (for Claude 3)</p> </li> <li> <p>Swarms library</p> </li> </ul>"},{"location":"swarms/examples/vision_processing/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/examples/vision_processing/#environment-variables","title":"Environment Variables","text":"<pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"  # Required for GPT-4V\nANTHROPIC_API_KEY=\"\"  # Required for Claude 3\n</code></pre>"},{"location":"swarms/examples/vision_processing/#working-with-images","title":"Working with Images","text":""},{"location":"swarms/examples/vision_processing/#supported-image-formats","title":"Supported Image Formats","text":"<p>Vision-enabled agents support various image formats:</p> Format Description JPEG/JPG Standard image format with lossy compression PNG Lossless format supporting transparency GIF Animated format (only first frame used) WebP Modern format with both lossy and lossless compression"},{"location":"swarms/examples/vision_processing/#image-guidelines","title":"Image Guidelines","text":"<ul> <li>Maximum file size: 20MB</li> <li>Recommended resolution: At least 512x512 pixels</li> <li>Image should be clear and well-lit</li> <li>Avoid heavily compressed or blurry images</li> </ul>"},{"location":"swarms/examples/vision_processing/#examples","title":"Examples","text":""},{"location":"swarms/examples/vision_processing/#1-quality-control-with-gpt-4v","title":"1. Quality Control with GPT-4V","text":"<pre><code>from swarms.structs import Agent\nfrom swarms.prompts.logistics import Quality_Control_Agent_Prompt\n\n# Load your image\nfactory_image = \"path/to/your/image.jpg\"  # Local file path\n# Or use a URL\n# factory_image = \"https://example.com/image.jpg\"\n\n# Initialize quality control agent with GPT-4V\nquality_control_agent = Agent(\n    agent_name=\"Quality Control Agent\",\n    agent_description=\"A quality control agent that analyzes images and provides detailed quality reports.\",\n    model_name=\"gpt-4.1-mini\",\n    system_prompt=Quality_Control_Agent_Prompt,\n    multi_modal=True,\n    max_loops=1\n)\n\n# Run the analysis\nresponse = quality_control_agent.run(\n    task=\"Analyze this image and provide a detailed quality control report\",\n    img=factory_image\n)\n\nprint(response)\n</code></pre>"},{"location":"swarms/examples/vision_processing/#2-visual-analysis-with-claude-3","title":"2. Visual Analysis with Claude 3","text":"<pre><code>from swarms.structs import Agent\nfrom swarms.prompts.logistics import Visual_Analysis_Prompt\n\n# Load your image\nproduct_image = \"path/to/your/product.jpg\"\n\n# Initialize visual analysis agent with Claude 3\nvisual_analyst = Agent(\n    agent_name=\"Visual Analyst\",\n    agent_description=\"An agent that performs detailed visual analysis of products and scenes.\",\n    model_name=\"anthropic/claude-3-opus-20240229\",\n    system_prompt=Visual_Analysis_Prompt,\n    multi_modal=True,\n    max_loops=1\n)\n\n# Run the analysis\nresponse = visual_analyst.run(\n    task=\"Provide a comprehensive analysis of this product image\",\n    img=product_image\n)\n\nprint(response)\n</code></pre>"},{"location":"swarms/examples/vision_processing/#3-image-batch-processing","title":"3. Image Batch Processing","text":"<pre><code>from swarms.structs import Agent\nimport os\n\ndef process_image_batch(image_folder, agent):\n    \"\"\"Process multiple images in a folder\"\"\"\n    results = []\n    for image_file in os.listdir(image_folder):\n        if image_file.lower().endswith(('.png', '.jpg', '.jpeg', '.webp')):\n            image_path = os.path.join(image_folder, image_file)\n            response = agent.run(\n                task=\"Analyze this image\",\n                img=image_path\n            )\n            results.append((image_file, response))\n    return results\n\n# Example usage\nimage_folder = \"path/to/image/folder\"\nbatch_results = process_image_batch(image_folder, visual_analyst)\n</code></pre>"},{"location":"swarms/examples/vision_processing/#best-practices","title":"Best Practices","text":"Category Best Practice Description Image Preparation Format Support Ensure images are in supported formats (JPEG, PNG, GIF, WebP) Size &amp; Quality Optimize image size and quality for better processing Image Quality Use clear, well-lit images for accurate analysis Model Selection GPT-4V Usage Use for general vision tasks and detailed analysis Claude 3 Usage Use for complex reasoning and longer outputs Batch Processing Consider batch processing for multiple images Error Handling Path Validation Always validate image paths before processing API Error Handling Implement proper error handling for API calls Rate Monitoring Monitor API rate limits and token usage Performance Optimization Result Caching Cache results when processing the same images Batch Processing Use batch processing for multiple images Parallel Processing Implement parallel processing for large datasets"},{"location":"swarms/examples/vision_tools/","title":"Agents with Vision and Tool Usage","text":"<p>This tutorial demonstrates how to create intelligent agents that can analyze images and use custom tools to perform specific actions based on their visual observations. You'll learn to build a quality control agent that can process images, identify potential security concerns, and automatically trigger appropriate responses using function calling capabilities.</p>"},{"location":"swarms/examples/vision_tools/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to configure an agent with multi-modal capabilities for image analysis</li> <li>How to integrate custom tools and functions with vision-enabled agents</li> <li>How to implement automated security analysis based on visual observations</li> <li>How to use function calling to trigger specific actions from image analysis results</li> <li>Best practices for building production-ready vision agents with tool integration</li> </ul>"},{"location":"swarms/examples/vision_tools/#use-cases","title":"Use Cases","text":"<p>This approach is perfect for:</p> <ul> <li> <p>Quality Control Systems: Automated inspection of manufacturing processes</p> </li> <li> <p>Security Monitoring: Real-time threat detection and response</p> </li> <li> <p>Object Detection: Identifying and categorizing items in images</p> </li> <li> <p>Compliance Checking: Ensuring standards are met in various environments</p> </li> <li> <p>Automated Reporting: Generating detailed analysis reports from visual data</p> </li> </ul>"},{"location":"swarms/examples/vision_tools/#installation","title":"Installation","text":"<p>Install the swarms package using pip:</p> <pre><code>pip install -U swarms\n</code></pre>"},{"location":"swarms/examples/vision_tools/#basic-setup","title":"Basic Setup","text":"<ol> <li>First, set up your environment variables:</li> </ol> <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nOPENAI_API_KEY=\"\"\n</code></pre>"},{"location":"swarms/examples/vision_tools/#code","title":"Code","text":"<ul> <li> <p>Create tools for your agent as a function with types and documentation</p> </li> <li> <p>Pass tools to your agent <code>Agent(tools=[list_of_callables])</code></p> </li> <li> <p>Add your image path to the run method like: <code>Agent().run(task=task, img=img)</code></p> </li> </ul> <pre><code>from swarms.structs import Agent\nfrom swarms.prompts.logistics import (\n    Quality_Control_Agent_Prompt,\n)\n\n\n# Image for analysis\nfactory_image = \"image.jpg\"\n\n\ndef security_analysis(danger_level: str) -&gt; str:\n    \"\"\"\n    Analyzes the security danger level and returns an appropriate response.\n\n    Args:\n        danger_level (str, optional): The level of danger to analyze.\n            Can be \"low\", \"medium\", \"high\", or None. Defaults to None.\n\n    Returns:\n        str: A string describing the danger level assessment.\n            - \"No danger level provided\" if danger_level is None\n            - \"No danger\" if danger_level is \"low\"\n            - \"Medium danger\" if danger_level is \"medium\"\n            - \"High danger\" if danger_level is \"high\"\n            - \"Unknown danger level\" for any other value\n    \"\"\"\n    if danger_level is None:\n        return \"No danger level provided\"\n\n    if danger_level == \"low\":\n        return \"No danger\"\n\n    if danger_level == \"medium\":\n        return \"Medium danger\"\n\n    if danger_level == \"high\":\n        return \"High danger\"\n\n    return \"Unknown danger level\"\n\n\ncustom_system_prompt = f\"\"\"\n{Quality_Control_Agent_Prompt}\n\nYou have access to tools that can help you with your analysis. When you need to perform a security analysis, you MUST use the security_analysis function with an appropriate danger level (low, medium, or high) based on your observations.\n\nAlways use the available tools when they are relevant to the task. If you determine there is any level of danger or security concern, call the security_analysis function with the appropriate danger level.\n\"\"\"\n\n# Quality control agent\nquality_control_agent = Agent(\n    agent_name=\"Quality Control Agent\",\n    agent_description=\"A quality control agent that analyzes images and provides a detailed report on the quality of the product in the image.\",\n    # model_name=\"anthropic/claude-3-opus-20240229\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=custom_system_prompt,\n    multi_modal=True,\n    max_loops=1,\n    output_type=\"str-all-except-first\",\n    # tools_list_dictionary=[schema],\n    tools=[security_analysis],\n)\n\n\nresponse = quality_control_agent.run(\n    task=\"Analyze the image and then perform a security analysis. Based on what you see in the image, determine if there is a low, medium, or high danger level and call the security_analysis function with that danger level\",\n    img=factory_image,\n)\n</code></pre>"},{"location":"swarms/examples/vision_tools/#support-and-community","title":"Support and Community","text":"<p>If you're facing issues or want to learn more, check out the following resources to join our Discord, stay updated on Twitter, and watch tutorials on YouTube!</p> Platform Link Description \ud83d\udcda Documentation docs.swarms.world Official documentation and guides \ud83d\udcdd Blog Medium Latest updates and technical articles \ud83d\udcac Discord Join Discord Live chat and community support \ud83d\udc26 Twitter @kyegomez Latest news and announcements \ud83d\udc65 LinkedIn The Swarm Corporation Professional network and updates \ud83d\udcfa YouTube Swarms Channel Tutorials and demos \ud83c\udfab Events Sign up here Join our community events"},{"location":"swarms/examples/vllm/","title":"VLLM Swarm Agents","text":"<p>Quick Summary</p> <p>This guide demonstrates how to create a sophisticated multi-agent system using VLLM and Swarms for comprehensive stock market analysis. You'll learn how to configure and orchestrate multiple AI agents working together to provide deep market insights.</p>"},{"location":"swarms/examples/vllm/#overview","title":"Overview","text":"<p>The example showcases how to build a stock analysis system with 5 specialized agents:</p> <ul> <li>Technical Analysis Agent</li> <li>Fundamental Analysis Agent  </li> <li>Market Sentiment Agent</li> <li>Quantitative Strategy Agent</li> <li>Portfolio Strategy Agent</li> </ul> <p>Each agent has specific expertise and works collaboratively through a concurrent workflow.</p>"},{"location":"swarms/examples/vllm/#prerequisites","title":"Prerequisites","text":"<p>Requirements</p> <p>Before starting, ensure you have:</p> <ul> <li>Python 3.7 or higher</li> <li>The Swarms package installed</li> <li>Access to VLLM compatible models</li> <li>Sufficient compute resources for running VLLM</li> </ul>"},{"location":"swarms/examples/vllm/#installation","title":"Installation","text":"<p>Setup Steps</p> <ol> <li> <p>Install the Swarms package: <pre><code>pip install swarms\n</code></pre></p> </li> <li> <p>Install VLLM dependencies (if not already installed): <pre><code>pip install vllm\n</code></pre></p> </li> </ol>"},{"location":"swarms/examples/vllm/#basic-usage","title":"Basic Usage","text":"<p>Here's a complete example of setting up the stock analysis swarm:</p> <pre><code>from swarms import Agent, ConcurrentWorkflow\nfrom swarms.utils.vllm_wrapper import VLLMWrapper\n\n# Initialize the VLLM wrapper\nvllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\",\n)\n</code></pre> <p>Model Selection</p> <p>The example uses Llama-2-7b-chat, but you can use any VLLM-compatible model. Make sure you have the necessary permissions and resources to run your chosen model.</p>"},{"location":"swarms/examples/vllm/#agent-configuration","title":"Agent Configuration","text":""},{"location":"swarms/examples/vllm/#technical-analysis-agent","title":"Technical Analysis Agent","text":"<pre><code>technical_analyst = Agent(\n    agent_name=\"Technical-Analysis-Agent\",\n    agent_description=\"Expert in technical analysis and chart patterns\",\n    system_prompt=\"\"\"You are an expert Technical Analysis Agent specializing in market technicals and chart patterns. Your responsibilities include:\n\n1. PRICE ACTION ANALYSIS\n- Identify key support and resistance levels\n- Analyze price trends and momentum\n- Detect chart patterns (e.g., head &amp; shoulders, triangles, flags)\n- Evaluate volume patterns and their implications\n\n2. TECHNICAL INDICATORS\n- Calculate and interpret moving averages (SMA, EMA)\n- Analyze momentum indicators (RSI, MACD, Stochastic)\n- Evaluate volume indicators (OBV, Volume Profile)\n- Monitor volatility indicators (Bollinger Bands, ATR)\n\n3. TRADING SIGNALS\n- Generate clear buy/sell signals based on technical criteria\n- Identify potential entry and exit points\n- Set appropriate stop-loss and take-profit levels\n- Calculate position sizing recommendations\n\n4. RISK MANAGEMENT\n- Assess market volatility and trend strength\n- Identify potential reversal points\n- Calculate risk/reward ratios for trades\n- Suggest position sizing based on risk parameters\n\nYour analysis should be data-driven, precise, and actionable. Always include specific price levels, time frames, and risk parameters in your recommendations.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n</code></pre> <p>Agent Customization</p> <p>Each agent can be customized with different:</p> <ul> <li> <p>System prompts</p> </li> <li> <p>Temperature settings</p> </li> <li> <p>Max token limits</p> </li> <li> <p>Response formats</p> </li> </ul>"},{"location":"swarms/examples/vllm/#running-the-swarm","title":"Running the Swarm","text":"<p>To execute the swarm analysis:</p> <pre><code>swarm = ConcurrentWorkflow(\n    name=\"Stock-Analysis-Swarm\",\n    description=\"A swarm of agents that analyze stocks and provide comprehensive analysis.\",\n    agents=stock_analysis_agents,\n)\n\n# Run the analysis\nresponse = swarm.run(\"Analyze the best etfs for gold and other similar commodities in volatile markets\")\n</code></pre>"},{"location":"swarms/examples/vllm/#full-code-example","title":"Full Code Example","text":"<pre><code>from swarms import Agent, ConcurrentWorkflow\nfrom swarms.utils.vllm_wrapper import VLLMWrapper\n\n# Initialize the VLLM wrapper\nvllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\",\n)\n\n# Technical Analysis Agent\ntechnical_analyst = Agent(\n    agent_name=\"Technical-Analysis-Agent\",\n    agent_description=\"Expert in technical analysis and chart patterns\",\n    system_prompt=\"\"\"You are an expert Technical Analysis Agent specializing in market technicals and chart patterns. Your responsibilities include:\n\n1. PRICE ACTION ANALYSIS\n- Identify key support and resistance levels\n- Analyze price trends and momentum\n- Detect chart patterns (e.g., head &amp; shoulders, triangles, flags)\n- Evaluate volume patterns and their implications\n\n2. TECHNICAL INDICATORS\n- Calculate and interpret moving averages (SMA, EMA)\n- Analyze momentum indicators (RSI, MACD, Stochastic)\n- Evaluate volume indicators (OBV, Volume Profile)\n- Monitor volatility indicators (Bollinger Bands, ATR)\n\n3. TRADING SIGNALS\n- Generate clear buy/sell signals based on technical criteria\n- Identify potential entry and exit points\n- Set appropriate stop-loss and take-profit levels\n- Calculate position sizing recommendations\n\n4. RISK MANAGEMENT\n- Assess market volatility and trend strength\n- Identify potential reversal points\n- Calculate risk/reward ratios for trades\n- Suggest position sizing based on risk parameters\n\nYour analysis should be data-driven, precise, and actionable. Always include specific price levels, time frames, and risk parameters in your recommendations.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n\n# Fundamental Analysis Agent\nfundamental_analyst = Agent(\n    agent_name=\"Fundamental-Analysis-Agent\",\n    agent_description=\"Expert in company fundamentals and valuation\",\n    system_prompt=\"\"\"You are an expert Fundamental Analysis Agent specializing in company valuation and financial metrics. Your core responsibilities include:\n\n1. FINANCIAL STATEMENT ANALYSIS\n- Analyze income statements, balance sheets, and cash flow statements\n- Calculate and interpret key financial ratios\n- Evaluate revenue growth and profit margins\n- Assess company's debt levels and cash position\n\n2. VALUATION METRICS\n- Calculate fair value using multiple valuation methods:\n  * Discounted Cash Flow (DCF)\n  * Price-to-Earnings (P/E)\n  * Price-to-Book (P/B)\n  * Enterprise Value/EBITDA\n- Compare valuations against industry peers\n\n3. BUSINESS MODEL ASSESSMENT\n- Evaluate competitive advantages and market position\n- Analyze industry dynamics and market share\n- Assess management quality and corporate governance\n- Identify potential risks and growth opportunities\n\n4. ECONOMIC CONTEXT\n- Consider macroeconomic factors affecting the company\n- Analyze industry cycles and trends\n- Evaluate regulatory environment and compliance\n- Assess global market conditions\n\nYour analysis should be comprehensive, focusing on both quantitative metrics and qualitative factors that impact long-term value.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n\n# Market Sentiment Agent\nsentiment_analyst = Agent(\n    agent_name=\"Market-Sentiment-Agent\",\n    agent_description=\"Expert in market psychology and sentiment analysis\",\n    system_prompt=\"\"\"You are an expert Market Sentiment Agent specializing in analyzing market psychology and investor behavior. Your key responsibilities include:\n\n1. SENTIMENT INDICATORS\n- Monitor and interpret market sentiment indicators:\n  * VIX (Fear Index)\n  * Put/Call Ratio\n  * Market Breadth\n  * Investor Surveys\n- Track institutional vs retail investor behavior\n\n2. NEWS AND SOCIAL MEDIA ANALYSIS\n- Analyze news flow and media sentiment\n- Monitor social media trends and discussions\n- Track analyst recommendations and changes\n- Evaluate corporate insider trading patterns\n\n3. MARKET POSITIONING\n- Assess hedge fund positioning and exposure\n- Monitor short interest and short squeeze potential\n- Track fund flows and asset allocation trends\n- Analyze options market sentiment\n\n4. CONTRARIAN SIGNALS\n- Identify extreme sentiment readings\n- Detect potential market turning points\n- Analyze historical sentiment patterns\n- Provide contrarian trading opportunities\n\nYour analysis should combine quantitative sentiment metrics with qualitative assessment of market psychology and crowd behavior.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n\n# Quantitative Strategy Agent\nquant_analyst = Agent(\n    agent_name=\"Quantitative-Strategy-Agent\",\n    agent_description=\"Expert in quantitative analysis and algorithmic strategies\",\n    system_prompt=\"\"\"You are an expert Quantitative Strategy Agent specializing in data-driven investment strategies. Your primary responsibilities include:\n\n1. FACTOR ANALYSIS\n- Analyze and monitor factor performance:\n  * Value\n  * Momentum\n  * Quality\n  * Size\n  * Low Volatility\n- Calculate factor exposures and correlations\n\n2. STATISTICAL ANALYSIS\n- Perform statistical arbitrage analysis\n- Calculate and monitor pair trading opportunities\n- Analyze market anomalies and inefficiencies\n- Develop mean reversion strategies\n\n3. RISK MODELING\n- Build and maintain risk models\n- Calculate portfolio optimization metrics\n- Monitor correlation matrices\n- Analyze tail risk and stress scenarios\n\n4. ALGORITHMIC STRATEGIES\n- Develop systematic trading strategies\n- Backtest and validate trading algorithms\n- Monitor strategy performance metrics\n- Optimize execution algorithms\n\nYour analysis should be purely quantitative, based on statistical evidence and mathematical models rather than subjective opinions.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n\n# Portfolio Strategy Agent\nportfolio_strategist = Agent(\n    agent_name=\"Portfolio-Strategy-Agent\",\n    agent_description=\"Expert in portfolio management and asset allocation\",\n    system_prompt=\"\"\"You are an expert Portfolio Strategy Agent specializing in portfolio construction and management. Your core responsibilities include:\n\n1. ASSET ALLOCATION\n- Develop strategic asset allocation frameworks\n- Recommend tactical asset allocation shifts\n- Optimize portfolio weightings\n- Balance risk and return objectives\n\n2. PORTFOLIO ANALYSIS\n- Calculate portfolio risk metrics\n- Monitor sector and factor exposures\n- Analyze portfolio correlation matrix\n- Track performance attribution\n\n3. RISK MANAGEMENT\n- Implement portfolio hedging strategies\n- Monitor and adjust position sizing\n- Set stop-loss and rebalancing rules\n- Develop drawdown protection strategies\n\n4. PORTFOLIO OPTIMIZATION\n- Calculate efficient frontier analysis\n- Optimize for various objectives:\n  * Maximum Sharpe Ratio\n  * Minimum Volatility\n  * Maximum Diversification\n- Consider transaction costs and taxes\n\nYour recommendations should focus on portfolio-level decisions that optimize risk-adjusted returns while meeting specific investment objectives.\"\"\",\n    max_loops=1,\n    llm=vllm,\n)\n\n# Create a list of all agents\nstock_analysis_agents = [\n    technical_analyst,\n    fundamental_analyst,\n    sentiment_analyst,\n    quant_analyst,\n    portfolio_strategist\n]\n\nswarm = ConcurrentWorkflow(\n    name=\"Stock-Analysis-Swarm\",\n    description=\"A swarm of agents that analyze stocks and provide a comprehensive analysis of the current trends and opportunities.\",\n    agents=stock_analysis_agents,\n)\n\nswarm.run(\"Analyze the best etfs for gold and other similiar commodities in volatile markets\")\n</code></pre>"},{"location":"swarms/examples/vllm/#best-practices","title":"Best Practices","text":"<p>Optimization Tips</p> <ol> <li> <ul> <li>Keep system prompts focused and specific</li> </ul> <p>Agent Design</p> <ul> <li> <p>Use clear role definitions</p> </li> <li> <p>Include error handling guidelines</p> </li> </ul> </li> <li> <p>Resource Management</p> <ul> <li> <p>Monitor memory usage with large models</p> </li> <li> <p>Implement proper cleanup procedures</p> </li> <li> <p>Use batching for multiple queries</p> </li> </ul> </li> <li> <p>Output Handling</p> <ul> <li> <p>Implement proper logging</p> </li> <li> <p>Format outputs consistently</p> </li> <li> <p>Include error checking</p> </li> </ul> </li> </ol>"},{"location":"swarms/examples/vllm/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<p>Troubleshooting</p> <p>Common issues you might encounter:</p> <ol> <li> <p>Memory Issues</p> <ul> <li> <p>Problem: VLLM consuming too much memory</p> </li> <li> <p>Solution: Adjust batch sizes and model parameters</p> </li> </ul> </li> <li> <p>Agent Coordination</p> <ul> <li> <p>Problem: Agents providing conflicting information</p> </li> <li> <p>Solution: Implement consensus mechanisms or priority rules</p> </li> </ul> </li> <li> <p>Performance</p> <ul> <li> <p>Problem: Slow response times</p> </li> <li> <p>Solution: Use proper batching and optimize model loading</p> </li> </ul> </li> </ol>"},{"location":"swarms/examples/vllm/#faq","title":"FAQ","text":"Can I use different models for different agents? <p>Yes, you can initialize multiple VLLM wrappers with different models for each agent. However, be mindful of memory usage.</p> How many agents can run concurrently? <p>The number depends on your hardware resources. Start with 3-5 agents and scale based on performance.</p> Can I customize agent communication patterns? <p>Yes, you can modify the ConcurrentWorkflow class or create custom workflows for specific communication patterns.</p>"},{"location":"swarms/examples/vllm/#advanced-configuration","title":"Advanced Configuration","text":"<p>Extended Settings</p> <pre><code>vllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\",\n    temperature=0.7,\n    max_tokens=2048,\n    top_p=0.95,\n)\n</code></pre>"},{"location":"swarms/examples/vllm/#contributing","title":"Contributing","text":"<p>Get Involved</p> <p>We welcome contributions! Here's how you can help:</p> <ol> <li>Report bugs and issues</li> <li>Submit feature requests</li> <li>Contribute to documentation</li> <li>Share example use cases</li> </ol>"},{"location":"swarms/examples/vllm/#resources","title":"Resources","text":"<p>Additional Reading</p> <ul> <li>VLLM Documentation</li> </ul>"},{"location":"swarms/examples/vllm_integration/","title":"vLLM Integration Guide","text":"<p>Overview</p> <p>vLLM is a high-performance and easy-to-use library for LLM inference and serving. This guide explains how to integrate vLLM with Swarms for efficient, production-grade language model deployment.</p>"},{"location":"swarms/examples/vllm_integration/#installation","title":"Installation","text":"<p>Prerequisites</p> <p>Before you begin, make sure you have Python 3.8+ installed on your system.</p> pippoetry <pre><code>pip install -U vllm swarms\n</code></pre> <pre><code>poetry add vllm swarms\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#basic-usage","title":"Basic Usage","text":"<p>Here's a simple example of how to use vLLM with Swarms:</p> basic_usage.py<pre><code>from swarms.utils.vllm_wrapper import VLLMWrapper\n\n# Initialize the vLLM wrapper\nvllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\",\n    temperature=0.7,\n    max_tokens=4000\n)\n\n# Run inference\nresponse = vllm.run(\"What is the capital of France?\")\nprint(response)\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#vllmwrapper-class","title":"VLLMWrapper Class","text":"<p>Class Overview</p> <p>The <code>VLLMWrapper</code> class provides a convenient interface for working with vLLM models.</p>"},{"location":"swarms/examples/vllm_integration/#key-parameters","title":"Key Parameters","text":"Parameter Type Description Default <code>model_name</code> str Name of the model to use \"meta-llama/Llama-2-7b-chat-hf\" <code>system_prompt</code> str System prompt to use None <code>stream</code> bool Whether to stream the output False <code>temperature</code> float Sampling temperature 0.5 <code>max_tokens</code> int Maximum number of tokens to generate 4000"},{"location":"swarms/examples/vllm_integration/#example-with-custom-parameters","title":"Example with Custom Parameters","text":"custom_parameters.py<pre><code>vllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-13b-chat-hf\",\n    system_prompt=\"You are an expert in artificial intelligence.\",\n    temperature=0.8,\n    max_tokens=2000\n)\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#integration-with-agents","title":"Integration with Agents","text":"<p>You can easily integrate vLLM with Swarms agents for more complex workflows:</p> agent_integration.py<pre><code>from swarms import Agent\nfrom swarms.utils.vllm_wrapper import VLLMWrapper\n\n# Initialize vLLM\nvllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\"\n)\n\n# Create an agent with vLLM\nagent = Agent(\n    agent_name=\"Research-Agent\",\n    agent_description=\"Expert in conducting research and analysis\",\n    system_prompt=\"\"\"You are an expert research agent. Your tasks include:\n    1. Analyzing complex topics\n    2. Providing detailed summaries\n    3. Making data-driven recommendations\"\"\",\n    llm=vllm,\n    max_loops=1\n)\n\n# Run the agent\nresponse = agent.run(\"Research the impact of AI on healthcare\")\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/examples/vllm_integration/#batch-processing","title":"Batch Processing","text":"<p>Performance Optimization</p> <p>Use batch processing for efficient handling of multiple tasks simultaneously.</p> batch_processing.py<pre><code>tasks = [\n    \"What is machine learning?\",\n    \"Explain neural networks\",\n    \"Describe deep learning\"\n]\n\nresults = vllm.batched_run(tasks, batch_size=3)\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#error-handling","title":"Error Handling","text":"<p>Error Management</p> <p>Always implement proper error handling in production environments.</p> error_handling.py<pre><code>from loguru import logger\n\ntry:\n    response = vllm.run(\"Complex task\")\nexcept Exception as error:\n    logger.error(f\"Error occurred: {error}\")\n</code></pre>"},{"location":"swarms/examples/vllm_integration/#best-practices","title":"Best Practices","text":"<p>Recommended Practices</p> Model SelectionSystem ResourcesPrompt EngineeringError HandlingPerformance <ul> <li>Choose appropriate model sizes based on your requirements</li> <li>Consider the trade-off between model size and inference speed</li> </ul> <ul> <li>Ensure sufficient GPU memory for your chosen model</li> <li>Monitor resource usage during batch processing</li> </ul> <ul> <li>Use clear and specific system prompts</li> <li>Structure user prompts for optimal results</li> </ul> <ul> <li>Implement proper error handling and logging</li> <li>Set up monitoring for production deployments</li> </ul> <ul> <li>Use batch processing for multiple tasks</li> <li>Adjust max_tokens based on your use case</li> <li>Fine-tune temperature for optimal output quality</li> </ul>"},{"location":"swarms/examples/vllm_integration/#example-multi-agent-system","title":"Example: Multi-Agent System","text":"<p>Here's an example of creating a multi-agent system using vLLM:</p> multi_agent_system.py<pre><code>from swarms import Agent, ConcurrentWorkflow\nfrom swarms.utils.vllm_wrapper import VLLMWrapper\n\n# Initialize vLLM\nvllm = VLLMWrapper(\n    model_name=\"meta-llama/Llama-2-7b-chat-hf\",\n    system_prompt=\"You are a helpful assistant.\"\n)\n\n# Create specialized agents\nresearch_agent = Agent(\n    agent_name=\"Research-Agent\",\n    agent_description=\"Expert in research\",\n    system_prompt=\"You are a research expert.\",\n    llm=vllm\n)\n\nanalysis_agent = Agent(\n    agent_name=\"Analysis-Agent\",\n    agent_description=\"Expert in analysis\",\n    system_prompt=\"You are an analysis expert.\",\n    llm=vllm\n)\n\n# Create a workflow\nagents = [research_agent, analysis_agent]\nworkflow = ConcurrentWorkflow(\n    name=\"Research-Analysis-Workflow\",\n    description=\"Comprehensive research and analysis workflow\",\n    agents=agents\n)\n\n# Run the workflow\nresult = workflow.run(\"Analyze the impact of renewable energy\")\n</code></pre>"},{"location":"swarms/examples/xai/","title":"Agent with XAI","text":"<ul> <li> <p>Add your <code>XAI_API_KEY</code> in the <code>.env</code> file</p> </li> <li> <p>Select your model_name like <code>xai/grok-beta</code> follows LiteLLM conventions</p> </li> <li> <p>Execute your agent!</p> </li> </ul> <pre><code>from swarms import Agent\nimport os\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Initialize the agent with ChromaDB memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    model_name=\"xai/grok-beta\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n)\n\n# Run a query\nagent.run(\"What are the components of a startup's stock incentive equity plan?\")\n</code></pre>"},{"location":"swarms/examples/yahoo_finance/","title":"Swarms Tools Example with Yahoo Finance","text":"<ul> <li><code>pip3 install swarms swarms-tools</code></li> <li>Add <code>OPENAI_API_KEY</code> to your <code>.env</code> file</li> <li>Run <code>yahoo_finance_agent.py</code></li> <li>Agent will make a function call to the desired tool</li> <li>The tool will be executed and the result will be returned to the agent</li> <li>The agent will then analyze the result and return the final output</li> </ul> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\nfrom swarms_tools import (\n    yahoo_finance_api,\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=1,\n    model_name=\"gpt-4o\",\n    dynamic_temperature_enabled=True,\n    user_name=\"swarms_corp\",\n    retry_attempts=3,\n    context_length=8192,\n    return_step_meta=False,\n    output_type=\"str\",  # \"json\", \"dict\", \"csv\" OR \"string\" \"yaml\" and\n    auto_generate_prompt=False,  # Auto generate prompt for the agent based on name, description, and system prompt, task\n    max_tokens=4000,  # max output tokens\n    saved_state_path=\"agent_00.json\",\n    interactive=False,\n    tools=[yahoo_finance_api],\n)\n\nagent.run(\"Analyze the latest metrics for nvidia\")\n# Less than 30 lines of code....\n</code></pre>"},{"location":"swarms/framework/","title":"Index","text":""},{"location":"swarms/framework/#swarms-framework-conceptual-breakdown","title":"Swarms Framework Conceptual Breakdown","text":"<p>The <code>swarms</code> framework is a sophisticated structure designed to orchestrate the collaborative work of multiple agents in a hierarchical manner. This breakdown provides a conceptual and visual representation of the framework, highlighting the interactions between models, tools, memory, agents, and swarms.</p>"},{"location":"swarms/framework/#hierarchical-structure","title":"Hierarchical Structure","text":"<p>The framework can be visualized as a multi-layered hierarchy:</p> <ol> <li>Models, Tools, Memory: These form the foundational components that agents utilize to perform tasks.</li> <li>Agents: Individual entities that encapsulate specific functionalities, utilizing models, tools, and memory.</li> <li>Swarm: A collection of multiple agents working together in a coordinated manner.</li> <li>Structs: High-level structures that organize and manage swarms, enabling complex workflows and interactions.</li> </ol>"},{"location":"swarms/framework/#visual-representation","title":"Visual Representation","text":"<p>Below are visual graphs illustrating the hierarchical and tree structure of the <code>swarms</code> framework.</p>"},{"location":"swarms/framework/#1-foundational-components-models-tools-memory","title":"1. Foundational Components: Models, Tools, Memory","text":""},{"location":"swarms/framework/#2-agents-and-their-interactions","title":"2. Agents and Their Interactions","text":"<pre><code>graph TD;\n    Agents --&gt; Swarm\n    subgraph Agents_Collection\n        Agent1\n        Agent2\n        Agent3\n    end\n    subgraph Individual_Agents\n        Agent1 --&gt; Models\n        Agent1 --&gt; Tools\n        Agent1 --&gt; Memory\n        Agent2 --&gt; Models\n        Agent2 --&gt; Tools\n        Agent2 --&gt; Memory\n        Agent3 --&gt; Models\n        Agent3 --&gt; Tools\n        Agent3 --&gt; Memory\n    end</code></pre>"},{"location":"swarms/framework/#3-multiple-agents-form-a-swarm","title":"3. Multiple Agents Form a Swarm","text":"<pre><code>graph TD;\n    Swarm1 --&gt; Struct\n    Swarm2 --&gt; Struct\n    Swarm3 --&gt; Struct\n    subgraph Swarms_Collection\n        Swarm1\n        Swarm2\n        Swarm3\n    end\n    subgraph Individual_Swarms\n        Swarm1 --&gt; Agent1\n        Swarm1 --&gt; Agent2\n        Swarm1 --&gt; Agent3\n        Swarm2 --&gt; Agent4\n        Swarm2 --&gt; Agent5\n        Swarm2 --&gt; Agent6\n        Swarm3 --&gt; Agent7\n        Swarm3 --&gt; Agent8\n        Swarm3 --&gt; Agent9\n    end</code></pre>"},{"location":"swarms/framework/#4-structs-organizing-multiple-swarms","title":"4. Structs Organizing Multiple Swarms","text":"<pre><code>graph TD;\n    Struct --&gt; Swarms_Collection\n    subgraph High_Level_Structs\n        Struct1\n        Struct2\n        Struct3\n    end\n    subgraph Struct1\n        Swarm1\n        Swarm2\n    end\n    subgraph Struct2\n        Swarm3\n    end\n    subgraph Struct3\n        Swarm4\n        Swarm5\n    end</code></pre>"},{"location":"swarms/framework/#directory-breakdown","title":"Directory Breakdown","text":"<p>The directory structure of the <code>swarms</code> framework is organized to support its hierarchical architecture:</p> <pre><code>swarms/\n\u251c\u2500\u2500 agents/\n\u251c\u2500\u2500 artifacts/\n\u251c\u2500\u2500 marketplace/\n\u251c\u2500\u2500 memory/\n\u251c\u2500\u2500 models/\n\u251c\u2500\u2500 prompts/\n\u251c\u2500\u2500 schemas/\n\u251c\u2500\u2500 structs/\n\u251c\u2500\u2500 telemetry/\n\u251c\u2500\u2500 tools/\n\u251c\u2500\u2500 utils/\n\u2514\u2500\u2500 __init__.py\n</code></pre>"},{"location":"swarms/framework/#summary","title":"Summary","text":"<p>The <code>swarms</code> framework is designed to facilitate complex multi-agent interactions through a structured and layered approach. By leveraging foundational components like models, tools, and memory, individual agents are empowered to perform specialized tasks. These agents are then coordinated within swarms to achieve collective goals, and swarms are managed within high-level structs to orchestrate sophisticated workflows.</p> <p>This hierarchical design ensures scalability, flexibility, and robustness, making the <code>swarms</code> framework a powerful tool for various applications in AI, data analysis, optimization, and beyond.</p>"},{"location":"swarms/framework/agents_explained/","title":"An Analysis of Agents","text":"<p>In the Swarms framework, agents are designed to perform tasks autonomously by leveraging large language models (LLMs), various tools, and long-term memory systems. This guide provides an extensive conceptual walkthrough of how an agent operates, detailing the sequence of actions it takes to complete a task and how it utilizes its internal components.</p>"},{"location":"swarms/framework/agents_explained/#agent-components-overview","title":"Agent Components Overview","text":"<ul> <li>LLM (Large Language Model): The core component responsible for understanding and generating natural language.</li> <li>Tools: External functions and services that the agent can call to perform specific tasks, such as querying databases or interacting with APIs.</li> <li>Long-term Memory: Systems like ChromaDB or Pinecone that store and retrieve information over extended periods, enabling the agent to remember past interactions and contexts.</li> </ul>"},{"location":"swarms/framework/agents_explained/#agent-workflow","title":"Agent Workflow","text":"<p>The workflow of an agent can be divided into several stages: task initiation, initial LLM processing, tool usage, memory interaction, and final LLM processing.</p>"},{"location":"swarms/framework/agents_explained/#stage-1-task-initiation","title":"Stage 1: Task Initiation","text":"<ul> <li>Input: The task or query that the agent needs to address.</li> <li>Output: A structured plan or approach for handling the task.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-2-initial-llm-processing","title":"Stage 2: Initial LLM Processing","text":"<ul> <li>Input: The task or query.</li> <li>Process: The LLM interprets the task, understanding the context and requirements.</li> <li>Output: An initial response or action plan.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-3-tool-usage","title":"Stage 3: Tool Usage","text":"<ul> <li>Input: The action plan or specific sub-tasks identified by the LLM.</li> <li>Process: The agent calls various tools to gather information, perform calculations, or interact with external systems.</li> <li>Function Calling as Tools: Tools are called as functions with specific inputs and outputs, enabling the agent to perform a wide range of tasks.</li> <li>Output: Data or results from the tools.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-4-memory-interaction","title":"Stage 4: Memory Interaction","text":"<ul> <li>Input: Intermediate results and context from the tools.</li> <li>Process: The agent interacts with long-term memory systems to store new information and retrieve relevant past data.</li> <li>RAG Systems (ChromaDB, Pinecone): These systems are used to enhance the agent\u2019s responses by providing relevant historical data and context.</li> <li>Output: Enhanced context and data for final processing.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-5-final-llm-processing","title":"Stage 5: Final LLM Processing","text":"<ul> <li>Input: Comprehensive data and context from the tools and memory systems.</li> <li>Process: The LLM generates the final response or completes the task using the enriched data.</li> <li>Output: The final output or action taken by the agent.</li> </ul>"},{"location":"swarms/framework/agents_explained/#detailed-workflow-with-mermaid-diagrams","title":"Detailed Workflow with Mermaid Diagrams","text":""},{"location":"swarms/framework/agents_explained/#agent-components-and-workflow","title":"Agent Components and Workflow","text":"<pre><code>graph TD\n    A[Task Initiation] --&gt;|Receives Task| B[Initial LLM Processing]\n    B --&gt;|Interprets Task| C[Tool Usage]\n    C --&gt;|Calls Tools| D[Function 1]\n    C --&gt;|Calls Tools| E[Function 2]\n    D --&gt;|Returns Data| C\n    E --&gt;|Returns Data| C\n    C --&gt;|Provides Data| F[Memory Interaction]\n    F --&gt;|Stores and Retrieves Data| G[RAG System]\n    G --&gt;|ChromaDB/Pinecone| H[Enhanced Data]\n    F --&gt;|Provides Enhanced Data| I[Final LLM Processing]\n    I --&gt;|Generates Final Response| J[Output]</code></pre>"},{"location":"swarms/framework/agents_explained/#explanation-of-each-stage","title":"Explanation of Each Stage","text":""},{"location":"swarms/framework/agents_explained/#stage-1-task-initiation_1","title":"Stage 1: Task Initiation","text":"<ul> <li>Task: The agent receives a task or query from an external source (e.g., a user query, a system trigger).</li> <li>Objective: To understand what needs to be done and prepare an initial approach.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-2-initial-llm-processing_1","title":"Stage 2: Initial LLM Processing","text":"<ul> <li>Interpretation: The LLM processes the task to comprehend its context and requirements.</li> <li>Planning: The LLM generates an initial plan or identifies the sub-tasks required to complete the task.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-3-tool-usage_1","title":"Stage 3: Tool Usage","text":"<ul> <li>Function Calls: The agent uses predefined functions (tools) to perform specific actions, such as querying a database or making API calls.</li> <li>Tool Integration: Each tool is called with specific parameters, and the results are collected for further processing.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-4-memory-interaction_1","title":"Stage 4: Memory Interaction","text":"<ul> <li>Long-term Memory: Systems like ChromaDB and Pinecone store and retrieve long-term data, providing the agent with historical context and past interactions.</li> <li>Retrieval-Augmented Generation (RAG): The agent uses RAG systems to enhance the current context with relevant past data, improving the quality and relevance of the final output.</li> </ul>"},{"location":"swarms/framework/agents_explained/#stage-5-final-llm-processing_1","title":"Stage 5: Final LLM Processing","text":"<ul> <li>Enhanced Processing: The LLM processes the enriched data and context provided by the tools and memory systems.</li> <li>Final Output: The LLM generates a comprehensive response or completes the task using the enhanced information.</li> </ul>"},{"location":"swarms/framework/agents_explained/#conclusion","title":"Conclusion","text":"<p>The Swarms framework's agents are powerful units that combine LLMs, tools, and long-term memory systems to perform complex tasks efficiently. By leveraging function calling for tools and RAG systems like ChromaDB and Pinecone, agents can enhance their capabilities and deliver highly relevant and accurate results. This conceptual guide and walkthrough provide a detailed understanding of how agents operate within the Swarms framework, enabling the development of sophisticated and collaborative AI systems.</p>"},{"location":"swarms/framework/code_cleanliness/","title":"Code Cleanliness in Python: A Comprehensive Guide","text":"<p>Code cleanliness is an essential aspect of software development that ensures code is easy to read, understand, and maintain. Clean code leads to fewer bugs, easier debugging, and more efficient collaboration among developers. This blog article delves into the principles of writing clean Python code, emphasizing the use of type annotations, docstrings, and the Loguru logging library. We'll explore the importance of each component and provide practical examples to illustrate best practices.</p>"},{"location":"swarms/framework/code_cleanliness/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction to Code Cleanliness</li> <li>Importance of Type Annotations</li> <li>Writing Effective Docstrings</li> <li>Structuring Your Code</li> <li>Error Handling and Logging with Loguru</li> <li>Refactoring for Clean Code</li> <li>Examples of Clean Code</li> <li>Conclusion</li> </ol>"},{"location":"swarms/framework/code_cleanliness/#1-introduction-to-code-cleanliness","title":"1. Introduction to Code Cleanliness","text":"<p>Code cleanliness refers to the practice of writing code that is easy to read, understand, and maintain. Clean code follows consistent conventions and is organized logically, making it easier for developers to collaborate and for new team members to get up to speed quickly.</p>"},{"location":"swarms/framework/code_cleanliness/#why-clean-code-matters","title":"Why Clean Code Matters","text":"<ol> <li>Readability: Clean code is easy to read and understand, which reduces the time needed to grasp what the code does.</li> <li>Maintainability: Clean code is easier to maintain and modify, reducing the risk of introducing bugs when making changes.</li> <li>Collaboration: Clean code facilitates collaboration among team members, as everyone can easily understand and follow the codebase.</li> <li>Debugging: Clean code makes it easier to identify and fix bugs, leading to more reliable software.</li> </ol>"},{"location":"swarms/framework/code_cleanliness/#2-importance-of-type-annotations","title":"2. Importance of Type Annotations","text":"<p>Type annotations in Python provide a way to specify the types of variables, function arguments, and return values. They enhance code readability and help catch type-related errors early in the development process.</p>"},{"location":"swarms/framework/code_cleanliness/#benefits-of-type-annotations","title":"Benefits of Type Annotations","text":"<ol> <li>Improved Readability: Type annotations make it clear what types of values are expected, improving code readability.</li> <li>Error Detection: Type annotations help catch type-related errors during development, reducing runtime errors.</li> <li>Better Tooling: Many modern IDEs and editors use type annotations to provide better code completion and error checking.</li> </ol>"},{"location":"swarms/framework/code_cleanliness/#example-of-type-annotations","title":"Example of Type Annotations","text":"<pre><code>from typing import List\n\ndef calculate_average(numbers: List[float]) -&gt; float:\n    \"\"\"\n    Calculates the average of a list of numbers.\n\n    Args:\n        numbers (List[float]): A list of numbers.\n\n    Returns:\n        float: The average of the numbers.\n    \"\"\"\n    return sum(numbers) / len(numbers)\n</code></pre> <p>In this example, the <code>calculate_average</code> function takes a list of floats as input and returns a float. The type annotations make it clear what types are expected and returned, enhancing readability and maintainability.</p>"},{"location":"swarms/framework/code_cleanliness/#3-writing-effective-docstrings","title":"3. Writing Effective Docstrings","text":"<p>Docstrings are an essential part of writing clean code in Python. They provide inline documentation for modules, classes, methods, and functions. Effective docstrings improve code readability and make it easier for other developers to understand and use your code.</p>"},{"location":"swarms/framework/code_cleanliness/#benefits-of-docstrings","title":"Benefits of Docstrings","text":"<ol> <li>Documentation: Docstrings serve as inline documentation, making it easier to understand the purpose and usage of code.</li> <li>Consistency: Well-written docstrings ensure consistent documentation across the codebase.</li> <li>Ease of Use: Docstrings make it easier for developers to use and understand code without having to read through the implementation details.</li> </ol>"},{"location":"swarms/framework/code_cleanliness/#example-of-effective-docstrings","title":"Example of Effective Docstrings","text":"<pre><code>def calculate_factorial(n: int) -&gt; int:\n    \"\"\"\n    Calculates the factorial of a given non-negative integer.\n\n    Args:\n        n (int): The non-negative integer to calculate the factorial of.\n\n    Returns:\n        int: The factorial of the given number.\n\n    Raises:\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if n &lt; 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial\n</code></pre> <p>In this example, the docstring clearly explains the purpose of the <code>calculate_factorial</code> function, its arguments, return value, and the exception it may raise.</p>"},{"location":"swarms/framework/code_cleanliness/#4-structuring-your-code","title":"4. Structuring Your Code","text":"<p>Proper code structure is crucial for code cleanliness. A well-structured codebase is easier to navigate, understand, and maintain. Here are some best practices for structuring your Python code:</p>"},{"location":"swarms/framework/code_cleanliness/#organizing-code-into-modules-and-packages","title":"Organizing Code into Modules and Packages","text":"<p>Organize your code into modules and packages to group related functionality together. This makes it easier to find and manage code.</p> <pre><code># project/\n# \u251c\u2500\u2500 main.py\n# \u251c\u2500\u2500 utils/\n# \u2502   \u251c\u2500\u2500 __init__.py\n# \u2502   \u251c\u2500\u2500 file_utils.py\n# \u2502   \u2514\u2500\u2500 math_utils.py\n# \u2514\u2500\u2500 models/\n#     \u251c\u2500\u2500 __init__.py\n#     \u251c\u2500\u2500 user.py\n#     \u2514\u2500\u2500 product.py\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#using-functions-and-classes","title":"Using Functions and Classes","text":"<p>Break down your code into small, reusable functions and classes. This makes your code more modular and easier to test.</p> <pre><code>class User:\n    def __init__(self, name: str, age: int):\n        \"\"\"\n        Initializes a new user.\n\n        Args:\n            name (str): The name of the user.\n            age (int): The age of the user.\n        \"\"\"\n        self.name = name\n        self.age = age\n\n    def greet(self) -&gt; str:\n        \"\"\"\n        Greets the user.\n\n        Returns:\n            str: A greeting message.\n        \"\"\"\n        return f\"Hello, {self.name}!\"\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#keeping-functions-small","title":"Keeping Functions Small","text":"<p>Functions should do one thing and do it well. Keep functions small and focused on a single task.</p> <pre><code>def save_user(user: User, filename: str) -&gt; None:\n    \"\"\"\n    Saves user data to a file.\n\n    Args:\n        user (User): The user object to save.\n        filename (str): The name of the file to save the user data to.\n    \"\"\"\n    with open(filename, 'w') as file:\n        file.write(f\"{user.name},{user.age}\")\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#5-error-handling-and-logging-with-loguru","title":"5. Error Handling and Logging with Loguru","text":"<p>Effective error handling and logging are critical components of clean code. They help you manage and diagnose issues that arise during the execution of your code.</p>"},{"location":"swarms/framework/code_cleanliness/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<ol> <li>Use Specific Exceptions: Catch specific exceptions rather than using a generic <code>except</code> clause.</li> <li>Provide Meaningful Messages: When raising exceptions, provide meaningful error messages to help diagnose the issue.</li> <li>Clean Up Resources: Use <code>finally</code> blocks or context managers to ensure that resources are properly cleaned up.</li> </ol>"},{"location":"swarms/framework/code_cleanliness/#example-of-error-handling","title":"Example of Error Handling","text":"<pre><code>def divide_numbers(numerator: float, denominator: float) -&gt; float:\n    \"\"\"\n    Divides the numerator by the denominator.\n\n    Args:\n        numerator (float): The number to be divided.\n        denominator (float): The number to divide by.\n\n    Returns:\n        float: The result of the division.\n\n    Raises:\n        ValueError: If the denominator is zero.\n    \"\"\"\n    if denominator == 0:\n        raise ValueError(\"The denominator cannot be zero.\")\n    return numerator / denominator\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#logging-with-loguru","title":"Logging with Loguru","text":"<p>Loguru is a powerful logging library for Python that makes logging simple and enjoyable. It provides a clean and easy-to-use API for logging messages with different severity levels.</p>"},{"location":"swarms/framework/code_cleanliness/#installing-loguru","title":"Installing Loguru","text":"<pre><code>pip install loguru\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#basic-usage-of-loguru","title":"Basic Usage of Loguru","text":"<pre><code>from loguru import logger\n\nlogger.debug(\"This is a debug message\")\nlogger.info(\"This is an info message\")\nlogger.warning(\"This is a warning message\")\nlogger.error(\"This is an error message\")\nlogger.critical(\"This is a critical message\")\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#example-of-logging-in-a-function","title":"Example of Logging in a Function","text":"<pre><code>from loguru import logger\n\ndef fetch_data(url: str) -&gt; str:\n    \"\"\"\n    Fetches data from a given URL and returns it as a string.\n\n    Args:\n        url (str): The URL to fetch data from.\n\n    Returns:\n        str: The data fetched from the URL.\n\n    Raises:\n        requests.exceptions.RequestException: If there is an error with the request.\n    \"\"\"\n    try:\n        logger.info(f\"Fetching data from {url}\")\n        response = requests.get(url)\n        response.raise_for_status()\n        logger.info(\"Data fetched successfully\")\n        return response.text\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error fetching data: {e}\")\n        raise\n</code></pre> <p>In this example, Loguru is used to log messages at different severity levels. The <code>fetch_data</code> function logs informational messages when fetching data and logs an error message if an exception is raised.</p>"},{"location":"swarms/framework/code_cleanliness/#6-refactoring-for-clean-code","title":"6. Refactoring for Clean Code","text":"<p>Refactoring is the process of restructuring existing code without changing its external behavior. It is an essential practice for maintaining clean code. Refactoring helps improve code readability, reduce complexity, and eliminate redundancy.</p>"},{"location":"swarms/framework/code_cleanliness/#identifying-code-smells","title":"Identifying Code Smells","text":"<p>Code smells are indicators of potential issues in the code that may require refactoring. Common code smells include: 1. Long Methods: Methods that are too long and do too many things. 2. Duplicated Code: Code that is duplicated in multiple places. 3. Large Classes: Classes that have too many responsibilities. 4. Poor Naming: Variables, functions, or classes with unclear or misleading names.</p>"},{"location":"swarms/framework/code_cleanliness/#refactoring-techniques","title":"Refactoring Techniques","text":"<ol> <li>Extract Method: Break down long methods into smaller, more focused methods.</li> <li>Rename Variables: Use meaningful names for variables, functions, and classes.</li> <li>Remove Duplicated Code: Consolidate duplicated code into a single location.</li> <li>Simplify Conditional Expressions: Simplify complex conditional expressions for</li> </ol> <p>better readability.</p>"},{"location":"swarms/framework/code_cleanliness/#example-of-refactoring","title":"Example of Refactoring","text":"<p>Before refactoring: <pre><code>def process_data(data: List[int]) -&gt; int:\n    total = 0\n    for value in data:\n        if value &gt; 0:\n            total += value\n    return total\n</code></pre></p> <p>After refactoring: <pre><code>def filter_positive_values(data: List[int]) -&gt; List[int]:\n    \"\"\"\n    Filters the positive values from the input data.\n\n    Args:\n        data (List[int]): The input data.\n\n    Returns:\n        List[int]: A list of positive values.\n    \"\"\"\n    return [value for value in data if value &gt; 0]\n\ndef sum_values(values: List[int]) -&gt; int:\n    \"\"\"\n    Sums the values in the input list.\n\n    Args:\n        values (List[int]): A list of values to sum.\n\n    Returns:\n        int: The sum of the values.\n    \"\"\"\n    return sum(values)\n\ndef process_data(data: List[int]) -&gt; int:\n    \"\"\"\n    Processes the data by filtering positive values and summing them.\n\n    Args:\n        data (List[int]): The input data.\n\n    Returns:\n        int: The sum of the positive values.\n    \"\"\"\n    positive_values = filter_positive_values(data)\n    return sum_values(positive_values)\n</code></pre></p> <p>In this example, the <code>process_data</code> function is refactored into smaller, more focused functions. This improves readability and maintainability.</p>"},{"location":"swarms/framework/code_cleanliness/#7-examples-of-clean-code","title":"7. Examples of Clean Code","text":""},{"location":"swarms/framework/code_cleanliness/#example-1-reading-a-file","title":"Example 1: Reading a File","text":"<pre><code>def read_file(file_path: str) -&gt; str:\n    \"\"\"\n    Reads the content of a file and returns it as a string.\n\n    Args:\n        file_path (str): The path to the file to read.\n\n    Returns:\n        str: The content of the file.\n\n    Raises:\n        FileNotFoundError: If the file does not exist.\n        IOError: If there is an error reading the file.\n    \"\"\"\n    try:\n        with open(file_path, 'r') as file:\n            return file.read()\n    except FileNotFoundError as e:\n        logger.error(f\"File not found: {file_path}\")\n        raise\n    except IOError as e:\n        logger.error(f\"Error reading file: {file_path}\")\n        raise\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#example-2-fetching-data-from-a-url","title":"Example 2: Fetching Data from a URL","text":"<pre><code>import requests\nfrom loguru import logger\n\ndef fetch_data(url: str) -&gt; str:\n    \"\"\"\n    Fetches data from a given URL and returns it as a string.\n\n    Args:\n        url (str): The URL to fetch data from.\n\n    Returns:\n        str: The data fetched from the URL.\n\n    Raises:\n        requests.exceptions.RequestException: If there is an error with the request.\n    \"\"\"\n    try:\n        logger.info(f\"Fetching data from {url}\")\n        response = requests.get(url)\n        response.raise_for_status()\n        logger.info(\"Data fetched successfully\")\n        return response.text\n    except requests.exceptions.RequestException as e:\n        logger.error(f\"Error fetching data: {e}\")\n        raise\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#example-3-calculating-factorial","title":"Example 3: Calculating Factorial","text":"<pre><code>def calculate_factorial(n: int) -&gt; int:\n    \"\"\"\n    Calculates the factorial of a given non-negative integer.\n\n    Args:\n        n (int): The non-negative integer to calculate the factorial of.\n\n    Returns:\n        int: The factorial of the given number.\n\n    Raises:\n        ValueError: If the input is a negative integer.\n    \"\"\"\n    if n &lt; 0:\n        raise ValueError(\"Input must be a non-negative integer.\")\n    factorial = 1\n    for i in range(1, n + 1):\n        factorial *= i\n    return factorial\n</code></pre>"},{"location":"swarms/framework/code_cleanliness/#8-conclusion","title":"8. Conclusion","text":"<p>Writing clean code in Python is crucial for developing maintainable, readable, and error-free software. By using type annotations, writing effective docstrings, structuring your code properly, and leveraging logging with Loguru, you can significantly improve the quality of your codebase.</p> <p>Remember to refactor your code regularly to eliminate code smells and improve readability. Clean code not only makes your life as a developer easier but also enhances collaboration and reduces the likelihood of bugs.</p> <p>By following the principles and best practices outlined in this article, you'll be well on your way to writing clean, maintainable Python code.</p>"},{"location":"swarms/framework/concept/","title":"Concept","text":"<p>To create a comprehensive overview of the Swarms framework, we can break it down into key concepts such as models, agents, tools, Retrieval-Augmented Generation (RAG) systems, and swarm systems. Below are conceptual explanations of these components along with mermaid diagrams to illustrate their interactions.</p>"},{"location":"swarms/framework/concept/#swarms-framework-overview","title":"Swarms Framework Overview","text":""},{"location":"swarms/framework/concept/#1-models","title":"1. Models","text":"<p>Models are the core component of the Swarms framework, representing the neural networks and machine learning models used to perform various tasks. These can be Large Language Models (LLMs), vision models, or any other AI models.</p>"},{"location":"swarms/framework/concept/#2-agents","title":"2. Agents","text":"<p>Agents are autonomous units that use models to perform specific tasks. In the Swarms framework, agents can leverage tools and interact with RAG systems.</p> <ul> <li>LLMs with Tools: These agents use large language models along with tools like databases, APIs, and external knowledge sources to enhance their capabilities.</li> <li>RAG Systems: These systems combine retrieval mechanisms with generative models to produce more accurate and contextually relevant outputs.</li> </ul>"},{"location":"swarms/framework/concept/#3-swarm-systems","title":"3. Swarm Systems","text":"<p>Swarm systems involve multiple agents working collaboratively to achieve complex tasks. These systems coordinate and communicate among agents to ensure efficient and effective task execution.</p>"},{"location":"swarms/framework/concept/#mermaid-diagrams","title":"Mermaid Diagrams","text":""},{"location":"swarms/framework/concept/#models","title":"Models","text":"<pre><code>graph TD\n    A[Model] --&gt;|Uses| B[Data]\n    A --&gt;|Trains| C[Algorithm]\n    A --&gt;|Outputs| D[Predictions]</code></pre>"},{"location":"swarms/framework/concept/#agents-llms-with-tools-and-rag-systems","title":"Agents: LLMs with Tools and RAG Systems","text":"<pre><code>graph TD\n    A[Agent] --&gt;|Uses| B[LLM]\n    A --&gt;|Interacts with| C[Tool]\n    C --&gt;|Provides Data to| B\n    A --&gt;|Queries| D[RAG System]\n    D --&gt;|Retrieves Information from| E[Database]\n    D --&gt;|Generates Responses with| F[Generative Model]</code></pre>"},{"location":"swarms/framework/concept/#swarm-systems","title":"Swarm Systems","text":"<pre><code>graph TD\n    A[Swarm System]\n    A --&gt;|Coordinates| B[Agent 1]\n    A --&gt;|Coordinates| C[Agent 2]\n    A --&gt;|Coordinates| D[Agent 3]\n    B --&gt;|Communicates with| C\n    C --&gt;|Communicates with| D\n    D --&gt;|Communicates with| B\n    B --&gt;|Performs Task| E[Task 1]\n    C --&gt;|Performs Task| F[Task 2]\n    D --&gt;|Performs Task| G[Task 3]\n    E --&gt;|Reports to| A\n    F --&gt;|Reports to| A\n    G --&gt;|Reports to| A</code></pre>"},{"location":"swarms/framework/concept/#conceptualization","title":"Conceptualization","text":"<ol> <li>Models: The basic building blocks trained on specific datasets to perform tasks.</li> <li>Agents: Intelligent entities that utilize models and tools to perform actions. LLM agents can use additional tools to enhance their capabilities.</li> <li>RAG Systems: Enhance agents by combining retrieval mechanisms (to fetch relevant information) with generative models (to create contextually relevant responses).</li> <li>Swarm Systems: Complex systems where multiple agents collaborate, communicate, and coordinate to perform complex, multi-step tasks efficiently.</li> </ol>"},{"location":"swarms/framework/concept/#summary","title":"Summary","text":"<p>The Swarms framework leverages models, agents, tools, RAG systems, and swarm systems to create a robust, collaborative environment for executing complex AI tasks. By coordinating multiple agents and enhancing their capabilities with tools and retrieval-augmented generation, Swarms can handle sophisticated and multi-faceted applications effectively.</p>"},{"location":"swarms/framework/reference/","title":"API Reference Documentation","text":""},{"location":"swarms/framework/reference/#swarms__init__","title":"<code>swarms.__init__</code>","text":"<p>Description: This module initializes the Swarms package by concurrently executing the bootup process and activating Sentry for telemetry. It imports various components from other modules within the Swarms package.</p> <p>Imports: - <code>concurrent.futures</code>: A module that provides a high-level interface for asynchronously executing callables.</p> <ul> <li> <p><code>swarms.telemetry.bootup</code>: Contains the <code>bootup</code> function for initializing telemetry.</p> </li> <li> <p><code>swarms.telemetry.sentry_active</code>: Contains the <code>activate_sentry</code> function to enable Sentry for error tracking.</p> </li> <li> <p>Other modules from the Swarms package are imported for use, including agents, artifacts, prompts, structs, telemetry, tools, utils, and schemas.</p> </li> </ul> <p>Concurrent Execution: The module uses <code>ThreadPoolExecutor</code> to run the <code>bootup</code> and <code>activate_sentry</code> functions concurrently.</p> <pre><code>import concurrent.futures\nfrom swarms.telemetry.bootup import bootup  # noqa: E402, F403\nfrom swarms.telemetry.sentry_active import activate_sentry\n\n# Use ThreadPoolExecutor to run bootup and activate_sentry concurrently\nwith concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:\n    executor.submit(bootup)\n    executor.submit(activate_sentry)\n\nfrom swarms.agents import *  # noqa: E402, F403\nfrom swarms.artifacts import *  # noqa: E402, F403\nfrom swarms.prompts import *  # noqa: E402, F403\nfrom swarms.structs import *  # noqa: E402, F403\nfrom swarms.telemetry import *  # noqa: E402, F403\nfrom swarms.tools import *  # noqa: E402, F403\nfrom swarms.utils import *  # noqa: E402, F403\nfrom swarms.schemas import *  # noqa: E402, F403\n</code></pre> <p>Note: There are no documentable functions or classes within this module itself, as it primarily serves to execute initial setup tasks and import other modules.</p>"},{"location":"swarms/framework/reference/#swarmsartifactsbase_artifact","title":"<code>swarms.artifacts.base_artifact</code>","text":"<p>Description: This module defines the <code>BaseArtifact</code> abstract base class for representing artifacts in the system. It provides methods to convert artifact values to various formats and enforces the implementation of an addition method for subclasses.</p> <p>Imports: - <code>json</code>: A module for parsing JSON data.</p> <ul> <li> <p><code>uuid</code>: A module for generating unique identifiers.</p> </li> <li> <p><code>ABC</code>, <code>abstractmethod</code>: Tools from the <code>abc</code> module to define abstract base classes.</p> </li> <li> <p><code>dataclass</code>: A decorator for creating data classes.</p> </li> <li> <p><code>Any</code>: A type hint for any data type.</p> </li> </ul>"},{"location":"swarms/framework/reference/#baseartifact","title":"<code>BaseArtifact</code>","text":"<p>Description: An abstract base class for artifacts that includes common attributes and methods for handling artifact values.</p> <p>Attributes: - <code>id</code> (<code>str</code>): A unique identifier for the artifact, generated if not provided.</p> <ul> <li> <p><code>name</code> (<code>str</code>): The name of the artifact. If not provided, it defaults to the artifact's ID.</p> </li> <li> <p><code>value</code> (<code>Any</code>): The value associated with the artifact.</p> </li> </ul> <p>Methods:</p> <ul> <li> <p><code>__post_init__(self) -&gt; None</code></p> <ul> <li> <p>Description: Initializes the artifact, setting the <code>id</code> and <code>name</code> attributes if they are not provided.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>value_to_bytes(cls, value: Any) -&gt; bytes</code></p> <ul> <li> <p>Description: Converts the given value to bytes.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>value</code> (<code>Any</code>): The value to convert.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bytes</code>): The value converted to bytes.</p> </li> </ul> </li> <li> <p><code>value_to_dict(cls, value: Any) -&gt; dict</code></p> <ul> <li> <p>Description: Converts the given value to a dictionary.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>value</code> (<code>Any</code>): The value to convert.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>dict</code>): The value converted to a dictionary.</p> </li> </ul> </li> <li> <p><code>to_text(self) -&gt; str</code></p> <ul> <li> <p>Description: Converts the artifact's value to a text representation.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): The string representation of the artifact's value.</p> </li> </ul> </li> <li> <p><code>__str__(self) -&gt; str</code></p> <ul> <li> <p>Description: Returns a string representation of the artifact.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): The string representation of the artifact.</p> </li> </ul> </li> <li> <p><code>__bool__(self) -&gt; bool</code></p> <ul> <li> <p>Description: Returns the boolean value of the artifact based on its value.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): The boolean value of the artifact.</p> </li> </ul> </li> <li> <p><code>__len__(self) -&gt; int</code></p> <ul> <li> <p>Description: Returns the length of the artifact's value.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>int</code>): The length of the artifact's value.</p> </li> </ul> </li> <li> <p><code>__add__(self, other: BaseArtifact) -&gt; BaseArtifact</code></p> <ul> <li> <p>Description: Abstract method for adding two artifacts together. Must be implemented by subclasses.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>other</code> (<code>BaseArtifact</code>): The other artifact to add.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>BaseArtifact</code>): The result of adding the two artifacts.</p> </li> </ul> </li> </ul> <p>Example: <pre><code>from swarms.artifacts.base_artifact import BaseArtifact\n\nclass MyArtifact(BaseArtifact):\n    def __add__(self, other: BaseArtifact) -&gt; BaseArtifact:\n\n        return MyArtifact(id=self.id, name=self.name, value=self.value + other.value)\n\nartifact1 = MyArtifact(id=\"123\", name=\"Artifact1\", value=10)\nartifact2 = MyArtifact(id=\"456\", name=\"Artifact2\", value=20)\nresult = artifact1 + artifact2\nprint(result)  # Output: MyArtifact with the combined value\n</code></pre></p>"},{"location":"swarms/framework/reference/#swarmsartifactstext_artifact","title":"<code>swarms.artifacts.text_artifact</code>","text":"<p>Description: This module defines the <code>TextArtifact</code> class, which represents a text-based artifact. It extends the <code>BaseArtifact</code> class and includes attributes and methods specific to  handling text values, including encoding options, embedding generation, and token counting.</p> <p>Imports: - <code>dataclass</code>, <code>field</code>: Decorators and functions from the <code>dataclasses</code> module for creating data classes.</p> <ul> <li> <p><code>Callable</code>: A type hint indicating a callable object from the <code>typing</code> module.</p> </li> <li> <p><code>BaseArtifact</code>: The abstract base class for artifacts, imported from <code>swarms.artifacts.base_artifact</code>.</p> </li> </ul>"},{"location":"swarms/framework/reference/#textartifact","title":"<code>TextArtifact</code>","text":"<p>Description: Represents a text artifact with additional functionality for handling text values, encoding, and embeddings.</p> <p>Attributes: - <code>value</code> (<code>str</code>): The text value of the artifact.</p> <ul> <li> <p><code>encoding</code> (<code>str</code>, optional): The encoding of the text (default is \"utf-8\").</p> </li> <li> <p><code>encoding_error_handler</code> (<code>str</code>, optional): The error handler for encoding errors (default is \"strict\").</p> </li> <li> <p><code>tokenizer</code> (<code>Callable</code>, optional): A callable for tokenizing the text value.</p> </li> <li> <p><code>_embedding</code> (<code>list[float]</code>): The embedding of the text artifact (default is an empty list).</p> </li> </ul> <p>Properties: - <code>embedding</code> (<code>Optional[list[float]]</code>): Returns the embedding of the text artifact if available; otherwise, returns <code>None</code>.</p> <p>Methods:</p> <ul> <li> <p><code>__add__(self, other: BaseArtifact) -&gt; TextArtifact</code></p> <ul> <li> <p>Description: Concatenates the text value of this artifact with the text value of another artifact.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>other</code> (<code>BaseArtifact</code>): The other artifact to concatenate with.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>TextArtifact</code>): A new <code>TextArtifact</code> instance with the concatenated value.</p> </li> </ul> </li> <li> <p><code>__bool__(self) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the text value of the artifact is non-empty.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if the text value is non-empty; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>generate_embedding(self, model) -&gt; list[float] | None</code></p> <ul> <li> <p>Description: Generates the embedding of the text artifact using a given embedding model.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>model</code>: An embedding model that provides the <code>embed_string</code> method.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>list[float] | None</code>): The generated embedding as a list of floats, or <code>None</code> if the embedding could not be generated.</p> </li> </ul> </li> <li> <p><code>token_count(self) -&gt; int</code></p> <ul> <li> <p>Description: Counts the number of tokens in the text artifact using a specified tokenizer.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>int</code>): The number of tokens in the text value.</p> </li> </ul> </li> <li> <p><code>to_bytes(self) -&gt; bytes</code></p> <ul> <li> <p>Description: Converts the text value of the artifact to bytes using the specified encoding and error handler.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bytes</code>): The text value encoded as bytes.</p> </li> </ul> </li> </ul> <p>Example: <pre><code>from swarms.artifacts.text_artifact import TextArtifact\n\n# Create a TextArtifact instance\ntext_artifact = TextArtifact(value=\"Hello, World!\")\n\n# Generate embedding (assuming an appropriate model is provided)\n# embedding = text_artifact.generate_embedding(model)\n\n# Count tokens in the text artifact\ntoken_count = text_artifact.token_count()\n\n# Convert to bytes\nbytes_value = text_artifact.to_bytes()\n\nprint(text_artifact)  # Output: Hello, World!\nprint(token_count)    # Output: Number of tokens\nprint(bytes_value)    # Output: b'Hello, World!'\n</code></pre></p>"},{"location":"swarms/framework/reference/#swarmsartifactsmain_artifact","title":"<code>swarms.artifacts.main_artifact</code>","text":"<p>Description: This module defines the <code>Artifact</code> class, which represents a file artifact with versioning capabilities. It allows for the creation, editing, saving, loading, and exporting of file artifacts, as well as managing their version history. The module also includes a <code>FileVersion</code> class to encapsulate the details of each version of the artifact.</p> <p>Imports: - <code>time</code>: A module for time-related functions.</p> <ul> <li> <p><code>logger</code>: A logging utility from <code>swarms.utils.loguru_logger</code>.</p> </li> <li> <p><code>os</code>: A module providing a way of using operating system-dependent functionality.</p> </li> <li> <p><code>json</code>: A module for parsing JSON data.</p> </li> <li> <p><code>List</code>, <code>Union</code>, <code>Dict</code>, <code>Any</code>: Type hints from the <code>typing</code> module.</p> </li> <li> <p><code>BaseModel</code>, <code>Field</code>, <code>validator</code>: Tools from the <code>pydantic</code> module for data validation and settings management.</p> </li> <li> <p><code>datetime</code>: A module for manipulating dates and times.</p> </li> </ul>"},{"location":"swarms/framework/reference/#fileversion","title":"<code>FileVersion</code>","text":"<p>Description: Represents a version of a file with its content and timestamp.</p> <p>Attributes: - <code>version_number</code> (<code>int</code>): The version number of the file.</p> <ul> <li> <p><code>content</code> (<code>str</code>): The content of the file version.</p> </li> <li> <p><code>timestamp</code> (<code>str</code>): The timestamp of the file version, formatted as \"YYYY-MM-DD HH:MM:SS\".</p> </li> </ul> <p>Methods:</p> <ul> <li> <p><code>__str__(self) -&gt; str</code></p> <ul> <li> <p>Description: Returns a string representation of the file version.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): A formatted string containing the version number, timestamp, and content.</p> </li> </ul> </li> </ul>"},{"location":"swarms/framework/reference/#artifact","title":"<code>Artifact</code>","text":"<p>Description: Represents a file artifact with attributes to manage its content and version history.</p> <p>Attributes: - <code>file_path</code> (<code>str</code>): The path to the file.</p> <ul> <li> <p><code>file_type</code> (<code>str</code>): The type of the file (e.g., \".txt\").</p> </li> <li> <p><code>contents</code> (<code>str</code>): The contents of the file.</p> </li> <li> <p><code>versions</code> (<code>List[FileVersion]</code>): The list of file versions.</p> </li> <li> <p><code>edit_count</code> (<code>int</code>): The number of times the file has been edited.</p> </li> </ul> <p>Methods:</p> <ul> <li> <p><code>validate_file_type(cls, v, values) -&gt; str</code></p> <ul> <li> <p>Description: Validates the file type based on the file extension.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>v</code> (<code>str</code>): The file type to validate.</p> </li> <li> <p><code>values</code> (<code>dict</code>): A dictionary of other field values.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): The validated file type.</p> </li> </ul> </li> <li> <p><code>create(self, initial_content: str) -&gt; None</code></p> <ul> <li> <p>Description: Creates a new file artifact with the initial content.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>initial_content</code> (<code>str</code>): The initial content to set for the artifact.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>edit(self, new_content: str) -&gt; None</code></p> <ul> <li> <p>Description: Edits the artifact's content, tracking the change in the version history.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>new_content</code> (<code>str</code>): The new content to set for the artifact.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>save(self) -&gt; None</code></p> <ul> <li> <p>Description: Saves the current artifact's contents to the specified file path.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>load(self) -&gt; None</code></p> <ul> <li> <p>Description: Loads the file contents from the specified file path into the artifact.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>get_version(self, version_number: int) -&gt; Union[FileVersion, None]</code></p> <ul> <li> <p>Description: Retrieves a specific version of the artifact by its version number.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>version_number</code> (<code>int</code>): The version number to retrieve.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>FileVersion | None</code>): The requested version if found; otherwise, <code>None</code>.</p> </li> </ul> </li> <li> <p><code>get_contents(self) -&gt; str</code></p> <ul> <li> <p>Description: Returns the current contents of the artifact as a string.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): The current contents of the artifact.</p> </li> </ul> </li> <li> <p><code>get_version_history(self) -&gt; str</code></p> <ul> <li> <p>Description: Returns the version history of the artifact as a formatted string.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): A formatted string containing the version history.</p> </li> </ul> </li> <li> <p><code>export_to_json(self, file_path: str) -&gt; None</code></p> <ul> <li> <p>Description: Exports the artifact to a JSON file.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>file_path</code> (<code>str</code>): The path to the JSON file where the artifact will be saved.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>import_from_json(cls, file_path: str) -&gt; \"Artifact\"</code></p> <ul> <li> <p>Description: Imports an artifact from a JSON file.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>file_path</code> (<code>str</code>): The path to the JSON file to import the artifact from.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>Artifact</code>): The imported artifact instance.</p> </li> </ul> </li> <li> <p><code>get_metrics(self) -&gt; str</code></p> <ul> <li> <p>Description: Returns all metrics of the artifact as a formatted string.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>str</code>): A string containing all metrics of the artifact.</p> </li> </ul> </li> <li> <p><code>to_dict(self) -&gt; Dict[str, Any]</code></p> <ul> <li> <p>Description: Converts the artifact instance to a dictionary representation.</p> </li> <li> <p>Parameters: None.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>Dict[str, Any]</code>): The dictionary representation of the artifact.</p> </li> </ul> </li> <li> <p><code>from_dict(cls, data: Dict[str, Any]) -&gt; \"Artifact\"</code></p> <ul> <li> <p>Description: Creates an artifact instance from a dictionary representation.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>data</code> (<code>Dict[str, Any]</code>): The dictionary to create the artifact from.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>Artifact</code>): The created artifact instance.</p> </li> </ul> </li> </ul> <p>Example: <pre><code>from swarms.artifacts.main_artifact import Artifact\n\n# Create an Artifact instance\nartifact = Artifact(file_path=\"example.txt\", file_type=\".txt\")\nartifact.create(\"Initial content\")\nartifact.edit(\"First edit\")\nartifact.edit(\"Second edit\")\nartifact.save()\n\n# Export to JSON\nartifact.export_to_json(\"artifact.json\")\n\n# Import from JSON\nimported_artifact = Artifact.import_from_json(\"artifact.json\")\n\n# Get metrics\nprint(artifact.get_metrics())\n</code></pre></p>"},{"location":"swarms/framework/reference/#swarmsartifacts__init__","title":"<code>swarms.artifacts.__init__</code>","text":"<p>Description: This module serves as the initialization point for the artifacts subpackage within the Swarms framework. It imports and exposes the key classes related to artifacts, including <code>BaseArtifact</code>, <code>TextArtifact</code>, and <code>Artifact</code>, making them available for use in other parts of the application.</p> <p>Imports: - <code>BaseArtifact</code>: The abstract base class for artifacts, imported from <code>swarms.artifacts.base_artifact</code>.</p> <ul> <li> <p><code>TextArtifact</code>: A class representing text-based artifacts, imported from <code>swarms.artifacts.text_artifact</code>.</p> </li> <li> <p><code>Artifact</code>: A class representing file artifacts with versioning capabilities, imported from <code>swarms.artifacts.main_artifact</code>.</p> </li> </ul> <p>Exported Classes: - <code>BaseArtifact</code>: The base class for all artifacts.</p> <ul> <li> <p><code>TextArtifact</code>: A specialized artifact class for handling text values.</p> </li> <li> <p><code>Artifact</code>: A class for managing file artifacts, including their content and version history.</p> </li> </ul> <p>Example: <pre><code>from swarms.artifacts import *\n\n# Create instances of the artifact classes\nbase_artifact = BaseArtifact(id=\"1\", name=\"Base Artifact\", value=\"Some value\")  # This will raise an error since BaseArtifact is abstract\ntext_artifact = TextArtifact(value=\"Sample text\")\nfile_artifact = Artifact(file_path=\"example.txt\", file_type=\".txt\")\n\n# Use the classes as needed\nprint(text_artifact)  # Output: Sample text\n</code></pre></p> <p>Note: Since <code>BaseArtifact</code> is an abstract class, it cannot be instantiated directly.</p>"},{"location":"swarms/framework/reference/#agents","title":"Agents","text":""},{"location":"swarms/framework/reference/#swarmsagents__init__","title":"<code>swarms.agents.__init__</code>","text":"<p>Description: This module serves as the initialization point for the agents subpackage within the Swarms framework. It imports and exposes key classes and functions related to agent operations, including stopping conditions and the <code>ToolAgent</code> class, making them available for use in other parts of the application.</p> <p>Imports: - <code>check_cancelled</code>: A function to check if the operation has been cancelled.</p> <ul> <li> <p><code>check_complete</code>: A function to check if the operation is complete.</p> </li> <li> <p><code>check_done</code>: A function to check if the operation is done.</p> </li> <li> <p><code>check_end</code>: A function to check if the operation has ended.</p> </li> <li> <p><code>check_error</code>: A function to check if there was an error during the operation.</p> </li> <li> <p><code>check_exit</code>: A function to check if the operation has exited.</p> </li> <li> <p><code>check_failure</code>: A function to check if the operation has failed.</p> </li> <li> <p><code>check_finished</code>: A function to check if the operation has finished.</p> </li> <li> <p><code>check_stopped</code>: A function to check if the operation has been stopped.</p> </li> <li> <p><code>check_success</code>: A function to check if the operation was successful.</p> </li> <li> <p><code>ToolAgent</code>: A class representing an agent that utilizes tools.</p> </li> </ul> <p>Exported Classes and Functions: - <code>ToolAgent</code>: The class for managing tool-based agents.</p> <ul> <li> <p><code>check_done</code>: Checks if the operation is done.</p> </li> <li> <p><code>check_finished</code>: Checks if the operation has finished.</p> </li> <li> <p><code>check_complete</code>: Checks if the operation is complete.</p> </li> <li> <p><code>check_success</code>: Checks if the operation was successful.</p> </li> <li> <p><code>check_failure</code>: Checks if the operation has failed.</p> </li> <li> <p><code>check_error</code>: Checks if there was an error during the operation.</p> </li> <li> <p><code>check_stopped</code>: Checks if the operation has been stopped.</p> </li> <li> <p><code>check_cancelled</code>: Checks if the operation has been cancelled.</p> </li> <li> <p><code>check_exit</code>: Checks if the operation has exited.</p> </li> <li> <p><code>check_end</code>: Checks if the operation has ended.</p> </li> </ul> <p>Example: <pre><code>from swarms.agents import *\n\n# Create an instance of ToolAgent\ntool_agent = ToolAgent()\n\n# Check the status of an operation\nif check_done():\n    print(\"The operation is done.\")\n</code></pre></p> <p>Note: The specific implementations of the stopping condition functions and the <code>ToolAgent</code> class are not detailed in this module, as they are imported from other modules within the <code>swarms.agents</code> package.</p>"},{"location":"swarms/framework/reference/#swarmsagentstool_agent","title":"<code>swarms.agents.tool_agent</code>","text":"<p>Description: This module defines the <code>ToolAgent</code> class, which represents a specialized agent capable of performing tasks using a specified model and tokenizer. It is designed to run operations that require input validation against a JSON schema, generating outputs based on defined tasks.</p> <p>Imports: - <code>Any</code>, <code>Optional</code>, <code>Callable</code>: Type hints from the <code>typing</code> module for flexible parameter types.</p> <ul> <li> <p><code>Agent</code>: The base class for agents, imported from <code>swarms.structs.agent</code>.</p> </li> <li> <p><code>Jsonformer</code>: A class responsible for transforming JSON data, imported from <code>swarms.tools.json_former</code>.</p> </li> <li> <p><code>logger</code>: A logging utility from <code>swarms.utils.loguru_logger</code>.</p> </li> </ul>"},{"location":"swarms/framework/reference/#toolagent","title":"<code>ToolAgent</code>","text":"<p>Description: Represents a tool agent that performs a specific task using a model and tokenizer. It facilitates the execution of tasks by calling the appropriate model or using the defined JSON schema for structured output.</p> <p>Attributes: - <code>name</code> (<code>str</code>): The name of the tool agent.</p> <ul> <li> <p><code>description</code> (<code>str</code>): A description of what the tool agent does.</p> </li> <li> <p><code>model</code> (<code>Any</code>): The model used by the tool agent for processing.</p> </li> <li> <p><code>tokenizer</code> (<code>Any</code>): The tokenizer used by the tool agent to prepare input data.</p> </li> <li> <p><code>json_schema</code> (<code>Any</code>): The JSON schema that defines the structure of the expected output.</p> </li> <li> <p><code>max_number_tokens</code> (<code>int</code>): The maximum number of tokens to generate (default is 500).</p> </li> <li> <p><code>parsing_function</code> (<code>Optional[Callable]</code>): A function for parsing the output, if provided.</p> </li> <li> <p><code>llm</code> (<code>Any</code>): A language model, if utilized instead of a custom model.</p> </li> </ul> <p>Methods:</p> <ul> <li> <p><code>__init__(self, name: str, description: str, model: Any, tokenizer: Any, json_schema: Any, max_number_tokens: int, parsing_function: Optional[Callable], llm: Any, *args,  **kwargs) -&gt; None</code></p> <ul> <li> <p>Description: Initializes a new instance of the ToolAgent class.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>name</code> (<code>str</code>): The name of the tool agent.</p> </li> <li> <p><code>description</code> (<code>str</code>): A description of the tool agent.</p> </li> <li> <p><code>model</code> (<code>Any</code>): The model to use (if applicable).</p> </li> <li> <p><code>tokenizer</code> (<code>Any</code>): The tokenizer to use (if applicable).</p> </li> <li> <p><code>json_schema</code> (<code>Any</code>): The JSON schema that outlines the expected output format.</p> </li> <li> <p><code>max_number_tokens</code> (<code>int</code>): Maximum token output size.</p> </li> <li> <p><code>parsing_function</code> (<code>Optional[Callable]</code>): Optional function to parse the output.</p> </li> <li> <p><code>llm</code> (<code>Any</code>): The language model to use as an alternative to a custom model.</p> </li> <li> <p><code>*args</code> and <code>**kwargs</code>: Additional arguments and keyword arguments for flexibility.</p> </li> <li> <p>Return: None.</p> </li> </ul> </li> <li> <p><code>run(self, task: str, *args, **kwargs) -&gt; Any</code></p> <ul> <li> <p>Description: Executes the tool agent for the specified task, utilizing either a model or a language model based on provided parameters.</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>task</code> (<code>str</code>): The task or prompt to be processed by the tool agent.</p> </li> <li> <p><code>*args</code>: Additional positional arguments for flexibility.</p> </li> <li> <p><code>**kwargs</code>: Additional keyword arguments for flexibility.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>Any</code>): The output generated by the tool agent based on the input task.</p> </li> <li> <p>Raises: </p> </li> <li> <p><code>Exception</code>: If neither <code>model</code> nor <code>llm</code> is provided or if an error occurs during task execution.</p> </li> </ul> </li> </ul> <p>Example: <pre><code>from transformers import AutoModelForCausalLM, AutoTokenizer\nfrom swarms.agents.tool_agent import ToolAgent\n\n# Load model and tokenizer\nmodel = AutoModelForCausalLM.from_pretrained(\"databricks/dolly-v2-12b\")\n\ntokenizer = AutoTokenizer.from_pretrained(\"databricks/dolly-v2-12b\")\n\n\n# Define a JSON schema\njson_schema = {\n    \"type\": \"object\",\n    \"properties\": {\n        \"name\": {\"type\": \"string\"},\n        \"age\": {\"type\": \"number\"},\n        \"is_student\": {\"type\": \"boolean\"},\n        \"courses\": {\n            \"type\": \"array\",\n            \"items\": {\"type\": \"string\"}\n        }\n    }\n}\n\n# Create and run a ToolAgent\ntask = \"Generate a person's information based on the following schema:\"\nagent = ToolAgent(model=model, tokenizer=tokenizer, json_schema=json_schema)\ngenerated_data = agent.run(task)\n\nprint(generated_data)\n</code></pre></p>"},{"location":"swarms/framework/reference/#swarmsagentsstopping_conditions","title":"<code>swarms.agents.stopping_conditions</code>","text":"<p>Description: This module contains a set of functions that check specific stopping conditions based on strings. These functions return boolean values indicating the presence of certain keywords, which can be used to determine the status of an operation or process.</p>"},{"location":"swarms/framework/reference/#functions","title":"Functions:","text":"<ul> <li> <p><code>check_done(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"\".  <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"\" is found in the string; otherwise, <code>False</code>. <li> <p><code>check_finished(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"finished\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"finished\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_complete(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"complete\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"complete\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_success(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"success\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"success\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_failure(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"failure\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"failure\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_error(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"error\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"error\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_stopped(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"stopped\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"stopped\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_cancelled(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"cancelled\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"cancelled\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_exit(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"exit\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"exit\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <li> <p><code>check_end(s: str) -&gt; bool</code></p> <ul> <li> <p>Description: Checks if the string contains the keyword \"end\".</p> </li> <li> <p>Parameters: </p> </li> <li> <p><code>s</code> (<code>str</code>): The input string to check.</p> </li> <li> <p>Return: </p> </li> <li> <p>(<code>bool</code>): <code>True</code> if \"end\" is found in the string; otherwise, <code>False</code>.</p> </li> </ul> </li> <p>Example: <pre><code>from swarms.agents.stopping_conditions import check_done, check_error\n\nstatus_message = \"The process has finished and &lt;DONE&gt;!\"\n\nif check_done(status_message):\n    print(\"The operation is done!\")\n\nif check_error(status_message):\n    print(\"An error has occurred!\")\n</code></pre></p> <p>Note: Each of these functions provides a simple way to check for specific keywords in a given string, which can be helpful in managing and monitoring tasks or operations.</p>"},{"location":"swarms/framework/reference/#schemas","title":"Schemas","text":""},{"location":"swarms/framework/reference/#swarmsschemasbase_schemas","title":"<code>swarms.schemas.base_schemas</code>","text":"<p>Description: This module defines various Pydantic models that represent schemas used in machine learning applications. These models facilitate data validation and serialization for different types of content, such as model cards, chat messages, and responses. </p> <p>Imports: - <code>uuid</code>: A module for generating unique identifiers.</p> <ul> <li> <p><code>time</code>: A module for time-related functions.</p> </li> <li> <p><code>List</code>, <code>Literal</code>, <code>Optional</code>, <code>Union</code>: Type hints from the <code>typing</code> module for flexible parameter types.</p> </li> <li> <p><code>BaseModel</code>, <code>Field</code>: Tools from the <code>pydantic</code> module for data validation and settings management.</p> </li> </ul>"},{"location":"swarms/framework/reference/#modelcard","title":"<code>ModelCard</code>","text":"<p>Description: A Pydantic model that represents a model card, which provides metadata about a machine learning model.</p> <p>Attributes: - <code>id</code> (<code>str</code>): The unique identifier for the model.</p> <ul> <li> <p><code>object</code> (<code>str</code>): A fixed string indicating the type of object (\"model\").</p> </li> <li> <p><code>created</code> (<code>int</code>): The timestamp of model creation, defaults to the current time.</p> </li> <li> <p><code>owned_by</code> (<code>str</code>): The owner of the model.</p> </li> <li> <p><code>root</code> (<code>Optional[str]</code>): The root model identifier if applicable.</p> </li> <li> <p><code>parent</code> (<code>Optional[str]</code>): The parent model identifier if applicable.</p> </li> <li> <p><code>permission</code> (<code>Optional[list]</code>): A list of permissions associated with the model.</p> </li> </ul>"},{"location":"swarms/framework/reference/#modellist","title":"<code>ModelList</code>","text":"<p>Description: A Pydantic model that represents a list of model cards.</p> <p>Attributes: - <code>object</code> (<code>str</code>): A fixed string indicating the type of object (\"list\").</p> <ul> <li><code>data</code> (<code>List[ModelCard]</code>): A list containing instances of <code>ModelCard</code>.</li> </ul>"},{"location":"swarms/framework/reference/#imageurl","title":"<code>ImageUrl</code>","text":"<p>Description: A Pydantic model representing an image URL.</p> <p>Attributes: - <code>url</code> (<code>str</code>): The URL of the image.</p>"},{"location":"swarms/framework/reference/#textcontent","title":"<code>TextContent</code>","text":"<p>Description: A Pydantic model representing text content.</p> <p>Attributes: - <code>type</code> (<code>Literal[\"text\"]</code>): A fixed string indicating the type of content (text).</p> <ul> <li><code>text</code> (<code>str</code>): The actual text content.</li> </ul>"},{"location":"swarms/framework/reference/#imageurlcontent","title":"<code>ImageUrlContent</code>","text":"<p>Description: A Pydantic model representing image content via URL.</p> <p>Attributes: - <code>type</code> (<code>Literal[\"image_url\"]</code>): A fixed string indicating the type of content (image URL).</p> <ul> <li><code>image_url</code> (<code>ImageUrl</code>): An instance of <code>ImageUrl</code> containing the URL of the image.</li> </ul>"},{"location":"swarms/framework/reference/#contentitem","title":"<code>ContentItem</code>","text":"<p>Description: A type alias for a union of <code>TextContent</code> and <code>ImageUrlContent</code>, representing any content type that can be processed.</p>"},{"location":"swarms/framework/reference/#chatmessageinput","title":"<code>ChatMessageInput</code>","text":"<p>Description: A Pydantic model representing an input message for chat applications.</p> <p>Attributes: - <code>role</code> (<code>str</code>): The role of the sender (e.g., \"user\", \"assistant\", or \"system\").</p> <ul> <li><code>content</code> (<code>Union[str, List[ContentItem]]</code>): The content of the message, which can be a string or a list of content items.</li> </ul>"},{"location":"swarms/framework/reference/#chatmessageresponse","title":"<code>ChatMessageResponse</code>","text":"<p>Description: A Pydantic model representing a response message in chat applications.</p> <p>Attributes: - <code>role</code> (<code>str</code>): The role of the sender (e.g., \"user\", \"assistant\", or \"system\").</p> <ul> <li><code>content</code> (<code>str</code>, optional): The content of the response message.</li> </ul>"},{"location":"swarms/framework/reference/#deltamessage","title":"<code>DeltaMessage</code>","text":"<p>Description: A Pydantic model representing a delta update for messages in chat applications.</p> <p>Attributes: - <code>role</code> (<code>Optional[Literal[\"user\", \"assistant\", \"system\"]]</code>): The role of the sender, if specified.</p> <ul> <li><code>content</code> (<code>Optional[str]</code>): The content of the delta message, if provided.</li> </ul>"},{"location":"swarms/framework/reference/#chatcompletionrequest","title":"<code>ChatCompletionRequest</code>","text":"<p>Description: A Pydantic model representing a request for chat completion.</p> <p>Attributes: - <code>model</code> (<code>str</code>): The model to use for completing the chat (default is \"gpt-4o\").</p> <ul> <li> <p><code>messages</code> (<code>List[ChatMessageInput]</code>): A list of input messages for the chat.</p> </li> <li> <p><code>temperature</code> (<code>Optional[float]</code>): Controls the randomness of the output (default is 0.8).</p> </li> <li> <p><code>top_p</code> (<code>Optional[float]</code>): An alternative to sampling with temperature (default is 0.8).</p> </li> <li> <p><code>max_tokens</code> (<code>Optional[int]</code>): The maximum number of tokens to generate (default is 4000).</p> </li> <li> <p><code>stream</code> (<code>Optional[bool]</code>): If true, the response will be streamed (default is False).</p> </li> <li> <p><code>repetition_penalty</code> (<code>Optional[float]</code>): A penalty for repeated tokens (default is 1.0).</p> </li> <li> <p><code>echo</code> (<code>Optional[bool]</code>): If true, the input will be echoed in the output (default is False).</p> </li> </ul>"},{"location":"swarms/framework/reference/#chatcompletionresponsechoice","title":"<code>ChatCompletionResponseChoice</code>","text":"<p>Description: A Pydantic model representing a choice in a chat completion response.</p> <p>Attributes: - <code>index</code> (<code>int</code>): The index of the choice.</p> <ul> <li> <p><code>input</code> (<code>str</code>): The input message.</p> </li> <li> <p><code>message</code> (<code>ChatMessageResponse</code>): The output message.</p> </li> </ul>"},{"location":"swarms/framework/reference/#chatcompletionresponsestreamchoice","title":"<code>ChatCompletionResponseStreamChoice</code>","text":"<p>Description: A Pydantic model representing a choice in a streamed chat completion response.</p> <p>Attributes: - <code>index</code> (<code>int</code>): The index of the choice.</p> <ul> <li><code>delta</code> (<code>DeltaMessage</code>): The delta update for the message.</li> </ul>"},{"location":"swarms/framework/reference/#usageinfo","title":"<code>UsageInfo</code>","text":"<p>Description: A Pydantic model representing usage information for a chat completion request.</p> <p>Attributes: - <code>prompt_tokens</code> (<code>int</code>): The number of tokens used in the prompt (default is 0).</p> <ul> <li> <p><code>total_tokens</code> (<code>int</code>): The total number of tokens used (default is 0).</p> </li> <li> <p><code>completion_tokens</code> (<code>Optional[int]</code>): The number of tokens used in the completion (default is 0).</p> </li> </ul>"},{"location":"swarms/framework/reference/#chatcompletionresponse","title":"<code>ChatCompletionResponse</code>","text":"<p>Description: A Pydantic model representing a response from a chat completion request.</p> <p>Attributes: - <code>model</code> (<code>str</code>): The model used for the completion.</p> <ul> <li> <p><code>object</code> (<code>Literal[\"chat.completion\", \"chat.completion.chunk\"]</code>): The type of response object.</p> </li> <li> <p><code>choices</code> (<code>List[Union[ChatCompletionResponseChoice, ChatCompletionResponseStreamChoice]]</code>): A list of choices from the completion.</p> </li> <li> <p><code>created</code> (<code>Optional[int]</code>): The timestamp of when the response was created.</p> </li> </ul>"},{"location":"swarms/framework/reference/#agentchatcompletionresponse","title":"<code>AgentChatCompletionResponse</code>","text":"<p>Description: A Pydantic model representing a completion response from an agent.</p> <p>Attributes: - <code>id</code> (<code>Optional[str]</code>): The ID of the agent that generated the completion response (default is a new UUID).</p> <ul> <li> <p><code>agent_name</code> (<code>Optional[str]</code>): The name of the agent that generated the response.</p> </li> <li> <p><code>object</code> (<code>Optional[Literal[\"chat.completion\", \"chat.completion.chunk\"]]</code>): The type of response object.</p> </li> <li> <p><code>choices</code> (<code>Optional[ChatCompletionResponseChoice]</code>): The choice from the completion response.</p> </li> <li> <p><code>created</code> (<code>Optional[int]</code>): The timestamp of when the response was created.</p> </li> </ul> <p>Example: <pre><code>from swarms.schemas.base_schemas import ChatCompletionRequest, ChatMessageInput\n\n# Create a chat completion request\nrequest = ChatCompletionRequest(\n    model=\"gpt-4\",\n\n    messages=[\n        ChatMessageInput(role=\"user\", content=\"Hello! How can I help you?\")\n    ]\n)\n</code></pre></p> <p>Note: The Pydantic models in this module provide a structured way to handle data related to machine learning models and chat interactions, ensuring that the data adheres to defined schemas.</p>"},{"location":"swarms/framework/reference/#swarmsschemasplan","title":"<code>swarms.schemas.plan</code>","text":"<p>Description: This module defines the <code>Plan</code> class, which represents a sequence of steps in a structured format. It utilizes Pydantic for data validation and configuration, ensuring that each plan consists of a list of defined steps.</p> <p>Imports: - <code>List</code>: A type hint from the <code>typing</code> module for work with lists.</p> <ul> <li> <p><code>BaseModel</code>: The Pydantic base class for data models, providing validation and serialization features.</p> </li> <li> <p><code>Step</code>: A model representing individual steps in the plan, imported from <code>swarms.schemas.agent_step_schemas</code>.</p> </li> </ul>"},{"location":"swarms/framework/reference/#plan","title":"<code>Plan</code>","text":"<p>Description: Represents a sequence of steps that comprise a plan. This class ensures that the data structure adheres to the expected model for steps.</p> <p>Attributes: - <code>steps</code> (<code>List[Step]</code>): A list of steps, where each step is an instance of the <code>Step</code> model.</p> <p>Config: - <code>orm_mode</code> (bool): Enables compatibility with ORM models to facilitate data loading from database objects.</p> <p>Example: <pre><code>from swarms.schemas.plan import Plan\nfrom swarms.schemas.agent_step_schemas import Step\n\n# Create a list of steps\nsteps = [\n    Step(/* initialize step attributes */),\n    Step(/* initialize step attributes */),\n]\n\n# Create a Plan instance\nplan = Plan(steps=steps)\n\n# Access the steps\nfor step in plan.steps:\n    print(step)\n</code></pre></p> <p>Note: The <code>Plan</code> class relies on the <code>Step</code> model for its structure, ensuring that the steps in a plan conform to the validation rules defined in the <code>Step</code> model.</p>"},{"location":"swarms/framework/reference/#swarmsschemas__init__","title":"<code>swarms.schemas.__init__</code>","text":"<p>Description: This module serves as the initialization point for the schemas subpackage within the Swarms framework. It imports and exposes key classes related to agent steps and agent input schemas, making them available for use in other parts of the application.</p> <p>Imports: - <code>Step</code>: A model representing an individual step in an agent's operation, imported from <code>swarms.schemas.agent_step_schemas</code>.</p> <ul> <li> <p><code>ManySteps</code>: A model representing multiple steps, also imported from <code>swarms.schemas.agent_step_schemas</code>.</p> </li> <li> <p><code>AgentSchema</code>: A model representing the schema for agent inputs, imported from <code>swarms.schemas.agent_input_schema</code>.</p> </li> </ul> <p>Exported Classes: - <code>Step</code>: The class for defining individual steps in an agent's operation.</p> <ul> <li> <p><code>ManySteps</code>: The class for defining multiple steps in an agent's operation.</p> </li> <li> <p><code>AgentSchema</code>: The class for defining the input schema for agents.</p> </li> </ul> <p>Example: <pre><code>from swarms.schemas import *\n\n# Create an instance of Step\nstep = Step(/* initialize step attributes */)\n\n# Create an instance of ManySteps\nmany_steps = ManySteps(steps=[step, step])\n\n# Create an instance of AgentSchema\nagent_schema = AgentSchema(/* initialize agent schema attributes */)\n</code></pre></p> <p>Note: This module acts as a central point for importing and utilizing the various schema classes defined in the Swarms framework, facilitating structured data handling for agents and their operations.</p>"},{"location":"swarms/framework/reference/#swarmsschemasagent_step_schemas","title":"<code>swarms.schemas.agent_step_schemas</code>","text":"<p>Description: This module defines the <code>Step</code> and <code>ManySteps</code> classes, which represent individual steps and collections of steps in a task, respectively. These classes utilize Pydantic for data validation and serialization, ensuring that each step adheres to the defined schema.</p> <p>Imports: - <code>time</code>: A module for time-related functions.</p> <ul> <li> <p><code>uuid</code>: A module for generating unique identifiers.</p> </li> <li> <p><code>List</code>, <code>Optional</code>, <code>Any</code>: Type hints from the <code>typing</code> module for flexible parameter types.</p> </li> <li> <p><code>BaseModel</code>, <code>Field</code>: Tools from the <code>pydantic</code> module for data validation and settings management.</p> </li> <li> <p><code>AgentChatCompletionResponse</code>: A model representing the response from an agent's chat completion, imported from <code>swarms.schemas.base_schemas</code>.</p> </li> </ul>"},{"location":"swarms/framework/reference/#get_current_time-str","title":"<code>get_current_time() -&gt; str</code>","text":"<p>Description: Returns the current time formatted as \"YYYY-MM-DD HH:MM:SS\".</p> <p>Return: - (<code>str</code>): The current time as a formatted string.</p>"},{"location":"swarms/framework/reference/#step","title":"<code>Step</code>","text":"<p>Description: A Pydantic model representing a single step in a task, including its ID, completion time, and response from an agent.</p> <p>Attributes: - <code>step_id</code> (<code>Optional[str]</code>): The unique identifier for the step, generated if not provided.</p> <ul> <li> <p><code>time</code> (<code>Optional[float]</code>): The time taken to complete the task step, formatted as a string.</p> </li> <li> <p><code>response</code> (<code>Optional[AgentChatCompletionResponse]</code>): The response from the agent for this step.</p> </li> </ul>"},{"location":"swarms/framework/reference/#manysteps","title":"<code>ManySteps</code>","text":"<p>Description: A Pydantic model representing a collection of steps associated with a specific agent and task.</p> <p>Attributes: - <code>agent_id</code> (<code>Optional[str]</code>): The unique identifier for the agent.</p> <ul> <li> <p><code>agent_name</code> (<code>Optional[str]</code>): The name of the agent.</p> </li> <li> <p><code>task</code> (<code>Optional[str]</code>): The name of the task being performed.</p> </li> <li> <p><code>max_loops</code> (<code>Optional[Any]</code>): The maximum number of steps in the task.</p> </li> <li> <p><code>run_id</code> (<code>Optional[str]</code>): The ID of the task this collection of steps belongs to.</p> </li> <li> <p><code>steps</code> (<code>Optional[List[Step]]</code>): A list of <code>Step</code> instances representing the steps of the task.</p> </li> <li> <p><code>full_history</code> (<code>Optional[str]</code>): A string containing the full history of the task.</p> </li> <li> <p><code>total_tokens</code> (<code>Optional[int]</code>): The total number of tokens generated during the task.</p> </li> <li> <p><code>stopping_token</code> (<code>Optional[str]</code>): The token at which the task stopped.</p> </li> <li> <p><code>interactive</code> (<code>Optional[bool]</code>): Indicates whether the task is interactive.</p> </li> <li> <p><code>dynamic_temperature_enabled</code> (<code>Optional[bool]</code>): Indicates whether dynamic temperature adjustments are enabled for the task.</p> </li> </ul> <p>Example: <pre><code>from swarms.schemas.agent_step_schemas import Step, ManySteps\n\n# Create a step instance\nstep = Step(step_id=\"12345\", response=AgentChatCompletionResponse(...))\n\n# Create a ManySteps instance\nmany_steps = ManySteps(\n    agent_id=\"agent-1\",\n\n    agent_name=\"Test Agent\",\n    task=\"Example Task\",\n    max_loops=5,\n    steps=[step],\n    full_history=\"Task executed successfully.\",\n    total_tokens=100\n)\n\nprint(many_steps)\n</code></pre></p> <p>Note: The <code>Step</code> and <code>ManySteps</code> classes provide structured representations of task steps, ensuring that all necessary information is captured and validated according to the defined schemas.</p>"},{"location":"swarms/framework/reference/#swarmsschemasagent_input_schema","title":"<code>swarms.schemas.agent_input_schema</code>","text":"<p>Description: This module defines the <code>AgentSchema</code> class using Pydantic, which represents the input parameters necessary for configuring an agent in the Swarms framework. It includes a variety of attributes for specifying the agent's behavior, model settings, and operational parameters.</p> <p>Imports: - <code>Any</code>, <code>Callable</code>, <code>Dict</code>, <code>List</code>, <code>Optional</code>: Type hints from the <code>typing</code> module for flexible parameter types.</p> <ul> <li> <p><code>BaseModel</code>, <code>Field</code>: Tools from the <code>pydantic</code> module for data validation and settings management.</p> </li> <li> <p><code>validator</code>: A decorator from Pydantic used for custom validation of fields.</p> </li> </ul>"},{"location":"swarms/framework/reference/#agentschema","title":"<code>AgentSchema</code>","text":"<p>Description: Represents the configuration for an agent, including attributes that govern its behavior, capabilities, and interaction with language models. This class ensures that the input data adheres to defined validation rules.</p> <p>Attributes: - <code>llm</code> (<code>Any</code>): The language model to use.</p> <ul> <li> <p><code>max_tokens</code> (<code>int</code>): The maximum number of tokens the agent can generate, must be greater than or equal to 1.</p> </li> <li> <p><code>context_window</code> (<code>int</code>): The size of the context window, must be greater than or equal to 1.</p> </li> <li> <p><code>user_name</code> (<code>str</code>): The name of the user interacting with the agent.</p> </li> <li> <p><code>agent_name</code> (<code>str</code>): The name of the agent.</p> </li> <li> <p><code>system_prompt</code> (<code>str</code>): The system prompt provided to the agent.</p> </li> <li> <p><code>template</code> (<code>Optional[str]</code>): An optional template for the agent, default is <code>None</code>.</p> </li> <li> <p><code>max_loops</code> (<code>Optional[int]</code>): The maximum number of loops the agent can perform (default is 1, must be greater than or equal to 1).</p> </li> <li> <p><code>stopping_condition</code> (<code>Optional[Callable[[str], bool]]</code>): A callable function that defines a stopping condition for the agent.</p> </li> <li> <p><code>loop_interval</code> (<code>Optional[int]</code>): The interval between loops (default is 0, must be greater than or equal to 0).</p> </li> <li> <p><code>retry_attempts</code> (<code>Optional[int]</code>): Number of times to retry an operation if it fails (default is 3, must be greater than or equal to 0).</p> </li> <li> <p><code>retry_interval</code> (<code>Optional[int]</code>): The time between retry attempts (default is 1, must be greater than or equal to 0).</p> </li> <li> <p><code>return_history</code> (<code>Optional[bool]</code>): Flag indicating whether to return the history of the agent's operations (default is <code>False</code>).</p> </li> <li> <p><code>stopping_token</code> (<code>Optional[str]</code>): Token indicating when to stop processing (default is <code>None</code>).</p> </li> <li> <p><code>dynamic_loops</code> (<code>Optional[bool]</code>): Indicates whether dynamic loops are enabled (default is <code>False</code>).</p> </li> <li> <p><code>interactive</code> (<code>Optional[bool]</code>): Indicates whether the agent operates in an interactive mode (default is <code>False</code>).</p> </li> <li> <p><code>dashboard</code> (<code>Optional[bool]</code>): Flag indicating whether a dashboard interface is enabled (default is <code>False</code>).</p> </li> <li> <p><code>agent_description</code> (<code>Optional[str]</code>): A description of the agent's functionality (default is <code>None</code>).</p> </li> <li> <p><code>tools</code> (<code>Optional[List[Callable]]</code>): List of callable tools the agent can use (default is <code>None</code>).</p> </li> <li> <p><code>dynamic_temperature_enabled</code> (<code>Optional[bool]</code>): Indicates whether dynamic temperature adjustments are enabled (default is <code>False</code>).</p> </li> <li> <p>Additional attributes for managing various functionalities and configurations related to the agent's behavior, such as logging, saving states, and managing tools.</p> </li> </ul>"},{"location":"swarms/framework/reference/#validators","title":"Validators:","text":"<ul> <li> <p>check_list_items_not_none(v): Ensures that items within certain list attributes (<code>tools</code>, <code>docs</code>, <code>sop_list</code>, etc.) are not <code>None</code>.</p> </li> <li> <p>check_optional_callable_not_none(v): Ensures that optional callable attributes are either <code>None</code> or callable.</p> </li> </ul> <p>Example: <pre><code>from swarms.schemas.agent_input_schema import AgentSchema\n\n# Define the agent configuration data\nagent_data = {\n    \"llm\": \"OpenAIChat\",\n    \"max_tokens\": 4096,\n    \"context_window\": 8192,\n    \"user_name\": \"Human\",\n    \"agent_name\": \"test-agent\",\n\n    \"system_prompt\": \"Custom system prompt\",\n}\n\n# Create an AgentSchema instance\nagent = AgentSchema(**agent_data)\nprint(agent)\n</code></pre></p> <p>Note: The <code>AgentSchema</code> class provides a structured way to configure agents in the Swarms framework, ensuring that all necessary parameters are validated before use.</p>"},{"location":"swarms/framework/test/","title":"How to Run Tests Using Pytest: A Comprehensive Guide","text":"<p>In modern software development, automated testing is crucial for ensuring the reliability and functionality of your code. One of the most popular testing frameworks for Python is <code>pytest</code>. </p> <p>This blog will provide an in-depth look at how to run tests using <code>pytest</code>, including testing a single file, multiple files, every file in the test repository, and providing guidelines for contributors to run tests reliably.</p>"},{"location":"swarms/framework/test/#what-is-pytest","title":"What is Pytest?","text":"<p><code>pytest</code> is a testing framework for Python that makes it easy to write simple and scalable test cases. It supports fixtures, parameterized testing, and has a rich plugin architecture. <code>pytest</code> is widely used because of its ease of use and powerful features that help streamline the testing process.</p>"},{"location":"swarms/framework/test/#installation","title":"Installation","text":"<p>To get started with <code>pytest</code>, you need to install it. You can install <code>pytest</code> using <code>pip</code>:</p> <pre><code>pip install pytest\n</code></pre>"},{"location":"swarms/framework/test/#writing-your-first-test","title":"Writing Your First Test","text":"<p>Before diving into running tests, let\u2019s write a simple test. Create a file named <code>test_sample.py</code> with the following content:</p> <pre><code>def test_addition():\n    assert 1 + 1 == 2\n\ndef test_subtraction():\n    assert 2 - 1 == 1\n</code></pre> <p>In this example, we have defined two basic tests: <code>test_addition</code> and <code>test_subtraction</code>.</p>"},{"location":"swarms/framework/test/#running-tests","title":"Running Tests","text":""},{"location":"swarms/framework/test/#running-a-single-test-file","title":"Running a Single Test File","text":"<p>To run a single test file, you can use the <code>pytest</code> command followed by the filename. For example, to run the tests in <code>test_sample.py</code>, use the following command:</p> <pre><code>pytest test_sample.py\n</code></pre> <p>The output will show the test results, including the number of tests passed, failed, or skipped.</p>"},{"location":"swarms/framework/test/#running-multiple-test-files","title":"Running Multiple Test Files","text":"<p>You can also run multiple test files by specifying their filenames separated by a space. For example:</p> <pre><code>pytest test_sample.py test_another_sample.py\n</code></pre> <p>If you have multiple test files in a directory, you can run all of them by specifying the directory name:</p> <pre><code>pytest tests/\n</code></pre>"},{"location":"swarms/framework/test/#running-all-tests-in-the-repository","title":"Running All Tests in the Repository","text":"<p>To run all tests in the repository, navigate to the root directory of your project and simply run:</p> <pre><code>pytest\n</code></pre> <p><code>pytest</code> will automatically discover and run all the test files that match the pattern <code>test_*.py</code> or <code>*_test.py</code>.</p>"},{"location":"swarms/framework/test/#test-discovery","title":"Test Discovery","text":"<p><code>pytest</code> automatically discovers test files and test functions based on their naming conventions. By default, it looks for files that match the pattern <code>test_*.py</code> or <code>*_test.py</code> and functions or methods that start with <code>test_</code>.</p>"},{"location":"swarms/framework/test/#using-markers","title":"Using Markers","text":"<p><code>pytest</code> allows you to use markers to group tests or add metadata to them. Markers can be used to run specific subsets of tests. For example, you can mark a test as <code>slow</code> and then run only the slow tests or skip them.</p> <pre><code>import pytest\n\n@pytest.mark.slow\ndef test_long_running():\n    import time\n    time.sleep(5)\n    assert True\n\ndef test_fast():\n    assert True\n</code></pre> <p>To run only the tests marked as <code>slow</code>, use the <code>-m</code> option:</p> <pre><code>pytest -m slow\n</code></pre>"},{"location":"swarms/framework/test/#parameterized-tests","title":"Parameterized Tests","text":"<p><code>pytest</code> supports parameterized testing, which allows you to run a test with different sets of input data. This can be done using the <code>@pytest.mark.parametrize</code> decorator.</p> <pre><code>import pytest\n\n@pytest.mark.parametrize(\"a,b,expected\", [\n    (1, 2, 3),\n    (2, 3, 5),\n    (3, 5, 8),\n])\ndef test_add(a, b, expected):\n    assert a + b == expected\n</code></pre> <p>In this example, <code>test_add</code> will run three times with different sets of input data.</p>"},{"location":"swarms/framework/test/#fixtures","title":"Fixtures","text":"<p>Fixtures are a powerful feature of <code>pytest</code> that allow you to set up some context for your tests. They can be used to provide a fixed baseline upon which tests can reliably and repeatedly execute.</p> <pre><code>import pytest\n\n@pytest.fixture\ndef sample_data():\n    return {\"name\": \"John\", \"age\": 30}\n\ndef test_sample_data(sample_data):\n    assert sample_data[\"name\"] == \"John\"\n    assert sample_data[\"age\"] == 30\n</code></pre> <p>Fixtures can be used to share setup and teardown code between tests.</p>"},{"location":"swarms/framework/test/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/framework/test/#running-tests-in-parallel","title":"Running Tests in Parallel","text":"<p><code>pytest</code> can run tests in parallel using the <code>pytest-xdist</code> plugin. To install <code>pytest-xdist</code>, run:</p> <pre><code>pip install pytest-xdist\n</code></pre> <p>To run tests in parallel, use the <code>-n</code> option followed by the number of CPU cores you want to use:</p> <pre><code>pytest -n 4\n</code></pre>"},{"location":"swarms/framework/test/#generating-test-reports","title":"Generating Test Reports","text":"<p><code>pytest</code> can generate detailed test reports. You can use the <code>--html</code> option to generate an HTML report:</p> <pre><code>pip install pytest-html\npytest --html=report.html\n</code></pre> <p>This command will generate a file named <code>report.html</code> with a detailed report of the test results.</p>"},{"location":"swarms/framework/test/#code-coverage","title":"Code Coverage","text":"<p>You can use the <code>pytest-cov</code> plugin to measure code coverage. To install <code>pytest-cov</code>, run:</p> <pre><code>pip install pytest-cov\n</code></pre> <p>To generate a coverage report, use the <code>--cov</code> option followed by the module name:</p> <pre><code>pytest --cov=my_module\n</code></pre> <p>This command will show the coverage summary in the terminal. You can also generate an HTML report:</p> <pre><code>pytest --cov=my_module --cov-report=html\n</code></pre> <p>The coverage report will be generated in the <code>htmlcov</code> directory.</p>"},{"location":"swarms/framework/test/#best-practices-for-writing-tests","title":"Best Practices for Writing Tests","text":"<ol> <li>Write Clear and Concise Tests: Each test should focus on a single piece of functionality.</li> <li>Use Descriptive Names: Test function names should clearly describe what they are testing.</li> <li>Keep Tests Independent: Tests should not depend on each other and should run in isolation.</li> <li>Use Fixtures: Use fixtures to set up the context for your tests.</li> <li>Mock External Dependencies: Use mocking to isolate the code under test from external dependencies.</li> </ol>"},{"location":"swarms/framework/test/#running-tests-reliably","title":"Running Tests Reliably","text":"<p>For contributors and team members, it\u2019s important to run tests reliably to ensure consistent results. Here are some guidelines:</p> <ol> <li> <p>Set Up a Virtual Environment: Use a virtual environment to manage dependencies and ensure a consistent testing environment.</p> <pre><code>python -m venv venv\nsource venv/bin/activate  # On Windows use `venv\\Scripts\\activate`\n</code></pre> </li> <li> <p>Install Dependencies: Install all required dependencies from the <code>requirements.txt</code> file.</p> <pre><code>pip install -r requirements.txt\n</code></pre> </li> <li> <p>Run Tests Before Pushing: Ensure all tests pass before pushing code to the repository.</p> </li> <li> <p>Use Continuous Integration (CI): Set up CI pipelines to automatically run tests on each commit or pull request.</p> </li> </ol>"},{"location":"swarms/framework/test/#example-ci-configuration-github-actions","title":"Example CI Configuration (GitHub Actions)","text":"<p>Here is an example of a GitHub Actions workflow to run tests using <code>pytest</code>:</p> <pre><code>name: Python package\n\non: [push, pull_request]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Install dependencies\n      run: |\n        python -m pip install --upgrade pip\n        pip install -r requirements.txt\n    - name: Run tests\n      run: |\n        pytest\n</code></pre> <p>This configuration will run the tests on every push and pull request, ensuring that your codebase remains stable.</p>"},{"location":"swarms/framework/test/#conclusion","title":"Conclusion","text":"<p><code>pytest</code> is a powerful and flexible testing framework that makes it easy to write and run tests for your Python code. By following the guidelines and best practices outlined in this blog, you can ensure that your tests are reliable and your codebase is robust. Whether you are testing a single file, multiple files, or the entire repository, <code>pytest</code> provides the tools you need to automate and streamline your testing process.</p> <p>Happy testing!</p>"},{"location":"swarms/framework/vision/","title":"Vision","text":""},{"location":"swarms/framework/vision/#swarms-vision","title":"Swarms Vision","text":"<p>Swarms is dedicated to transforming enterprise automation by offering a robust and intuitive interface for multi-agent collaboration and seamless integration with multiple models. Our mission is to enable enterprises to enhance their operational efficiency and effectiveness through intelligent automation.</p>"},{"location":"swarms/framework/vision/#vision-statement","title":"Vision Statement","text":"<p>To become the preeminent framework for orchestrating multi-agent collaboration and integration, empowering enterprises to achieve exceptional automation efficiency and operational excellence.</p>"},{"location":"swarms/framework/vision/#core-principles","title":"Core Principles","text":"<ol> <li>Multi-Agent Collaboration: Facilitate seamless collaboration between diverse agents to solve complex and dynamic problems.</li> <li>Integration: Provide robust and flexible integration with various models and frameworks to maximize functionality.</li> <li>Enterprise Automation: Deliver enterprise-grade solutions designed for reliability, scalability, and security.</li> <li>Open Ecosystem: Promote an open and extensible ecosystem that encourages innovation, community engagement, and collaborative development.</li> </ol>"},{"location":"swarms/framework/vision/#vision-document-with-mermaid-graphs","title":"Vision Document with Mermaid Graphs","text":""},{"location":"swarms/framework/vision/#overview-diagram","title":"Overview Diagram","text":"<pre><code>graph TD\n    A[Swarms Framework] --&gt; B[Multi-Agent Collaboration]\n    A --&gt; C[Integration with Multiple Models]\n    A --&gt; D[Enterprise Automation]\n    A --&gt; E[Open Ecosystem]\n\n    B --&gt; F[Seamless Communication]\n    B --&gt; G[Collaboration Protocols]\n\n    C --&gt; H[Model Integration]\n    C --&gt; I[Framework Compatibility]\n\n    D --&gt; J[Operational Efficiency]\n    D --&gt; K[Reliability and Scalability]\n\n    E --&gt; L[Encourage Innovation]\n    E --&gt; M[Community Driven]</code></pre>"},{"location":"swarms/framework/vision/#multi-agent-collaboration","title":"Multi-Agent Collaboration","text":"<pre><code>graph TD\n    B[Multi-Agent Collaboration] --&gt; F[Seamless Communication]\n    B --&gt; G[Collaboration Protocols]\n\n    F --&gt; N[Cross-Agent Messaging]\n    F --&gt; O[Task Coordination]\n    F --&gt; P[Real-Time Updates]\n\n    G --&gt; Q[Standard APIs]\n    G --&gt; R[Extensible Protocols]\n    G --&gt; S[Security and Compliance]\n\n    N --&gt; T[Agent Messaging Hub]\n    O --&gt; U[Task Assignment and Monitoring]\n    P --&gt; V[Instantaneous Data Sync]\n\n    Q --&gt; W[Unified API Interface]\n    R --&gt; X[Customizable Protocols]\n    S --&gt; Y[Compliance with Standards]\n    S --&gt; Z[Secure Communication Channels]</code></pre>"},{"location":"swarms/framework/vision/#integration-with-multiple-models","title":"Integration with Multiple Models","text":"<pre><code>graph TD\n    C[Integration with Multiple Models] --&gt; H[Model Integration]\n    C --&gt; I[Framework Compatibility]\n\n    H --&gt; R[Plug-and-Play Models]\n    H --&gt; S[Model Orchestration]\n    H --&gt; T[Model Versioning]\n\n    I --&gt; U[Support for OpenAI]\n    I --&gt; V[Support for Anthropic]\n    I --&gt; W[Support for Gemini]\n    I --&gt; X[Support for LangChain]\n    I --&gt; Y[Support for AutoGen]\n    I --&gt; Z[Support for Custom Models]\n\n    R --&gt; AA[Easy Model Integration]\n    S --&gt; AB[Dynamic Model Orchestration]\n    T --&gt; AC[Version Control]\n\n    U --&gt; AD[Integration with OpenAI Models]\n    V --&gt; AE[Integration with Anthropic Models]\n    W --&gt; AF[Integration with Gemini Models]\n    X --&gt; AG[Integration with LangChain Models]\n    Y --&gt; AH[Integration with AutoGen Models]\n    Z --&gt; AI[Support for Proprietary Models]</code></pre>"},{"location":"swarms/framework/vision/#enterprise-automation","title":"Enterprise Automation","text":"<pre><code>graph TD\n    D[Enterprise Automation] --&gt; J[Operational Efficiency]\n    D --&gt; K[Reliability and Scalability]\n\n    J --&gt; Y[Automate Workflows]\n    J --&gt; Z[Reduce Manual Work]\n    J --&gt; AA[Increase Productivity]\n\n    K --&gt; AB[High Uptime]\n    K --&gt; AC[Enterprise-Grade Security]\n    K --&gt; AD[Scalable Solutions]\n\n    Y --&gt; AE[Workflow Automation Tools]\n    Z --&gt; AF[Eliminate Redundant Tasks]\n    AA --&gt; AG[Boost Employee Efficiency]\n\n    AB --&gt; AH[Robust Infrastructure]\n    AC --&gt; AI[Security Compliance]\n    AD --&gt; AJ[Scale with Demand]</code></pre>"},{"location":"swarms/framework/vision/#open-ecosystem","title":"Open Ecosystem","text":"<pre><code>graph TD\n    E[Open Ecosystem] --&gt; L[Encourage Innovation]\n    E --&gt; M[Community Driven]\n\n    L --&gt; AC[Open Source Contributions]\n    L --&gt; AD[Hackathons and Workshops]\n    L --&gt; AE[Research and Development]\n\n    M --&gt; AF[Active Community Support]\n    M --&gt; AG[Collaborative Development]\n    M --&gt; AH[Shared Resources]\n\n    AC --&gt; AI[Community Contributions]\n    AD --&gt; AJ[Innovative Events]\n    AE --&gt; AK[Continuous R&amp;D]\n\n    AF --&gt; AL[Supportive Community]\n    AG --&gt; AM[Joint Development Projects]\n    AH --&gt; AN[Shared Knowledge Base]</code></pre>"},{"location":"swarms/framework/vision/#conclusion","title":"Conclusion","text":"<p>Swarms excels in enabling seamless communication and coordination between multiple agents, fostering a collaborative environment where agents can work together to solve complex tasks. Our platform supports cross-agent messaging, task coordination, and real-time updates, ensuring that all agents are synchronized and can efficiently contribute to the collective goal.</p> <p>Swarms provides robust integration capabilities with a wide array of models, including OpenAI, Anthropic, Gemini, LangChain, AutoGen, and custom models. This ensures that enterprises can leverage the best models available to meet their specific needs, while also allowing for dynamic model orchestration and version control to keep operations up-to-date and effective.</p> <p>Our framework is designed to enhance operational efficiency through automation. By automating workflows, reducing manual work, and increasing productivity, Swarms helps enterprises achieve higher efficiency and operational excellence. Our solutions are built for high uptime, enterprise-grade security, and scalability, ensuring reliable and secure operations.</p> <p>Swarms promotes an open and extensible ecosystem, encouraging community-driven innovation and development. We support open-source contributions, organize hackathons and workshops, and continuously invest in research and development. Our active community fosters collaborative development, shared resources, and a supportive environment for innovation.</p> <p>Swarms is dedicated to providing a comprehensive and powerful framework for enterprises seeking to automate operations through multi-agent collaboration and integration with various models. Our commitment to an open ecosystem, enterprise-grade automation solutions, and seamless multi-agent collaboration ensures that Swarms remains the leading choice for enterprises aiming to achieve operational excellence through intelligent automation.</p>"},{"location":"swarms/install/docker_setup/","title":"Docker Setup Guide for Contributors to Swarms","text":"<p>Welcome to the <code>swarms</code> project Docker setup guide. This document will help you establish a Docker-based environment for contributing to <code>swarms</code>. Docker provides a consistent and isolated environment, ensuring that all contributors can work in the same settings, reducing the \"it works on my machine\" syndrome.</p>"},{"location":"swarms/install/docker_setup/#purpose","title":"Purpose","text":"<p>The purpose of this guide is to:</p> <ul> <li>Ensure contributors can quickly set up their development environment.</li> <li>Provide a consistent testing and deployment workflow.</li> <li>Introduce Docker basics and best practices.</li> </ul>"},{"location":"swarms/install/docker_setup/#scope","title":"Scope","text":"<p>This guide covers:</p> <ul> <li>Installing Docker</li> <li>Cloning the <code>swarms</code> repository</li> <li>Building a Docker image</li> <li>Running the <code>swarms</code> application in a Docker container</li> <li>Running tests using Docker</li> <li>Pushing changes and working with Docker Hub</li> </ul>"},{"location":"swarms/install/docker_setup/#docker-installation","title":"Docker Installation","text":""},{"location":"swarms/install/docker_setup/#windows","title":"Windows","text":"<ol> <li>Download Docker Desktop for Windows from the official website.</li> <li>Install Docker Desktop, ensuring that the \"Use Windows containers instead of Linux containers\" option is unchecked.</li> <li>Start Docker Desktop and wait for the Docker engine to start.</li> </ol>"},{"location":"swarms/install/docker_setup/#macos","title":"macOS","text":"<ol> <li>Download Docker Desktop for macOS from the official website.</li> <li>Follow the installation instructions, drag-and-drop Docker into the Applications folder.</li> <li>Start Docker Desktop from the Applications folder.</li> </ol>"},{"location":"swarms/install/docker_setup/#linux-ubuntu","title":"Linux (Ubuntu)","text":"<ol> <li>Update your package index: <code>sudo apt-get update</code>.</li> <li>Install packages to allow apt to use a repository over HTTPS.</li> <li>Add Docker\u2019s official GPG key.</li> <li>Set up the stable repository.</li> <li>Install the latest version of Docker Engine and containerd.</li> </ol> <pre><code>sudo apt-get install docker-ce docker-ce-cli containerd.io\n</code></pre> <ol> <li>Verify that Docker Engine is installed correctly by running the hello-world image.</li> </ol> <pre><code>sudo docker run hello-world\n</code></pre>"},{"location":"swarms/install/docker_setup/#post-installation-steps-for-linux","title":"Post-installation Steps for Linux","text":"<ul> <li>Manage Docker as a non-root user.</li> <li>Configure Docker to start on boot.</li> </ul>"},{"location":"swarms/install/docker_setup/#cloning-the-repository","title":"Cloning the Repository","text":"<pre><code>git clone https://github.com/your-username/swarms.git\ncd swarms\n</code></pre>"},{"location":"swarms/install/docker_setup/#docker-basics","title":"Docker Basics","text":""},{"location":"swarms/install/docker_setup/#dockerfile-overview","title":"Dockerfile Overview","text":"<ul> <li>Explain the structure and commands of a Dockerfile used in the <code>swarms</code> project.</li> </ul>"},{"location":"swarms/install/docker_setup/#building-the-image","title":"Building the Image","text":"<pre><code>docker build -t swarms-dev .\n</code></pre>"},{"location":"swarms/install/docker_setup/#running-a-container","title":"Running a Container","text":"<pre><code>docker run -it --rm swarms-dev\n</code></pre>"},{"location":"swarms/install/docker_setup/#development-workflow-with-docker","title":"Development Workflow with Docker","text":""},{"location":"swarms/install/docker_setup/#running-the-application","title":"Running the Application","text":"<ul> <li>Commands to run the <code>swarms</code> application within Docker.</li> </ul>"},{"location":"swarms/install/docker_setup/#making-changes","title":"Making Changes","text":"<ul> <li>How to make changes to the code and reflect those changes within the Docker container.</li> </ul>"},{"location":"swarms/install/docker_setup/#running-tests","title":"Running Tests","text":"<ul> <li>Instructions on running tests using <code>pytest</code> within the Docker environment.</li> </ul>"},{"location":"swarms/install/docker_setup/#docker-compose-for-local-development","title":"Docker Compose for Local Development","text":"<ul> <li>Introduce Docker Compose and its role in simplifying multi-container setups.</li> <li>Create a <code>docker-compose.yml</code> file for the <code>swarms</code> project.</li> </ul>"},{"location":"swarms/install/docker_setup/#dockerfile","title":"Dockerfile","text":"<p>Creating a Dockerfile for deploying the <code>swarms</code> framework to the cloud involves setting up the necessary environment to run your Python application, ensuring all dependencies are installed, and configuring the container to execute the desired tasks. Here's an example Dockerfile that sets up such an environment:</p> <pre><code># Use an official Python runtime as a parent image\nFROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE 1\nENV PYTHONUNBUFFERED 1\n\n# Set the working directory in the container\nWORKDIR /usr/src/swarm_cloud\n\n# Install system dependencies\nRUN apt-get update \\\n    &amp;&amp; apt-get -y install gcc \\\n    &amp;&amp; apt-get clean\n\n# Install Python dependencies\n# COPY requirements.txt and pyproject.toml if you're using poetry for dependency management\nCOPY requirements.txt .\nRUN pip install --upgrade pip\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Install the 'swarms' package, assuming it's available on PyPI\nENV SWARM_API_KEY=your_swarm_api_key_here\nENV OPENAI_API_KEY=your_openai_key\nRUN pip install swarms\n\n# Copy the rest of the application\nCOPY . .\n\n# Add entrypoint script if needed\n# COPY ./entrypoint.sh .\n# RUN chmod +x /usr/src/swarm_cloud/entrypoint.sh\n\n# Expose port if your application has a web interface\n# EXPOSE 5000\n\n# Define environment variable for the swarm to work\n# Add Docker CMD or ENTRYPOINT script to run the application\n# CMD python your_swarm_startup_script.py\n# Or use the entrypoint script if you have one\n# ENTRYPOINT [\"/usr/src/swarm_cloud/entrypoint.sh\"]\n\n# If you're using `CMD` to execute a Python script, make sure it's executable\n# RUN chmod +x your_swarm_startup_script.py\n</code></pre> <p>To build and run this Docker image:</p> <ol> <li>Replace <code>requirements.txt</code> with your actual requirements file or <code>pyproject.toml</code> and <code>poetry.lock</code> if you're using Poetry.</li> <li>Replace <code>your_swarm_startup_script.py</code> with the script that starts your application.</li> <li>If your application requires an API key or other sensitive data, make sure to set these securely, perhaps using environment variables or secrets management solutions provided by your cloud provider.</li> <li>If you have an entrypoint script, uncomment the <code>COPY</code> and <code>RUN</code> lines for <code>entrypoint.sh</code>.</li> <li>If your application has a web interface, uncomment the <code>EXPOSE</code> line and set it to the correct port.</li> </ol> <p>Now, build your Docker image:</p> <pre><code>docker build -t swarm-cloud .\n</code></pre> <p>And run it:</p> <pre><code>docker run -d --name my-swarm-app swarm-cloud\n</code></pre> <p>For deploying to the cloud, you'll need to push your Docker image to a container registry (like Docker Hub or a private registry), then pull it from your cloud environment to run it. Cloud providers often have services specifically for this purpose (like AWS ECS, GCP GKE, or Azure AKS). The deployment process will involve:</p> <ul> <li>Pushing the image to a registry.</li> <li>Configuring cloud services to run your image.</li> <li>Setting up networking, storage, and other cloud resources.</li> <li>Monitoring, logging, and potentially scaling your containers.</li> </ul> <p>Remember to secure sensitive data, use tagged releases for your images, and follow best practices for operating in the cloud.</p>"},{"location":"swarms/install/env/","title":"Environment Variables","text":""},{"location":"swarms/install/env/#overview","title":"Overview","text":"<p>Swarms uses environment variables for configuration management and secure credential storage. This approach keeps sensitive information like API keys out of your code and allows for easy configuration changes across different environments.</p>"},{"location":"swarms/install/env/#core-environment-variables","title":"Core Environment Variables","text":""},{"location":"swarms/install/env/#framework-configuration","title":"Framework Configuration","text":"Configuration Variables Variable Description Example <code>SWARMS_VERBOSE_GLOBAL</code> Controls global logging verbosity <code>True</code> or <code>False</code> <code>WORKSPACE_DIR</code> Defines the workspace directory for agent operations <code>agent_workspace</code>"},{"location":"swarms/install/env/#llm-provider-api-keys","title":"LLM Provider API Keys","text":"OpenAIAnthropicGroqGoogleHugging FacePerplexity AIAI21CohereMistral AITogether AI <pre><code>OPENAI_API_KEY=\"your-openai-key\"\n</code></pre> <pre><code>ANTHROPIC_API_KEY=\"your-anthropic-key\"\n</code></pre> <pre><code>GROQ_API_KEY=\"your-groq-key\"\n</code></pre> <pre><code>GEMINI_API_KEY=\"your-gemini-key\"\n</code></pre> <pre><code>HUGGINGFACE_TOKEN=\"your-huggingface-token\"\n</code></pre> <pre><code>PPLX_API_KEY=\"your-perplexity-key\"\n</code></pre> <pre><code>AI21_API_KEY=\"your-ai21-key\"\n</code></pre> <pre><code>COHERE_API_KEY=\"your-cohere-key\"\n</code></pre> <pre><code>MISTRAL_API_KEY=\"your-mistral-key\"\n</code></pre> <pre><code>TOGETHER_API_KEY=\"your-together-key\"\n</code></pre>"},{"location":"swarms/install/env/#tool-provider-keys","title":"Tool Provider Keys","text":"Search ToolsAnalytics &amp; MonitoringBrowser Automation <pre><code>BING_BROWSER_API=\"your-bing-key\"\nBRAVESEARCH_API_KEY=\"your-brave-key\"\nTAVILY_API_KEY=\"your-tavily-key\"\nYOU_API_KEY=\"your-you-key\"\n</code></pre> <pre><code>EXA_API_KEY=\"your-exa-key\"\n</code></pre> <pre><code>MULTION_API_KEY=\"your-multion-key\"\n</code></pre>"},{"location":"swarms/install/env/#security-best-practices","title":"Security Best Practices","text":""},{"location":"swarms/install/env/#environment-file-management","title":"Environment File Management","text":"<ol> <li>Create a <code>.env</code> file in your project root</li> <li>Never commit <code>.env</code> files to version control</li> <li>Add <code>.env</code> to your <code>.gitignore</code>:     <pre><code>echo \".env\" &gt;&gt; .gitignore\n</code></pre></li> </ol>"},{"location":"swarms/install/env/#api-key-security","title":"API Key Security","text":"<p>Important Security Considerations</p> <ul> <li>Rotate API keys regularly</li> <li>Use different API keys for development and production</li> <li>Never hardcode API keys in your code</li> <li>Limit API key permissions to only what's necessary</li> <li>Monitor API key usage for unusual patterns</li> </ul>"},{"location":"swarms/install/env/#template-configuration","title":"Template Configuration","text":"<p>Create a <code>.env.example</code> template without actual values:</p> <pre><code># Required Configuration\nOPENAI_API_KEY=\"\"\nANTHROPIC_API_KEY=\"\"\nGROQ_API_KEY=\"\"\nWORKSPACE_DIR=\"agent_workspace\"\n\n# Optional Configuration\nSWARMS_VERBOSE_GLOBAL=\"False\"\n</code></pre>"},{"location":"swarms/install/env/#loading-environment-variables","title":"Loading Environment Variables","text":"<pre><code>from dotenv import load_dotenv\nimport os\n\n# Load environment variables\nload_dotenv()\n\n# Access variables\nworkspace_dir = os.getenv(\"WORKSPACE_DIR\")\nopenai_key = os.getenv(\"OPENAI_API_KEY\")\n</code></pre>"},{"location":"swarms/install/env/#environment-setup-guide","title":"Environment Setup Guide","text":"1. Install Dependencies2. Create Environment File3. Configure Variables4. Verify Setup <pre><code>pip install python-dotenv\n</code></pre> <pre><code>cp .env.example .env\n</code></pre> <ul> <li>Open <code>.env</code> in your text editor</li> <li>Add your API keys and configuration</li> <li>Save the file</li> </ul> <pre><code>import os\nfrom dotenv import load_dotenv\n\nload_dotenv()\nassert os.getenv(\"OPENAI_API_KEY\") is not None, \"OpenAI API key not found\"\n</code></pre>"},{"location":"swarms/install/env/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"DevelopmentProductionTesting <pre><code>WORKSPACE_DIR=\"agent_workspace\"\nSWARMS_VERBOSE_GLOBAL=\"True\"\n</code></pre> <pre><code>WORKSPACE_DIR=\"/var/swarms/workspace\"\nSWARMS_VERBOSE_GLOBAL=\"False\"\n</code></pre> <pre><code>WORKSPACE_DIR=\"test_workspace\"\nSWARMS_VERBOSE_GLOBAL=\"True\"\n</code></pre>"},{"location":"swarms/install/env/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms/install/env/#common-issues","title":"Common Issues","text":"Environment Variables Not Loading <ul> <li>Verify <code>.env</code> file exists in project root</li> <li>Confirm <code>load_dotenv()</code> is called before accessing variables</li> <li>Check file permissions</li> </ul> API Key Issues <ul> <li>Verify key format is correct</li> <li>Ensure key has not expired</li> <li>Check for leading/trailing whitespace</li> </ul> Workspace Directory Problems <ul> <li>Confirm directory exists</li> <li>Verify write permissions</li> <li>Check path is absolute when required</li> </ul>"},{"location":"swarms/install/install/","title":"Swarms Installation Guide","text":"<p>You can install <code>swarms</code> with pip in a Python&gt;=3.10 environment.</p>"},{"location":"swarms/install/install/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure you have the following installed:</p> <ul> <li>Python 3.10 or higher: Download Python</li> <li>pip (specific version recommended): <code>pip &gt;= 21.0</code></li> <li>git (for cloning the repository): Download Git</li> </ul>"},{"location":"swarms/install/install/#installation-options","title":"Installation Options","text":"pip (Recommended)UV InstallationDevelopment InstallationUsing DockerUsing KubernetesCI/CD Pipelines <p>UV is a fast Python package installer and resolver written in Rust. It's significantly faster than pip and provides better dependency resolution.</p> Basic InstallationDevelopment Installation <pre><code># Install UV first\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Install swarms using UV\nuv pip install swarms\n</code></pre> <pre><code># Clone the repository\ngit clone https://github.com/kyegomez/swarms.git\ncd swarms\n\n# Install in editable mode\nuv pip install -e .\n</code></pre> <p>For desktop installation with extras:</p> <pre><code>uv pip install -e .[desktop]\n</code></pre> Using virtualenvUsing AnacondaUsing Poetry <ol> <li> <p>Clone the repository and navigate to the root directory:</p> <pre><code>git clone https://github.com/kyegomez/swarms.git\ncd swarms\n</code></pre> </li> <li> <p>Setup Python environment and activate it:</p> <pre><code>python3 -m venv venv\nsource venv/bin/activate\npip install --upgrade pip\n</code></pre> </li> <li> <p>Install Swarms:</p> <ul> <li> <p>Headless install:</p> <pre><code>pip install -e .\n</code></pre> </li> <li> <p>Desktop install:</p> <pre><code>pip install -e .[desktop]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p>Create and activate an Anaconda environment:</p> <pre><code>conda create -n swarms python=3.10\nconda activate swarms\n</code></pre> </li> <li> <p>Clone the repository and navigate to the root directory:</p> <pre><code>git clone https://github.com/kyegomez/swarms.git\ncd swarms\n</code></pre> </li> <li> <p>Install Swarms:</p> <ul> <li> <p>Headless install:</p> <pre><code>pip install -e .\n</code></pre> </li> <li> <p>Desktop install:</p> <pre><code>pip install -e .[desktop]\n</code></pre> </li> </ul> </li> </ol> <ol> <li> <p>Clone the repository and navigate to the root directory:</p> <pre><code>git clone https://github.com/kyegomez/swarms.git\ncd swarms\n</code></pre> </li> <li> <p>Setup Python environment and activate it:</p> <pre><code>poetry env use python3.10\npoetry shell\n</code></pre> </li> <li> <p>Install Swarms:</p> <ul> <li> <p>Headless install:</p> <pre><code>poetry install\n</code></pre> </li> <li> <p>Desktop install:</p> <pre><code>poetry install --extras \"desktop\"\n</code></pre> </li> </ul> </li> </ol> <p>Docker is an excellent option for creating isolated and reproducible environments, suitable for both development and production. Contact us if there are any issues with the docker setup</p> <ol> <li> <p>Pull the Docker image:</p> <pre><code>docker pull swarmscorp/swarms:tagname\n</code></pre> </li> <li> <p>Run the Docker container:</p> <pre><code>docker run -it --rm swarmscorp/swarms:tagname\n</code></pre> </li> <li> <p>Build and run a custom Docker image:</p> <pre><code># Use Python 3.11 instead of 3.13\nFROM python:3.11-slim\n\n# Set environment variables\nENV PYTHONDONTWRITEBYTECODE=1 \\\n    PYTHONUNBUFFERED=1 \\\n    WORKSPACE_DIR=\"agent_workspace\" \\\n    OPENAI_API_KEY=\"your_swarm_api_key_here\"\n\n# Set the working directory\nWORKDIR /usr/src/swarms\n\n# Install system dependencies\nRUN apt-get update &amp;&amp; apt-get install -y \\\n    build-essential \\\n    gcc \\\n    g++ \\\n    gfortran \\\n    &amp;&amp; rm -rf /var/lib/apt/lists/*\n\n# Install swarms package\nRUN pip3 install -U swarm-models\nRUN pip3 install -U swarms\n\n# Copy the application\nCOPY . .\n</code></pre> </li> </ol> <p>Kubernetes provides an automated way to deploy, scale, and manage containerized applications.</p> <ol> <li> <p>Create a Deployment YAML file:</p> <pre><code>apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: swarms-deployment\nspec:\n  replicas: 3\n  selector:\n    matchLabels:\n      app: swarms\n  template:\n    metadata:\n      labels:\n        app: swarms\n    spec:\n      containers:\n      - name: swarms\n        image: kyegomez/swarms\n        ports:\n        - containerPort: 8080\n</code></pre> </li> <li> <p>Apply the Deployment:</p> <pre><code>kubectl apply -f deployment.yaml\n</code></pre> </li> <li> <p>Expose the Deployment:</p> <pre><code>kubectl expose deployment swarms-deployment --type=LoadBalancer --name=swarms-service\n</code></pre> </li> </ol> <p>Integrating Swarms into your CI/CD pipeline ensures automated testing and deployment.</p>"},{"location":"swarms/install/install/#headless-installation","title":"Headless Installation","text":"<p>The headless installation of <code>swarms</code> is designed for environments where graphical user interfaces (GUI) are not needed, making it more lightweight and suitable for server-side applications.</p> <pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/install/install/#using-github-actions","title":"Using GitHub Actions","text":"<pre><code># .github/workflows/ci.yml\nname: CI\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  build:\n\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.10\n    - name: Install dependencies\n      run: |\n        python -m venv venv\n        source venv/bin/activate\n        pip install --upgrade pip\n        pip install -e .\n    - name: Run tests\n      run: |\n        source venv/bin/activate\n        pytest\n</code></pre>"},{"location":"swarms/install/install/#using-jenkins","title":"Using Jenkins","text":"<pre><code>pipeline {\n    agent any\n\n    stages {\n        stage('Clone repository') {\n            steps {\n                git 'https://github.com/kyegomez/swarms.git'\n            }\n        }\n        stage('Setup Python') {\n            steps {\n                sh 'python3 -m venv venv'\n                sh 'source venv/bin/activate &amp;&amp; pip install --upgrade pip'\n            }\n        }\n        stage('Install dependencies') {\n            steps {\n                sh 'source venv/bin/activate &amp;&amp; pip install -e .'\n            }\n        }\n        stage('Run tests') {\n            steps {\n                sh 'source venv/bin/activate &amp;&amp; pytest'\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"swarms/install/install/#rust","title":"Rust","text":"Cargo install <p>Get started with the Rust implementation of Swarms. Get started with the docs here</p> <pre><code>cargo add swarms-rs\n</code></pre>"},{"location":"swarms/install/quickstart/","title":"Quickstart","text":""},{"location":"swarms/install/quickstart/#quickstart","title":"Quickstart","text":"<p>Swarms is an enterprise-grade, production-ready multi-agent collaboration framework that enables you to orchestrate agents to work collaboratively at scale to automate real-world activities. Follow this quickstart guide to get up and running with Swarms, including setting up your environment, building an agent, and leveraging multi-agent methods.</p>"},{"location":"swarms/install/quickstart/#requirements","title":"Requirements","text":"<ul> <li>Python 3.10 or above</li> <li><code>.env</code> file with API keys from your providers like <code>OPENAI_API_KEY</code>, <code>ANTHROPIC_API_KEY</code></li> <li>Set an environment variable for your workspace directory:   <pre><code>WORKSPACE_DIR=\"agent_workspace\"\n</code></pre></li> </ul>"},{"location":"swarms/install/quickstart/#installation","title":"Installation","text":"<p>To install Swarms, run: <pre><code>$ pip install -U swarms\n</code></pre></p>"},{"location":"swarms/install/quickstart/#usage-example-single-agent","title":"Usage Example: Single Agent","text":"<p>Here's a simple example of creating a financial analysis agent powered by OpenAI's GPT-4o-mini model. This agent will analyze financial queries like how to set up a ROTH IRA.</p> <pre><code>from swarms.structs.agent import Agent\n\n# Initialize the agent with GPT-4o-mini model\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"Analyze financial situations and provide advice...\",\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    saved_state_path=\"finance_agent.json\",\n    model_name=\"gpt-4o-mini\",\n)\n\n# Run your query\nout = agent.run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\"\n)\nprint(out)\n</code></pre>"},{"location":"swarms/install/quickstart/#agent-class","title":"Agent Class","text":"<ul> <li>Attributes:</li> <li><code>agent_name</code>: Name of the agent.</li> <li><code>system_prompt</code>: System-level instruction guiding the agent's behavior.</li> <li><code>model_name</code>: Name of the model to use (e.g., \"gpt-4o-mini\").</li> <li><code>max_loops</code>: Max iterations for a task.</li> <li> <p><code>autosave</code>: Auto-saves the state after each iteration.</p> </li> <li> <p>Methods:</p> </li> <li><code>run(task: str)</code>: Executes the agent's task.</li> <li><code>ingest_docs(doc_path: str)</code>: Ingests documents into the agent's knowledge base.</li> <li><code>filtered_run(task: str)</code>: Runs agent with a filtered system prompt.</li> </ul>"},{"location":"swarms/install/quickstart/#creating-agents-from-yaml","title":"Creating Agents from YAML","text":""},{"location":"swarms/install/quickstart/#step-1-define-your-agents-in-a-yaml-file","title":"Step 1: Define Your Agents in a YAML File","text":"<p>The <code>create_agents_from_yaml</code> function works by reading agent configurations from a YAML file. Below is an example of what your YAML file (<code>agents_config.yaml</code>) should look like this. Example YAML Configuration (<code>agents_config.yaml</code>):</p> <pre><code>agents:\n  - agent_name: \"Financial-Analysis-Agent\"\n    system_prompt: \"You are a financial analysis expert. Analyze market trends and provide investment recommendations.\"\n    model_name: \"claude-3-opus-20240229\"\n    max_loops: 1\n    autosave: false\n    dashboard: false\n    verbose: false\n    dynamic_temperature_enabled: false\n    user_name: \"swarms_corp\"\n    retry_attempts: 1\n    context_length: 200000\n    return_step_meta: false\n    output_type: \"str\"\n    temperature: 0.1\n    max_tokens: 2000\n    task: \"Analyze tech stocks for 2024 investment strategy. Provide detailed analysis and recommendations.\"\n\n  - agent_name: \"Risk-Analysis-Agent\"\n    system_prompt: \"You are a risk analysis expert. Evaluate investment risks and provide mitigation strategies.\"\n    model_name: \"claude-3-opus-20240229\"\n    max_loops: 1\n    autosave: false\n    dashboard: false\n    verbose: false\n    dynamic_temperature_enabled: false\n    user_name: \"swarms_corp\"\n    retry_attempts: 1\n    context_length: 150000\n    return_step_meta: false\n    output_type: \"str\"\n    temperature: 0.1\n    max_tokens: 2000\n    task: \"Conduct a comprehensive risk analysis of the top 5 tech companies in 2024. Include risk factors and mitigation strategies.\"\n\nswarm_architecture:\n  name: \"Financial Analysis Swarm\"\n  description: \"A swarm for comprehensive financial and risk analysis\"\n  max_loops: 1\n  swarm_type: \"SequentialWorkflow\"\n  task: \"Analyze tech stocks and their associated risks for 2024 investment strategy\"\n  autosave: false\n  return_json: true\n</code></pre>"},{"location":"swarms/install/quickstart/#key-configuration-fields","title":"Key Configuration Fields:","text":"<ul> <li>agent_name: Name of the agent.</li> <li>system_prompt: The system prompt used to guide the agent's behavior.</li> <li>model_name: The language model to use (e.g., claude-3-opus-20240229).</li> <li>task: Task for the agent to execute.</li> <li>swarm_architecture: (Optional) Configuration for swarm behavior.</li> </ul>"},{"location":"swarms/install/quickstart/#step-2-create-the-main-script","title":"Step 2: Create the Main Script","text":"<p>Now, create the main Python script that will use the <code>create_agents_from_yaml</code> function.</p>"},{"location":"swarms/install/quickstart/#mainpy","title":"<code>main.py</code>:","text":"<pre><code>from swarms.agents.create_agents_from_yaml import create_agents_from_yaml\n\n# Create agents and get task results\ntask_results = create_agents_from_yaml(\n    yaml_file=\"agents_config.yaml\",\n    return_type=\"run_swarm\"\n)\n\nprint(task_results)\n</code></pre>"},{"location":"swarms/install/quickstart/#example-run","title":"Example Run:","text":"<pre><code>python main.py\n</code></pre> <p>This will: 1. Load agent configurations from <code>agents_config.yaml</code>. 2. Create the agents specified in the YAML file. 3. Run the tasks provided for each agent. 4. Output the task results to the console.</p>"},{"location":"swarms/install/quickstart/#step-3-customize-the-return-type","title":"Step 3: Customize the Return Type","text":"<p>The <code>create_agents_from_yaml</code> function supports multiple return types. You can control what is returned by setting the <code>return_type</code> parameter to <code>\"agents\"</code>, <code>\"tasks\"</code>, or <code>\"both\"</code>.</p> <ol> <li>Return Only Agents To create agents but not run tasks, set <code>return_type=\"agents\"</code>:</li> </ol> <pre><code>agents = create_agents_from_yaml(yaml_file, return_type=\"agents\")\nfor agent in agents:\n    print(f\"Agent {agent.agent_name} created.\")\n</code></pre> <ol> <li>Return Only Task Results If you only care about the task results and not the agent objects, set <code>return_type=\"tasks\"</code>:</li> </ol> <pre><code>task_results = create_agents_from_yaml(yaml_file, return_type=\"tasks\")\nfor result in task_results:\n    print(f\"Agent {result['agent_name']} executed task '{result['task']}' with output: {result['output']}\")\n</code></pre> <ol> <li>Return Both Agents and Task Results To return both the list of created agents and task results, use <code>return_type=\"both\"</code>:</li> </ol> <pre><code>agents, task_results = create_agents_from_yaml(yaml_file, return_type=\"both\")\n# Process agents and tasks separately\n</code></pre>"},{"location":"swarms/install/quickstart/#step-4-yaml-structure-for-multiple-agents","title":"Step 4: YAML Structure for Multiple Agents","text":"<p>The YAML file can define any number of agents, each with its own unique configuration. You can scale this setup by adding more agents and tasks to the <code>agents</code> list within the YAML file.</p> <pre><code>agents:\n  - agent_name: \"Agent1\"\n    # Agent1 config...\n\n  - agent_name: \"Agent2\"\n    # Agent2 config...\n\n  - agent_name: \"Agent3\"\n    # Agent3 config...\n</code></pre> <p>Each agent will be initialized according to its configuration, and tasks (if provided) will be executed automatically.</p>"},{"location":"swarms/install/quickstart/#integrating-external-agents","title":"Integrating External Agents","text":"<p>Integrating external agents from other agent frameworks is easy with swarms.</p> <p>Steps:</p> <ol> <li>Create a new class that inherits <code>Agent</code></li> <li>Create a <code>.run(task: str) -&gt; str</code> method that runs the agent and returns the response. </li> <li>The new Agent must return a string of the response. But you may add additional methods to save the output to JSON.</li> </ol>"},{"location":"swarms/install/quickstart/#griptape-example","title":"Griptape Example","text":"<p>For example, here's an example on how to create an agent from griptape.</p> <p>Here's how you can create a custom Griptape agent that integrates with the Swarms framework by inheriting from the <code>Agent</code> class in Swarms and overriding the <code>run(task: str) -&gt; str</code> method.</p> <pre><code>from swarms import (\n    Agent as SwarmsAgent,\n)  # Import the base Agent class from Swarms\nfrom griptape.structures import Agent as GriptapeAgent\nfrom griptape.tools import (\n    WebScraperTool,\n    FileManagerTool,\n    PromptSummaryTool,\n)\n\n\n# Create a custom agent class that inherits from SwarmsAgent\nclass GriptapeSwarmsAgent(SwarmsAgent):\n    def __init__(self, *args, **kwargs):\n        # Initialize the Griptape agent with its tools\n        self.agent = GriptapeAgent(\n            input=\"Load {{ args[0] }}, summarize it, and store it in a file called {{ args[1] }}.\",\n            tools=[\n                WebScraperTool(off_prompt=True),\n                PromptSummaryTool(off_prompt=True),\n                FileManagerTool(),\n            ],\n            *args,\n            **kwargs,\n            # Add additional settings\n        )\n\n    # Override the run method to take a task and execute it using the Griptape agent\n    def run(self, task: str) -&gt; str:\n        # Extract URL and filename from task (you can modify this parsing based on task structure)\n        url, filename = task.split(\n            \",\"\n        )  # Example of splitting task string\n        # Execute the Griptape agent with the task inputs\n        result = self.agent.run(url.strip(), filename.strip())\n        # Return the final result as a string\n        return str(result)\n\n\n# Example usage:\ngriptape_swarms_agent = GriptapeSwarmsAgent()\noutput = griptape_swarms_agent.run(\n    \"https://griptape.ai, griptape.txt\"\n)\nprint(output)\n</code></pre>"},{"location":"swarms/install/quickstart/#key-components","title":"Key Components:","text":"<ol> <li>GriptapeSwarmsAgent: A custom class that inherits from the <code>SwarmsAgent</code> class and integrates the Griptape agent.</li> <li>run(task: str) -&gt; str: A method that takes a task string, processes it (e.g., splitting into a URL and filename), and runs the Griptape agent with the provided inputs.</li> <li>Griptape Tools: The tools integrated into the Griptape agent (e.g., <code>WebScraperTool</code>, <code>PromptSummaryTool</code>, <code>FileManagerTool</code>) allow for web scraping, summarization, and file management.</li> </ol> <p>You can now easily plug this custom Griptape agent into the Swarms Framework and use it to run tasks!</p>"},{"location":"swarms/install/quickstart/#overview-of-swarm-architectures-in-the-swarms-framework","title":"Overview of Swarm Architectures in the Swarms Framework","text":""},{"location":"swarms/install/quickstart/#1-sequential-workflow","title":"1. Sequential Workflow","text":"<p>Overview: The <code>SequentialWorkflow</code> enables tasks to be executed one after the other. Each agent processes its task and passes the output to the next agent in the sequence.</p>"},{"location":"swarms/install/quickstart/#mermaid-graph","title":"Mermaid Graph:","text":"<pre><code>graph TD;\n    A[Task Input] --&gt; B[Blog Generator Agent];\n    B --&gt; C[Summarizer Agent];\n    C --&gt; D[Task Output];</code></pre>"},{"location":"swarms/install/quickstart/#code-example","title":"Code Example:","text":"<pre><code>from swarms import Agent, SequentialWorkflow\n\n# Initialize agents without importing a specific LLM class\nagent1 = Agent(\n    agent_name=\"Blog generator\",\n    system_prompt=\"Generate a blog post\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1\n)\nagent2 = Agent(\n    agent_name=\"Summarizer\",\n    system_prompt=\"Summarize the blog post\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1\n)\n\n# Create Sequential workflow\nworkflow = SequentialWorkflow(agents=[agent1, agent2], max_loops=1)\n\n# Run workflow\noutput = workflow.run(\"Generate a blog post on how swarms of agents can help businesses grow.\")\nprint(output)\n</code></pre>"},{"location":"swarms/install/quickstart/#2-agent-rearrange","title":"2. Agent Rearrange","text":"<p>Overview: <code>AgentRearrange</code> allows the orchestration of agents in both sequential and parallel configurations. The user can define a flexible flow of tasks between agents.</p>"},{"location":"swarms/install/quickstart/#mermaid-graph_1","title":"Mermaid Graph:","text":"<pre><code>graph TD;\n    A[Director Agent] --&gt; B[Worker 1 Agent];\n    A --&gt; C[Worker 2 Agent];\n    B --&gt; D[Task Completed];\n    C --&gt; D[Task Completed];</code></pre>"},{"location":"swarms/install/quickstart/#code-example_1","title":"Code Example:","text":"<pre><code>from swarms import Agent, AgentRearrange\n\n# Initialize agents using model_name (no explicit LLM import)\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs tasks\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1\n)\nworker1 = Agent(\n    agent_name=\"Worker1\",\n    system_prompt=\"Generate a transcript\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1\n)\nworker2 = Agent(\n    agent_name=\"Worker2\",\n    system_prompt=\"Summarize the transcript\",\n    model_name=\"claude-3-sonnet-20240229\",\n    max_loops=1\n)\n\n# Define the flow and create the rearranged system\nflow = \"Director -&gt; Worker1 -&gt; Worker2\"\nagent_system = AgentRearrange(agents=[director, worker1, worker2], flow=flow)\n\n# Run it\noutput = agent_system.run(\"Create a YouTube transcript and summary\")\nprint(output)\n</code></pre>"},{"location":"swarms/install/quickstart/#4-mixture-of-agents","title":"4. Mixture of Agents","text":"<p>Overview: <code>MixtureOfAgents</code> is a parallelized architecture where agents perform tasks concurrently and then feed their results back into a loop for final aggregation. This is useful for highly parallelizable tasks.</p>"},{"location":"swarms/install/quickstart/#mermaid-graph_2","title":"Mermaid Graph:","text":"<pre><code>graph TD;\n    A[Director Agent] --&gt; B[Accountant 1];\n    A --&gt; C[Accountant 2];\n    B --&gt; D[Final Aggregation];\n    C --&gt; D[Final Aggregation];</code></pre>"},{"location":"swarms/install/quickstart/#code-example_2","title":"Code Example:","text":"<pre><code>from swarms import Agent, OpenAIChat, MixtureOfAgents\n\n# Initialize agents\ndirector = Agent(agent_name=\"Director\", system_prompt=\"Directs tasks\", llm=OpenAIChat(), max_loops=1)\naccountant1 = Agent(agent_name=\"Accountant1\", system_prompt=\"Prepare financial statements\", llm=OpenAIChat(), max_loops=1)\naccountant2 = Agent(agent_name=\"Accountant2\", system_prompt=\"Audit financial records\", llm=OpenAIChat(), max_loops=1)\n\n# Create Mixture of Agents swarm\nswarm = MixtureOfAgents(name=\"Mixture of Accountants\", agents=[director, accountant1, accountant2], layers=3, final_agent=director)\n\n# Run the swarm\noutput = swarm.run(\"Prepare financial statements and audit financial records\")\nprint(output)\n</code></pre>"},{"location":"swarms/install/quickstart/#5-spreadsheet-swarm","title":"5. Spreadsheet Swarm","text":"<p>Overview: <code>SpreadSheetSwarm</code> enables the management of thousands of agents simultaneously, where each agent operates on its own thread. It's ideal for overseeing large-scale agent outputs.</p>"},{"location":"swarms/install/quickstart/#mermaid-graph_3","title":"Mermaid Graph:","text":"<pre><code>graph TD;\n    A[Spreadsheet Swarm] --&gt; B[Twitter Agent];\n    A --&gt; C[Instagram Agent];\n    A --&gt; D[Facebook Agent];\n    A --&gt; E[LinkedIn Agent];\n    A --&gt; F[Email Agent];</code></pre>"},{"location":"swarms/install/quickstart/#code-example_3","title":"Code Example:","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.spreadsheet_swarm import SpreadSheetSwarm\n\n# Initialize agents for different marketing platforms using model_name\nagents = [\n    Agent(\n        agent_name=\"Twitter Agent\",\n        system_prompt=\"Create a tweet\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    ),\n    Agent(\n        agent_name=\"Instagram Agent\",\n        system_prompt=\"Create an Instagram post\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    ),\n    Agent(\n        agent_name=\"Facebook Agent\",\n        system_prompt=\"Create a Facebook post\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    ),\n    Agent(\n        agent_name=\"LinkedIn Agent\",\n        system_prompt=\"Create a LinkedIn post\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    ),\n    Agent(\n        agent_name=\"Email Agent\",\n        system_prompt=\"Write a marketing email\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    ),\n]\n\n# Create the Spreadsheet Swarm\nswarm = SpreadSheetSwarm(\n    agents=agents,\n    save_file_path=\"real_estate_marketing_spreadsheet.csv\",\n    run_all_agents=False,\n    max_loops=2\n)\n\n# Run the swarm\nswarm.run(\"Create posts to promote luxury properties in North Texas.\")\n</code></pre> <p>These are the key swarm architectures available in the Swarms Framework. Each one is designed to solve different types of multi-agent orchestration problems, from sequential tasks to large-scale parallel processing.</p>"},{"location":"swarms/install/quickstart/#overview-of-swarm-architectures","title":"Overview of Swarm Architectures","text":""},{"location":"swarms/install/quickstart/#workflow-classes","title":"Workflow Classes","text":"<ul> <li>SequentialWorkflow:</li> <li> <p>Chains agents, where one agent's output becomes the next agent's input.</p> </li> <li> <p>AgentRearrange:</p> </li> <li>Dynamically rearranges agent tasks either in parallel or sequentially based on defined flow.</li> </ul>"},{"location":"swarms/install/quickstart/#swarm-architectures","title":"Swarm Architectures","text":"<ul> <li>Hierarchical Swarms:</li> <li> <p>Implements top-down control, where a boss agent coordinates tasks among sub-agents.</p> </li> <li> <p>Spreadsheet Swarm:</p> </li> <li>A large-scale swarm architecture for managing multiple agents working concurrently.</li> </ul>"},{"location":"swarms/install/workspace_manager/","title":"Swarms Framework Environment Configuration","text":"<p>This guide details the environment variables used in the Swarms framework for configuration and customization of your agent-based applications.</p>"},{"location":"swarms/install/workspace_manager/#configuration-setup","title":"Configuration Setup","text":"<p>Create a <code>.env</code> file in your project's root directory to configure the Swarms framework. This file will contain all necessary environment variables for customizing your agent's behavior, logging, and analytics.</p>"},{"location":"swarms/install/workspace_manager/#environment-variables","title":"Environment Variables","text":""},{"location":"swarms/install/workspace_manager/#core-variables","title":"Core Variables","text":""},{"location":"swarms/install/workspace_manager/#workspace_dir","title":"<code>WORKSPACE_DIR</code>","text":"<ul> <li>Purpose: Defines the directory where all agent states and execution logs are stored</li> <li>Type: String (path)</li> <li>Default: <code>./workspace</code></li> <li>Example:  <pre><code>WORKSPACE_DIR=/path/to/your/workspace\n</code></pre></li> <li>Usage:</li> <li>Stores JSON files containing agent states</li> <li>Maintains execution history</li> <li>Keeps track of agent interactions</li> <li>Preserves conversation logs</li> </ul>"},{"location":"swarms/install/workspace_manager/#swarms_autoupdate_on","title":"<code>SWARMS_AUTOUPDATE_ON</code>","text":"<ul> <li>Purpose: Controls automatic updates of the Swarms framework</li> <li>Type: Boolean</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>SWARMS_AUTOUPDATE_ON=true\n</code></pre></li> <li>Features:</li> <li>Automatically updates to the latest stable version</li> <li>Ensures you have the newest features</li> <li>Maintains compatibility with the latest improvements</li> <li>Handles dependency updates</li> <li>Considerations:</li> <li>Set to <code>false</code> if you need version stability</li> <li>Recommended <code>true</code> for development environments</li> <li>Consider system requirements for auto-updates</li> <li>May require restart after updates</li> </ul>"},{"location":"swarms/install/workspace_manager/#telemetry-configuration","title":"Telemetry Configuration","text":""},{"location":"swarms/install/workspace_manager/#use_telemetry","title":"<code>USE_TELEMETRY</code>","text":"<ul> <li>Purpose: Controls whether telemetry data is collected</li> <li>Type: Boolean</li> <li>Default: <code>false</code></li> <li>Example: <pre><code>USE_TELEMETRY=true\n</code></pre></li> <li>Data Collected:</li> <li>Agent performance metrics</li> <li>Execution time statistics</li> <li>Memory usage</li> <li>Error rates</li> <li>System health indicators</li> </ul>"},{"location":"swarms/install/workspace_manager/#analytics-integration","title":"Analytics Integration","text":""},{"location":"swarms/install/workspace_manager/#swarms_api_key","title":"<code>SWARMS_API_KEY</code>","text":"<ul> <li>Purpose: Authentication key for the Swarms Analytics Suite</li> <li>Type: String</li> <li>Required: Yes, for analytics features</li> <li>Example: <pre><code>SWARMS_API_KEY=your_api_key_here\n</code></pre></li> <li>Features:</li> <li>Real-time agent execution tracking</li> <li>Usage analytics</li> <li>Performance monitoring</li> <li>Cost tracking</li> <li>Custom metrics</li> </ul>"},{"location":"swarms/install/workspace_manager/#getting-started","title":"Getting Started","text":"<ol> <li> <p>Create a new <code>.env</code> file: <pre><code>touch .env\n</code></pre></p> </li> <li> <p>Add your configuration: <pre><code># Basic configuration\nWORKSPACE_DIR=./my_workspace\n\n# Enable auto-updates\nSWARMS_AUTOUPDATE_ON=true\n\n# Enable telemetry\nUSE_TELEMETRY=true\n\n# Add your Swarms API key\nSWARMS_API_KEY=your_api_key_here\n</code></pre></p> </li> <li> <p>Obtain your API key:</p> </li> <li>Visit swarms.ai</li> <li>Create an account or log in</li> <li>Navigate to the API section</li> <li>Generate your unique API key</li> </ol>"},{"location":"swarms/install/workspace_manager/#best-practices","title":"Best Practices","text":"<ol> <li>Security:</li> <li>Never commit your <code>.env</code> file to version control</li> <li>Add <code>.env</code> to your <code>.gitignore</code> file</li> <li> <p>Keep your API keys secure and rotate them periodically</p> </li> <li> <p>Workspace Organization:</p> </li> <li>Use descriptive workspace directory names</li> <li>Implement regular cleanup of old logs</li> <li> <p>Monitor workspace size to prevent disk space issues</p> </li> <li> <p>Telemetry Management:</p> </li> <li>Enable telemetry in development for debugging</li> <li>Consider privacy implications in production</li> <li> <p>Review collected data periodically</p> </li> <li> <p>Auto-Update Management:</p> </li> <li>Test updates in development before enabling in production</li> <li>Keep backups before enabling auto-updates</li> <li>Monitor system resources during updates</li> <li>Schedule updates during low-traffic periods</li> </ol>"},{"location":"swarms/install/workspace_manager/#examples","title":"Examples","text":""},{"location":"swarms/install/workspace_manager/#basic-development-setup","title":"Basic Development Setup","text":"<pre><code>WORKSPACE_DIR=./dev_workspace\nSWARMS_AUTOUPDATE_ON=true\nUSE_TELEMETRY=true\nSWARMS_API_KEY=sk_test_xxxxxxxxxxxx\n</code></pre>"},{"location":"swarms/install/workspace_manager/#production-setup","title":"Production Setup","text":"<pre><code>WORKSPACE_DIR=/var/log/swarms/prod_workspace\nSWARMS_AUTOUPDATE_ON=false\nUSE_TELEMETRY=true\nSWARMS_API_KEY=sk_prod_xxxxxxxxxxxx\n</code></pre>"},{"location":"swarms/install/workspace_manager/#testing-environment","title":"Testing Environment","text":"<pre><code>WORKSPACE_DIR=./test_workspace\nSWARMS_AUTOUPDATE_ON=true\nUSE_TELEMETRY=false\nSWARMS_API_KEY=sk_test_xxxxxxxxxxxx\n</code></pre>"},{"location":"swarms/install/workspace_manager/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>Workspace Access Issues:</li> <li>Ensure proper file permissions</li> <li>Verify the directory exists</li> <li> <p>Check disk space availability</p> </li> <li> <p>API Key Problems:</p> </li> <li>Confirm key is properly formatted</li> <li>Verify key hasn't expired</li> <li> <p>Check for proper environment variable loading</p> </li> <li> <p>Telemetry Issues:</p> </li> <li>Confirm network connectivity</li> <li>Verify firewall settings</li> <li> <p>Check for proper boolean values</p> </li> <li> <p>Auto-Update Issues:</p> </li> <li>Check internet connectivity</li> <li>Verify sufficient disk space</li> <li>Ensure proper permissions for updates</li> <li>Check system compatibility requirements</li> </ol>"},{"location":"swarms/install/workspace_manager/#additional-resources","title":"Additional Resources","text":"<ul> <li>Swarms Framework Documentation</li> <li>Swarms Analytics Dashboard</li> <li>API Reference</li> </ul>"},{"location":"swarms/memory/diy_memory/","title":"Integrating the Agent Class with Memory Systems/RAG in the Swarms Memory Framework","text":"<p>In this guide, we will cover how to integrate various memory systems from the Swarms Memory framework into an agent class. The Swarms Memory framework allows for the integration of different database-backed memory systems, enabling agents to retain and query long-term knowledge effectively. We'll walk through examples of integrating with Pinecone, ChromaDB, and Faiss, showcasing how to configure custom functions and embed memory functionality into an agent class.</p>"},{"location":"swarms/memory/diy_memory/#installation","title":"Installation","text":"<p>First, you need to install the Swarms Memory package:</p> <pre><code>$ pip install swarms swarms-memory\n</code></pre>"},{"location":"swarms/memory/diy_memory/#integrating-chromadb-with-the-agent-class","title":"Integrating ChromaDB with the Agent Class","text":"<p>ChromaDB is a simple, high-performance vector store for use with embeddings. Here's how you can integrate ChromaDB:</p> <pre><code>from swarms_memory import ChromaDB\nfrom swarms.structs.agent import Agent\n\n# Initialize ChromaDB memory\nchromadb_memory = ChromaDB(\n    metric=\"cosine\",\n    output_dir=\"finance_agent_rag\",\n)\n\n# Initialize the Financial Analysis Agent with GPT-4o-mini model\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n    model_name=\"gpt-4o-mini\",\n    long_term_memory=chromadb_memory,\n)\n\n# Run a query\nresponse = agent.run(\n    \"What are the components of a startup's stock incentive equity plan?\"\n)\nprint(response)\n</code></pre>"},{"location":"swarms/memory/diy_memory/#integrating-faiss-with-the-agent-class","title":"Integrating Faiss with the Agent Class","text":"<p>Faiss is a library for efficient similarity search and clustering of dense vectors. Here's how you can integrate Faiss:</p> <pre><code>from typing import List, Dict, Any\nfrom swarms_memory.faiss_wrapper import FAISSDB\nfrom swarms import Agent\nfrom swarm_models import Anthropic\nfrom transformers import AutoTokenizer, AutoModel\nimport torch\nimport os\n\n# Custom embedding function using a HuggingFace model\ndef custom_embedding_function(text: str) -&gt; List[float]:\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-uncased\")\n    model = AutoModel.from_pretrained(\"bert-base-uncased\")\n    inputs = tokenizer(\n        text,\n        return_tensors=\"pt\",\n        padding=True,\n        truncation=True,\n        max_length=512,\n    )\n    with torch.no_grad():\n        outputs = model(**inputs)\n    embeddings = (\n        outputs.last_hidden_state.mean(dim=1).squeeze().tolist()\n    )\n    return embeddings\n\n# Initialize the FAISS memory wrapper\nfaiss_memory = FAISSDB(\n    dimension=768,\n    index_type=\"Flat\",\n    embedding_function=custom_embedding_function,\n    metric=\"cosine\",\n)\n\n# Model\nmodel = Anthropic(anthropic_api_key=os.getenv(\"ANTHROPIC_API_KEY\"))\n\n# Initialize the agent with Faiss memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"Agent system prompt here\",\n    agent_description=\"Agent performs financial analysis.\",\n    llm=model,\n    long_term_memory=faiss_memory,\n)\n\n# Run a query\nagent.run(\"Explain the differences between various types of financial instruments.\")\n</code></pre>"},{"location":"swarms/memory/diy_memory/#mermaid-graphs-for-visualizing-integration","title":"Mermaid Graphs for Visualizing Integration","text":"<p>To help visualize the integration process, here's a Mermaid graph illustrating how an agent interacts with the memory systems:</p> <pre><code>graph TD;\n    A[Agent] --&gt;|Queries| B[Memory System]\n    B --&gt; C{Pinecone / ChromaDB / Faiss}\n    C --&gt; D[Embedding Function]\n    D --&gt; E[LLM Model]\n    E --&gt; F[Query Results]\n    F --&gt;|Returns| A</code></pre> <p>This graph shows the flow from the agent sending queries to the memory system, which processes them using the embedding function and LLM model, and finally returns the results back to the agent.</p>"},{"location":"swarms/memory/diy_memory/#conclusion","title":"Conclusion","text":"<p>Integrating various memory systems from the Swarms Memory framework into the agent class enables the creation of powerful, memory-augmented agents capable of retaining and recalling information over time. Whether you're using Pinecone, ChromaDB, or Faiss, the process involves initializing the memory system, embedding functions, and then passing this memory system to the agent class. The examples and visualizations provided should help you get started with building your own memory-augmented agents.</p> <p>Happy coding!</p>"},{"location":"swarms/models/","title":"Swarm Models","text":"<pre><code>$ pip3 install -U swarm-models\n</code></pre> <p>Welcome to the documentation for the llm section of the swarms package, designed to facilitate seamless integration with various AI language models and APIs. This package empowers developers, end-users, and system administrators to interact with AI models from different providers, such as OpenAI, Hugging Face, Google PaLM, and Anthropic.</p>"},{"location":"swarms/models/#table-of-contents","title":"Table of Contents","text":"<ol> <li>OpenAI</li> <li>HuggingFace</li> <li>Anthropic</li> </ol>"},{"location":"swarms/models/#1-openai-swarm_modelsopenai","title":"1. OpenAI (swarm_models.OpenAI)","text":"<p>The OpenAI class provides an interface to interact with OpenAI's language models. It allows both synchronous and asynchronous interactions.</p> <p>Constructor: <pre><code>OpenAI(api_key: str, system: str = None, console: bool = True, model: str = None, params: dict = None, save_messages: bool = True)\n</code></pre></p> <p>Attributes: - <code>api_key</code> (str): Your OpenAI API key.</p> <ul> <li> <p><code>system</code> (str, optional): A system message to be used in conversations.</p> </li> <li> <p><code>console</code> (bool, default=True): Display console logs.</p> </li> <li> <p><code>model</code> (str, optional): Name of the language model to use.</p> </li> <li> <p><code>params</code> (dict, optional): Additional parameters for model interactions.</p> </li> <li> <p><code>save_messages</code> (bool, default=True): Save conversation messages.</p> </li> </ul> <p>Methods:</p> <ul> <li> <p><code>run(message: str, **kwargs) -&gt; str</code>: Generate a response using the OpenAI model.</p> </li> <li> <p><code>generate_async(message: str, **kwargs) -&gt; str</code>: Generate a response asynchronously.</p> </li> <li> <p><code>ask_multiple(ids: List[str], question_template: str) -&gt; List[str]</code>: Query multiple IDs simultaneously.</p> </li> <li> <p><code>stream_multiple(ids: List[str], question_template: str) -&gt; List[str]</code>: Stream multiple responses.</p> </li> </ul> <p>Usage Example: <pre><code>import asyncio\n\nfrom swarm_models import OpenAI\n\nchat = OpenAI(api_key=\"YOUR_OPENAI_API_KEY\")\n\nresponse = chat.run(\"Hello, how can I assist you?\")\nprint(response)\n\nids = [\"id1\", \"id2\", \"id3\"]\nasync_responses = asyncio.run(chat.ask_multiple(ids, \"How is {id}?\"))\nprint(async_responses)\n</code></pre></p>"},{"location":"swarms/models/#2-huggingface-swarm_modelshuggingfacellm","title":"2. HuggingFace (swarm_models.HuggingFaceLLM)","text":"<p>The HuggingFaceLLM class allows interaction with language models from Hugging Face.</p> <p>Constructor: <pre><code>HuggingFaceLLM(model_id: str, device: str = None, max_length: int = 20, quantize: bool = False, quantization_config: dict = None)\n</code></pre></p> <p>Attributes:</p> <ul> <li> <p><code>model_id</code> (str): ID or name of the Hugging Face model.</p> </li> <li> <p><code>device</code> (str, optional): Device to run the model on (e.g., 'cuda', 'cpu').</p> </li> <li> <p><code>max_length</code> (int, default=20): Maximum length of generated text.</p> </li> <li> <p><code>quantize</code> (bool, default=False): Apply model quantization.</p> </li> <li> <p><code>quantization_config</code> (dict, optional): Configuration for quantization.</p> </li> </ul> <p>Methods:</p> <ul> <li><code>run(prompt_text: str, max_length: int = None) -&gt; str</code>: Generate text based on a prompt.</li> </ul> <p>Usage Example: <pre><code>from swarm_models import HuggingFaceLLM\n\nmodel_id = \"gpt2\"\nhugging_face_model = HuggingFaceLLM(model_id=model_id)\n\nprompt = \"Once upon a time\"\ngenerated_text = hugging_face_model.run(prompt)\nprint(generated_text)\n</code></pre></p>"},{"location":"swarms/models/#3-anthropic-swarm_modelsanthropic","title":"3. Anthropic (swarm_models.Anthropic)","text":"<p>The Anthropic class enables interaction with Anthropic's large language models.</p> <p>Constructor: <pre><code>Anthropic(model: str = \"claude-2\", max_tokens_to_sample: int = 256, temperature: float = None, top_k: int = None, top_p: float = None, streaming: bool = False, default_request_timeout: int = None)\n</code></pre></p> <p>Attributes:</p> <ul> <li> <p><code>model</code> (str): Name of the Anthropic model.</p> </li> <li> <p><code>max_tokens_to_sample</code> (int, default=256): Maximum tokens to sample.</p> </li> <li> <p><code>temperature</code> (float, optional): Temperature for text generation.</p> </li> <li> <p><code>top_k</code> (int, optional): Top-k sampling value.</p> </li> <li> <p><code>top_p</code> (float, optional): Top-p sampling value.</p> </li> <li> <p><code>streaming</code> (bool, default=False): Enable streaming mode.</p> </li> <li> <p><code>default_request_timeout</code> (int, optional): Default request timeout.</p> </li> </ul> <p>Methods:</p> <ul> <li><code>run(prompt: str, stop: List[str] = None) -&gt; str</code>: Generate text based on a prompt.</li> </ul> <p>Usage Example: <pre><code>from swarm_models import Anthropic\n\nanthropic = Anthropic()\nprompt = \"Once upon a time\"\ngenerated_text = anthropic.run(prompt)\nprint(generated_text)\n</code></pre></p> <p>This concludes the documentation for the \"models\" folder, providing you with tools to seamlessly integrate with various language models and APIs. Happy coding!</p>"},{"location":"swarms/models/agent_and_models/","title":"Model Integration in Agents","text":"<p>About Model Integration</p> <p>Agents supports multiple model providers through LiteLLM integration, allowing you to easily switch between different language models. This document outlines the available providers and how to use them with agents.</p>"},{"location":"swarms/models/agent_and_models/#important-note-on-model-names","title":"Important Note on Model Names","text":"<p>Required Format</p> <p>When specifying a model in an agent, you must use the format <code>provider/model_name</code>. For example: <pre><code>\"openai/gpt-4\"\n\"anthropic/claude-3-opus-latest\"\n\"cohere/command-r-plus\"\n</code></pre> This format ensures the agent knows which provider to use for the specified model.</p>"},{"location":"swarms/models/agent_and_models/#available-model-providers","title":"Available Model Providers","text":""},{"location":"swarms/models/agent_and_models/#openai","title":"OpenAI","text":"OpenAI Models <ul> <li>Provider name: <code>openai</code></li> <li>Available Models:<ul> <li><code>gpt-4</code></li> <li><code>gpt-3.5-turbo</code></li> <li><code>gpt-4-turbo-preview</code></li> </ul> </li> </ul>"},{"location":"swarms/models/agent_and_models/#anthropic","title":"Anthropic","text":"Anthropic Models <ul> <li>Provider name: <code>anthropic</code></li> <li>Available Models:<ul> <li>Claude 3 Opus:<ul> <li><code>claude-3-opus-latest</code></li> <li><code>claude-3-opus-20240229</code></li> </ul> </li> <li>Claude 3 Sonnet:<ul> <li><code>claude-3-sonnet-20240229</code></li> <li><code>claude-3-5-sonnet-latest</code></li> <li><code>claude-3-5-sonnet-20240620</code></li> <li><code>claude-3-7-sonnet-latest</code></li> <li><code>claude-3-7-sonnet-20250219</code></li> <li><code>claude-3-5-sonnet-20241022</code></li> </ul> </li> <li>Claude 3 Haiku:<ul> <li><code>claude-3-haiku-20240307</code></li> <li><code>claude-3-5-haiku-20241022</code></li> <li><code>claude-3-5-haiku-latest</code></li> </ul> </li> <li>Legacy Models:<ul> <li><code>claude-2</code></li> <li><code>claude-2.1</code></li> <li><code>claude-instant-1</code></li> <li><code>claude-instant-1.2</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"swarms/models/agent_and_models/#cohere","title":"Cohere","text":"Cohere Models <ul> <li>Provider name: <code>cohere</code></li> <li>Available Models:<ul> <li>Command:<ul> <li><code>command</code></li> <li><code>command-r</code></li> <li><code>command-r-08-2024</code></li> <li><code>command-r7b-12-2024</code></li> </ul> </li> <li>Command Light:<ul> <li><code>command-light</code></li> </ul> </li> <li>Command R Plus:<ul> <li><code>command-r-plus</code></li> <li><code>command-r-plus-08-2024</code></li> </ul> </li> </ul> </li> </ul>"},{"location":"swarms/models/agent_and_models/#google","title":"Google","text":"Google Models <ul> <li>Provider name: <code>google</code></li> <li>Available Models:<ul> <li><code>gemini-pro</code></li> <li><code>gemini-pro-vision</code></li> </ul> </li> </ul>"},{"location":"swarms/models/agent_and_models/#mistral","title":"Mistral","text":"Mistral Models <ul> <li>Provider name: <code>mistral</code></li> <li>Available Models:<ul> <li><code>mistral-tiny</code></li> <li><code>mistral-small</code></li> <li><code>mistral-medium</code></li> </ul> </li> </ul>"},{"location":"swarms/models/agent_and_models/#using-different-models-in-your-agents","title":"Using Different Models In Your Agents","text":"<p>To use a different model with your Swarms agent, specify the model name in the <code>model_name</code> parameter when initializing the Agent, using the provider/model_name format:</p> <pre><code>from swarms import Agent\n\n# Using OpenAI's GPT-4\nagent = Agent(\n    agent_name=\"Research-Agent\",\n    model_name=\"openai/gpt-4o\",  # Note the provider/model_name format\n    # ... other parameters\n)\n\n# Using Anthropic's Claude\nagent = Agent(\n    agent_name=\"Analysis-Agent\",\n    model_name=\"anthropic/claude-3-sonnet-20240229\",  # Note the provider/model_name format\n    # ... other parameters\n)\n\n# Using Cohere's Command\nagent = Agent(\n    agent_name=\"Text-Agent\",\n    model_name=\"cohere/command-r-plus\",  # Note the provider/model_name format\n    # ... other parameters\n)\n</code></pre>"},{"location":"swarms/models/agent_and_models/#model-configuration","title":"Model Configuration","text":"<p>When using different models, you can configure various parameters:</p> <pre><code>agent = Agent(\n    agent_name=\"Custom-Agent\",\n    model_name=\"openai/gpt-4\",\n    temperature=0.7,  # Controls randomness (0.0 to 1.0)\n    max_tokens=2000,  # Maximum tokens in response\n    top_p=0.9,       # Nucleus sampling parameter\n    frequency_penalty=0.0,  # Reduces repetition\n    presence_penalty=0.0,   # Encourages new topics\n    # ... other parameters\n)\n</code></pre>"},{"location":"swarms/models/agent_and_models/#best-practices","title":"Best Practices","text":""},{"location":"swarms/models/agent_and_models/#model-selection","title":"Model Selection","text":"<p>Choosing the Right Model</p> <ul> <li>Choose models based on your specific use case</li> <li>Consider cost, performance, and feature requirements</li> <li>Test different models for your specific task</li> </ul>"},{"location":"swarms/models/agent_and_models/#error-handling","title":"Error Handling","text":"<p>Error Management</p> <ul> <li>Implement proper error handling for model-specific errors</li> <li>Handle rate limits and API quotas appropriately</li> </ul>"},{"location":"swarms/models/agent_and_models/#cost-management","title":"Cost Management","text":"<p>Cost Considerations</p> <ul> <li>Monitor token usage and costs</li> <li>Use appropriate model sizes for your needs</li> </ul>"},{"location":"swarms/models/agent_and_models/#example-use-cases","title":"Example Use Cases","text":""},{"location":"swarms/models/agent_and_models/#1-complex-analysis-gpt-4","title":"1. Complex Analysis (GPT-4)","text":"<pre><code>agent = Agent(\n    agent_name=\"Analysis-Agent\",\n    model_name=\"openai/gpt-4\",  # Note the provider/model_name format\n    temperature=0.3,  # Lower temperature for more focused responses\n    max_tokens=4000\n)\n</code></pre>"},{"location":"swarms/models/agent_and_models/#2-creative-tasks-claude","title":"2. Creative Tasks (Claude)","text":"<pre><code>agent = Agent(\n    agent_name=\"Creative-Agent\",\n    model_name=\"anthropic/claude-3-sonnet-20240229\",  # Note the provider/model_name format\n    temperature=0.8,  # Higher temperature for more creative responses\n    max_tokens=2000\n)\n</code></pre>"},{"location":"swarms/models/agent_and_models/#3-vision-tasks-gemini","title":"3. Vision Tasks (Gemini)","text":"<pre><code>agent = Agent(\n    agent_name=\"Vision-Agent\",\n    model_name=\"google/gemini-pro-vision\",  # Note the provider/model_name format\n    temperature=0.4,\n    max_tokens=1000\n)\n</code></pre>"},{"location":"swarms/models/agent_and_models/#troubleshooting","title":"Troubleshooting","text":"<p>Common Issues</p> <p>If you encounter issues with specific models:</p> <ol> <li>Verify your API keys are correctly set</li> <li>Check model availability in your region</li> <li>Ensure you have sufficient quota/credits</li> <li>Verify the model name is correct and supported</li> </ol>"},{"location":"swarms/models/agent_and_models/#additional-resources","title":"Additional Resources","text":"<ul> <li>LiteLLM Documentation</li> <li>OpenAI API Documentation</li> <li>Anthropic API Documentation</li> <li>Google AI Documentation</li> </ul>"},{"location":"swarms/models/anthropic/","title":"Documentation for the <code>Anthropic</code> Class","text":""},{"location":"swarms/models/anthropic/#overview-and-introduction","title":"Overview and Introduction","text":"<p>The <code>Anthropic</code> class provides an interface to interact with the Anthropic large language models. This class encapsulates the necessary functionality to request completions from the Anthropic API based on a provided prompt and other configurable parameters.</p>"},{"location":"swarms/models/anthropic/#key-concepts-and-terminology","title":"Key Concepts and Terminology","text":"<ul> <li>Anthropic: A large language model, akin to GPT-3 and its successors.</li> <li>Prompt: A piece of text that serves as the starting point for model completions.</li> <li>Stop Sequences: Specific tokens or sequences to indicate when the model should stop generating.</li> <li>Tokens: Discrete pieces of information in a text. For example, in English, a token can be as short as one character or as long as one word.</li> </ul>"},{"location":"swarms/models/anthropic/#class-definition","title":"Class Definition","text":""},{"location":"swarms/models/anthropic/#anthropic","title":"<code>Anthropic</code>","text":"<pre><code>class Anthropic:\n    \"\"\"Anthropic large language models.\"\"\"\n</code></pre>"},{"location":"swarms/models/anthropic/#parameters","title":"Parameters:","text":"<ul> <li> <p><code>model (str)</code>: The name of the model to use for completions. Default is \"claude-2\".</p> </li> <li> <p><code>max_tokens_to_sample (int)</code>: Maximum number of tokens to generate in the output. Default is 256.</p> </li> <li> <p><code>temperature (float, optional)</code>: Sampling temperature. A higher value will make the output more random, while a lower value will make it more deterministic.</p> </li> <li> <p><code>top_k (int, optional)</code>: Sample from the top-k most probable next tokens. Setting this parameter can reduce randomness in the output.</p> </li> <li> <p><code>top_p (float, optional)</code>: Sample from the smallest set of tokens such that their cumulative probability exceeds the specified value. Used in nucleus sampling to provide a balance between randomness and determinism.</p> </li> <li> <p><code>streaming (bool)</code>: Whether to stream the output or not. Default is False.</p> </li> <li> <p><code>default_request_timeout (int, optional)</code>: Default timeout in seconds for API requests. Default is 600.</p> </li> </ul>"},{"location":"swarms/models/anthropic/#methods-and-their-functionality","title":"Methods and their Functionality","text":""},{"location":"swarms/models/anthropic/#_default_paramsself-dict","title":"<code>_default_params(self) -&gt; dict</code>","text":"<ul> <li> <p>Provides the default parameters for calling the Anthropic API.</p> </li> <li> <p>Returns: A dictionary containing the default parameters.</p> </li> </ul>"},{"location":"swarms/models/anthropic/#generateself-prompt-str-stop-liststr-none-str","title":"<code>generate(self, prompt: str, stop: list[str] = None) -&gt; str</code>","text":"<ul> <li> <p>Calls out to Anthropic's completion endpoint to generate text based on the given prompt.</p> </li> <li> <p>Parameters:</p> <ul> <li> <p><code>prompt (str)</code>: The input text to provide context for the generated text.</p> </li> <li> <p><code>stop (list[str], optional)</code>: Sequences to indicate when the model should stop generating.</p> </li> </ul> </li> <li> <p>Returns: A string containing the model's generated completion based on the prompt.</p> </li> </ul>"},{"location":"swarms/models/anthropic/#__call__self-prompt-str-stop-liststr-none-str","title":"<code>__call__(self, prompt: str, stop: list[str] = None) -&gt; str</code>","text":"<ul> <li> <p>An alternative to the <code>generate</code> method that allows calling the class instance directly.</p> </li> <li> <p>Parameters:</p> <ul> <li> <p><code>prompt (str)</code>: The input text to provide context for the generated text.</p> </li> <li> <p><code>stop (list[str], optional)</code>: Sequences to indicate when the model should stop generating.</p> </li> </ul> </li> <li> <p>Returns: A string containing the model's generated completion based on the prompt.</p> </li> </ul>"},{"location":"swarms/models/anthropic/#usage-examples","title":"Usage Examples","text":"<pre><code># Import necessary modules and classes\nfrom swarm_models import Anthropic\n\n# Initialize an instance of the Anthropic class\nmodel = Anthropic(anthropic_api_key=\"\")\n\n# Using the run method\ncompletion_1 = model.run(\"What is the capital of France?\")\nprint(completion_1)\n\n# Using the __call__ method\ncompletion_2 = model(\"How far is the moon from the earth?\", stop=[\"miles\", \"km\"])\nprint(completion_2)\n</code></pre>"},{"location":"swarms/models/anthropic/#mathematical-formula","title":"Mathematical Formula","text":"<p>The underlying operations of the <code>Anthropic</code> class involve probabilistic sampling based on token logits from the Anthropic model. Mathematically, the process of generating a token \\( t \\) from the given logits \\( l \\) can be described by the softmax function:</p> \\[ P(t) = \\frac{e^{l_t}}{\\sum_{i} e^{l_i}} \\] <p>Where: - \\( P(t) \\) is the probability of token \\( t \\). - \\( l_t \\) is the logit corresponding to token \\( t \\). - The summation runs over all possible tokens.</p> <p>The temperature, top-k, and top-p parameters are further used to modulate the probabilities.</p>"},{"location":"swarms/models/anthropic/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li> <p>Ensure you have a valid <code>ANTHROPIC_API_KEY</code> set as an environment variable or passed during class instantiation.</p> </li> <li> <p>Always handle exceptions that may arise from API timeouts or invalid prompts.</p> </li> </ul>"},{"location":"swarms/models/anthropic/#references-and-resources","title":"References and Resources","text":"<ul> <li> <p>Anthropic's official documentation</p> </li> <li> <p>Token-based sampling in Language Models for a deeper understanding of token sampling.</p> </li> </ul>"},{"location":"swarms/models/base_llm/","title":"Language Model Interface Documentation","text":""},{"location":"swarms/models/base_llm/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Abstract Language Model</li> <li>Initialization</li> <li>Attributes</li> <li>Methods</li> <li>Implementation</li> <li>Usage Examples</li> <li>Additional Features</li> <li>Performance Metrics</li> <li>Logging and Checkpoints</li> <li>Resource Utilization Tracking</li> <li>Conclusion</li> </ol>"},{"location":"swarms/models/base_llm/#1-introduction","title":"1. Introduction","text":"<p>The Language Model Interface (<code>BaseLLM</code>) is a flexible and extensible framework for working with various language models. This documentation provides a comprehensive guide to the interface, its attributes, methods, and usage examples. Whether you're using a pre-trained language model or building your own, this interface can help streamline the process of text generation, chatbots, summarization, and more.</p>"},{"location":"swarms/models/base_llm/#2-abstract-language-model","title":"2. Abstract Language Model","text":""},{"location":"swarms/models/base_llm/#initialization","title":"Initialization","text":"<p>The <code>BaseLLM</code> class provides a common interface for language models. It can be initialized with various parameters to customize model behavior. Here are the initialization parameters:</p> Parameter Description Default Value <code>model_name</code> The name of the language model to use. None <code>max_tokens</code> The maximum number of tokens in the generated text. None <code>temperature</code> The temperature parameter for controlling randomness in text generation. None <code>top_k</code> The top-k parameter for filtering words in text generation. None <code>top_p</code> The top-p parameter for filtering words in text generation. None <code>system_prompt</code> A system-level prompt to set context for generation. None <code>beam_width</code> The beam width for beam search. None <code>num_return_sequences</code> The number of sequences to return in the output. None <code>seed</code> The random seed for reproducibility. None <code>frequency_penalty</code> The frequency penalty parameter for promoting word diversity. None <code>presence_penalty</code> The presence penalty parameter for discouraging repetitions. None <code>stop_token</code> A stop token to indicate the end of generated text. None <code>length_penalty</code> The length penalty parameter for controlling the output length. None <code>role</code> The role of the language model (e.g., assistant, user, etc.). None <code>max_length</code> The maximum length of generated sequences. None <code>do_sample</code> Whether to use sampling during text generation. None <code>early_stopping</code> Whether to use early stopping during text generation. None <code>num_beams</code> The number of beams to use in beam search. None <code>repition_penalty</code> The repetition penalty parameter for discouraging repeated tokens. None <code>pad_token_id</code> The token ID for padding. None <code>eos_token_id</code> The token ID for the end of a sequence. None <code>bos_token_id</code> The token ID for the beginning of a sequence. None <code>device</code> The device to run the model on (e.g., 'cpu' or 'cuda'). None"},{"location":"swarms/models/base_llm/#attributes","title":"Attributes","text":"<ul> <li><code>model_name</code>: The name of the language model being used.</li> <li><code>max_tokens</code>: The maximum number of tokens in generated text.</li> <li><code>temperature</code>: The temperature parameter controlling randomness.</li> <li><code>top_k</code>: The top-k parameter for word filtering.</li> <li><code>top_p</code>: The top-p parameter for word filtering.</li> <li><code>system_prompt</code>: A system-level prompt for context.</li> <li><code>beam_width</code>: The beam width for beam search.</li> <li><code>num_return_sequences</code>: The number of output sequences.</li> <li><code>seed</code>: The random seed for reproducibility.</li> <li><code>frequency_penalty</code>: The frequency penalty parameter.</li> <li><code>presence_penalty</code>: The presence penalty parameter.</li> <li><code>stop_token</code>: The stop token to indicate text end.</li> <li><code>length_penalty</code>: The length penalty parameter.</li> <li><code>role</code>: The role of the language model.</li> <li><code>max_length</code>: The maximum length of generated sequences.</li> <li><code>do_sample</code>: Whether to use sampling during generation.</li> <li><code>early_stopping</code>: Whether to use early stopping.</li> <li><code>num_beams</code>: The number of beams in beam search.</li> <li><code>repition_penalty</code>: The repetition penalty parameter.</li> <li><code>pad_token_id</code>: The token ID for padding.</li> <li><code>eos_token_id</code>: The token ID for the end of a sequence.</li> <li><code>bos_token_id</code>: The token ID for the beginning of a sequence.</li> <li><code>device</code>: The device used for model execution.</li> <li><code>history</code>: A list of conversation history.</li> </ul>"},{"location":"swarms/models/base_llm/#methods","title":"Methods","text":"<p>The <code>BaseLLM</code> class defines several methods for working with language models:</p> <ul> <li> <p><code>run(task: Optional[str] = None, *args, **kwargs) -&gt; str</code>: Generate text using the language model. This method is abstract and must be implemented by subclasses.</p> </li> <li> <p><code>arun(task: Optional[str] = None, *args, **kwargs)</code>: An asynchronous version of <code>run</code> for concurrent text generation.</p> </li> <li> <p><code>batch_run(tasks: List[str], *args, **kwargs)</code>: Generate text for a batch of tasks.</p> </li> <li> <p><code>abatch_run(tasks: List[str], *args, **kwargs)</code>: An asynchronous version of <code>batch_run</code> for concurrent batch generation.</p> </li> <li> <p><code>chat(task: str, history: str = \"\") -&gt; str</code>: Conduct a chat with the model, providing a conversation history.</p> </li> <li> <p><code>__call__(task: str) -&gt; str</code>: Call the model to generate text.</p> </li> <li> <p><code>_tokens_per_second() -&gt; float</code>: Calculate tokens generated per second.</p> </li> <li> <p><code>_num_tokens(text: str) -&gt; int</code>: Calculate the number of tokens in a text.</p> </li> <li> <p><code>_time_for_generation(task: str) -&gt; float</code>: Measure the time taken for text generation.</p> </li> <li> <p><code>generate_summary(text: str) -&gt; str</code>: Generate a summary of the provided text.</p> </li> <li> <p><code>set_temperature(value: float)</code>: Set the temperature parameter.</p> </li> <li> <p><code>set_max_tokens(value: int)</code>: Set the maximum number of tokens.</p> </li> <li> <p><code>clear_history()</code>: Clear the conversation history.</p> </li> <li> <p><code>enable_logging(log_file: str = \"model.log\")</code>: Initialize logging for the model.</p> </li> <li> <p><code>log_event(message: str)</code>: Log an event.</p> </li> <li> <p><code>save_checkpoint(checkpoint_dir: str = \"checkpoints\")</code>: Save the model state as a checkpoint.</p> </li> <li> <p><code>load_checkpoint(checkpoint_path: str)</code>: Load the model state from a checkpoint.</p> </li> <li> <p><code>toggle_creative_mode(enable: bool)</code>: Toggle creative mode for the model.</p> </li> <li> <p><code>track_resource_utilization()</code>: Track and report resource utilization.</p> </li> <li> <p>`</p> </li> </ul> <p>get_generation_time() -&gt; float`: Get the time taken for text generation.</p> <ul> <li> <p><code>set_max_length(max_length: int)</code>: Set the maximum length of generated sequences.</p> </li> <li> <p><code>set_model_name(model_name: str)</code>: Set the model name.</p> </li> <li> <p><code>set_frequency_penalty(frequency_penalty: float)</code>: Set the frequency penalty parameter.</p> </li> <li> <p><code>set_presence_penalty(presence_penalty: float)</code>: Set the presence penalty parameter.</p> </li> <li> <p><code>set_stop_token(stop_token: str)</code>: Set the stop token.</p> </li> <li> <p><code>set_length_penalty(length_penalty: float)</code>: Set the length penalty parameter.</p> </li> <li> <p><code>set_role(role: str)</code>: Set the role of the model.</p> </li> <li> <p><code>set_top_k(top_k: int)</code>: Set the top-k parameter.</p> </li> <li> <p><code>set_top_p(top_p: float)</code>: Set the top-p parameter.</p> </li> <li> <p><code>set_num_beams(num_beams: int)</code>: Set the number of beams.</p> </li> <li> <p><code>set_do_sample(do_sample: bool)</code>: Set whether to use sampling.</p> </li> <li> <p><code>set_early_stopping(early_stopping: bool)</code>: Set whether to use early stopping.</p> </li> <li> <p><code>set_seed(seed: int)</code>: Set the random seed.</p> </li> <li> <p><code>set_device(device: str)</code>: Set the device for model execution.</p> </li> </ul>"},{"location":"swarms/models/base_llm/#3-implementation","title":"3. Implementation","text":"<p>The <code>BaseLLM</code> class serves as the base for implementing specific language models. Subclasses of <code>BaseLLM</code> should implement the <code>run</code> method to define how text is generated for a given task. This design allows flexibility in integrating different language models while maintaining a common interface.</p>"},{"location":"swarms/models/base_llm/#4-usage-examples","title":"4. Usage Examples","text":"<p>To demonstrate how to use the <code>BaseLLM</code> interface, let's create an example using a hypothetical language model. We'll initialize an instance of the model and generate text for a simple task.</p> <pre><code># Import the BaseLLM class\nfrom swarm_models import BaseLLM\n\n# Create an instance of the language model\nlanguage_model = BaseLLM(\n    model_name=\"my_language_model\",\n    max_tokens=50,\n    temperature=0.7,\n    top_k=50,\n    top_p=0.9,\n    device=\"cuda\",\n)\n\n# Generate text for a task\ntask = \"Translate the following English text to French: 'Hello, world.'\"\ngenerated_text = language_model.run(task)\n\n# Print the generated text\nprint(generated_text)\n</code></pre> <p>In this example, we've created an instance of our hypothetical language model, configured its parameters, and used the <code>run</code> method to generate text for a translation task.</p>"},{"location":"swarms/models/base_llm/#5-additional-features","title":"5. Additional Features","text":"<p>The <code>BaseLLM</code> interface provides additional features for customization and control:</p> <ul> <li><code>batch_run</code>: Generate text for a batch of tasks efficiently.</li> <li><code>arun</code> and <code>abatch_run</code>: Asynchronous versions of <code>run</code> and <code>batch_run</code> for concurrent text generation.</li> <li><code>chat</code>: Conduct a conversation with the model by providing a history of the conversation.</li> <li><code>__call__</code>: Allow the model to be called directly to generate text.</li> </ul> <p>These features enhance the flexibility and utility of the interface in various applications, including chatbots, language translation, and content generation.</p>"},{"location":"swarms/models/base_llm/#6-performance-metrics","title":"6. Performance Metrics","text":"<p>The <code>BaseLLM</code> class offers methods for tracking performance metrics:</p> <ul> <li><code>_tokens_per_second</code>: Calculate tokens generated per second.</li> <li><code>_num_tokens</code>: Calculate the number of tokens in a text.</li> <li><code>_time_for_generation</code>: Measure the time taken for text generation.</li> </ul> <p>These metrics help assess the efficiency and speed of text generation, enabling optimizations as needed.</p>"},{"location":"swarms/models/base_llm/#7-logging-and-checkpoints","title":"7. Logging and Checkpoints","text":"<p>Logging and checkpointing are crucial for tracking model behavior and ensuring reproducibility:</p> <ul> <li><code>enable_logging</code>: Initialize logging for the model.</li> <li><code>log_event</code>: Log events and activities.</li> <li><code>save_checkpoint</code>: Save the model state as a checkpoint.</li> <li><code>load_checkpoint</code>: Load the model state from a checkpoint.</li> </ul> <p>These capabilities aid in debugging, monitoring, and resuming model experiments.</p>"},{"location":"swarms/models/base_llm/#8-resource-utilization-tracking","title":"8. Resource Utilization Tracking","text":"<p>The <code>track_resource_utilization</code> method is a placeholder for tracking and reporting resource utilization, such as CPU and memory usage. It can be customized to suit specific monitoring needs.</p>"},{"location":"swarms/models/base_llm/#9-conclusion","title":"9. Conclusion","text":"<p>The Language Model Interface (<code>BaseLLM</code>) is a versatile framework for working with language models. Whether you're using pre-trained models or developing your own, this interface provides a consistent and extensible foundation. By following the provided guidelines and examples, you can integrate and customize language models for various natural language processing tasks.</p>"},{"location":"swarms/models/base_multimodal_model/","title":"<code>BaseMultiModalModel</code> Documentation","text":"<p>Swarms is a Python library that provides a framework for running multimodal AI models. It allows you to combine text and image inputs and generate coherent and context-aware responses. This library is designed to be extensible, allowing you to integrate various multimodal models.</p>"},{"location":"swarms/models/base_multimodal_model/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Installation</li> <li>Getting Started</li> <li>BaseMultiModalModel Class<ul> <li>Initialization</li> <li>Methods</li> </ul> </li> <li>Usage Examples</li> <li>Additional Tips</li> <li>References and Resources</li> </ol>"},{"location":"swarms/models/base_multimodal_model/#1-introduction","title":"1. Introduction","text":"<p>Swarms is designed to simplify the process of working with multimodal AI models. These models are capable of understanding and generating content based on both textual and image inputs. With this library, you can run such models and receive context-aware responses.</p>"},{"location":"swarms/models/base_multimodal_model/#2-installation","title":"2. Installation","text":"<p>To install swarms, you can use pip:</p> <pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/models/base_multimodal_model/#3-getting-started","title":"3. Getting Started","text":"<p>To get started with Swarms, you'll need to import the library and create an instance of the <code>BaseMultiModalModel</code> class. This class serves as the foundation for running multimodal models.</p> <pre><code>from swarm_models import BaseMultiModalModel\n\nmodel = BaseMultiModalModel(\n    model_name=\"your_model_name\",\n    temperature=0.5,\n    max_tokens=500,\n    max_workers=10,\n    top_p=1,\n    top_k=50,\n    beautify=False,\n    device=\"cuda\",\n    max_new_tokens=500,\n    retries=3,\n)\n</code></pre> <p>You can customize the initialization parameters based on your model's requirements.</p>"},{"location":"swarms/models/base_multimodal_model/#4-basemultimodalmodel-class","title":"4. BaseMultiModalModel Class","text":""},{"location":"swarms/models/base_multimodal_model/#initialization","title":"Initialization","text":"<p>The <code>BaseMultiModalModel</code> class is initialized with several parameters that control its behavior. Here's a breakdown of the initialization parameters:</p> Parameter Description Default Value <code>model_name</code> The name of the multimodal model to use. None <code>temperature</code> The temperature parameter for controlling randomness in text generation. 0.5 <code>max_tokens</code> The maximum number of tokens in the generated text. 500 <code>max_workers</code> The maximum number of concurrent workers for running tasks. 10 <code>top_p</code> The top-p parameter for filtering words in text generation. 1 <code>top_k</code> The top-k parameter for filtering words in text generation. 50 <code>beautify</code> Whether to beautify the output text. False <code>device</code> The device to run the model on (e.g., 'cuda' or 'cpu'). 'cuda' <code>max_new_tokens</code> The maximum number of new tokens allowed in generated responses. 500 <code>retries</code> The number of retries in case of an error during text generation. 3 <code>system_prompt</code> A system-level prompt to set context for generation. None <code>meta_prompt</code> A meta prompt to provide guidance for including image labels in responses. None"},{"location":"swarms/models/base_multimodal_model/#methods","title":"Methods","text":"<p>The <code>BaseMultiModalModel</code> class defines various methods for running multimodal models and managing interactions:</p> <ul> <li> <p><code>run(task: str, img: str) -&gt; str</code>: Run the multimodal model with a text task and an image URL to generate a response.</p> </li> <li> <p><code>arun(task: str, img: str) -&gt; str</code>: Run the multimodal model asynchronously with a text task and an image URL to generate a response.</p> </li> <li> <p><code>get_img_from_web(img: str) -&gt; Image</code>: Fetch an image from a URL and return it as a PIL Image.</p> </li> <li> <p><code>encode_img(img: str) -&gt; str</code>: Encode an image to base64 format.</p> </li> <li> <p><code>get_img(img: str) -&gt; Image</code>: Load an image from the local file system and return it as a PIL Image.</p> </li> <li> <p><code>clear_chat_history()</code>: Clear the chat history maintained by the model.</p> </li> <li> <p><code>run_many(tasks: List[str], imgs: List[str]) -&gt; List[str]</code>: Run the model on multiple text tasks and image URLs concurrently and return a list of responses.</p> </li> <li> <p><code>run_batch(tasks_images: List[Tuple[str, str]]) -&gt; List[str]</code>: Process a batch of text tasks and image URLs and return a list of responses.</p> </li> <li> <p><code>run_batch_async(tasks_images: List[Tuple[str, str]]) -&gt; List[str]</code>: Process a batch of text tasks and image URLs asynchronously and return a list of responses.</p> </li> <li> <p><code>run_batch_async_with_retries(tasks_images: List[Tuple[str, str]]) -&gt; List[str]</code>: Process a batch of text tasks and image URLs asynchronously with retries in case of errors and return a list of responses.</p> </li> <li> <p><code>unique_chat_history() -&gt; List[str]</code>: Get the unique chat history stored by the model.</p> </li> <li> <p><code>run_with_retries(task: str, img: str) -&gt; str</code>: Run the model with retries in case of an error.</p> </li> <li> <p><code>run_batch_with_retries(tasks_images: List[Tuple[str, str]]) -&gt; List[str]</code>: Run a batch of tasks with retries in case of errors and return a list of responses.</p> </li> <li> <p><code>_tokens_per_second() -&gt; float</code>: Calculate the tokens generated per second during text generation.</p> </li> <li> <p><code>_time_for_generation(task: str) -&gt; float</code>: Measure the time taken for text generation for a specific task.</p> </li> <li> <p><code>generate_summary(text: str) -&gt; str</code>: Generate a summary of the provided text.</p> </li> <li> <p><code>set_temperature(value: float)</code>: Set the temperature parameter for controlling randomness in text generation.</p> </li> <li> <p><code>set_max_tokens(value: int)</code>: Set the maximum number of tokens allowed in generated responses.</p> </li> <li> <p><code>get_generation_time() -&gt; float</code>: Get the time taken for text generation for the last task.</p> </li> <li> <p><code>get_chat_history() -&gt; List[str]</code>: Get the chat history, including all interactions.</p> </li> <li> <p><code>get_unique_chat_history() -&gt; List[str]</code>: Get the unique chat history, removing duplicate interactions.</p> </li> <li> <p><code>get_chat_history_length() -&gt; int</code>: Get the length of the chat history.</p> </li> <li> <p><code>get_unique_chat_history_length() -&gt; int</code>: Get the length of the unique chat history.</p> </li> <li> <p><code>get_chat_history_tokens() -&gt; int</code>: Get the total number of tokens in the chat history.</p> </li> <li> <p><code>print_beautiful(content: str, color: str = 'cyan')</code>: Print content beautifully using colored text.</p> </li> <li> <p><code>stream(content: str)</code>: Stream the content, printing it character by character.</p> </li> <li> <p><code>meta_prompt() -&gt; str</code>: Get the meta prompt that provides guidance for including image labels in responses.</p> </li> </ul>"},{"location":"swarms/models/base_multimodal_model/#5-usage-examples","title":"5. Usage Examples","text":"<p>Let's explore some usage examples of the MultiModalAI library:</p>"},{"location":"swarms/models/base_multimodal_model/#example-1-running","title":"Example 1: Running","text":"<p>the Model</p> <pre><code># Import the library\nfrom swarm_models import BaseMultiModalModel\n\n# Create an instance of the model\nmodel = BaseMultiModalModel(\n    model_name=\"your_model_name\",\n    temperature=0.5,\n    max_tokens=500,\n    device=\"cuda\",\n)\n\n# Run the model with a text task and an image URL\nresponse = model.run(\n    \"Generate a summary of this text\", \"https://www.example.com/image.jpg\"\n)\nprint(response)\n</code></pre>"},{"location":"swarms/models/base_multimodal_model/#example-2-running-multiple-tasks-concurrently","title":"Example 2: Running Multiple Tasks Concurrently","text":"<pre><code># Import the library\nfrom swarm_models import BaseMultiModalModel\n\n# Create an instance of the model\nmodel = BaseMultiModalModel(\n    model_name=\"your_model_name\",\n    temperature=0.5,\n    max_tokens=500,\n    max_workers=4,\n    device=\"cuda\",\n)\n\n# Define a list of tasks and image URLs\ntasks = [\"Task 1\", \"Task 2\", \"Task 3\"]\nimages = [\"https://image1.jpg\", \"https://image2.jpg\", \"https://image3.jpg\"]\n\n# Run the model on multiple tasks concurrently\nresponses = model.run_many(tasks, images)\nfor response in responses:\n    print(response)\n</code></pre>"},{"location":"swarms/models/base_multimodal_model/#example-3-running-the-model-asynchronously","title":"Example 3: Running the Model Asynchronously","text":"<pre><code># Import the library\nfrom swarm_models import BaseMultiModalModel\n\n# Create an instance of the model\nmodel = BaseMultiModalModel(\n    model_name=\"your_model_name\",\n    temperature=0.5,\n    max_tokens=500,\n    device=\"cuda\",\n)\n\n# Define a list of tasks and image URLs\ntasks_images = [\n    (\"Task 1\", \"https://image1.jpg\"),\n    (\"Task 2\", \"https://image2.jpg\"),\n    (\"Task 3\", \"https://image3.jpg\"),\n]\n\n# Run the model on multiple tasks asynchronously\nresponses = model.run_batch_async(tasks_images)\nfor response in responses:\n    print(response)\n</code></pre>"},{"location":"swarms/models/base_multimodal_model/#example-4-inheriting-basemultimodalmodel-for-its-prebuilt-classes","title":"Example 4: Inheriting <code>BaseMultiModalModel</code> for it's prebuilt classes","text":"<pre><code>from swarm_models import BaseMultiModalModel\n\n\nclass CustomMultiModalModel(BaseMultiModalModel):\n    def __init__(self, model_name, custom_parameter, *args, **kwargs):\n        # Call the parent class constructor\n        super().__init__(model_name=model_name, *args, **kwargs)\n        # Initialize custom parameters specific to your model\n        self.custom_parameter = custom_parameter\n\n    def __call__(self, text, img):\n        # Implement the multimodal model logic here\n        # You can use self.custom_parameter and other inherited attributes\n        pass\n\n    def generate_summary(self, text):\n        # Implement the summary generation logic using your model\n        # You can use self.custom_parameter and other inherited attributes\n        pass\n\n\n# Create an instance of your custom multimodal model\ncustom_model = CustomMultiModalModel(\n    model_name=\"your_custom_model_name\",\n    custom_parameter=\"your_custom_value\",\n    temperature=0.5,\n    max_tokens=500,\n    device=\"cuda\",\n)\n\n# Run your custom model\nresponse = custom_model.run(\n    \"Generate a summary of this text\", \"https://www.example.com/image.jpg\"\n)\nprint(response)\n\n# Generate a summary using your custom model\nsummary = custom_model.generate_summary(\"This is a sample text to summarize.\")\nprint(summary)\n</code></pre> <p>In the code above:</p> <ol> <li> <p>We define a <code>CustomMultiModalModel</code> class that inherits from <code>BaseMultiModalModel</code>.</p> </li> <li> <p>In the constructor of our custom class, we call the parent class constructor using <code>super()</code> and initialize any custom parameters specific to our model. In this example, we introduced a <code>custom_parameter</code>.</p> </li> <li> <p>We override the <code>__call__</code> method, which is responsible for running the multimodal model logic. Here, you can implement the specific behavior of your model, considering both text and image inputs.</p> </li> <li> <p>We override the <code>generate_summary</code> method, which is used to generate a summary of text input. You can implement your custom summarization logic here.</p> </li> <li> <p>We create an instance of our custom model, passing the required parameters, including the custom parameter.</p> </li> <li> <p>We demonstrate how to run the custom model and generate a summary using it.</p> </li> </ol> <p>By inheriting from <code>BaseMultiModalModel</code>, you can leverage the prebuilt features and methods provided by the library while customizing the behavior of your multimodal model. This allows you to create powerful and specialized models for various multimodal tasks.</p> <p>These examples demonstrate how to use MultiModalAI to run multimodal models with text and image inputs. You can adjust the parameters and methods to suit your specific use cases.</p>"},{"location":"swarms/models/base_multimodal_model/#6-additional-tips","title":"6. Additional Tips","text":"<p>Here are some additional tips and considerations for using MultiModalAI effectively:</p> <ul> <li> <p>Custom Models: You can create your own multimodal models and inherit from the <code>BaseMultiModalModel</code> class to integrate them with this library.</p> </li> <li> <p>Retries: In cases where text generation might fail due to various reasons (e.g., server issues), using methods with retries can be helpful.</p> </li> <li> <p>Monitoring: You can monitor the performance of your model using methods like <code>_tokens_per_second()</code> and <code>_time_for_generation()</code>.</p> </li> <li> <p>Chat History: The library maintains a chat history, allowing you to keep track of interactions.</p> </li> <li> <p>Streaming: The <code>stream()</code> method can be useful for displaying output character by character, which can be helpful for certain applications.</p> </li> </ul>"},{"location":"swarms/models/base_multimodal_model/#7-references-and-resources","title":"7. References and Resources","text":"<p>Here are some references and resources that you may find useful for working with multimodal models:</p> <ul> <li> <p>Hugging Face Transformers Library: A library for working with various transformer-based models.</p> </li> <li> <p>PIL (Python Imaging Library): Documentation for working with images in Python using the Pillow library.</p> </li> <li> <p>Concurrent Programming in Python: Official Python documentation for concurrent programming.</p> </li> <li> <p>Requests Library Documentation: Documentation for the Requests library, which is used for making HTTP requests.</p> </li> <li> <p>Base64 Encoding in Python: Official Python documentation for base64 encoding and decoding.</p> </li> </ul> <p>This concludes the documentation for the MultiModalAI library. You can now explore the library further and integrate it with your multimodal AI projects.</p>"},{"location":"swarms/models/cerebras/","title":"Using Cerebras LLaMA with Swarms","text":"<p>This guide demonstrates how to create and use an AI agent powered by the Cerebras LLaMA 3 70B model using the Swarms framework.</p>"},{"location":"swarms/models/cerebras/#prerequisites","title":"Prerequisites","text":"<ul> <li> <p>Python 3.7+</p> </li> <li> <p>Swarms library installed (<code>pip install swarms</code>)</p> </li> <li> <p>Set your ENV key <code>CEREBRAS_API_KEY</code></p> </li> </ul>"},{"location":"swarms/models/cerebras/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"swarms/models/cerebras/#1-import-required-module","title":"1. Import Required Module","text":"<pre><code>from swarms.structs.agent import Agent\n</code></pre> <p>This imports the <code>Agent</code> class from Swarms, which is the core component for creating AI agents.</p>"},{"location":"swarms/models/cerebras/#2-create-an-agent-instance","title":"2. Create an Agent Instance","text":"<pre><code>agent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    max_loops=4,\n    model_name=\"cerebras/llama3-70b-instruct\",\n    dynamic_temperature_enabled=True,\n    interactive=False,\n    output_type=\"all\",\n)\n</code></pre> <p>Let's break down each parameter:</p> <ul> <li> <p><code>agent_name</code>: A descriptive name for your agent (here, \"Financial-Analysis-Agent\")</p> </li> <li> <p><code>agent_description</code>: A brief description of the agent's purpose</p> </li> <li> <p><code>max_loops</code>: Maximum number of interaction loops the agent can perform (set to 4)</p> </li> <li> <p><code>model_name</code>: Specifies the Cerebras LLaMA 3 70B model to use</p> </li> <li> <p><code>dynamic_temperature_enabled</code>: Enables dynamic adjustment of temperature for varied responses</p> </li> <li> <p><code>interactive</code>: When False, runs without requiring user interaction</p> </li> <li> <p><code>output_type</code>: Set to \"all\" to return complete response information</p> </li> </ul>"},{"location":"swarms/models/cerebras/#3-run-the-agent","title":"3. Run the Agent","text":"<pre><code>agent.run(\"Conduct an analysis of the best real undervalued ETFs\")\n</code></pre> <p>This command:</p> <ol> <li> <p>Activates the agent</p> </li> <li> <p>Processes the given prompt about ETF analysis</p> </li> <li> <p>Returns the analysis based on the model's knowledge</p> </li> </ol>"},{"location":"swarms/models/cerebras/#notes","title":"Notes","text":"<ul> <li> <p>The Cerebras LLaMA 3 70B model is a powerful language model suitable for complex analysis tasks</p> </li> <li> <p>The agent can be customized further with additional parameters</p> </li> <li> <p>The <code>max_loops=4</code> setting prevents infinite loops while allowing sufficient processing depth</p> </li> <li> <p>Setting <code>interactive=False</code> makes the agent run autonomously without user intervention</p> </li> </ul>"},{"location":"swarms/models/cerebras/#example-output","title":"Example Output","text":"<p>The agent will provide a detailed analysis of undervalued ETFs, including:</p> <ul> <li> <p>Market analysis</p> </li> <li> <p>Performance metrics</p> </li> <li> <p>Risk assessment</p> </li> <li> <p>Investment recommendations</p> </li> </ul> <p>Note: Actual output will vary based on current market conditions and the model's training data.</p>"},{"location":"swarms/models/custom_model/","title":"How to Create A Custom Language Model","text":"<p>When working with advanced language models, there might come a time when you need a custom solution tailored to your specific needs. Inheriting from an <code>BaseLLM</code> in a Python framework allows developers to create custom language model classes with ease. This developer guide will take you through the process step by step.</p>"},{"location":"swarms/models/custom_model/#prerequisites","title":"Prerequisites","text":"<p>Before you begin, ensure that you have:</p> <ul> <li>A working knowledge of Python programming.</li> <li>Basic understanding of object-oriented programming (OOP) in Python.</li> <li>Familiarity with language models and natural language processing (NLP).</li> <li>The appropriate Python framework installed, with access to <code>BaseLLM</code>.</li> </ul>"},{"location":"swarms/models/custom_model/#step-by-step-guide","title":"Step-by-Step Guide","text":""},{"location":"swarms/models/custom_model/#step-1-understand-basellm","title":"Step 1: Understand <code>BaseLLM</code>","text":"<p>The <code>BaseLLM</code> is an abstract base class that defines a set of methods and properties which your custom language model (LLM) should implement. Abstract classes in Python are not designed to be instantiated directly but are meant to be subclasses.</p>"},{"location":"swarms/models/custom_model/#step-2-create-a-new-class","title":"Step 2: Create a New Class","text":"<p>Start by defining a new class that inherits from <code>BaseLLM</code>. This class will implement the required methods defined in the abstract base class.</p> <pre><code>from swarms import BaseLLM\n\nclass vLLMLM(BaseLLM):\n    pass\n</code></pre>"},{"location":"swarms/models/custom_model/#step-3-initialize-your-class","title":"Step 3: Initialize Your Class","text":"<p>Implement the <code>__init__</code> method to initialize your custom LLM. You'll want to initialize the base class as well and define any additional parameters for your model.</p> <pre><code>class vLLMLM(BaseLLM):\n    def __init__(self, model_name='default_model', tensor_parallel_size=1, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.model_name = model_name\n        self.tensor_parallel_size = tensor_parallel_size\n        # Add any additional initialization here\n</code></pre>"},{"location":"swarms/models/custom_model/#step-4-implement-required-methods","title":"Step 4: Implement Required Methods","text":"<p>Implement the <code>run</code> method or any other abstract methods required by <code>BaseLLM</code>. This is where you define how your model processes input and returns output.</p> <pre><code>class vLLMLM(BaseLLM):\n    # ... existing code ...\n\n    def run(self, task, *args, **kwargs):\n        # Logic for running your model goes here\n        return \"Processed output\"\n</code></pre>"},{"location":"swarms/models/custom_model/#step-5-test-your-model","title":"Step 5: Test Your Model","text":"<p>Instantiate your custom LLM and test it to ensure that it works as expected.</p> <pre><code>model = vLLMLM(model_name='my_custom_model', tensor_parallel_size=2)\noutput = model.run(\"What are the symptoms of COVID-19?\")\nprint(output)  # Outputs: \"Processed output\"\n</code></pre>"},{"location":"swarms/models/custom_model/#step-6-integrate-additional-components","title":"Step 6: Integrate Additional Components","text":"<p>Depending on the requirements, you might need to integrate additional components such as database connections, parallel computing resources, or custom processing pipelines.</p>"},{"location":"swarms/models/custom_model/#step-7-documentation","title":"Step 7: Documentation","text":"<p>Write comprehensive docstrings for your class and its methods. Good documentation is crucial for maintaining the code and for other developers who might use your model.</p> <pre><code>class vLLMLM(BaseLLM):\n    \"\"\"\n    A custom language model class that extends BaseLLM.\n\n    ... more detailed docstring ...\n    \"\"\"\n    # ... existing code ...\n</code></pre>"},{"location":"swarms/models/custom_model/#step-8-best-practices","title":"Step 8: Best Practices","text":"<p>Follow best practices such as error handling, input validation, and resource management to ensure your model is robust and reliable.</p>"},{"location":"swarms/models/custom_model/#step-9-packaging-your-model","title":"Step 9: Packaging Your Model","text":"<p>Package your custom LLM class into a module or package that can be easily distributed and imported into other projects.</p>"},{"location":"swarms/models/custom_model/#step-10-version-control-and-collaboration","title":"Step 10: Version Control and Collaboration","text":"<p>Use a version control system like Git to track changes to your model. This makes collaboration easier and helps you keep a history of your work.</p>"},{"location":"swarms/models/custom_model/#conclusion","title":"Conclusion","text":"<p>By following this guide, you should now have a custom model that extends the <code>BaseLLM</code>. Remember that the key to a successful custom LLM is understanding the base functionalities, implementing necessary changes, and testing thoroughly. Keep iterating and improving based on feedback and performance metrics.</p>"},{"location":"swarms/models/custom_model/#further-reading","title":"Further Reading","text":"<ul> <li>Official Python documentation on abstract base classes.</li> <li>In-depth tutorials on object-oriented programming in Python.</li> <li>Advanced NLP techniques and optimization strategies for language models.</li> </ul> <p>This guide provides the fundamental steps to create custom models using <code>BaseLLM</code>. For detailed implementation and advanced customization, it's essential to dive deeper into the specific functionalities and capabilities of the language model framework you are using.</p>"},{"location":"swarms/models/dalle3/","title":"<code>Dalle3</code> Documentation","text":""},{"location":"swarms/models/dalle3/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Installation</li> <li>Quick Start</li> <li>Dalle3 Class<ul> <li>Attributes</li> <li>Methods</li> </ul> </li> <li>Usage Examples</li> <li>Error Handling</li> <li>Advanced Usage</li> <li>References</li> </ol>"},{"location":"swarms/models/dalle3/#introduction","title":"Introduction","text":"<p>The Dalle3 library is a Python module that provides an easy-to-use interface for generating images from text descriptions using the DALL\u00b7E 3 model by OpenAI. DALL\u00b7E 3 is a powerful language model capable of converting textual prompts into images. This documentation will guide you through the installation, setup, and usage of the Dalle3 library.</p>"},{"location":"swarms/models/dalle3/#installation","title":"Installation","text":"<p>To use the Dalle3 model, you must first install swarms:</p> <pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/models/dalle3/#quick-start","title":"Quick Start","text":"<p>Let's get started with a quick example of using the Dalle3 library to generate an image from a text prompt:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class\ndalle = Dalle3()\n\n# Define a text prompt\ntask = \"A painting of a dog\"\n\n# Generate an image from the text prompt\nimage_url = dalle3(task)\n\n# Print the generated image URL\nprint(image_url)\n</code></pre> <p>This example demonstrates the basic usage of the Dalle3 library to convert a text prompt into an image. The generated image URL will be printed to the console.</p>"},{"location":"swarms/models/dalle3/#dalle3-class","title":"Dalle3 Class","text":"<p>The Dalle3 library provides a <code>Dalle3</code> class that allows you to interact with the DALL\u00b7E 3 model. This class has several attributes and methods for generating images from text prompts.</p>"},{"location":"swarms/models/dalle3/#attributes","title":"Attributes","text":"<ul> <li><code>model</code> (str): The name of the DALL\u00b7E 3 model. Default: \"dall-e-3\".</li> <li><code>img</code> (str): The image URL generated by the Dalle3 API.</li> <li><code>size</code> (str): The size of the generated image. Default: \"1024x1024\".</li> <li><code>max_retries</code> (int): The maximum number of API request retries. Default: 3.</li> <li><code>quality</code> (str): The quality of the generated image. Default: \"standard\".</li> <li><code>n</code> (int): The number of variations to create. Default: 4.</li> </ul>"},{"location":"swarms/models/dalle3/#methods","title":"Methods","text":""},{"location":"swarms/models/dalle3/#__call__self-task-str-dalle3","title":"<code>__call__(self, task: str) -&gt; Dalle3</code>","text":"<p>This method makes a call to the Dalle3 API and returns the image URL generated from the provided text prompt.</p> <p>Parameters: - <code>task</code> (str): The text prompt to be converted to an image.</p> <p>Returns: - <code>Dalle3</code>: An instance of the Dalle3 class with the image URL generated by the Dalle3 API.</p>"},{"location":"swarms/models/dalle3/#create_variationsself-img-str","title":"<code>create_variations(self, img: str)</code>","text":"<p>This method creates variations of an image using the Dalle3 API.</p> <p>Parameters: - <code>img</code> (str): The image to be used for the API request.</p> <p>Returns: - <code>img</code> (str): The image URL of the generated variations.</p>"},{"location":"swarms/models/dalle3/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/models/dalle3/#example-1-basic-image-generation","title":"Example 1: Basic Image Generation","text":"<pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class\ndalle3 = Dalle3()\n\n# Define a text prompt\ntask = \"A painting of a dog\"\n\n# Generate an image from the text prompt\nimage_url = dalle3(task)\n\n# Print the generated image URL\nprint(image_url)\n</code></pre>"},{"location":"swarms/models/dalle3/#example-2-creating-image-variations","title":"Example 2: Creating Image Variations","text":"<pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class\ndalle3 = Dalle3()\n\n# Define the URL of an existing image\nimg_url = \"https://images.unsplash.com/photo-1694734479898-6ac4633158ac?q=80&amp;w=1287&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\n\n# Create variations of the image\nvariations_url = dalle3.create_variations(img_url)\n\n# Print the URLs of the generated variations\nprint(variations_url)\n</code></pre> <p>Certainly! Here are additional examples that cover various edge cases and methods of the <code>Dalle3</code> class in the Dalle3 library:</p>"},{"location":"swarms/models/dalle3/#example-3-customizing-image-size","title":"Example 3: Customizing Image Size","text":"<p>You can customize the size of the generated image by specifying the <code>size</code> parameter when creating an instance of the <code>Dalle3</code> class. Here's how to generate a smaller image:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class with a custom image size\ndalle3 = Dalle3(size=\"512x512\")\n\n# Define a text prompt\ntask = \"A small painting of a cat\"\n\n# Generate a smaller image from the text prompt\nimage_url = dalle3(task)\n\n# Print the generated image URL\nprint(image_url)\n</code></pre>"},{"location":"swarms/models/dalle3/#example-4-adjusting-retry-limit","title":"Example 4: Adjusting Retry Limit","text":"<p>You can adjust the maximum number of API request retries using the <code>max_retries</code> parameter. Here's how to increase the retry limit:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class with a higher retry limit\ndalle3 = Dalle3(max_retries=5)\n\n# Define a text prompt\ntask = \"An image of a landscape\"\n\n# Generate an image with a higher retry limit\nimage_url = dalle3(task)\n\n# Print the generated image URL\nprint(image_url)\n</code></pre>"},{"location":"swarms/models/dalle3/#example-5-generating-image-variations","title":"Example 5: Generating Image Variations","text":"<p>To create variations of an existing image, you can use the <code>create_variations</code> method. Here's an example:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class\ndalle3 = Dalle3()\n\n# Define the URL of an existing image\nimg_url = \"https://images.unsplash.com/photo-1677290043066-12eccd944004?q=80&amp;w=1287&amp;auto=format&amp;fit=crop&amp;ixlib=rb-4.0.3&amp;ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D\"\n\n# Create variations of the image\nvariations_url = dalle3.create_variations(img_url)\n\n# Print the URLs of the generated variations\nprint(variations_url)\n</code></pre>"},{"location":"swarms/models/dalle3/#example-6-handling-api-errors","title":"Example 6: Handling API Errors","text":"<p>The Dalle3 library provides error handling for API-related issues. Here's how to handle and display API errors:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class\ndalle3 = Dalle3()\n\n# Define a text prompt\ntask = \"Invalid prompt that may cause an API error\"\n\ntry:\n    # Attempt to generate an image with an invalid prompt\n    image_url = dalle3(task)\n    print(image_url)\nexcept Exception as e:\n    print(f\"Error occurred: {str(e)}\")\n</code></pre>"},{"location":"swarms/models/dalle3/#example-7-customizing-image-quality","title":"Example 7: Customizing Image Quality","text":"<p>You can customize the quality of the generated image by specifying the <code>quality</code> parameter. Here's how to generate a high-quality image:</p> <pre><code>from swarm_models.dalle3 import Dalle3\n\n# Create an instance of the Dalle3 class with high quality\ndalle3 = Dalle3(quality=\"high\")\n\n# Define a text prompt\ntask = \"A high-quality image of a sunset\"\n\n# Generate a high-quality image from the text prompt\nimage_url = dalle3(task)\n\n# Print the generated image URL\nprint(image_url)\n</code></pre>"},{"location":"swarms/models/dalle3/#error-handling","title":"Error Handling","text":"<p>The Dalle3 library provides error handling for API-related issues. If an error occurs during API communication, the library will handle it and provide detailed error messages. Make sure to handle exceptions appropriately in your code.</p>"},{"location":"swarms/models/dalle3/#advanced-usage","title":"Advanced Usage","text":"<p>For advanced usage and customization of the Dalle3 library, you can explore the attributes and methods of the <code>Dalle3</code> class. Adjusting parameters such as <code>size</code>, <code>max_retries</code>, and <code>quality</code> allows you to fine-tune the image generation process to your specific needs.</p>"},{"location":"swarms/models/dalle3/#references","title":"References","text":"<p>For more information about the DALL\u00b7E 3 model and the Dalle3 library, you can refer to the official OpenAI documentation and resources.</p> <ul> <li>OpenAI API Documentation</li> <li>DALL\u00b7E 3 Model Information</li> <li>Dalle3 GitHub Repository</li> </ul> <p>This concludes the documentation for the Dalle3 library. You can now use the library to generate images from text prompts and explore its advanced features for various applications.</p>"},{"location":"swarms/models/distilled_whisperx/","title":"DistilWhisperModel Documentation","text":""},{"location":"swarms/models/distilled_whisperx/#overview","title":"Overview","text":"<p>The <code>DistilWhisperModel</code> is a Python class designed to handle English speech recognition tasks. It leverages the capabilities of the Whisper model, which is fine-tuned for speech-to-text processes. It is designed for both synchronous and asynchronous transcription of audio inputs, offering flexibility for real-time applications or batch processing.</p>"},{"location":"swarms/models/distilled_whisperx/#installation","title":"Installation","text":"<p>Before you can use <code>DistilWhisperModel</code>, ensure you have the required libraries installed:</p> <pre><code>pip3 install --upgrade swarms\n</code></pre>"},{"location":"swarms/models/distilled_whisperx/#initialization","title":"Initialization","text":"<p>The <code>DistilWhisperModel</code> class is initialized with the following parameters:</p> Parameter Type Description Default <code>model_id</code> <code>str</code> The identifier for the pre-trained Whisper model <code>\"distil-whisper/distil-large-v2\"</code> <p>Example of initialization:</p> <pre><code>from swarm_models import DistilWhisperModel\n\n# Initialize with default model\nmodel_wrapper = DistilWhisperModel()\n\n# Initialize with a specific model ID\nmodel_wrapper = DistilWhisperModel(model_id=\"distil-whisper/distil-large-v2\")\n</code></pre>"},{"location":"swarms/models/distilled_whisperx/#attributes","title":"Attributes","text":"<p>After initialization, the <code>DistilWhisperModel</code> has several attributes:</p> Attribute Type Description <code>device</code> <code>str</code> The device used for computation (<code>\"cuda:0\"</code> for GPU or <code>\"cpu\"</code>). <code>torch_dtype</code> <code>torch.dtype</code> The data type used for the Torch tensors. <code>model_id</code> <code>str</code> The model identifier string. <code>model</code> <code>torch.nn.Module</code> The actual Whisper model loaded from the identifier. <code>processor</code> <code>transformers.AutoProcessor</code> The processor for handling input data."},{"location":"swarms/models/distilled_whisperx/#methods","title":"Methods","text":""},{"location":"swarms/models/distilled_whisperx/#transcribe","title":"<code>transcribe</code>","text":"<p>Transcribes audio input synchronously.</p> <p>Arguments:</p> Argument Type Description <code>inputs</code> <code>Union[str, dict]</code> File path or audio data dictionary. <p>Returns: <code>str</code> - The transcribed text.</p> <p>Usage Example:</p> <pre><code># Synchronous transcription\ntranscription = model_wrapper.transcribe(\"path/to/audio.mp3\")\nprint(transcription)\n</code></pre>"},{"location":"swarms/models/distilled_whisperx/#async_transcribe","title":"<code>async_transcribe</code>","text":"<p>Transcribes audio input asynchronously.</p> <p>Arguments:</p> Argument Type Description <code>inputs</code> <code>Union[str, dict]</code> File path or audio data dictionary. <p>Returns: <code>Coroutine</code> - A coroutine that when awaited, returns the transcribed text.</p> <p>Usage Example:</p> <pre><code>import asyncio\n\n# Asynchronous transcription\ntranscription = asyncio.run(model_wrapper.async_transcribe(\"path/to/audio.mp3\"))\nprint(transcription)\n</code></pre>"},{"location":"swarms/models/distilled_whisperx/#real_time_transcribe","title":"<code>real_time_transcribe</code>","text":"<p>Simulates real-time transcription of an audio file.</p> <p>Arguments:</p> Argument Type Description <code>audio_file_path</code> <code>str</code> Path to the audio file. <code>chunk_duration</code> <code>int</code> Duration of audio chunks in seconds. <p>Usage Example:</p> <pre><code># Real-time transcription simulation\nmodel_wrapper.real_time_transcribe(\"path/to/audio.mp3\", chunk_duration=5)\n</code></pre>"},{"location":"swarms/models/distilled_whisperx/#error-handling","title":"Error Handling","text":"<p>The <code>DistilWhisperModel</code> class incorporates error handling for file not found errors and generic exceptions during the transcription process. If a non-recoverable exception is raised, it is printed to the console in red to indicate failure.</p>"},{"location":"swarms/models/distilled_whisperx/#conclusion","title":"Conclusion","text":"<p>The <code>DistilWhisperModel</code> offers a convenient interface to the powerful Whisper model for speech recognition. Its design supports both batch and real-time transcription, catering to different application needs. The class's error handling and retry logic make it robust for real-world applications.</p>"},{"location":"swarms/models/distilled_whisperx/#additional-notes","title":"Additional Notes","text":"<ul> <li>Ensure you have appropriate permissions to read audio files when using file paths.</li> <li>Transcription quality depends on the audio quality and the Whisper model's performance on your dataset.</li> <li>Adjust <code>chunk_duration</code> according to the processing power of your system for real-time transcription.</li> </ul> <p>For a full list of models supported by <code>transformers.AutoModelForSpeechSeq2Seq</code>, visit the Hugging Face Model Hub.</p>"},{"location":"swarms/models/fuyu/","title":"Fuyu Documentation","text":""},{"location":"swarms/models/fuyu/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for Fuyu, a versatile model for generating text conditioned on both textual prompts and images. Fuyu is based on the Adept's Fuyu model and offers a convenient way to create text that is influenced by the content of an image. In this documentation, you will find comprehensive information on the Fuyu class, its architecture, usage, and examples.</p>"},{"location":"swarms/models/fuyu/#overview","title":"Overview","text":"<p>Fuyu is a text generation model that leverages both text and images to generate coherent and contextually relevant text. It combines state-of-the-art language modeling techniques with image processing capabilities to produce text that is semantically connected to the content of an image. Whether you need to create captions for images or generate text that describes visual content, Fuyu can assist you.</p>"},{"location":"swarms/models/fuyu/#class-definition","title":"Class Definition","text":"<pre><code>class Fuyu:\n    def __init__(\n        self,\n        pretrained_path: str = \"adept/fuyu-8b\",\n        device_map: str = \"cuda:0\",\n        max_new_tokens: int = 7,\n    ):\n</code></pre>"},{"location":"swarms/models/fuyu/#purpose","title":"Purpose","text":"<p>The Fuyu class serves as a convenient interface for using the Adept's Fuyu model. It allows you to generate text based on a textual prompt and an image. The primary purpose of Fuyu is to provide a user-friendly way to create text that is influenced by visual content, making it suitable for various applications, including image captioning, storytelling, and creative text generation.</p>"},{"location":"swarms/models/fuyu/#parameters","title":"Parameters","text":"<ul> <li><code>pretrained_path</code> (str): The path to the pretrained Fuyu model. By default, it uses the \"adept/fuyu-8b\" model.</li> <li><code>device_map</code> (str): The device to use for model inference (e.g., \"cuda:0\" for GPU or \"cpu\" for CPU). Default: \"cuda:0\".</li> <li><code>max_new_tokens</code> (int): The maximum number of tokens to generate in the output text. Default: 7.</li> </ul>"},{"location":"swarms/models/fuyu/#usage","title":"Usage","text":"<p>To use Fuyu, follow these steps:</p> <ol> <li>Initialize the Fuyu instance:</li> </ol> <pre><code>from swarm_models.fuyu import Fuyu\n\nfuyu = Fuyu()\n</code></pre> <ol> <li>Generate Text with Fuyu:</li> </ol> <pre><code>text = \"Hello, my name is\"\nimg_path = \"path/to/image.png\"\noutput_text = fuyu(text, img_path)\n</code></pre>"},{"location":"swarms/models/fuyu/#example-2-text-generation","title":"Example 2 - Text Generation","text":"<pre><code>from swarm_models.fuyu import Fuyu\n\nfuyu = Fuyu()\n\ntext = \"Hello, my name is\"\n\nimg_path = \"path/to/image.png\"\n\noutput_text = fuyu(text, img_path)\nprint(output_text)\n</code></pre>"},{"location":"swarms/models/fuyu/#how-fuyu-works","title":"How Fuyu Works","text":"<p>Fuyu combines text and image processing to generate meaningful text outputs. Here's how it works:</p> <ol> <li> <p>Initialization: When you create a Fuyu instance, you specify the pretrained model path, the device for inference, and the maximum number of tokens to generate.</p> </li> <li> <p>Processing Text and Images: Fuyu can process both textual prompts and images. You provide a text prompt and the path to an image as input.</p> </li> <li> <p>Tokenization: Fuyu tokenizes the input text and encodes the image using its tokenizer.</p> </li> <li> <p>Model Inference: The model takes the tokenized inputs and generates text that is conditioned on both the text and the image.</p> </li> <li> <p>Output Text: Fuyu returns the generated text as the output.</p> </li> </ol>"},{"location":"swarms/models/fuyu/#additional-information","title":"Additional Information","text":"<ul> <li>Fuyu uses the Adept's Fuyu model, which is pretrained on a large corpus of text and images, making it capable of generating coherent and contextually relevant text.</li> <li>You can specify the device for inference to utilize GPU acceleration if available.</li> <li>The <code>max_new_tokens</code> parameter allows you to control the length of the generated text.</li> </ul> <p>That concludes the documentation for Fuyu. We hope you find this model useful for your text generation tasks that involve images. If you have any questions or encounter any issues, please refer to the Fuyu documentation for further assistance. Enjoy working with Fuyu!</p>"},{"location":"swarms/models/gemini/","title":"Gemini","text":""},{"location":"swarms/models/gemini/#gemini-documentation","title":"<code>Gemini</code> Documentation","text":""},{"location":"swarms/models/gemini/#introduction","title":"Introduction","text":"<p>The Gemini module is a versatile tool for leveraging the power of multimodal AI models to generate content. It allows users to combine textual and image inputs to generate creative and informative outputs. In this documentation, we will explore the Gemini module in detail, covering its purpose, architecture, methods, and usage examples.</p>"},{"location":"swarms/models/gemini/#purpose","title":"Purpose","text":"<p>The Gemini module is designed to bridge the gap between text and image data, enabling users to harness the capabilities of multimodal AI models effectively. By providing both a textual task and an image as input, Gemini generates content that aligns with the specified task and incorporates the visual information from the image.</p>"},{"location":"swarms/models/gemini/#installation","title":"Installation","text":"<p>Before using Gemini, ensure that you have the required dependencies installed. You can install them using the following commands:</p> <pre><code>pip install swarms\npip install google-generativeai\npip install python-dotenv\n</code></pre>"},{"location":"swarms/models/gemini/#class-gemini","title":"Class: Gemini","text":""},{"location":"swarms/models/gemini/#overview","title":"Overview","text":"<p>The <code>Gemini</code> class is the central component of the Gemini module. It inherits from the <code>BaseMultiModalModel</code> class and provides methods to interact with the Gemini AI model. Let's dive into its architecture and functionality.</p>"},{"location":"swarms/models/gemini/#class-constructor","title":"Class Constructor","text":"<pre><code>class Gemini(BaseMultiModalModel):\n    def __init__(\n        self,\n        model_name: str = \"gemini-pro\",\n        gemini_api_key: str = get_gemini_api_key_env,\n        *args,\n        **kwargs,\n    ):\n</code></pre> Parameter Type Description Default Value <code>model_name</code> str The name of the Gemini model. \"gemini-pro\" <code>gemini_api_key</code> str The Gemini API key. If not provided, it is fetched from the environment. (None) <ul> <li> <p><code>model_name</code>: Specifies the name of the Gemini model to use. By default, it is set to \"gemini-pro,\" but you can specify a different model if needed.</p> </li> <li> <p><code>gemini_api_key</code>: This parameter allows you to provide your Gemini API key directly. If not provided, the constructor attempts to fetch it from the environment using the <code>get_gemini_api_key_env</code> helper function.</p> </li> </ul>"},{"location":"swarms/models/gemini/#methods","title":"Methods","text":"<ol> <li>run()</li> </ol> <pre><code>def run(\n    self,\n    task: str = None,\n    img: str = None,\n    *args,\n    **kwargs,\n) -&gt; str:\n</code></pre> Parameter Type Description <code>task</code> str The textual task for content generation. <code>img</code> str The path to the image to be processed. <code>*args</code> Variable Additional positional arguments. <code>**kwargs</code> Variable Additional keyword arguments. <ul> <li> <p><code>task</code>: Specifies the textual task for content generation. It can be a sentence or a phrase that describes the desired content.</p> </li> <li> <p><code>img</code>: Provides the path to the image that will be processed along with the textual task. Gemini combines the visual information from the image with the textual task to generate content.</p> </li> <li> <p><code>*args</code> and <code>**kwargs</code>: Allow for additional, flexible arguments that can be passed to the underlying Gemini model. These arguments can vary based on the specific Gemini model being used.</p> </li> </ul> <p>Returns: A string containing the generated content.</p> <p>Examples:</p> <pre><code>from swarm_models import Gemini\n\n# Initialize the Gemini model\ngemini = Gemini()\n\n# Generate content for a textual task with an image\ngenerated_content = gemini.run(\n    task=\"Describe this image\",\n    img=\"image.jpg\",\n)\n\n# Print the generated content\nprint(generated_content)\n</code></pre> <p>In this example, we initialize the Gemini model, provide a textual task, and specify an image for processing. The <code>run()</code> method generates content based on the input and returns the result.</p> <ol> <li>process_img()</li> </ol> <pre><code>def process_img(\n    self,\n    img: str = None,\n    type: str = \"image/png\",\n    *args,\n    **kwargs,\n):\n</code></pre> Parameter Type Description Default Value <code>img</code> str The path to the image to be processed. (None) <code>type</code> str The MIME type of the image (e.g., \"image/png\"). \"image/png\" <code>*args</code> Variable Additional positional arguments. <code>**kwargs</code> Variable Additional keyword arguments. <ul> <li> <p><code>img</code>: Specifies the path to the image that will be processed. It's essential to provide a valid image path for image-based content generation.</p> </li> <li> <p><code>type</code>: Indicates the MIME type of the image. By default, it is set to \"image/png,\" but you can change it based on the image format you're using.</p> </li> <li> <p><code>*args</code> and <code>**kwargs</code>: Allow for additional, flexible arguments that can be passed to the underlying Gemini model. These arguments can vary based on the specific Gemini model being used.</p> </li> </ul> <p>Raises: ValueError if any of the following conditions are met:    - No image is provided.    - The image type is not specified.    - The Gemini API key is missing.</p> <p>Examples:</p> <pre><code>from swarm_models.gemini import Gemini\n\n# Initialize the Gemini model\ngemini = Gemini()\n\n# Process an image\nprocessed_image = gemini.process_img(\n    img=\"image.jpg\",\n    type=\"image/jpeg\",\n)\n\n# Further use the processed image in content generation\ngenerated_content = gemini.run(\n    task=\"Describe this image\",\n    img=processed_image,\n)\n\n# Print the generated content\nprint(generated_content)\n</code></pre> <p>In this example, we demonstrate how to process an image using the <code>process_img()</code> method and then use the processed image in content generation.</p>"},{"location":"swarms/models/gemini/#additional-information","title":"Additional Information","text":"<ul> <li> <p>Gemini is designed to work seamlessly with various multimodal AI models, making it a powerful tool for content generation tasks.</p> </li> <li> <p>The module uses the <code>google.generativeai</code> package to access the underlying AI models. Ensure that you have this package installed to leverage the full capabilities of Gemini.</p> </li> <li> <p>It's essential to provide a valid Gemini API key for authentication. You can either pass it directly during initialization or store it in the environment variable \"GEMINI_API_KEY.\"</p> </li> <li> <p>Gemini's flexibility allows you to experiment with different Gemini models and tailor the content generation process to your specific needs.</p> </li> <li> <p>Keep in mind that Gemini is designed to handle both textual and image inputs, making it a valuable asset for various applications, including natural language processing and computer vision tasks.</p> </li> <li> <p>If you encounter any issues or have specific requirements, refer to the Gemini documentation for more details and advanced usage.</p> </li> </ul>"},{"location":"swarms/models/gemini/#references-and-resources","title":"References and Resources","text":"<ul> <li> <p>Gemini GitHub Repository: Explore the Gemini repository for additional information, updates, and examples.</p> </li> <li> <p>Google GenerativeAI Documentation: Dive deeper into the capabilities of the Google GenerativeAI package used by Gemini.</p> </li> <li> <p>Gemini API Documentation: Access the official documentation for the Gemini API to explore advanced features and integrations.</p> </li> </ul>"},{"location":"swarms/models/gemini/#conclusion","title":"Conclusion","text":"<p>In this comprehensive documentation, we've explored the Gemini module, its purpose, architecture, methods, and usage examples. Gemini empowers developers to generate content by combining textual tasks and images, making it a valuable asset for multimodal AI applications. Whether you're working on natural language processing or computer vision projects, Gemini can help you achieve impressive results.</p>"},{"location":"swarms/models/gpt4v/","title":"<code>GPT4VisionAPI</code> Documentation","text":"<p>Table of Contents - Introduction - Installation - Module Overview - Class: GPT4VisionAPI   - Initialization   - Methods     - encode_image     - run     - call - Examples   - Example 1: Basic Usage   - Example 2: Custom API Key   - Example 3: Adjusting Maximum Tokens - Additional Information - References</p>"},{"location":"swarms/models/gpt4v/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for the <code>GPT4VisionAPI</code> module! This module is a powerful wrapper for the OpenAI GPT-4 Vision model. It allows you to interact with the model to generate descriptions or answers related to images. This documentation will provide you with comprehensive information on how to use this module effectively.</p>"},{"location":"swarms/models/gpt4v/#installation","title":"Installation","text":"<p>Before you start using the <code>GPT4VisionAPI</code> module, make sure you have the required dependencies installed. You can install them using the following commands:</p> <pre><code>pip3 install --upgrade swarms\n</code></pre>"},{"location":"swarms/models/gpt4v/#module-overview","title":"Module Overview","text":"<p>The <code>GPT4VisionAPI</code> module serves as a bridge between your application and the OpenAI GPT-4 Vision model. It allows you to send requests to the model and retrieve responses related to images. Here are some key features and functionality provided by this module:</p> <ul> <li>Encoding images to base64 format.</li> <li>Running the GPT-4 Vision model with specified tasks and images.</li> <li>Customization options such as setting the OpenAI API key and maximum token limit.</li> </ul>"},{"location":"swarms/models/gpt4v/#class-gpt4visionapi","title":"Class: GPT4VisionAPI","text":"<p>The <code>GPT4VisionAPI</code> class is the core component of this module. It encapsulates the functionality required to interact with the GPT-4 Vision model. Below, we'll dive into the class in detail.</p>"},{"location":"swarms/models/gpt4v/#initialization","title":"Initialization","text":"<p>When initializing the <code>GPT4VisionAPI</code> class, you have the option to provide the OpenAI API key and set the maximum token limit. Here are the parameters and their descriptions:</p> Parameter Type Default Value Description openai_api_key str <code>OPENAI_API_KEY</code> environment variable (if available) The OpenAI API key. If not provided, it defaults to the <code>OPENAI_API_KEY</code> environment variable. max_tokens int 300 The maximum number of tokens to generate in the model's response. <p>Here's how you can initialize the <code>GPT4VisionAPI</code> class:</p> <pre><code>from swarm_models import GPT4VisionAPI\n\n# Initialize with default API key and max_tokens\napi = GPT4VisionAPI()\n\n# Initialize with custom API key and max_tokens\ncustom_api_key = \"your_custom_api_key\"\napi = GPT4VisionAPI(openai_api_key=custom_api_key, max_tokens=500)\n</code></pre>"},{"location":"swarms/models/gpt4v/#methods","title":"Methods","text":""},{"location":"swarms/models/gpt4v/#encode_image","title":"encode_image","text":"<p>This method allows you to encode an image from a URL to base64 format. It's a utility function used internally by the module.</p> <pre><code>def encode_image(img: str) -&gt; str:\n    \"\"\"\n    Encode image to base64.\n\n    Parameters:\n    - img (str): URL of the image to encode.\n\n    Returns:\n    str: Base64 encoded image.\n    \"\"\"\n</code></pre>"},{"location":"swarms/models/gpt4v/#run","title":"run","text":"<p>The <code>run</code> method is the primary way to interact with the GPT-4 Vision model. It sends a request to the model with a task and an image URL, and it returns the model's response.</p> <pre><code>def run(task: str, img: str) -&gt; str:\n    \"\"\"\n    Run the GPT-4 Vision model.\n\n    Parameters:\n    - task (str): The task or question related to the image.\n    - img (str): URL of the image to analyze.\n\n    Returns:\n    str: The model's response.\n    \"\"\"\n</code></pre>"},{"location":"swarms/models/gpt4v/#call","title":"call","text":"<p>The <code>__call__</code> method is a convenient way to run the GPT-4 Vision model. It has the same functionality as the <code>run</code> method.</p> <pre><code>def __call__(task: str, img: str) -&gt; str:\n    \"\"\"\n       Run the GPT-4 Vision model (callable).\n\n       Parameters:\n       - task (str): The task or question related to the image.\n       - img\n\n    (str): URL of the image to analyze.\n\n       Returns:\n       str: The model's response.\n    \"\"\"\n</code></pre>"},{"location":"swarms/models/gpt4v/#examples","title":"Examples","text":"<p>Let's explore some usage examples of the <code>GPT4VisionAPI</code> module to better understand how to use it effectively.</p>"},{"location":"swarms/models/gpt4v/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<p>In this example, we'll use the module with the default API key and maximum tokens to analyze an image.</p> <pre><code>from swarm_models import GPT4VisionAPI\n\n# Initialize with default API key and max_tokens\napi = GPT4VisionAPI()\n\n# Define the task and image URL\ntask = \"What is the color of the object?\"\nimg = \"https://i.imgur.com/2M2ZGwC.jpeg\"\n\n# Run the GPT-4 Vision model\nresponse = api.run(task, img)\n\n# Print the model's response\nprint(response)\n</code></pre>"},{"location":"swarms/models/gpt4v/#example-2-custom-api-key","title":"Example 2: Custom API Key","text":"<p>If you have a custom API key, you can initialize the module with it as shown in this example.</p> <pre><code>from swarm_models import GPT4VisionAPI\n\n# Initialize with custom API key and max_tokens\ncustom_api_key = \"your_custom_api_key\"\napi = GPT4VisionAPI(openai_api_key=custom_api_key, max_tokens=500)\n\n# Define the task and image URL\ntask = \"What is the object in the image?\"\nimg = \"https://i.imgur.com/3T3ZHwD.jpeg\"\n\n# Run the GPT-4 Vision model\nresponse = api.run(task, img)\n\n# Print the model's response\nprint(response)\n</code></pre>"},{"location":"swarms/models/gpt4v/#example-3-adjusting-maximum-tokens","title":"Example 3: Adjusting Maximum Tokens","text":"<p>You can also customize the maximum token limit when initializing the module. In this example, we set it to 1000 tokens.</p> <pre><code>from swarm_models import GPT4VisionAPI\n\n# Initialize with default API key and custom max_tokens\napi = GPT4VisionAPI(max_tokens=1000)\n\n# Define the task and image URL\ntask = \"Describe the scene in the image.\"\nimg = \"https://i.imgur.com/4P4ZRxU.jpeg\"\n\n# Run the GPT-4 Vision model\nresponse = api.run(task, img)\n\n# Print the model's response\nprint(response)\n</code></pre>"},{"location":"swarms/models/gpt4v/#additional-information","title":"Additional Information","text":"<ul> <li>If you encounter any errors or issues with the module, make sure to check your API key and internet connectivity.</li> <li>It's recommended to handle exceptions when using the module to gracefully handle errors.</li> <li>You can further customize the module to fit your specific use case by modifying the code as needed.</li> </ul>"},{"location":"swarms/models/gpt4v/#references","title":"References","text":"<ul> <li>OpenAI API Documentation</li> </ul> <p>This documentation provides a comprehensive guide on how to use the <code>GPT4VisionAPI</code> module effectively. It covers initialization, methods, usage examples, and additional information to ensure a smooth experience when working with the GPT-4 Vision model.</p>"},{"location":"swarms/models/groq/","title":"Groq API Key Setup Documentation","text":"<p>This documentation provides instructions on how to obtain your Groq API key and set it up in a <code>.env</code> file for use in your project.</p>"},{"location":"swarms/models/groq/#step-1-obtain-your-groq-api-key","title":"Step 1: Obtain Your Groq API Key","text":"<ol> <li>Sign Up / Log In: </li> <li> <p>Visit the Groq website and sign up for an account if you don't have one. If you already have an account, log in.</p> </li> <li> <p>Access API Keys:</p> </li> <li> <p>Once logged in, navigate to the API section of your account dashboard. This is usually found under \"Settings\" or \"API Management\".</p> </li> <li> <p>Generate API Key:</p> </li> <li>If you do not have an API key, look for an option to generate a new key. Follow the prompts to create your API key. Make sure to copy it to your clipboard.</li> </ol>"},{"location":"swarms/models/groq/#step-2-create-a-env-file","title":"Step 2: Create a <code>.env</code> File","text":"<ol> <li>Create the File:</li> <li> <p>In the root directory of your project, create a new file named <code>.env</code>.</p> </li> <li> <p>Add Your API Key:</p> </li> <li>Open the <code>.env</code> file in a text editor and add the following line, replacing <code>your_groq_api_key_here</code> with the API key you copied earlier:</li> </ol> <pre><code>GROQ_API_KEY=your_groq_api_key_here\n</code></pre> <ol> <li>Save the File:</li> <li>Save the changes to the <code>.env</code> file.</li> </ol>"},{"location":"swarms/models/groq/#full-example","title":"Full Example","text":"<pre><code>import os\nfrom swarm_models import OpenAIChat\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\nmodel.run(\"What are the best metrics to track and understand risk in private equity\")\n</code></pre>"},{"location":"swarms/models/groq/#important-notes","title":"Important Notes","text":"<ul> <li>Keep Your API Key Secure: Do not share your API key publicly or commit it to version control systems like Git. Use the <code>.gitignore</code> file to exclude the <code>.env</code> file from being tracked.</li> <li>Environment Variables: Make sure to install any necessary libraries (like <code>python-dotenv</code>) to load environment variables from the <code>.env</code> file if your project requires it.</li> </ul>"},{"location":"swarms/models/groq/#conclusion","title":"Conclusion","text":"<p>You are now ready to use the Groq API in your project! If you encounter any issues, refer to the Groq documentation or support for further assistance.</p>"},{"location":"swarms/models/hf/","title":"HuggingFaceLLM","text":""},{"location":"swarms/models/hf/#overview-introduction","title":"Overview &amp; Introduction","text":"<p>The <code>HuggingFaceLLM</code> class in the Zeta library provides a simple and easy-to-use interface to harness the power of Hugging Face's transformer-based language models, specifically for causal language modeling. This enables developers to generate coherent and contextually relevant sentences or paragraphs given a prompt, without delving deep into the intricate details of the underlying model or the tokenization process.</p> <p>Causal Language Modeling (CLM) is a task where given a series of tokens (or words), the model predicts the next token in the sequence. This functionality is central to many natural language processing tasks, including chatbots, story generation, and code autocompletion.</p>"},{"location":"swarms/models/hf/#class-definition","title":"Class Definition","text":"<pre><code>class HuggingFaceLLM:\n</code></pre>"},{"location":"swarms/models/hf/#parameters","title":"Parameters:","text":"<ul> <li> <p><code>model_id (str)</code>: Identifier for the pre-trained model on the Hugging Face model hub. Examples include \"gpt2-medium\", \"openai-gpt\", etc.</p> </li> <li> <p><code>device (str, optional)</code>: The device on which to load and run the model. Defaults to 'cuda' if GPU is available, else 'cpu'.</p> </li> <li> <p><code>max_length (int, optional)</code>: Maximum length of the generated sequence. Defaults to 20.</p> </li> <li> <p><code>quantization_config (dict, optional)</code>: Configuration dictionary for model quantization (if applicable). Default is <code>None</code>.</p> </li> </ul>"},{"location":"swarms/models/hf/#functionality-usage","title":"Functionality &amp; Usage","text":""},{"location":"swarms/models/hf/#initialization","title":"Initialization:","text":"<pre><code>llm = HuggingFaceLLM(model_id=\"gpt2-medium\")\n</code></pre> <p>Upon initialization, the specified pre-trained model and tokenizer are loaded from Hugging Face's model hub. The model is then moved to the designated device. If there's an issue loading either the model or the tokenizer, an error will be logged.</p>"},{"location":"swarms/models/hf/#generation","title":"Generation:","text":"<p>The main functionality of this class is text generation. The class provides two methods for this: <code>__call__</code> and <code>generate</code>. Both methods take in a prompt text and an optional <code>max_length</code> parameter and return the generated text.</p> <p>Usage: <pre><code>from swarms import HuggingFaceLLM\n\n# Initialize\nllm = HuggingFaceLLM(model_id=\"gpt2-medium\")\n\n# Generate text using __call__ method\nresult = llm(\"Once upon a time,\")\nprint(result)\n\n# Alternatively, using the generate method\nresult = llm.generate(\"The future of AI is\")\nprint(result)\n</code></pre></p>"},{"location":"swarms/models/hf/#mathematical-explanation","title":"Mathematical Explanation:","text":"<p>Given a sequence of tokens \\( x_1, x_2, ..., x_n \\), a causal language model aims to maximize the likelihood of the next token \\( x_{n+1} \\) in the sequence. Formally, it tries to optimize:</p> \\[ P(x_{n+1} | x_1, x_2, ..., x_n) \\] <p>Where \\( P \\) is the probability distribution over all possible tokens in the vocabulary.</p> <p>The model takes the tokenized input sequence, feeds it through several transformer blocks, and finally through a linear layer to produce logits for each token in the vocabulary. The token with the highest logit value is typically chosen as the next token in the sequence.</p>"},{"location":"swarms/models/hf/#additional-information-tips","title":"Additional Information &amp; Tips:","text":"<ul> <li> <p>Ensure you have an active internet connection when initializing the class for the first time, as the models and tokenizers are fetched from Hugging Face's servers.</p> </li> <li> <p>Although the default <code>max_length</code> is set to 20, it's advisable to adjust this parameter based on the context of the problem.</p> </li> <li> <p>Keep an eye on GPU memory when using large models or generating long sequences.</p> </li> </ul>"},{"location":"swarms/models/hf/#references-resources","title":"References &amp; Resources:","text":"<ul> <li> <p>Hugging Face Model Hub: https://huggingface.co/models</p> </li> <li> <p>Introduction to Transformers: https://huggingface.co/transformers/introduction.html</p> </li> <li> <p>Causal Language Modeling: Vaswani, A., et al. (2017). Attention is All You Need. arXiv:1706.03762</p> </li> </ul> <p>Note: This documentation template provides a comprehensive overview of the <code>HuggingFaceLLM</code> class. Developers can follow similar structures when documenting other classes or functionalities.</p>"},{"location":"swarms/models/huggingface/","title":"Huggingface","text":""},{"location":"swarms/models/huggingface/#huggingfacellm-documentation","title":"<code>HuggingfaceLLM</code> Documentation","text":""},{"location":"swarms/models/huggingface/#introduction","title":"Introduction","text":"<p>The <code>HuggingfaceLLM</code> class is designed for running inference using models from the Hugging Face Transformers library. This documentation provides an in-depth understanding of the class, its purpose, attributes, methods, and usage examples.</p>"},{"location":"swarms/models/huggingface/#purpose","title":"Purpose","text":"<p>The <code>HuggingfaceLLM</code> class serves the following purposes:</p> <ol> <li>Load pre-trained Hugging Face models and tokenizers.</li> <li>Generate text-based responses from the loaded model using a given prompt.</li> <li>Provide flexibility in device selection, quantization, and other configuration options.</li> </ol>"},{"location":"swarms/models/huggingface/#class-definition","title":"Class Definition","text":"<p>The <code>HuggingfaceLLM</code> class is defined as follows:</p> <pre><code>class HuggingfaceLLM:\n    def __init__(\n        self,\n        model_id: str,\n        device: str = None,\n        max_length: int = 20,\n        quantize: bool = False,\n        quantization_config: dict = None,\n        verbose=False,\n        distributed=False,\n        decoding=False,\n    ):\n        # Attributes and initialization logic explained below\n        pass\n\n    def load_model(self):\n        # Method to load the pre-trained model and tokenizer\n        pass\n\n    def run(self, prompt_text: str, max_length: int = None):\n        # Method to generate text-based responses\n        pass\n\n    def __call__(self, prompt_text: str, max_length: int = None):\n        # Alternate method for generating text-based responses\n        pass\n</code></pre>"},{"location":"swarms/models/huggingface/#attributes","title":"Attributes","text":"Attribute Description <code>model_id</code> The ID of the pre-trained model to be used. <code>device</code> The device on which the model runs (<code>'cuda'</code> for GPU or <code>'cpu'</code> for CPU). <code>max_length</code> The maximum length of the generated text. <code>quantize</code> A boolean indicating whether quantization should be used. <code>quantization_config</code> A dictionary with configuration options for quantization. <code>verbose</code> A boolean indicating whether verbose logs should be printed. <code>logger</code> An optional logger for logging messages (defaults to a basic logger). <code>distributed</code> A boolean indicating whether distributed processing should be used. <code>decoding</code> A boolean indicating whether to perform decoding during text generation."},{"location":"swarms/models/huggingface/#class-methods","title":"Class Methods","text":""},{"location":"swarms/models/huggingface/#__init__-method","title":"<code>__init__</code> Method","text":"<p>The <code>__init__</code> method initializes an instance of the <code>HuggingfaceLLM</code> class with the specified parameters. It also loads the pre-trained model and tokenizer.</p> <ul> <li><code>model_id</code> (str): The ID of the pre-trained model to use.</li> <li><code>device</code> (str, optional): The device to run the model on ('cuda' or 'cpu').</li> <li><code>max_length</code> (int, optional): The maximum length of the generated text.</li> <li><code>quantize</code> (bool, optional): Whether to use quantization.</li> <li><code>quantization_config</code> (dict, optional): Configuration for quantization.</li> <li><code>verbose</code> (bool, optional): Whether to print verbose logs.</li> <li><code>logger</code> (logging.Logger, optional): The logger to use.</li> <li><code>distributed</code> (bool, optional): Whether to use distributed processing.</li> <li><code>decoding</code> (bool, optional): Whether to perform decoding during text generation.</li> </ul>"},{"location":"swarms/models/huggingface/#load_model-method","title":"<code>load_model</code> Method","text":"<p>The <code>load_model</code> method loads the pre-trained model and tokenizer specified by <code>model_id</code>.</p>"},{"location":"swarms/models/huggingface/#run-and-__call__-methods","title":"<code>run</code> and <code>__call__</code> Methods","text":"<p>Both <code>run</code> and <code>__call__</code> methods generate text-based responses based on a given prompt. They accept the following parameters:</p> <ul> <li><code>prompt_text</code> (str): The text prompt to initiate text generation.</li> <li><code>max_length</code> (int, optional): The maximum length of the generated text.</li> </ul>"},{"location":"swarms/models/huggingface/#usage-examples","title":"Usage Examples","text":"<p>Here are three ways to use the <code>HuggingfaceLLM</code> class:</p>"},{"location":"swarms/models/huggingface/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code>from swarm_models import HuggingfaceLLM\n\n# Initialize the HuggingfaceLLM instance with a model ID\nmodel_id = \"NousResearch/Nous-Hermes-2-Vision-Alpha\"\ninference = HuggingfaceLLM(model_id=model_id)\n\n# Generate text based on a prompt\nprompt_text = \"Once upon a time\"\ngenerated_text = inference(prompt_text)\nprint(generated_text)\n</code></pre>"},{"location":"swarms/models/huggingface/#example-2-custom-configuration","title":"Example 2: Custom Configuration","text":"<pre><code>from swarm_models import HuggingfaceLLM\n\n# Initialize with custom configuration\ncustom_config = {\n    \"quantize\": True,\n    \"quantization_config\": {\"load_in_4bit\": True},\n    \"verbose\": True,\n}\ninference = HuggingfaceLLM(\n    model_id=\"NousResearch/Nous-Hermes-2-Vision-Alpha\", **custom_config\n)\n\n# Generate text based on a prompt\nprompt_text = \"Tell me a joke\"\ngenerated_text = inference(prompt_text)\nprint(generated_text)\n</code></pre>"},{"location":"swarms/models/huggingface/#example-3-distributed-processing","title":"Example 3: Distributed Processing","text":"<pre><code>from swarm_models import HuggingfaceLLM\n\n# Initialize for distributed processing\ninference = HuggingfaceLLM(model_id=\"gpt2-medium\", distributed=True)\n\n# Generate text based on a prompt\nprompt_text = \"Translate the following sentence to French\"\ngenerated_text = inference(prompt_text)\nprint(generated_text)\n</code></pre>"},{"location":"swarms/models/huggingface/#additional-information","title":"Additional Information","text":"<ul> <li>The <code>HuggingfaceLLM</code> class provides the flexibility to load and use pre-trained models from the Hugging Face Transformers library.</li> <li>Quantization can be enabled to reduce model size and inference time.</li> <li>Distributed processing can be used for parallelized inference.</li> <li>Verbose logging can help in debugging and understanding the text generation process.</li> </ul>"},{"location":"swarms/models/huggingface/#references","title":"References","text":"<ul> <li>Hugging Face Transformers Documentation</li> <li>PyTorch Documentation</li> </ul> <p>This documentation provides a comprehensive understanding of the <code>HuggingfaceLLM</code> class, its attributes, methods, and usage examples. Developers can use this class to perform text generation tasks efficiently using pre-trained models from the Hugging Face Transformers library.</p>"},{"location":"swarms/models/idefics/","title":"<code>Idefics</code> Documentation","text":""},{"location":"swarms/models/idefics/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for Idefics, a versatile multimodal inference tool using pre-trained models from the Hugging Face Hub. Idefics is designed to facilitate the generation of text from various prompts, including text and images. This documentation provides a comprehensive understanding of Idefics, its architecture, usage, and how it can be integrated into your projects.</p>"},{"location":"swarms/models/idefics/#overview","title":"Overview","text":"<p>Idefics leverages the power of pre-trained models to generate textual responses based on a wide range of prompts. It is capable of handling both text and images, making it suitable for various multimodal tasks, including text generation from images.</p>"},{"location":"swarms/models/idefics/#class-definition","title":"Class Definition","text":"<pre><code>class Idefics:\n    def __init__(\n        self,\n        checkpoint=\"HuggingFaceM4/idefics-9b-instruct\",\n        device=None,\n        torch_dtype=torch.bfloat16,\n        max_length=100,\n    ):\n</code></pre>"},{"location":"swarms/models/idefics/#usage","title":"Usage","text":"<p>To use Idefics, follow these steps:</p> <ol> <li>Initialize the Idefics instance:</li> </ol> <pre><code>from swarm_models import Idefics\n\nmodel = Idefics()\n</code></pre> <ol> <li>Generate text based on prompts:</li> </ol> <pre><code>prompts = [\n    \"User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG\"\n]\nresponse = model(prompts)\nprint(response)\n</code></pre>"},{"location":"swarms/models/idefics/#example-1-image-questioning","title":"Example 1 - Image Questioning","text":"<pre><code>from swarm_models import Idefics\n\nmodel = Idefics()\nprompts = [\n    \"User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG\"\n]\nresponse = model(prompts)\nprint(response)\n</code></pre>"},{"location":"swarms/models/idefics/#example-2-bidirectional-conversation","title":"Example 2 - Bidirectional Conversation","text":"<pre><code>from swarm_models import Idefics\n\nmodel = Idefics()\nuser_input = \"User: What is in this image? https://upload.wikimedia.org/wikipedia/commons/8/86/Id%C3%A9fix.JPG\"\nresponse = model.chat(user_input)\nprint(response)\n\nuser_input = \"User: Who is that? https://static.wikia.nocookie.net/asterix/images/2/25/R22b.gif/revision/latest?cb=20110815073052\"\nresponse = model.chat(user_input)\nprint(response)\n</code></pre>"},{"location":"swarms/models/idefics/#example-3-configuration-changes","title":"Example 3 - Configuration Changes","text":"<pre><code>model.set_checkpoint(\"new_checkpoint\")\nmodel.set_device(\"cpu\")\nmodel.set_max_length(200)\nmodel.clear_chat_history()\n</code></pre>"},{"location":"swarms/models/idefics/#how-idefics-works","title":"How Idefics Works","text":"<p>Idefics operates by leveraging pre-trained models from the Hugging Face Hub. Here's how it works:</p> <ol> <li> <p>Initialization: When you create an Idefics instance, it initializes the model using a specified checkpoint, sets the device for inference, and configures other parameters like data type and maximum text length.</p> </li> <li> <p>Prompt-Based Inference: You can use the <code>infer</code> method to generate text based on prompts. It processes prompts in batched or non-batched mode, depending on your preference. It uses a pre-trained processor to handle text and images.</p> </li> <li> <p>Bidirectional Conversation: The <code>chat</code> method enables bidirectional conversations. You provide user input, and the model responds accordingly. The chat history is maintained for context.</p> </li> <li> <p>Configuration Changes: You can change the model checkpoint, device, maximum text length, or clear the chat history as needed during runtime.</p> </li> </ol>"},{"location":"swarms/models/idefics/#parameters","title":"Parameters","text":"<ul> <li><code>checkpoint</code>: The name of the pre-trained model checkpoint (default is \"HuggingFaceM4/idefics-9b-instruct\").</li> <li><code>device</code>: The device to use for inference. By default, it uses CUDA if available; otherwise, it uses CPU.</li> <li><code>torch_dtype</code>: The data type to use for inference. By default, it uses torch.bfloat16.</li> <li><code>max_length</code>: The maximum length of the generated text (default is 100).</li> </ul>"},{"location":"swarms/models/idefics/#additional-information","title":"Additional Information","text":"<ul> <li>Idefics provides a convenient way to engage in bidirectional conversations with pre-trained models.</li> <li>You can easily change the model checkpoint, device, and other settings to adapt to your specific use case.</li> </ul> <p>That concludes the documentation for Idefics. We hope you find this tool valuable for your multimodal text generation tasks. If you have any questions or encounter any issues, please refer to the Hugging Face Transformers documentation for further assistance. Enjoy working with Idefics!</p>"},{"location":"swarms/models/kosmos/","title":"<code>Kosmos</code> Documentation","text":""},{"location":"swarms/models/kosmos/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for Kosmos, a powerful multimodal AI model that can perform various tasks, including multimodal grounding, referring expression comprehension, referring expression generation, grounded visual question answering (VQA), and grounded image captioning. Kosmos is based on the ydshieh/kosmos-2-patch14-224 model and is designed to process both text and images to provide meaningful outputs. In this documentation, you will find a detailed explanation of the Kosmos class, its functions, parameters, and usage examples.</p>"},{"location":"swarms/models/kosmos/#overview","title":"Overview","text":"<p>Kosmos is a state-of-the-art multimodal AI model that combines the power of natural language understanding with image analysis. It can perform several tasks that involve processing both textual prompts and images to provide informative responses. Whether you need to find objects in an image, understand referring expressions, generate descriptions, answer questions, or create captions, Kosmos has you covered.</p>"},{"location":"swarms/models/kosmos/#class-definition","title":"Class Definition","text":"<pre><code>class Kosmos:\n    def __init__(self, model_name=\"ydshieh/kosmos-2-patch14-224\"):\n</code></pre>"},{"location":"swarms/models/kosmos/#usage","title":"Usage","text":"<p>To use Kosmos, follow these steps:</p> <ol> <li>Initialize the Kosmos instance:</li> </ol> <pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n</code></pre> <ol> <li>Perform Multimodal Grounding:</li> </ol> <pre><code>kosmos.multimodal_grounding(\n    \"Find the red apple in the image.\", \"https://example.com/apple.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/kosmos/#example-1-multimodal-grounding","title":"Example 1 - Multimodal Grounding","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.multimodal_grounding(\n    \"Find the red apple in the image.\", \"https://example.com/apple.jpg\"\n)\n</code></pre> <ol> <li>Perform Referring Expression Comprehension:</li> </ol> <pre><code>kosmos.referring_expression_comprehension(\n    \"Show me the green bottle.\", \"https://example.com/bottle.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/kosmos/#example-2-referring-expression-comprehension","title":"Example 2 - Referring Expression Comprehension","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.referring_expression_comprehension(\n    \"Show me the green bottle.\", \"https://example.com/bottle.jpg\"\n)\n</code></pre> <ol> <li>Generate Referring Expressions:</li> </ol> <pre><code>kosmos.referring_expression_generation(\n    \"It is on the table.\", \"https://example.com/table.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/kosmos/#example-3-referring-expression-generation","title":"Example 3 - Referring Expression Generation","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.referring_expression_generation(\n    \"It is on the table.\", \"https://example.com/table.jpg\"\n)\n</code></pre> <ol> <li>Perform Grounded Visual Question Answering (VQA):</li> </ol> <pre><code>kosmos.grounded_vqa(\"What is the color of the car?\", \"https://example.com/car.jpg\")\n</code></pre>"},{"location":"swarms/models/kosmos/#example-4-grounded-visual-question-answering","title":"Example 4 - Grounded Visual Question Answering","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.grounded_vqa(\"What is the color of the car?\", \"https://example.com/car.jpg\")\n</code></pre> <ol> <li>Generate Grounded Image Captions:</li> </ol> <pre><code>kosmos.grounded_image_captioning(\"https://example.com/beach.jpg\")\n</code></pre>"},{"location":"swarms/models/kosmos/#example-5-grounded-image-captioning","title":"Example 5 - Grounded Image Captioning","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.grounded_image_captioning(\"https://example.com/beach.jpg\")\n</code></pre> <ol> <li>Generate Detailed Grounded Image Captions:</li> </ol> <pre><code>kosmos.grounded_image_captioning_detailed(\"https://example.com/beach.jpg\")\n</code></pre>"},{"location":"swarms/models/kosmos/#example-6-detailed-grounded-image-captioning","title":"Example 6 - Detailed Grounded Image Captioning","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nkosmos.grounded_image_captioning_detailed(\"https://example.com/beach.jpg\")\n</code></pre> <ol> <li>Draw Entity Boxes on Image:</li> </ol> <pre><code>image = kosmos.get_image(\"https://example.com/image.jpg\")\nentities = [\n    (\"apple\", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),\n    (\"banana\", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),\n]\nkosmos.draw_entity_boxes_on_image(image, entities, show=True)\n</code></pre>"},{"location":"swarms/models/kosmos/#example-7-drawing-entity-boxes-on-image","title":"Example 7 - Drawing Entity Boxes on Image","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\n\nimage = kosmos.get_image(\"https://example.com/image.jpg\")\nentities = [\n    (\"apple\", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),\n    (\"banana\", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),\n]\nkosmos.draw_entity_boxes_on_image(image, entities, show=True)\n</code></pre> <ol> <li>Generate Boxes for Entities:</li> </ol> <pre><code>entities = [\n    (\"apple\", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),\n    (\"banana\", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),\n]\nimage = kosmos.generate_boxes(\n    \"Find the apple and the banana in the image.\", \"https://example.com/image.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/kosmos/#example-8-generating-boxes-for-entities","title":"Example 8 - Generating Boxes for Entities","text":"<pre><code>from swarm_models.kosmos_two import Kosmos\n\nkosmos = Kosmos()\nentities = [\n    (\"apple\", (0, 3), [(0.2, 0.3, 0.4, 0.5)]),\n    (\"banana\", (4, 9), [(0.6, 0.2, 0.8, 0.4)]),\n]\nimage = kosmos.generate_boxes(\n    \"Find the apple and the banana in the image.\", \"https://example.com/image.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/kosmos/#how-kosmos-works","title":"How Kosmos Works","text":"<p>Kosmos is a multimodal AI model that combines text and image processing. It uses the ydshieh/kosmos-2-patch14-224 model for understanding and generating responses. Here's how it works:</p> <ol> <li> <p>Initialization: When you create a Kosmos instance, it loads the ydshieh/kosmos-2-patch14-224 model for multimodal tasks.</p> </li> <li> <p>Processing Text and Images: Kosmos can process both text prompts and images. It takes a textual prompt and an image URL as input.</p> </li> <li> <p>Task Execution: Based on the task you specify, Kosmos generates informative responses by combining natural language understanding with image analysis.</p> </li> <li> <p>Drawing Entity Boxes: You can use the <code>draw_entity_boxes_on_image</code> method to draw bounding boxes around entities in an image.</p> </li> <li> <p>Generating Boxes for Entities: The <code>generate_boxes</code> method allows you to generate bounding boxes for entities mentioned in a prompt.</p> </li> </ol>"},{"location":"swarms/models/kosmos/#parameters","title":"Parameters","text":"<ul> <li><code>model_name</code>: The name or path of the Kosmos model to be used. By default, it uses the ydshieh/kosmos-2-patch14-224 model.</li> </ul>"},{"location":"swarms/models/kosmos/#additional-information","title":"Additional Information","text":"<ul> <li>Kosmos can handle various multimodal tasks, making it a versatile tool for understanding and generating content.</li> <li>You can provide image URLs for image-based tasks, and Kosmos will automatically retrieve and process the images.</li> <li>The <code>draw_entity_boxes_on_image</code> method is useful for visualizing the results of multimodal grounding tasks.</li> <li>The <code>generate_boxes</code> method is handy for generating bounding boxes around entities mentioned in a textual prompt.</li> </ul> <p>That concludes the documentation for Kosmos. We hope you find this multimodal AI model valuable for your projects. If you have any questions or encounter any issues, please refer to the Kosmos documentation for further assistance. Enjoy working with Kosmos!</p>"},{"location":"swarms/models/layoutlm_document_qa/","title":"<code>LayoutLMDocumentQA</code> Documentation","text":""},{"location":"swarms/models/layoutlm_document_qa/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for LayoutLMDocumentQA, a multimodal model designed for visual question answering (QA) on real-world documents, such as invoices, PDFs, and more. This comprehensive documentation will provide you with a deep understanding of the LayoutLMDocumentQA class, its architecture, usage, and examples.</p>"},{"location":"swarms/models/layoutlm_document_qa/#overview","title":"Overview","text":"<p>LayoutLMDocumentQA is a versatile model that combines layout-based understanding of documents with natural language processing to answer questions about the content of documents. It is particularly useful for automating tasks like invoice processing, extracting information from PDFs, and handling various document-based QA scenarios.</p>"},{"location":"swarms/models/layoutlm_document_qa/#class-definition","title":"Class Definition","text":"<pre><code>class LayoutLMDocumentQA(AbstractModel):\n    def __init__(\n        self, \n        model_name: str = \"impira/layoutlm-document-qa\",\n        task: str = \"document-question-answering\",\n    ):\n</code></pre>"},{"location":"swarms/models/layoutlm_document_qa/#purpose","title":"Purpose","text":"<p>The LayoutLMDocumentQA class serves the following primary purposes:</p> <ol> <li> <p>Document QA: LayoutLMDocumentQA is specifically designed for document-based question answering. It can process both the textual content and the layout of a document to answer questions.</p> </li> <li> <p>Multimodal Understanding: It combines natural language understanding with document layout analysis, making it suitable for documents with complex structures.</p> </li> </ol>"},{"location":"swarms/models/layoutlm_document_qa/#parameters","title":"Parameters","text":"<ul> <li><code>model_name</code> (str): The name or path of the pretrained LayoutLMDocumentQA model. Default: \"impira/layoutlm-document-qa\".</li> <li><code>task</code> (str): The specific task for which the model will be used. Default: \"document-question-answering\".</li> </ul>"},{"location":"swarms/models/layoutlm_document_qa/#usage","title":"Usage","text":"<p>To use LayoutLMDocumentQA, follow these steps:</p> <ol> <li>Initialize the LayoutLMDocumentQA instance:</li> </ol> <pre><code>from swarm_models import LayoutLMDocumentQA\n\nlayout_lm_doc_qa = LayoutLMDocumentQA()\n</code></pre>"},{"location":"swarms/models/layoutlm_document_qa/#example-1-initialization","title":"Example 1 - Initialization","text":"<pre><code>layout_lm_doc_qa = LayoutLMDocumentQA()\n</code></pre> <ol> <li>Ask a question about a document and provide the document's image path:</li> </ol> <pre><code>question = \"What is the total amount?\"\nimage_path = \"path/to/document_image.png\"\nanswer = layout_lm_doc_qa(question, image_path)\n</code></pre>"},{"location":"swarms/models/layoutlm_document_qa/#example-2-document-qa","title":"Example 2 - Document QA","text":"<pre><code>layout_lm_doc_qa = LayoutLMDocumentQA()\nquestion = \"What is the total amount?\"\nimage_path = \"path/to/document_image.png\"\nanswer = layout_lm_doc_qa(question, image_path)\n</code></pre>"},{"location":"swarms/models/layoutlm_document_qa/#how-layoutlmdocumentqa-works","title":"How LayoutLMDocumentQA Works","text":"<p>LayoutLMDocumentQA employs a multimodal approach to document QA. Here's how it works:</p> <ol> <li> <p>Initialization: When you create a LayoutLMDocumentQA instance, you can specify the model to use and the task, which is \"document-question-answering\" by default.</p> </li> <li> <p>Question and Document: You provide a question about the document and the image path of the document to the LayoutLMDocumentQA instance.</p> </li> <li> <p>Multimodal Processing: LayoutLMDocumentQA processes both the question and the document image. It combines layout-based analysis with natural language understanding.</p> </li> <li> <p>Answer Generation: The model generates an answer to the question based on its analysis of the document layout and content.</p> </li> </ol>"},{"location":"swarms/models/layoutlm_document_qa/#additional-information","title":"Additional Information","text":"<ul> <li>LayoutLMDocumentQA uses the \"impira/layoutlm-document-qa\" pretrained model, which is specifically designed for document-based question answering.</li> <li>You can adapt this model to various document QA scenarios by changing the task and providing relevant questions and documents.</li> <li>This model is particularly useful for automating document-based tasks and extracting valuable information from structured documents.</li> </ul> <p>That concludes the documentation for LayoutLMDocumentQA. We hope you find this tool valuable for your document-based question answering needs. If you have any questions or encounter any issues, please refer to the LayoutLMDocumentQA documentation for further assistance. Enjoy using LayoutLMDocumentQA!</p>"},{"location":"swarms/models/llama3/","title":"Llama3","text":""},{"location":"swarms/models/llama3/#llava3","title":"Llava3","text":"<pre><code>from transformers import AutoTokenizer, AutoModelForCausalLM\nimport torch\nfrom swarm_models.base_llm import BaseLLM\n\n\nclass Llama3(BaseLLM):\n    \"\"\"\n    Llama3 class represents a Llama model for natural language generation.\n\n        Args:\n            model_id (str): The ID of the Llama model to use.\n            system_prompt (str): The system prompt to use for generating responses.\n            temperature (float): The temperature value for controlling the randomness of the generated responses.\n            top_p (float): The top-p value for controlling the diversity of the generated responses.\n            max_tokens (int): The maximum number of tokens to generate in the response.\n            **kwargs: Additional keyword arguments.\n\n        Attributes:\n            model_id (str): The ID of the Llama model being used.\n            system_prompt (str): The system prompt for generating responses.\n            temperature (float): The temperature value for generating responses.\n            top_p (float): The top-p value for generating responses.\n            max_tokens (int): The maximum number of tokens to generate in the response.\n            tokenizer (AutoTokenizer): The tokenizer for the Llama model.\n            model (AutoModelForCausalLM): The Llama model for generating responses.\n\n        Methods:\n            run(task, *args, **kwargs): Generates a response for the given task.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        model_id=\"meta-llama/Meta-Llama-3-8B-Instruct\",\n        system_prompt: str = None,\n        temperature: float = 0.6,\n        top_p: float = 0.9,\n        max_tokens: int = 4000,\n        **kwargs,\n    ):\n        self.model_id = model_id\n        self.system_prompt = system_prompt\n        self.temperature = temperature\n        self.top_p = top_p\n        self.max_tokens = max_tokens\n        self.tokenizer = AutoTokenizer.from_pretrained(model_id)\n        self.model = AutoModelForCausalLM.from_pretrained(\n            model_id,\n            torch_dtype=torch.bfloat16,\n            device_map=\"auto\",\n        )\n\n    def run(self, task: str, *args, **kwargs):\n        \"\"\"\n        Generates a response for the given task.\n\n        Args:\n            task (str): The user's task or input.\n\n        Returns:\n            str: The generated response.\n\n        \"\"\"\n        messages = [\n            {\"role\": \"system\", \"content\": self.system_prompt},\n            {\"role\": \"user\", \"content\": task},\n        ]\n\n        input_ids = self.tokenizer.apply_chat_template(\n            messages, add_generation_prompt=True, return_tensors=\"pt\"\n        ).to(self.model.device)\n\n        terminators = [\n            self.tokenizer.eos_token_id,\n            self.tokenizer.convert_tokens_to_ids(\"&lt;|eot_id|&gt;\"),\n        ]\n\n        outputs = self.model.generate(\n            input_ids,\n            max_new_tokens=self.max_tokens,\n            eos_token_id=terminators,\n            do_sample=True,\n            temperature=self.temperature,\n            top_p=self.top_p,\n            *args,\n            **kwargs,\n        )\n        response = outputs[0][input_ids.shape[-1] :]\n        return self.tokenizer.decode(\n            response, skip_special_tokens=True\n        )\n</code></pre>"},{"location":"swarms/models/models_available_overview/","title":"Models available overview","text":""},{"location":"swarms/models/models_available_overview/#the-swarms-framework-a-comprehensive-guide-to-model-apis-and-usage","title":"The Swarms Framework: A Comprehensive Guide to Model APIs and Usage","text":""},{"location":"swarms/models/models_available_overview/#introduction","title":"Introduction","text":"<p>The Swarms framework is a versatile and robust tool designed to streamline the integration and orchestration of multiple AI models, making it easier for developers to build sophisticated multi-agent systems. This blog aims to provide a detailed guide on using the Swarms framework, covering the various models it supports, common methods, settings, and practical examples.</p>"},{"location":"swarms/models/models_available_overview/#overview-of-the-swarms-framework","title":"Overview of the Swarms Framework","text":"<p>Swarms is a \"framework of frameworks\" that allows seamless integration of various AI models, including those from OpenAI, Anthropic, Hugging Face, Azure, and more. This flexibility enables users to leverage the strengths of different models within a single application. The framework provides a unified interface for model interaction, simplifying the process of integrating and managing multiple AI models.</p>"},{"location":"swarms/models/models_available_overview/#getting-started-with-swarms","title":"Getting Started with Swarms","text":"<p>To get started with Swarms, you need to install the framework and set up the necessary environment variables. Here's a step-by-step guide:</p>"},{"location":"swarms/models/models_available_overview/#installation","title":"Installation","text":"<p>You can install the Swarms framework using pip:</p> <pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/models/models_available_overview/#setting-up-environment-variables","title":"Setting Up Environment Variables","text":"<p>Swarms relies on environment variables to manage API keys and other configurations. You can use the <code>dotenv</code> package to load these variables from a <code>.env</code> file.</p> <pre><code>pip install python-dotenv\n</code></pre> <p>Create a <code>.env</code> file in your project directory and add your API keys and other settings:</p> <pre><code>OPENAI_API_KEY=your_openai_api_key\nANTHROPIC_API_KEY=your_anthropic_api_key\nAZURE_OPENAI_ENDPOINT=your_azure_openai_endpoint\nAZURE_OPENAI_DEPLOYMENT=your_azure_openai_deployment\nOPENAI_API_VERSION=your_openai_api_version\nAZURE_OPENAI_API_KEY=your_azure_openai_api_key\nAZURE_OPENAI_AD_TOKEN=your_azure_openai_ad_token\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-swarms-framework","title":"Using the Swarms Framework","text":"<p>Swarms supports a variety of models from different providers. Here are some examples of how to use these models within the Swarms framework.</p>"},{"location":"swarms/models/models_available_overview/#using-the-anthropic-model","title":"Using the Anthropic Model","text":"<p>The Anthropic model is one of the many models supported by Swarms. Here's how you can use it:</p> <pre><code>import os\nfrom swarm_models import Anthropic\n\n# Load the environment variables\nanthropic_api_key = os.getenv(\"ANTHROPIC_API_KEY\")\n\n# Create an instance of the Anthropic model\nmodel = Anthropic(anthropic_api_key=anthropic_api_key)\n\n# Define the task\ntask = \"What is quantum field theory? What are 3 books on the field?\"\n\n# Generate a response\nresponse = model(task)\n\n# Print the response\nprint(response)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-huggingfacellm-model","title":"Using the HuggingfaceLLM Model","text":"<p>HuggingfaceLLM allows you to use models from Hugging Face's vast repository. Here's an example:</p> <pre><code>from swarm_models import HuggingfaceLLM\n\n# Define the model ID\nmodel_id = \"NousResearch/Yarn-Mistral-7b-128k\"\n\n# Create an instance of the HuggingfaceLLM model\ninference = HuggingfaceLLM(model_id=model_id)\n\n# Define the task\ntask = \"Once upon a time\"\n\n# Generate a response\ngenerated_text = inference(task)\nprint(generated_text)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-openaichat-model","title":"Using the OpenAIChat Model","text":"<p>The OpenAIChat model is designed for conversational tasks. Here's how to use it:</p> <pre><code>import os\nfrom swarm_models import OpenAIChat\n\n# Load the environment variables\nopenai_api_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat model\nopenai = OpenAIChat(openai_api_key=openai_api_key, verbose=False)\n\n# Define the task\nchat = openai(\"What are quantum fields?\")\nprint(chat)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-togetherllm-model","title":"Using the TogetherLLM Model","text":"<p>TogetherLLM supports models from the Together ecosystem. Here's an example:</p> <pre><code>from swarms import TogetherLLM\n\n# Initialize the model with your parameters\nmodel = TogetherLLM(\n    model_name=\"mistralai/Mixtral-8x7B-Instruct-v0.1\",\n    max_tokens=1000,\n    together_api_key=\"your_together_api_key\",\n)\n\n# Run the model\nresponse = model.run(\"Generate a blog post about the best way to make money online.\")\nprint(response)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-azure-openai-model","title":"Using the Azure OpenAI Model","text":"<p>The Azure OpenAI model is another powerful tool that can be integrated with Swarms. Here's how to use it:</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import AzureOpenAI\n\n# Load the environment variables\nload_dotenv()\n\n# Create an instance of the AzureOpenAI class\nmodel = AzureOpenAI(\n    azure_endpoint=os.getenv(\"AZURE_OPENAI_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_OPENAI_DEPLOYMENT\"),\n    openai_api_version=os.getenv(\"OPENAI_API_VERSION\"),\n    openai_api_key=os.getenv(\"AZURE_OPENAI_API_KEY\"),\n    azure_ad_token=os.getenv(\"AZURE_OPENAI_AD_TOKEN\"),\n)\n\n# Define the prompt\nprompt = (\n    \"Analyze this load document and assess it for any risks and\"\n    \" create a table in markdown format.\"\n)\n\n# Generate a response\nresponse = model(prompt)\nprint(response)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-gpt4visionapi-model","title":"Using the GPT4VisionAPI Model","text":"<p>The GPT4VisionAPI model can analyze images and provide detailed insights. Here's how to use it:</p> <pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import GPT4VisionAPI\n\n# Load the environment variables\nload_dotenv()\n\n# Get the API key from the environment variables\napi_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the GPT4VisionAPI class\ngpt4vision = GPT4VisionAPI(\n    openai_api_key=api_key,\n    model_name=\"gpt-4o\",\n    max_tokens=1000,\n    openai_proxy=\"https://api.openai.com/v1/chat/completions\",\n)\n\n# Define the URL of the image to analyze\nimg = \"ear.png\"\n\n# Define the task to perform on the image\ntask = \"What is this image\"\n\n# Run the GPT4VisionAPI on the image with the specified task\nanswer = gpt4vision.run(task, img, return_json=True)\n\n# Print the answer\nprint(answer)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#using-the-qwenvlmultimodal-model","title":"Using the QwenVLMultiModal Model","text":"<p>The QwenVLMultiModal model is designed for multi-modal tasks, such as processing both text and images. Here's an example of how to use it:</p> <pre><code>from swarms import QwenVLMultiModal\n\n# Instantiate the QwenVLMultiModal model\nmodel = QwenVLMultiModal(\n    model_name=\"Qwen/Qwen-VL-Chat\",\n    device=\"cuda\",\n    quantize=True,\n)\n\n# Run the model\nresponse = model(\"Hello, how are you?\", \"https://example.com/image.jpg\")\n\n# Print the response\nprint(response)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#common-methods-in-swarms","title":"Common Methods in Swarms","text":"<p>Swarms provides several common methods that are useful across different models. One of the most frequently used methods is <code>__call__</code>.</p>"},{"location":"swarms/models/models_available_overview/#the-__call__-method","title":"The <code>__call__</code> Method","text":"<p>The <code>__call__</code> method is used to run the model on a given task. Here is a generic example:</p> <pre><code># Assuming `model` is an instance of any supported model\ntask = \"Explain the theory of relativity.\"\nresponse = model(task)\nprint(response)\n</code></pre> <p>This method abstracts the complexity of interacting with different model APIs, providing a consistent interface for executing tasks.</p>"},{"location":"swarms/models/models_available_overview/#common-settings-in-swarms","title":"Common Settings in Swarms","text":"<p>Swarms allows you to configure various settings to customize the behavior of the models. Here are some common settings:</p>"},{"location":"swarms/models/models_available_overview/#api-keys","title":"API Keys","text":"<p>API keys are essential for authenticating and accessing the models. These keys are typically set through environment variables:</p> <pre><code>import os\n\n# Set API keys as environment variables\nos.environ['OPENAI_API_KEY'] = 'your_openai_api_key'\nos.environ['ANTHROPIC_API_KEY'] = 'your_anthropic_api_key'\n</code></pre>"},{"location":"swarms/models/models_available_overview/#model-specific-settings","title":"Model-Specific Settings","text":"<p>Different models may have specific settings that need to be configured. For example, the <code>AzureOpenAI</code> model requires several settings related to the Azure environment:</p> <pre><code>model = AzureOpenAI(\n    azure_endpoint=os.getenv(\"AZURE_OPENAI_ENDPOINT\"),\n    deployment_name=os.getenv(\"AZURE_OPENAI_DEPLOYMENT\"),\n    openai_api_version=os.getenv(\"OPENAI_API_VERSION\"),\n    openai_api_key=os.getenv(\"AZURE_OPENAI_API_KEY\"),\n    azure_ad_token=os.getenv(\"AZURE_OPENAI_AD_TOKEN\"),\n)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#advanced-usage-and-best-practices","title":"Advanced Usage and Best Practices","text":"<p>To make the most out of the Swarms framework, consider the following best practices:</p>"},{"location":"swarms/models/models_available_overview/#extensive-logging","title":"Extensive Logging","text":"<p>Use logging to monitor the behavior and performance of your models. The <code>loguru</code> library is recommended for its simplicity and flexibility:</p> <pre><code>from loguru import logger\n\n# Log model interactions\nlogger.info(\"Running task on Anthropic model\")\nresponse = model(task)\nlogger.info(f\"Response: {response}\")\n</code></pre>"},{"location":"swarms/models/models_available_overview/#error-handling","title":"Error Handling","text":"<p>Implement robust error handling to manage API failures and other issues gracefully:</p> <pre><code>try:\n    response = model(task)\nexcept Exception as e:\n    logger.error(f\"Error running task: {e}\")\n    response = \"An error occurred while processing your request.\"\nprint(response)\n</code></pre>"},{"location":"swarms/models/models_available_overview/#conclusion","title":"Conclusion","text":"<p>The Swarms framework provides a powerful and flexible way to integrate and manage multiple AI models within a single application. By following the guidelines and examples provided in this blog, you can leverage Swarms to build sophisticated, multi-agent systems with ease. Whether you're using models from OpenAI, Anthropic, Azure, or Hugging Face,</p> <p>Swarms offers a unified interface that simplifies the process of model orchestration and execution.</p>"},{"location":"swarms/models/nougat/","title":"<code>Nougat</code> Documentation","text":""},{"location":"swarms/models/nougat/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for Nougat, a versatile model designed by Meta for transcribing scientific PDFs into user-friendly Markdown format, extracting information from PDFs, and extracting metadata from PDF documents. This documentation will provide you with a deep understanding of the Nougat class, its architecture, usage, and examples.</p>"},{"location":"swarms/models/nougat/#overview","title":"Overview","text":"<p>Nougat is a powerful tool that combines language modeling and image processing capabilities to convert scientific PDF documents into Markdown format. It is particularly useful for researchers, students, and professionals who need to extract valuable information from PDFs quickly. With Nougat, you can simplify complex PDFs, making their content more accessible and easy to work with.</p>"},{"location":"swarms/models/nougat/#class-definition","title":"Class Definition","text":"<pre><code>class Nougat:\n    def __init__(\n        self,\n        model_name_or_path=\"facebook/nougat-base\",\n        min_length: int = 1,\n        max_new_tokens: int = 30,\n    ):\n</code></pre>"},{"location":"swarms/models/nougat/#purpose","title":"Purpose","text":"<p>The Nougat class serves the following primary purposes:</p> <ol> <li> <p>PDF Transcription: Nougat is designed to transcribe scientific PDFs into Markdown format. It helps convert complex PDF documents into a more readable and structured format, making it easier to extract information.</p> </li> <li> <p>Information Extraction: It allows users to extract valuable information and content from PDFs efficiently. This can be particularly useful for researchers and professionals who need to extract data, figures, or text from scientific papers.</p> </li> <li> <p>Metadata Extraction: Nougat can also extract metadata from PDF documents, providing essential details about the document, such as title, author, and publication date.</p> </li> </ol>"},{"location":"swarms/models/nougat/#parameters","title":"Parameters","text":"<ul> <li><code>model_name_or_path</code> (str): The name or path of the pretrained Nougat model. Default: \"facebook/nougat-base\".</li> <li><code>min_length</code> (int): The minimum length of the generated transcription. Default: 1.</li> <li><code>max_new_tokens</code> (int): The maximum number of new tokens to generate in the Markdown transcription. Default: 30.</li> </ul>"},{"location":"swarms/models/nougat/#usage","title":"Usage","text":"<p>To use Nougat, follow these steps:</p> <ol> <li>Initialize the Nougat instance:</li> </ol> <pre><code>from swarm_models import Nougat\n\nnougat = Nougat()\n</code></pre>"},{"location":"swarms/models/nougat/#example-1-initialization","title":"Example 1 - Initialization","text":"<pre><code>nougat = Nougat()\n</code></pre> <ol> <li>Transcribe a PDF image using Nougat:</li> </ol> <pre><code>markdown_transcription = nougat(\"path/to/pdf_file.png\")\n</code></pre>"},{"location":"swarms/models/nougat/#example-2-pdf-transcription","title":"Example 2 - PDF Transcription","text":"<pre><code>nougat = Nougat()\nmarkdown_transcription = nougat(\"path/to/pdf_file.png\")\n</code></pre> <ol> <li>Extract information from a PDF:</li> </ol> <pre><code>information = nougat.extract_information(\"path/to/pdf_file.png\")\n</code></pre>"},{"location":"swarms/models/nougat/#example-3-information-extraction","title":"Example 3 - Information Extraction","text":"<pre><code>nougat = Nougat()\ninformation = nougat.extract_information(\"path/to/pdf_file.png\")\n</code></pre> <ol> <li>Extract metadata from a PDF:</li> </ol> <pre><code>metadata = nougat.extract_metadata(\"path/to/pdf_file.png\")\n</code></pre>"},{"location":"swarms/models/nougat/#example-4-metadata-extraction","title":"Example 4 - Metadata Extraction","text":"<pre><code>nougat = Nougat()\nmetadata = nougat.extract_metadata(\"path/to/pdf_file.png\")\n</code></pre>"},{"location":"swarms/models/nougat/#how-nougat-works","title":"How Nougat Works","text":"<p>Nougat employs a vision encoder-decoder model, along with a dedicated processor, to transcribe PDFs into Markdown format and perform information and metadata extraction. Here's how it works:</p> <ol> <li> <p>Initialization: When you create a Nougat instance, you can specify the model to use, the minimum transcription length, and the maximum number of new tokens to generate.</p> </li> <li> <p>Processing PDFs: Nougat can process PDFs as input. You can provide the path to a PDF document.</p> </li> <li> <p>Image Processing: The processor converts PDF pages into images, which are then encoded by the model.</p> </li> <li> <p>Transcription: Nougat generates Markdown transcriptions of PDF content, ensuring a minimum length and respecting the token limit.</p> </li> <li> <p>Information Extraction: Information extraction involves parsing the Markdown transcription to identify key details or content of interest.</p> </li> <li> <p>Metadata Extraction: Metadata extraction involves identifying and extracting document metadata, such as title, author, and publication date.</p> </li> </ol>"},{"location":"swarms/models/nougat/#additional-information","title":"Additional Information","text":"<ul> <li>Nougat leverages the \"facebook/nougat-base\" pretrained model, which is specifically designed for document transcription and extraction tasks.</li> <li>You can adjust the minimum transcription length and the maximum number of new tokens to control the output's length and quality.</li> <li>Nougat can be run on both CPU and GPU devices.</li> </ul> <p>That concludes the documentation for Nougat. We hope you find this tool valuable for your PDF transcription, information extraction, and metadata extraction needs. If you have any questions or encounter any issues, please refer to the Nougat documentation for further assistance. Enjoy using Nougat!</p>"},{"location":"swarms/models/openai/","title":"<code>BaseOpenAI</code> and <code>OpenAI</code> Documentation","text":""},{"location":"swarms/models/openai/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Class Architecture</li> <li>Purpose</li> <li>Class Attributes</li> <li>Methods</li> <li>Construction</li> <li>Configuration</li> <li>Tokenization</li> <li>Generation</li> <li>Asynchronous Generation</li> <li>Usage Examples</li> <li>Creating an OpenAI Object</li> <li>Generating Text</li> <li>Advanced Configuration</li> </ol>"},{"location":"swarms/models/openai/#1-overview","title":"1. Overview","text":"<p>The <code>BaseOpenAI</code> and <code>OpenAI</code> classes are part of the LangChain library, designed to interact with OpenAI's large language models (LLMs). These classes provide a seamless interface for utilizing OpenAI's API to generate natural language text.</p>"},{"location":"swarms/models/openai/#2-class-architecture","title":"2. Class Architecture","text":"<p>Both <code>BaseOpenAI</code> and <code>OpenAI</code> classes inherit from <code>BaseLLM</code>, demonstrating an inheritance-based architecture. This architecture allows for easy extensibility and customization while adhering to the principles of object-oriented programming.</p>"},{"location":"swarms/models/openai/#3-purpose","title":"3. Purpose","text":"<p>The purpose of these classes is to simplify the interaction with OpenAI's LLMs. They encapsulate API calls, handle tokenization, and provide a high-level interface for generating text. By instantiating an object of the <code>OpenAI</code> class, developers can quickly leverage the power of OpenAI's models to generate text for various applications, such as chatbots, content generation, and more.</p>"},{"location":"swarms/models/openai/#4-class-attributes","title":"4. Class Attributes","text":"<p>Here are the key attributes and their descriptions for the <code>BaseOpenAI</code> and <code>OpenAI</code> classes:</p> Attribute Description <code>lc_secrets</code> A dictionary of secrets required for LangChain, including the OpenAI API key. <code>lc_attributes</code> A dictionary of attributes relevant to LangChain. <code>is_lc_serializable()</code> A method indicating if the class is serializable for LangChain. <code>model_name</code> The name of the language model to use. <code>temperature</code> The sampling temperature for text generation. <code>max_tokens</code> The maximum number of tokens to generate in a completion. <code>top_p</code> The total probability mass of tokens to consider at each step. <code>frequency_penalty</code> Penalizes repeated tokens according to frequency. <code>presence_penalty</code> Penalizes repeated tokens. <code>n</code> How many completions to generate for each prompt. <code>best_of</code> Generates <code>best_of</code> completions server-side and returns the \"best.\" <code>model_kwargs</code> Holds any model parameters valid for <code>create</code> calls not explicitly specified. <code>openai_api_key</code> The OpenAI API key used for authentication. <code>openai_api_base</code> The base URL for the OpenAI API. <code>openai_organization</code> The OpenAI organization name, if applicable. <code>openai_proxy</code> An explicit proxy URL for OpenAI requests. <code>batch_size</code> The batch size to use when passing multiple documents for generation. <code>request_timeout</code> The timeout for requests to the OpenAI completion API. <code>logit_bias</code> Adjustment to the probability of specific tokens being generated. <code>max_retries</code> The maximum number of retries to make when generating. <code>streaming</code> Whether to stream the results or not. <code>allowed_special</code> A set of special tokens that are allowed. <code>disallowed_special</code> A collection of special tokens that are not allowed. <code>tiktoken_model_name</code> The model name to pass to <code>tiktoken</code> for token counting."},{"location":"swarms/models/openai/#5-methods","title":"5. Methods","text":""},{"location":"swarms/models/openai/#51-construction","title":"5.1 Construction","text":""},{"location":"swarms/models/openai/#511-__new__cls-data-any-unionopenaichat-baseopenai","title":"5.1.1 <code>__new__(cls, **data: Any) -&gt; Union[OpenAIChat, BaseOpenAI]</code>","text":"<ul> <li>Description: Initializes the OpenAI object.</li> <li>Arguments:</li> <li><code>cls</code> (class): The class instance.</li> <li><code>data</code> (dict): Additional data for initialization.</li> <li>Returns:</li> <li>Union[OpenAIChat, BaseOpenAI]: An instance of the OpenAI class.</li> </ul>"},{"location":"swarms/models/openai/#52-configuration","title":"5.2 Configuration","text":""},{"location":"swarms/models/openai/#521-build_extracls-values-dictstr-any-dictstr-any","title":"5.2.1 <code>build_extra(cls, values: Dict[str, Any]) -&gt; Dict[str, Any]</code>","text":"<ul> <li>Description: Builds extra kwargs from additional params passed in.</li> <li>Arguments:</li> <li><code>cls</code> (class): The class instance.</li> <li><code>values</code> (dict): Values and parameters to build extra kwargs.</li> <li>Returns:</li> <li>Dict[str, Any]: A dictionary of built extra kwargs.</li> </ul>"},{"location":"swarms/models/openai/#522-validate_environmentcls-values-dict-dict","title":"5.2.2 <code>validate_environment(cls, values: Dict) -&gt; Dict</code>","text":"<ul> <li>Description: Validates that the API key and python package exist in the environment.</li> <li>Arguments:</li> <li><code>values</code> (dict): The class values and parameters.</li> <li>Returns:</li> <li>Dict: A dictionary of validated values.</li> </ul>"},{"location":"swarms/models/openai/#53-tokenization","title":"5.3 Tokenization","text":""},{"location":"swarms/models/openai/#531-get_sub_promptsself-params-dictstr-any-prompts-liststr-stop-optionalliststr-none-listliststr","title":"5.3.1 <code>get_sub_prompts(self, params: Dict[str, Any], prompts: List[str], stop: Optional[List[str]] = None) -&gt; List[List[str]]</code>","text":"<ul> <li>Description: Gets sub-prompts for LLM call.</li> <li>Arguments:</li> <li><code>params</code> (dict): Parameters for LLM call.</li> <li><code>prompts</code> (list): List of prompts.</li> <li><code>stop</code> (list, optional): List of stop words.</li> <li>Returns:</li> <li>List[List[str]]: List of sub-prompts.</li> </ul>"},{"location":"swarms/models/openai/#532-get_token_idsself-text-str-listint","title":"5.3.2 <code>get_token_ids(self, text: str) -&gt; List[int]</code>","text":"<ul> <li>Description: Gets token IDs using the <code>tiktoken</code> package.</li> <li>Arguments:</li> <li><code>text</code> (str): The text for which to calculate token IDs.</li> <li>Returns:</li> <li>List[int]: A list of token IDs.</li> </ul>"},{"location":"swarms/models/openai/#533-modelname_to_contextsizemodelname-str-int","title":"5.3.3 <code>modelname_to_contextsize(modelname: str) -&gt; int</code>","text":"<ul> <li>Description: Calculates the maximum number of tokens possible to generate for a model.</li> <li>Arguments:</li> <li><code>modelname</code> (str): The model name to determine the context size for.</li> <li>Returns:</li> <li>int: The maximum context size.</li> </ul>"},{"location":"swarms/models/openai/#534-max_tokens_for_promptself-prompt-str-int","title":"5.3.4 <code>max_tokens_for_prompt(self, prompt: str) -&gt; int</code>","text":"<ul> <li>Description: Calculates the maximum number of tokens possible to generate for a prompt.</li> <li>Arguments:</li> <li><code>prompt</code> (str): The prompt for which to</li> </ul> <p>determine the maximum token limit. - Returns:   - int: The maximum token limit.</p>"},{"location":"swarms/models/openai/#54-generation","title":"5.4 Generation","text":""},{"location":"swarms/models/openai/#541-generateself-text-unionstr-liststr-kwargs-unionstr-liststr","title":"5.4.1 <code>generate(self, text: Union[str, List[str]], **kwargs) -&gt; Union[str, List[str]]</code>","text":"<ul> <li>Description: Generates text using the OpenAI API.</li> <li>Arguments:</li> <li><code>text</code> (str or list): The input text or list of inputs.</li> <li><code>**kwargs</code> (dict): Additional parameters for the generation process.</li> <li>Returns:</li> <li>Union[str, List[str]]: The generated text or list of generated texts.</li> </ul>"},{"location":"swarms/models/openai/#55-asynchronous-generation","title":"5.5 Asynchronous Generation","text":""},{"location":"swarms/models/openai/#551-generate_asyncself-text-unionstr-liststr-kwargs-unionstr-liststr","title":"5.5.1 <code>generate_async(self, text: Union[str, List[str]], **kwargs) -&gt; Union[str, List[str]]</code>","text":"<ul> <li>Description: Generates text asynchronously using the OpenAI API.</li> <li>Arguments:</li> <li><code>text</code> (str or list): The input text or list of inputs.</li> <li><code>**kwargs</code> (dict): Additional parameters for the asynchronous generation process.</li> <li>Returns:</li> <li>Union[str, List[str]]: The generated text or list of generated texts.</li> </ul>"},{"location":"swarms/models/openai/#6-usage-examples","title":"6. Usage Examples","text":""},{"location":"swarms/models/openai/#61-creating-an-openai-object","title":"6.1 Creating an OpenAI Object","text":"<pre><code># Import the OpenAI class\nfrom swarm_models import OpenAI\n\n# Set your OpenAI API key\napi_key = \"YOUR_API_KEY\"\n\n# Create an OpenAI object\nopenai = OpenAI(api_key)\n</code></pre>"},{"location":"swarms/models/openai/#62-generating-text","title":"6.2 Generating Text","text":"<pre><code># Generate text from a single prompt\nprompt = \"Translate the following English text to French: 'Hello, how are you?'\"\ngenerated_text = openai.generate(prompt, max_tokens=50)\n\n# Generate text from multiple prompts\nprompts = [\n    \"Translate this: 'Good morning' to Spanish.\",\n    \"Summarize the following article:\",\n    article_text,\n]\ngenerated_texts = openai.generate(prompts, max_tokens=100)\n\n# Generate text asynchronously\nasync_prompt = \"Translate 'Thank you' into German.\"\nasync_result = openai.generate_async(async_prompt, max_tokens=30)\n\n# Access the result of an asynchronous generation\nasync_result_text = async_result.get()\n</code></pre>"},{"location":"swarms/models/openai/#63-advanced-configuration","title":"6.3 Advanced Configuration","text":"<pre><code># Configure generation with advanced options\ncustom_options = {\n    \"temperature\": 0.7,\n    \"max_tokens\": 100,\n    \"top_p\": 0.9,\n    \"frequency_penalty\": 0.2,\n    \"presence_penalty\": 0.4,\n}\ngenerated_text = openai.generate(prompt, **custom_options)\n</code></pre> <p>This documentation provides a comprehensive understanding of the <code>BaseOpenAI</code> and <code>OpenAI</code> classes, their attributes, methods, and usage examples. Developers can utilize these classes to interact with OpenAI's language models efficiently, enabling various natural language generation tasks.</p>"},{"location":"swarms/models/openai_chat/","title":"<code>OpenAIChat</code> Documentation","text":""},{"location":"swarms/models/openai_chat/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Class Overview</li> <li>Class Architecture</li> <li>Class Attributes</li> <li>Methods<ul> <li>Construction</li> <li>Configuration</li> <li>Message Handling</li> <li>Generation</li> <li>Tokenization</li> </ul> </li> <li>Usage Examples</li> <li>Additional Information</li> </ol>"},{"location":"swarms/models/openai_chat/#1-introduction","title":"1. Introduction","text":"<p>The <code>OpenAIChat</code> class is part of the LangChain library and serves as an interface to interact with OpenAI's Chat large language models. This documentation provides an in-depth understanding of the class, its attributes, methods, and usage examples.</p>"},{"location":"swarms/models/openai_chat/#2-class-overview","title":"2. Class Overview","text":"<p>The <code>OpenAIChat</code> class is designed for conducting chat-like conversations with OpenAI's language models, such as GPT-3.5 Turbo. It allows you to create interactive conversations by sending messages and receiving model-generated responses. This class simplifies the process of integrating OpenAI's models into chatbot applications and other natural language processing tasks.</p>"},{"location":"swarms/models/openai_chat/#3-class-architecture","title":"3. Class Architecture","text":"<p>The <code>OpenAIChat</code> class is built on top of the <code>BaseLLM</code> class, which provides a foundation for working with large language models. This inheritance-based architecture allows for customization and extension while adhering to object-oriented programming principles.</p>"},{"location":"swarms/models/openai_chat/#4-class-attributes","title":"4. Class Attributes","text":"<p>Here are the key attributes and their descriptions for the <code>OpenAIChat</code> class:</p> Attribute Description <code>client</code> An internal client for making API calls to OpenAI. <code>model_name</code> The name of the language model to use (default: \"gpt-3.5-turbo\"). <code>model_kwargs</code> Additional model parameters valid for <code>create</code> calls not explicitly specified. <code>openai_api_key</code> The OpenAI API key used for authentication. <code>openai_api_base</code> The base URL for the OpenAI API. <code>openai_proxy</code> An explicit proxy URL for OpenAI requests. <code>max_retries</code> The maximum number of retries to make when generating (default: 6). <code>prefix_messages</code> A list of messages to set the initial conversation state (default: []). <code>streaming</code> Whether to stream the results or not (default: False). <code>allowed_special</code> A set of special tokens that are allowed (default: an empty set). <code>disallowed_special</code> A collection of special tokens that are not allowed (default: \"all\")."},{"location":"swarms/models/openai_chat/#5-methods","title":"5. Methods","text":""},{"location":"swarms/models/openai_chat/#51-construction","title":"5.1 Construction","text":""},{"location":"swarms/models/openai_chat/#511-__init__self-model_name-str-gpt-35-turbo-openai_api_key-optionalstr-none-openai_api_base-optionalstr-none-openai_proxy-optionalstr-none-max_retries-int-6-prefix_messages-list","title":"5.1.1 <code>__init__(self, model_name: str = \"gpt-3.5-turbo\", openai_api_key: Optional[str] = None, openai_api_base: Optional[str] = None, openai_proxy: Optional[str] = None, max_retries: int = 6, prefix_messages: List = [])</code>","text":"<ul> <li>Description: Initializes an OpenAIChat object.</li> <li>Arguments:</li> <li><code>model_name</code> (str): The name of the language model to use (default: \"gpt-3.5-turbo\").</li> <li><code>openai_api_key</code> (str, optional): The OpenAI API key used for authentication.</li> <li><code>openai_api_base</code> (str, optional): The base URL for the OpenAI API.</li> <li><code>openai_proxy</code> (str, optional): An explicit proxy URL for OpenAI requests.</li> <li><code>max_retries</code> (int): The maximum number of retries to make when generating (default: 6).</li> <li><code>prefix_messages</code> (List): A list of messages to set the initial conversation state (default: []).</li> </ul>"},{"location":"swarms/models/openai_chat/#52-configuration","title":"5.2 Configuration","text":""},{"location":"swarms/models/openai_chat/#521-build_extraself-values-dictstr-any-dictstr-any","title":"5.2.1 <code>build_extra(self, values: Dict[str, Any]) -&gt; Dict[str, Any]</code>","text":"<ul> <li>Description: Builds extra kwargs from additional parameters passed in.</li> <li>Arguments:</li> <li><code>values</code> (dict): Values and parameters to build extra kwargs.</li> <li>Returns:</li> <li>Dict[str, Any]: A dictionary of built extra kwargs.</li> </ul>"},{"location":"swarms/models/openai_chat/#522-validate_environmentself-values-dict-dict","title":"5.2.2 <code>validate_environment(self, values: Dict) -&gt; Dict</code>","text":"<ul> <li>Description: Validates that the API key and Python package exist in the environment.</li> <li>Arguments:</li> <li><code>values</code> (dict): The class values and parameters.</li> <li>Returns:</li> <li>Dict: A dictionary of validated values.</li> </ul>"},{"location":"swarms/models/openai_chat/#53-message-handling","title":"5.3 Message Handling","text":""},{"location":"swarms/models/openai_chat/#531-_get_chat_paramsself-prompts-liststr-stop-optionalliststr-none-tuple","title":"5.3.1 <code>_get_chat_params(self, prompts: List[str], stop: Optional[List[str]] = None) -&gt; Tuple</code>","text":"<ul> <li>Description: Gets chat-related parameters for generating responses.</li> <li>Arguments:</li> <li><code>prompts</code> (list): List of user messages.</li> <li><code>stop</code> (list, optional): List of stop words.</li> <li>Returns:</li> <li>Tuple: Messages and parameters.</li> </ul>"},{"location":"swarms/models/openai_chat/#54-generation","title":"5.4 Generation","text":""},{"location":"swarms/models/openai_chat/#541-_streamself-prompt-str-stop-optionalliststr-none-run_manager-optionalcallbackmanagerforllmrun-none-kwargs-any-iteratorgenerationchunk","title":"5.4.1 <code>_stream(self, prompt: str, stop: Optional[List[str]] = None, run_manager: Optional[CallbackManagerForLLMRun] = None, **kwargs: Any) -&gt; Iterator[GenerationChunk]</code>","text":"<ul> <li>Description: Generates text asynchronously using the OpenAI API.</li> <li>Arguments:</li> <li><code>prompt</code> (str): The user's message.</li> <li><code>stop</code> (list, optional): List of stop words.</li> <li><code>run_manager</code> (optional): Callback manager for asynchronous generation.</li> <li><code>**kwargs</code> (dict): Additional parameters for asynchronous generation.</li> <li>Returns:</li> <li>Iterator[GenerationChunk]: An iterator of generated text chunks.</li> </ul>"},{"location":"swarms/models/openai_chat/#542-_agenerateself-prompts-liststr-stop-optionalliststr-none-run_manager-optionalasynccallbackmanagerforllmrun-none-kwargs-any-llmresult","title":"5.4.2 <code>_agenerate(self, prompts: List[str], stop: Optional[List[str]] = None, run_manager: Optional[AsyncCallbackManagerForLLMRun] = None, **kwargs: Any) -&gt; LLMResult</code>","text":"<ul> <li>Description: Generates text asynchronously using the OpenAI API (async version).</li> <li>Arguments:</li> <li><code>prompts</code> (list): List of user messages.</li> <li><code>stop</code> (list, optional): List of stop words.</li> <li><code>run_manager</code> (optional): Callback manager for asynchronous generation.</li> <li><code>**kwargs</code> (dict): Additional parameters for asynchronous generation.</li> <li>Returns:</li> <li>LLMResult: A result object containing the generated text.</li> </ul>"},{"location":"swarms/models/openai_chat/#55-tokenization","title":"5.5 Tokenization","text":""},{"location":"swarms/models/openai_chat/#551-get_token_idsself-text-str-listint","title":"5.5.1 <code>get_token_ids(self, text: str) -&gt; List[int]</code>","text":"<ul> <li>Description: Gets token IDs using the tiktoken package.</li> <li>Arguments:</li> <li><code>text</code> (str): The text for which to calculate token IDs.</li> <li>Returns:</li> <li>List[int]: A list of</li> </ul> <p>token IDs.</p>"},{"location":"swarms/models/openai_chat/#6-usage-examples","title":"6. Usage Examples","text":""},{"location":"swarms/models/openai_chat/#example-1-initializing-openaichat","title":"Example 1: Initializing <code>OpenAIChat</code>","text":"<pre><code>from swarm_models import OpenAIChat\n\n# Initialize OpenAIChat with model name and API key\nopenai_chat = OpenAIChat(model_name=\"gpt-3.5-turbo\", openai_api_key=\"YOUR_API_KEY\")\n</code></pre>"},{"location":"swarms/models/openai_chat/#example-2-sending-messages-and-generating-responses","title":"Example 2: Sending Messages and Generating Responses","text":"<pre><code># Define a conversation\nconversation = [\n    \"User: Tell me a joke.\",\n    \"Assistant: Why did the chicken cross the road?\",\n    \"User: I don't know. Why?\",\n    \"Assistant: To get to the other side!\",\n]\n\n# Set the conversation as the prefix messages\nopenai_chat.prefix_messages = conversation\n\n# Generate a response\nuser_message = \"User: Tell me another joke.\"\nresponse = openai_chat.generate([user_message])\n\n# Print the generated response\nprint(\n    response[0][0].text\n)  # Output: \"Assistant: Why don't scientists trust atoms? Because they make up everything!\"\n</code></pre>"},{"location":"swarms/models/openai_chat/#example-3-asynchronous-generation","title":"Example 3: Asynchronous Generation","text":"<pre><code>import asyncio\n\n\n# Define an asynchronous function for generating responses\nasync def generate_responses():\n    user_message = \"User: Tell me a fun fact.\"\n    async for chunk in openai_chat.stream([user_message]):\n        print(chunk.text)\n\n\n# Run the asynchronous generation function\nasyncio.run(generate_responses())\n</code></pre>"},{"location":"swarms/models/openai_chat/#7-additional-information","title":"7. Additional Information","text":"<ul> <li>To use the <code>OpenAIChat</code> class, you should have the <code>openai</code> Python package installed, and the environment variable <code>OPENAI_API_KEY</code> set with your API key.</li> <li>Any parameters that are valid to be passed to the <code>openai.create</code> call can be passed to the <code>OpenAIChat</code> constructor.</li> <li>You can customize the behavior of the class by setting various attributes, such as <code>model_name</code>, <code>openai_api_key</code>, <code>prefix_messages</code>, and more.</li> <li>For asynchronous generation, you can use the <code>_stream</code> and <code>_agenerate</code> methods to interactively receive model-generated text chunks.</li> <li>To calculate token IDs, you can use the <code>get_token_ids</code> method, which utilizes the <code>tiktoken</code> package. Make sure to install the <code>tiktoken</code> package with <code>pip install tiktoken</code> if needed.</li> </ul> <p>This documentation provides a comprehensive overview of the <code>OpenAIChat</code> class, its attributes, methods, and usage examples. You can use this class to create chatbot applications, conduct conversations with language models, and explore the capabilities of OpenAI's GPT-3.5 Turbo model.</p>"},{"location":"swarms/models/openai_function_caller/","title":"OpenAIFunctionCaller Documentation","text":"<p>The <code>OpenAIFunctionCaller</code> class is designed to interface with OpenAI's chat completion API, allowing users to generate responses based on given prompts using specified models. This class encapsulates the setup and execution of API calls, including handling API keys, model parameters, and response formatting. The class extends the <code>BaseLLM</code> and utilizes OpenAI's client library to facilitate interactions.</p>"},{"location":"swarms/models/openai_function_caller/#class-definition","title":"Class Definition","text":""},{"location":"swarms/models/openai_function_caller/#openaifunctioncaller","title":"OpenAIFunctionCaller","text":"<p>A class that represents a caller for OpenAI chat completions.</p>"},{"location":"swarms/models/openai_function_caller/#attributes","title":"Attributes","text":"Attribute Type Description <code>system_prompt</code> <code>str</code> The system prompt to be used in the chat completion. <code>model_name</code> <code>str</code> The name of the OpenAI model to be used. <code>max_tokens</code> <code>int</code> The maximum number of tokens in the generated completion. <code>temperature</code> <code>float</code> The temperature parameter for randomness in the completion. <code>base_model</code> <code>BaseModel</code> The base model to be used for the completion. <code>parallel_tool_calls</code> <code>bool</code> Whether to make parallel tool calls. <code>top_p</code> <code>float</code> The top-p parameter for nucleus sampling in the completion. <code>client</code> <code>openai.OpenAI</code> The OpenAI client for making API calls."},{"location":"swarms/models/openai_function_caller/#methods","title":"Methods","text":""},{"location":"swarms/models/openai_function_caller/#check_api_key","title":"<code>check_api_key</code>","text":"<p>Checks if the API key is provided and retrieves it from the environment if not.</p> Parameter Type Description None <p>Returns:</p> Type Description <code>str</code> The API key."},{"location":"swarms/models/openai_function_caller/#run","title":"<code>run</code>","text":"<p>Runs the chat completion with the given task and returns the generated completion.</p> Parameter Type Description <code>task</code> <code>str</code> The user's task for the chat completion. <code>*args</code> Additional positional arguments to be passed to the OpenAI API. <code>**kwargs</code> Additional keyword arguments to be passed to the OpenAI API. <p>Returns:</p> Type Description <code>str</code> The generated completion."},{"location":"swarms/models/openai_function_caller/#convert_to_dict_from_base_model","title":"<code>convert_to_dict_from_base_model</code>","text":"<p>Converts a <code>BaseModel</code> to a dictionary.</p> Parameter Type Description <code>base_model</code> <code>BaseModel</code> The BaseModel to be converted. <p>Returns:</p> Type Description <code>dict</code> A dictionary representing the BaseModel."},{"location":"swarms/models/openai_function_caller/#convert_list_of_base_models","title":"<code>convert_list_of_base_models</code>","text":"<p>Converts a list of <code>BaseModels</code> to a list of dictionaries.</p> Parameter Type Description <code>base_models</code> <code>List[BaseModel]</code> A list of BaseModels to be converted. <p>Returns:</p> Type Description <code>List[Dict]</code> A list of dictionaries representing the converted BaseModels."},{"location":"swarms/models/openai_function_caller/#usage-examples","title":"Usage Examples","text":"<p>Here are three examples demonstrating different ways to use the <code>OpenAIFunctionCaller</code> class:</p>"},{"location":"swarms/models/openai_function_caller/#example-1-production-grade-claude-artifacts","title":"Example 1: Production-Grade Claude Artifacts","text":"<pre><code>import openai\nfrom swarm_models.openai_function_caller import OpenAIFunctionCaller\nfrom swarms.artifacts.main_artifact import Artifact\n\n\n# Pydantic is a data validation library that provides data validation and parsing using Python type hints.\n\n\n# Example usage:\n# Initialize the function caller\nmodel = OpenAIFunctionCaller(\n    system_prompt=\"You're a helpful assistant.The time is August 6, 2024\",\n    max_tokens=500,\n    temperature=0.5,\n    base_model=Artifact,\n    parallel_tool_calls=False,\n)\n\n\n# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.\n# Here, we initialize an instance of the OpenAIFunctionCaller class with the following parameters:\n# - system_prompt: A prompt that sets the context for the conversation with the API.\n# - max_tokens: The maximum number of tokens to generate in the API response.\n# - temperature: A parameter that controls the randomness of the generated text.\n# - base_model: The base model to use for the API calls, in this case, the WeatherAPI class.\nout = model.run(\"Create a python file with a python game code in it\")\nprint(out)\n</code></pre>"},{"location":"swarms/models/openai_function_caller/#example-2-prompt-generator","title":"Example 2: Prompt Generator","text":"<pre><code>from swarm_models.openai_function_caller import OpenAIFunctionCaller\nfrom pydantic import BaseModel, Field\nfrom typing import Sequence\n\n\nclass PromptUseCase(BaseModel):\n    use_case_name: str = Field(\n        ...,\n        description=\"The name of the use case\",\n    )\n    use_case_description: str = Field(\n        ...,\n        description=\"The description of the use case\",\n    )\n\n\nclass PromptSpec(BaseModel):\n    prompt_name: str = Field(\n        ...,\n        description=\"The name of the prompt\",\n    )\n    prompt_description: str = Field(\n        ...,\n        description=\"The description of the prompt\",\n    )\n    prompt: str = Field(\n        ...,\n        description=\"The prompt for the agent\",\n    )\n    tags: str = Field(\n        ...,\n        description=\"The tags for the prompt such as sentiment, code, etc seperated by commas.\",\n    )\n    use_cases: Sequence[PromptUseCase] = Field(\n        ...,\n        description=\"The use cases for the prompt\",\n    )\n\n\n# Example usage:\n# Initialize the function caller\nmodel = OpenAIFunctionCaller(\n    system_prompt=\"You're an agent creator, you're purpose is to create system prompt for new LLM Agents for the user. Follow the best practices for creating a prompt such as making it direct and clear. Providing instructions and many-shot examples will help the agent understand the task better.\",\n    max_tokens=1000,\n    temperature=0.5,\n    base_model=PromptSpec,\n    parallel_tool_calls=False,\n)\n\n\n# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.\nout = model.run(\n    \"Create an prompt for generating quality rust code with instructions and examples.\"\n)\nprint(out)\n</code></pre>"},{"location":"swarms/models/openai_function_caller/#example-3-sentiment-analysis","title":"Example 3: Sentiment Analysis","text":"<pre><code>from swarm_models.openai_function_caller import OpenAIFunctionCaller\nfrom pydantic import BaseModel, Field\n\n\n# Pydantic is a data validation library that provides data validation and parsing using Python type hints.\n# It is used here to define the data structure for making API calls to retrieve weather information.\nclass SentimentAnalysisCard(BaseModel):\n    text: str = Field(\n        ...,\n        description=\"The text to be analyzed for sentiment rating\",\n    )\n    rating: str = Field(\n        ...,\n        description=\"The sentiment rating of the text from 0.0 to 1.0\",\n    )\n\n\n# The WeatherAPI class is a Pydantic BaseModel that represents the data structure\n# for making API calls to retrieve weather information. It has two attributes: city and date.\n\n# Example usage:\n# Initialize the function caller\nmodel = OpenAIFunctionCaller(\n    system_prompt=\"You're a sentiment Analysis Agent, you're purpose is to rate the sentiment of text\",\n    max_tokens=100,\n    temperature=0.5,\n    base_model=SentimentAnalysisCard,\n    parallel_tool_calls=False,\n)\n\n\n# The OpenAIFunctionCaller class is used to interact with the OpenAI API and make function calls.\n# Here, we initialize an instance of the OpenAIFunctionCaller class with the following parameters:\n# - system_prompt: A prompt that sets the context for the conversation with the API.\n# - max_tokens: The maximum number of tokens to generate in the API response.\n# - temperature: A parameter that controls the randomness of the generated text.\n# - base_model: The base model to use for the API calls, in this case, the WeatherAPI class.\nout = model.run(\"The hotel was average, but the food was excellent.\")\nprint(out)\n</code></pre>"},{"location":"swarms/models/openai_function_caller/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Ensure that your OpenAI API key is securely stored and not hard-coded into your source code. Use environment variables to manage sensitive information.</li> <li>Adjust the <code>temperature</code> and <code>top_p</code> parameters to control the randomness and diversity of the generated responses. Lower values for <code>temperature</code> will result in more deterministic outputs, while higher values will introduce more variability.</li> <li>When using <code>parallel_tool_calls</code>, ensure that the tools you are calling in parallel are thread-safe and can handle concurrent execution.</li> </ul>"},{"location":"swarms/models/openai_function_caller/#references-and-resources","title":"References and Resources","text":"<ul> <li>OpenAI API Documentation</li> <li>Pydantic Documentation</li> <li>Loguru Logger Documentation</li> </ul> <p>By following this comprehensive guide, you can effectively utilize the <code>OpenAIFunctionCaller</code> class to generate chat completions using OpenAI's models, customize the response parameters, and handle API interactions seamlessly within your application.</p>"},{"location":"swarms/models/openai_tts/","title":"<code>OpenAITTS</code> Documentation","text":""},{"location":"swarms/models/openai_tts/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Installation</li> <li>Usage</li> <li>Initialization</li> <li>Running TTS</li> <li>Running TTS and Saving</li> <li>Examples</li> <li>Basic Usage</li> <li>Saving the Output</li> <li>Advanced Options</li> <li>Troubleshooting</li> <li>References</li> </ol>"},{"location":"swarms/models/openai_tts/#1-overview","title":"1. Overview","text":"<p>The <code>OpenAITTS</code> module is a Python library that provides an interface for converting text to speech (TTS) using the OpenAI TTS API. It allows you to generate high-quality speech from text input, making it suitable for various applications such as voice assistants, speech synthesis, and more.</p>"},{"location":"swarms/models/openai_tts/#features","title":"Features:","text":"<ul> <li>Convert text to speech using OpenAI's TTS model.</li> <li>Supports specifying the model name, voice, and other parameters.</li> <li>Option to save the generated speech to a WAV file.</li> </ul>"},{"location":"swarms/models/openai_tts/#2-installation","title":"2. Installation","text":"<p>To use the <code>OpenAITTS</code> model, you need to install the necessary dependencies. You can do this using <code>pip</code>:</p> <pre><code>pip install swarms requests wave\n</code></pre>"},{"location":"swarms/models/openai_tts/#3-usage","title":"3. Usage","text":""},{"location":"swarms/models/openai_tts/#initialization","title":"Initialization","text":"<p>To use the <code>OpenAITTS</code> module, you need to initialize an instance of the <code>OpenAITTS</code> class. Here's how you can do it:</p> <pre><code>from swarm_models.openai_tts import OpenAITTS\n\n# Initialize the OpenAITTS instance\ntts = OpenAITTS(\n    model_name=\"tts-1-1106\",\n    proxy_url=\"https://api.openai.com/v1/audio/speech\",\n    openai_api_key=openai_api_key_env,\n    voice=\"onyx\",\n)\n</code></pre>"},{"location":"swarms/models/openai_tts/#parameters","title":"Parameters:","text":"<ul> <li><code>model_name</code> (str): The name of the TTS model to use (default is \"tts-1-1106\").</li> <li><code>proxy_url</code> (str): The URL for the OpenAI TTS API (default is \"https://api.openai.com/v1/audio/speech\").</li> <li><code>openai_api_key</code> (str): Your OpenAI API key. It can be obtained from the OpenAI website.</li> <li><code>voice</code> (str): The voice to use for generating speech (default is \"onyx\").</li> <li><code>chunk_size</code> (int): The size of data chunks when fetching audio (default is 1024 * 1024 bytes).</li> <li><code>autosave</code> (bool): Whether to automatically save the generated speech to a file (default is False).</li> <li><code>saved_filepath</code> (str): The path to the file where the speech will be saved (default is \"runs/tts_speech.wav\").</li> </ul>"},{"location":"swarms/models/openai_tts/#running-tts","title":"Running TTS","text":"<p>Once the <code>OpenAITTS</code> instance is initialized, you can use it to convert text to speech using the <code>run</code> method:</p> <pre><code># Generate speech from text\nspeech_data = tts.run(\"Hello, world!\")\n</code></pre>"},{"location":"swarms/models/openai_tts/#parameters_1","title":"Parameters:","text":"<ul> <li><code>task</code> (str): The text you want to convert to speech.</li> </ul>"},{"location":"swarms/models/openai_tts/#returns","title":"Returns:","text":"<ul> <li><code>speech_data</code> (bytes): The generated speech data.</li> </ul>"},{"location":"swarms/models/openai_tts/#running-tts-and-saving","title":"Running TTS and Saving","text":"<p>You can also use the <code>run_and_save</code> method to generate speech from text and save it to a file:</p> <pre><code># Generate speech from text and save it to a file\nspeech_data = tts.run_and_save(\"Hello, world!\")\n</code></pre>"},{"location":"swarms/models/openai_tts/#parameters_2","title":"Parameters:","text":"<ul> <li><code>task</code> (str): The text you want to convert to speech.</li> </ul>"},{"location":"swarms/models/openai_tts/#returns_1","title":"Returns:","text":"<ul> <li><code>speech_data</code> (bytes): The generated speech data.</li> </ul>"},{"location":"swarms/models/openai_tts/#4-examples","title":"4. Examples","text":""},{"location":"swarms/models/openai_tts/#basic-usage","title":"Basic Usage","text":"<p>Here's a basic example of how to use the <code>OpenAITTS</code> module to generate speech from text:</p> <pre><code>from swarm_models.openai_tts import OpenAITTS\n\n# Initialize the OpenAITTS instance\ntts = OpenAITTS(\n    model_name=\"tts-1-1106\",\n    proxy_url=\"https://api.openai.com/v1/audio/speech\",\n    openai_api_key=openai_api_key_env,\n    voice=\"onyx\",\n)\n\n# Generate speech from text\nspeech_data = tts.run(\"Hello, world!\")\n</code></pre>"},{"location":"swarms/models/openai_tts/#saving-the-output","title":"Saving the Output","text":"<p>You can save the generated speech to a WAV file using the <code>run_and_save</code> method:</p> <pre><code># Generate speech from text and save it to a file\nspeech_data = tts.run_and_save(\"Hello, world!\")\n</code></pre>"},{"location":"swarms/models/openai_tts/#5-advanced-options","title":"5. Advanced Options","text":"<p>The <code>OpenAITTS</code> module supports various advanced options for customizing the TTS generation process. You can specify the model name, voice, and other parameters during initialization. Additionally, you can configure the chunk size for audio data fetching and choose whether to automatically save the generated speech to a file.</p>"},{"location":"swarms/models/openai_tts/#6-troubleshooting","title":"6. Troubleshooting","text":"<p>If you encounter any issues while using the <code>OpenAITTS</code> module, please make sure you have installed all the required dependencies and that your OpenAI API key is correctly configured. If you still face problems, refer to the OpenAI documentation or contact their support for assistance.</p>"},{"location":"swarms/models/openai_tts/#7-references","title":"7. References","text":"<ul> <li>OpenAI API Documentation</li> <li>Python Requests Library</li> <li>Python Wave Library</li> </ul> <p>This documentation provides a comprehensive guide on how to use the <code>OpenAITTS</code> module to convert text to speech using OpenAI's TTS model. It covers initialization, basic usage, advanced options, troubleshooting, and references for further exploration.</p>"},{"location":"swarms/models/vilt/","title":"<code>Vilt</code> Documentation","text":""},{"location":"swarms/models/vilt/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for Vilt, a Vision-and-Language Transformer (ViLT) model fine-tuned on the VQAv2 dataset. Vilt is a powerful model capable of answering questions about images. This documentation will provide a comprehensive understanding of Vilt, its architecture, usage, and how it can be integrated into your projects.</p>"},{"location":"swarms/models/vilt/#overview","title":"Overview","text":"<p>Vilt is based on the Vision-and-Language Transformer (ViLT) architecture, designed for tasks that involve understanding both text and images. It has been fine-tuned on the VQAv2 dataset, making it adept at answering questions about images. This model is particularly useful for tasks where textual and visual information needs to be combined to provide meaningful answers.</p>"},{"location":"swarms/models/vilt/#class-definition","title":"Class Definition","text":"<pre><code>class Vilt:\n    def __init__(self):\n        \"\"\"\n        Initialize the Vilt model.\n        \"\"\"\n</code></pre>"},{"location":"swarms/models/vilt/#usage","title":"Usage","text":"<p>To use the Vilt model, follow these steps:</p> <ol> <li>Initialize the Vilt model:</li> </ol> <pre><code>from swarm_models import Vilt\n\nmodel = Vilt()\n</code></pre> <ol> <li>Call the model with a text question and an image URL:</li> </ol> <pre><code>output = model(\n    \"What is this image?\", \"http://images.cocodataset.org/val2017/000000039769.jpg\"\n)\n</code></pre>"},{"location":"swarms/models/vilt/#example-1-image-questioning","title":"Example 1 - Image Questioning","text":"<pre><code>model = Vilt()\noutput = model(\n    \"What are the objects in this image?\",\n    \"http://images.cocodataset.org/val2017/000000039769.jpg\",\n)\nprint(output)\n</code></pre>"},{"location":"swarms/models/vilt/#example-2-image-analysis","title":"Example 2 - Image Analysis","text":"<pre><code>model = Vilt()\noutput = model(\n    \"Describe the scene in this image.\",\n    \"http://images.cocodataset.org/val2017/000000039769.jpg\",\n)\nprint(output)\n</code></pre>"},{"location":"swarms/models/vilt/#example-3-visual-knowledge-retrieval","title":"Example 3 - Visual Knowledge Retrieval","text":"<pre><code>model = Vilt()\noutput = model(\n    \"Tell me more about the landmark in this image.\",\n    \"http://images.cocodataset.org/val2017/000000039769.jpg\",\n)\nprint(output)\n</code></pre>"},{"location":"swarms/models/vilt/#how-vilt-works","title":"How Vilt Works","text":"<p>Vilt operates by combining text and image information to generate meaningful answers to questions about the provided image. Here's how it works:</p> <ol> <li> <p>Initialization: When you create a Vilt instance, it initializes the processor and the model. The processor is responsible for handling the image and text input, while the model is the fine-tuned ViLT model.</p> </li> <li> <p>Processing Input: When you call the Vilt model with a text question and an image URL, it downloads the image and processes it along with the text question. This processing step involves tokenization and encoding of the input.</p> </li> <li> <p>Forward Pass: The encoded input is then passed through the ViLT model. It calculates the logits, and the answer with the highest probability is selected.</p> </li> <li> <p>Output: The predicted answer is returned as the output of the model.</p> </li> </ol>"},{"location":"swarms/models/vilt/#parameters","title":"Parameters","text":"<p>Vilt does not require any specific parameters during initialization. It is pre-configured to work with the \"dandelin/vilt-b32-finetuned-vqa\" model.</p>"},{"location":"swarms/models/vilt/#additional-information","title":"Additional Information","text":"<ul> <li>Vilt is fine-tuned on the VQAv2 dataset, making it proficient at answering questions about a wide range of images.</li> <li>You can use Vilt for various applications, including image question-answering, image analysis, and visual knowledge retrieval.</li> </ul> <p>That concludes the documentation for Vilt. We hope you find this model useful for your vision-and-language tasks. If you have any questions or encounter any issues, please refer to the Hugging Face Transformers documentation for further assistance. Enjoy working with Vilt!</p>"},{"location":"swarms/prompts/essence/","title":"The Essence of Enterprise-Grade Prompting","text":"<p>Large Language Models (LLMs) like GPT-4 have revolutionized the landscape of AI-driven automation, customer support, marketing, and more. However, extracting the highest quality output from these models requires a thoughtful approach to crafting prompts\u2014an endeavor that goes beyond mere trial and error. In enterprise settings, where consistency, quality, and performance are paramount, enterprise-grade prompting has emerged as a structured discipline, combining art with the science of human-machine communication.</p> <p>Enterprise-grade prompting involves understanding the intricate dynamics between language models, context, and the task at hand. It requires knowledge of not only the technical capabilities of LLMs but also the intricacies of how they interpret human language. Effective prompting becomes the linchpin for ensuring that AI-driven outputs are accurate, reliable, and aligned with business needs. It is this discipline that turns raw AI capabilities into tangible enterprise value.</p> <p>In this essay, we will dissect the essence of enterprise-grade prompting, explore the most effective prompting strategies, explain what works and what doesn't, and conclude with the current holy grail of automated prompt engineering. We will also share concrete examples and illustrations of each technique, with a particular focus on their application in an enterprise setting.</p>"},{"location":"swarms/prompts/essence/#1-foundational-principles-of-prompting","title":"1. Foundational Principles of Prompting","text":"<p>The effectiveness of prompting lies in understanding both the capabilities and limitations of LLMs. A well-structured prompt helps LLMs focus on the most relevant information while avoiding ambiguities that can lead to unreliable results. In enterprise-grade contexts, prompts must be designed with the end-user's expectations in mind, ensuring quality, safety, scalability, and traceability.</p> <ul> <li>Clarity: Prompts should be clear and devoid of unnecessary jargon. Ambiguity can misguide the model, leading to poor-quality output. For enterprise use, clarity means avoiding misunderstandings that could affect customer relationships or lead to non-compliance with regulations.</li> <li>Context: Providing sufficient context ensures the model understands the nuances of the prompt. For example, specifying whether a response is aimed at a technical audience versus a general audience can lead to more accurate outputs. Context is essential in creating responses that are not only accurate but also relevant to the target audience.</li> <li>Instruction Granularity: The level of detail in the instruction significantly impacts the quality of the output. Broad instructions might lead to vagueness, whereas overly detailed instructions could overwhelm the model. Finding the right balance is key to generating useful responses.</li> </ul> <p>Example: Instead of prompting \"Explain what a blockchain is,\" an enterprise-grade prompt might be \"Explain the concept of blockchain, focusing on how distributed ledgers help increase transparency in supply chain management. Keep the explanation under 200 words for a general audience.\" This prompt provides clear, relevant, and concise instructions tailored to specific needs.</p>"},{"location":"swarms/prompts/essence/#2-best-prompting-strategies","title":"2. Best Prompting Strategies","text":"<p>The field of enterprise-grade prompting employs numerous strategies to maximize the quality of LLM output. Here are some of the most effective ones:</p>"},{"location":"swarms/prompts/essence/#21-instruction-based-prompting","title":"2.1. Instruction-Based Prompting","text":"<p>Instruction-based prompting provides explicit instructions for the LLM to follow. This approach is valuable in enterprise applications where responses must adhere to a specific tone, structure, or depth of analysis.</p> <p>Example:</p> <ul> <li>\"Summarize the following press release in 3 bullet points suitable for a marketing team meeting.\"</li> </ul> <p>This prompt is highly effective because it instructs the model on what format (bullet points), audience (marketing team), and depth (summary) to produce, minimizing the risk of irrelevant details.</p> <p>Why It Works: LLMs excel when they have a clear set of rules to follow. Enterprises benefit from this structured approach, as it ensures consistency across multiple use cases, be it marketing, HR, or customer service. Clear instructions also make it easier to validate outputs against defined expectations, which is crucial for maintaining quality.</p>"},{"location":"swarms/prompts/essence/#22-multi-shot-prompting","title":"2.2. Multi-Shot Prompting","text":"<p>Multi-shot prompting provides several examples before asking the model to complete a task. This helps set expectations by showing the model the desired style and type of output.</p> <p>Example:</p> <ul> <li>\"Here are some example customer support responses:</li> <li>Customer: 'I can't access my account.'      Response: 'We're sorry you're having trouble accessing your account. Please try resetting your password using the link provided.'</li> <li> <p>Customer: 'I received a damaged item.'      Response: 'We apologize for the damaged item. Please provide us with your order number so we can send a replacement.'</p> </li> <li> <p>Customer: 'The app keeps crashing on my phone.'   Response:\"</p> </li> </ul> <p>Why It Works: Multi-shot prompting is highly effective in enterprise-grade applications where consistency is critical. Showing multiple examples helps the model learn patterns without needing extensive fine-tuning, saving both time and cost. Enterprises can leverage this technique to ensure that responses remain aligned with brand standards and customer expectations across different departments.</p>"},{"location":"swarms/prompts/essence/#23-chain-of-thought-prompting","title":"2.3. Chain of Thought Prompting","text":"<p>Chain of Thought (CoT) prompting helps LLMs generate reasoning steps explicitly before arriving at an answer. This method is useful for complex problem-solving tasks or when transparency in decision-making is important.</p> <p>Example:</p> <ul> <li>\"A logistics company wants to minimize fuel costs across multiple delivery routes. Here are the conditions: Each truck has a fuel capacity of 100 gallons, and the price of fuel fluctuates per state. Think through the most cost-effective approach for planning delivery, step by step.\"</li> </ul> <p>Why It Works: CoT prompting allows the model to work through the process iteratively, providing more explainable results. In enterprise applications where complex decision-making is involved, this strategy ensures stakeholders understand why a particular output was generated. This transparency is crucial in high-stakes areas like finance, healthcare, and logistics, where understanding the reasoning behind an output is as important as the output itself.</p>"},{"location":"swarms/prompts/essence/#24-iterative-feedback-and-adaptive-prompting","title":"2.4. Iterative Feedback and Adaptive Prompting","text":"<p>Iterative prompting involves providing multiple prompts or rounds of feedback to refine the output. Adaptive prompts take prior responses and adjust based on context, ensuring the final output meets the required standard.</p> <p>Example:</p> <ul> <li>First Prompt: \"Generate a mission statement for our AI-driven logistics company.\"</li> <li>Model Response: \"We use artificial intelligence to enhance logistics.\"</li> <li>Follow-up Prompt: \"Can you make the statement more specific by mentioning how AI improves efficiency and sustainability?\"</li> </ul> <p>Why It Works: Enterprises require output that is precise and tailored to brand identity. Iterative feedback provides an effective means to adjust and refine outputs until the desired quality is achieved. By breaking down the task into multiple feedback loops, enterprises can ensure the final output is aligned with their core values and objectives.</p>"},{"location":"swarms/prompts/essence/#25-contextual-expansion-for-enhanced-relevance","title":"2.5. Contextual Expansion for Enhanced Relevance","text":"<p>A lesser-known but powerful strategy is contextual expansion. This involves expanding the prompt to include broader information about the context, thereby allowing the model to generate richer, more relevant responses.</p> <p>Example:</p> <ul> <li>Original Prompt: \"Write a response to a customer asking for a refund.\"</li> <li>Contextually Expanded Prompt: \"Write a response to a customer asking for a refund on a recently purchased product. The customer expressed dissatisfaction with the quality and mentioned they want the process to be quick. Ensure the response is empathetic and explains the refund process clearly, while also offering alternative solutions like an exchange if possible.\"</li> </ul> <p>Why It Works: By including more context, the prompt allows the model to generate a response that feels more tailored to the customer's situation, enhancing both satisfaction and trust. Enterprises benefit from this approach by increasing the quality of customer service interactions.</p>"},{"location":"swarms/prompts/essence/#3-what-doesnt-work-in-prompting","title":"3. What Doesn't Work in Prompting","text":"<p>While the above methods are effective, prompting can often fall short in certain scenarios:</p>"},{"location":"swarms/prompts/essence/#31-overly-vague-prompts","title":"3.1. Overly Vague Prompts","text":"<p>An insufficiently detailed prompt results in vague outputs. For example, simply asking \"What are some strategies to grow a business?\" can lead to generic responses that lack actionable insight. Vague prompts are particularly problematic in enterprise settings where specificity is crucial to drive action.</p>"},{"location":"swarms/prompts/essence/#32-excessive-length","title":"3.2. Excessive Length","text":"<p>Overloading a prompt with details often causes the LLM to become confused, producing incomplete or inaccurate responses. For example, \"Explain blockchain, focusing on cryptographic methods, network nodes, ledger distribution, proof of work, mining processes, hash functions, transaction validation, etc.\" attempts to include too many subjects for a concise response. Enterprise-grade prompts should focus on a specific area to avoid overwhelming the model and degrading the output quality.</p>"},{"location":"swarms/prompts/essence/#33-ambiguity-in-expected-output","title":"3.3. Ambiguity in Expected Output","text":"<p>Ambiguity arises when prompts don't clearly specify the desired output format, tone, or length. For example, asking \"Describe our new product\" without specifying whether it should be a single-line summary, a paragraph, or a technical overview can lead to an unpredictable response. Enterprises must clearly define expectations to ensure consistent and high-quality outputs.</p>"},{"location":"swarms/prompts/essence/#4-the-holy-grail-automated-prompt-engineering","title":"4. The Holy Grail: Automated Prompt Engineering","text":"<p>In an enterprise setting, scaling prompt engineering for consistency and high performance remains a key challenge. Automated Prompt Engineering (APE) offers a potential solution for bridging the gap between individual craftsmanship and enterprise-wide implementation.</p> <p>4.1. AI-Augmented Prompt Design</p> <p>Automated Prompt Engineering tools can evaluate the outputs generated by various prompts, selecting the one with the highest quality metrics. These tools can be trained to understand what constitutes an ideal response for specific enterprise contexts.</p> <p>Example:</p> <ul> <li>An APE system takes multiple variations of a prompt for generating email responses to customer complaints. After evaluating the sentiment, tone, and accuracy of each response, it selects the prompt that yields the most favorable output for business goals.</li> </ul> <p>Why It Works: AI-Augmented Prompt Design reduces the need for manual intervention and standardizes the quality of responses across the organization. This approach helps enterprises maintain consistency while saving valuable time that would otherwise be spent on trial-and-error prompting.</p> <p>4.2. Reinforcement Learning for Prompts (RLP)</p> <p>Using Reinforcement Learning for Prompts involves training models to automatically iterate on prompts to improve the quality of the final output. The model is rewarded for generating responses that align with predefined criteria, such as clarity, completeness, or relevance.</p> <p>Example:</p> <ul> <li>An enterprise uses RLP to refine prompts used in internal compliance checks. The model iteratively generates summaries of compliance reports, refining the prompt until it consistently generates clear, concise, and accurate summaries aligned with internal guidelines.</li> </ul> <p>Why It Works: RLP can significantly improve the quality of complex outputs over time. Enterprises that require a high level of precision, such as in legal or compliance-related applications, benefit from RLP by ensuring outputs meet stringent standards.</p> <p>4.3. Dynamic Contextual Adaptation</p> <p>Another aspect of automated prompt engineering involves adapting prompts in real time based on user context. For example, if a user interacting with a customer support bot seems frustrated (as detected by sentiment analysis), an adaptive prompt may be used to generate a more empathetic response.</p> <p>Example:</p> <ul> <li>User: \"I'm really annoyed that my order hasn't arrived yet.\"</li> <li>Prompt (adapted): \"I'm truly sorry for the inconvenience you're experiencing. Please let me help you resolve this as quickly as possible. Could you provide your order number so I can check its status right away?\"</li> </ul> <p>Why It Works: In dynamic enterprise environments, where every user experience matters, adapting prompts to the immediate context can significantly improve customer satisfaction. Real-time adaptation allows the model to be more responsive and attuned to customer needs, thereby fostering loyalty and trust.</p> <p>4.4. Collaborative Prompt Refinement</p> <p>Automated prompt engineering can also involve collaboration between AI models and human experts. Collaborative Prompt Refinement (CPR) allows human operators to provide iterative guidance, which the model then uses to enhance its understanding and improve future outputs.</p> <p>Example:</p> <ul> <li>A financial analyst uses a prompt to generate an investment report. The model provides an initial draft, and the analyst refines it with comments. The model learns from these comments and applies similar refinements to future reports, reducing the analyst\u2019s workload over time.</li> </ul> <p>Why It Works: CPR bridges the gap between human expertise and machine efficiency, ensuring that outputs are not only technically accurate but also aligned with expert expectations. This iterative learning loop enhances the model\u2019s ability to autonomously generate high-quality content.</p>"},{"location":"swarms/prompts/essence/#5-the-future-of-enterprise-grade-prompting","title":"5. The Future of Enterprise-Grade Prompting","text":"<p>The future of enterprise-grade prompting is in leveraging automation, context-awareness, and reinforcement learning. By moving from static prompts to dynamic, learning-enabled systems, enterprises can ensure consistent and optimized communication across their AI systems.</p> <p>Automated systems such as APE and RLP are in their early stages, but they represent the potential to deliver highly scalable prompting solutions that automatically evolve based on user feedback and performance metrics. As more sophisticated models and methods become available, enterprise-grade prompting will likely involve:</p> <ul> <li>Fully Adaptive Models: Models that can detect and adjust to the tone, intent, and needs of users in real time. This means less manual intervention and greater responsiveness to user context.</li> <li>Cross-Domain Learning: Prompting systems that leverage insights across multiple domains to improve response quality. For example, lessons learned from customer service prompts could be applied to internal HR prompts to enhance employee communications.</li> <li>Human-in-the-Loop Systems: Combining automated prompt generation with human validation to ensure compliance, accuracy, and brand consistency. Human-in-the-loop systems allow enterprises to leverage the efficiency of automation while maintaining a high level of quality control.</li> </ul> <p>The rise of self-improving prompting systems marks a significant shift in how enterprises leverage AI for communication and decision-making. As more sophisticated models emerge, we anticipate a greater emphasis on adaptability, real-time learning, and seamless integration with existing business processes.</p> <p>Conclusion</p> <p>Enterprise-grade prompting transcends the art of crafting effective prompts into a well-defined process, merging structure with creativity and guided refinement. By understanding the foundational principles, leveraging strategies like instruction-based and chain-of-thought prompting, and adopting automation, enterprises can consistently extract high-quality results from LLMs.</p> <p>The evolution towards automated prompt engineering is transforming enterprise AI use from reactive problem-solving to proactive, intelligent decision-making. As the enterprise AI ecosystem matures, prompting will continue to be the linchpin that aligns the capabilities of LLMs with real-world business needs, ensuring optimal outcomes at scale.</p> <p>Whether it's customer support, compliance, marketing, or operational analytics, the strategies outlined in this essay\u2014paired with advancements in automated prompt engineering\u2014hold the key to effective, scalable, and enterprise-grade utilization of AI models. Enterprises that invest in these methodologies today are likely to maintain a competitive edge in an increasingly automated business landscape.</p> <p>Next Steps</p> <p>This essay is a stepping stone towards understanding enterprise-grade prompting. We encourage AI teams to start experimenting with these prompting techniques in sandbox environments, identify what works best for their needs, and gradually iterate. Automation is the future, and investing in automated prompt engineering today will yield highly optimized, scalable solutions that consistently deliver value.</p> <p>Ready to take the next step? Let\u2019s explore how to design adaptive prompting frameworks tailored to your enterprise\u2019s unique requirements.</p>"},{"location":"swarms/prompts/main/","title":"Managing Prompts in Production","text":"<p>The <code>Prompt</code> class provides a comprehensive solution for managing prompts, including advanced features like version control, autosaving, and logging. This guide will walk you through how to effectively use this class in a production environment, focusing on its core features, use cases, and best practices.</p>"},{"location":"swarms/prompts/main/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Getting Started<ul> <li>Installation and Setup</li> <li>Creating a New Prompt</li> </ul> </li> <li>Managing Prompt Content<ul> <li>Editing Prompts</li> <li>Retrieving Prompt Content</li> </ul> </li> <li>Version Control<ul> <li>Tracking Edits and History</li> <li>Rolling Back to Previous Versions</li> </ul> </li> <li>Autosaving Prompts<ul> <li>Enabling and Configuring Autosave</li> <li>Manually Triggering Autosave</li> </ul> </li> <li>Logging and Telemetry</li> <li>Handling Errors</li> <li>Extending the Prompt Class<ul> <li>Customizing the Save Mechanism</li> <li>Integrating with Databases</li> </ul> </li> </ol>"},{"location":"swarms/prompts/main/#1-getting-started","title":"1. Getting Started","text":""},{"location":"swarms/prompts/main/#installation-and-setup","title":"Installation and Setup","text":"<p>Before diving into how to use the <code>Prompt</code> class, ensure that you have the required dependencies installed:</p> <pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/prompts/main/#creating-a-new-prompt","title":"Creating a New Prompt","text":"<p>To create a new instance of a <code>Prompt</code>, simply initialize it with the required attributes such as <code>content</code>:</p> <pre><code>from swarms import Prompt\n\nprompt = Prompt(\n    content=\"This is my first prompt!\",\n    name=\"My First Prompt\",\n    description=\"A simple example prompt.\"\n)\n\nprint(prompt)\n</code></pre> <p>This creates a new prompt with the current timestamp and a unique identifier.</p>"},{"location":"swarms/prompts/main/#2-managing-prompt-content","title":"2. Managing Prompt Content","text":""},{"location":"swarms/prompts/main/#editing-prompts","title":"Editing Prompts","text":"<p>Once you have initialized a prompt, you can edit its content using the <code>edit_prompt</code> method. Each time the content is edited, a new version is stored in the <code>edit_history</code>, and the <code>last_modified_at</code> timestamp is updated.</p> <pre><code>new_content = \"This is an updated version of my prompt.\"\nprompt.edit_prompt(new_content)\n</code></pre> <p>Note: If the new content is identical to the current content, an error will be raised to prevent unnecessary edits:</p> <pre><code>try:\n    prompt.edit_prompt(\"This is my first prompt!\")  # Same as initial content\nexcept ValueError as e:\n    print(e)  # Output: New content must be different from the current content.\n</code></pre>"},{"location":"swarms/prompts/main/#retrieving-prompt-content","title":"Retrieving Prompt Content","text":"<p>You can retrieve the current prompt content using the <code>get_prompt</code> method:</p> <pre><code>current_content = prompt.get_prompt()\nprint(current_content)  # Output: This is an updated version of my prompt.\n</code></pre> <p>This method also logs telemetry data, which includes both system information and prompt metadata.</p>"},{"location":"swarms/prompts/main/#3-version-control","title":"3. Version Control","text":""},{"location":"swarms/prompts/main/#tracking-edits-and-history","title":"Tracking Edits and History","text":"<p>The <code>Prompt</code> class automatically tracks every change made to the prompt. This is stored in the <code>edit_history</code> attribute as a list of previous versions.</p> <pre><code>print(prompt.edit_history)  # Output: ['This is my first prompt!', 'This is an updated version of my prompt.']\n</code></pre> <p>The number of edits is also tracked using the <code>edit_count</code> attribute:</p> <pre><code>print(prompt.edit_count)  # Output: 2\n</code></pre>"},{"location":"swarms/prompts/main/#rolling-back-to-previous-versions","title":"Rolling Back to Previous Versions","text":"<p>If you want to revert a prompt to a previous version, you can use the <code>rollback</code> method, passing the version index you want to revert to:</p> <pre><code>prompt.rollback(0)\nprint(prompt.get_prompt())  # Output: This is my first prompt!\n</code></pre> <p>The rollback operation is thread-safe, and any rollback also triggers a telemetry log.</p>"},{"location":"swarms/prompts/main/#4-autosaving-prompts","title":"4. Autosaving Prompts","text":""},{"location":"swarms/prompts/main/#enabling-and-configuring-autosave","title":"Enabling and Configuring Autosave","text":"<p>To automatically save prompts to storage after every change, you can enable the <code>autosave</code> feature when initializing the prompt:</p> <pre><code>prompt = Prompt(\n    content=\"This is my first prompt!\",\n    autosave=True,\n    autosave_folder=\"my_prompts\"  # Specify the folder within WORKSPACE_DIR\n)\n</code></pre> <p>This will ensure that every edit or rollback action triggers an autosave to the specified folder.</p>"},{"location":"swarms/prompts/main/#manually-triggering-autosave","title":"Manually Triggering Autosave","text":"<p>You can also manually trigger an autosave by calling the <code>_autosave</code> method (which is a private method typically used internally):</p> <pre><code>prompt._autosave()  # Manually triggers autosaving\n</code></pre> <p>Autosaves are stored as JSON files in the folder specified by <code>autosave_folder</code> under the workspace directory (<code>WORKSPACE_DIR</code> environment variable).</p>"},{"location":"swarms/prompts/main/#5-logging-and-telemetry","title":"5. Logging and Telemetry","text":"<p>The <code>Prompt</code> class integrates with the <code>loguru</code> logging library to provide detailed logs for every major action, such as editing, rolling back, and saving. The <code>log_telemetry</code> method captures and logs system data, including prompt metadata, for each operation.</p> <p>Here's an example of a log when editing a prompt:</p> <pre><code>2024-10-10 10:12:34.567 | INFO  | Editing prompt a7b8f9. Current content: 'This is my first prompt!'\n2024-10-10 10:12:34.789 | DEBUG | Prompt a7b8f9 updated. Edit count: 1. New content: 'This is an updated version of my prompt.'\n</code></pre> <p>You can extend logging by integrating the <code>log_telemetry</code> method with your own telemetry systems or databases:</p> <pre><code>prompt.log_telemetry()\n</code></pre>"},{"location":"swarms/prompts/main/#6-handling-errors","title":"6. Handling Errors","text":"<p>Error handling in the <code>Prompt</code> class is robust and prevents common mistakes, such as editing with identical content or rolling back to an invalid version. Here's a common scenario:</p>"},{"location":"swarms/prompts/main/#editing-with-identical-content","title":"Editing with Identical Content","text":"<pre><code>try:\n    prompt.edit_prompt(\"This is an updated version of my prompt.\")\nexcept ValueError as e:\n    print(e)  # Output: New content must be different from the current content.\n</code></pre>"},{"location":"swarms/prompts/main/#invalid-rollback-version","title":"Invalid Rollback Version","text":"<pre><code>try:\n    prompt.rollback(10)  # Invalid version index\nexcept IndexError as e:\n    print(e)  # Output: Invalid version number for rollback.\n</code></pre> <p>Always ensure that version numbers passed to <code>rollback</code> are within the valid range of existing versions.</p>"},{"location":"swarms/prompts/main/#7-extending-the-prompt-class","title":"7. Extending the Prompt Class","text":""},{"location":"swarms/prompts/main/#customizing-the-save-mechanism","title":"Customizing the Save Mechanism","text":"<p>The <code>Prompt</code> class currently includes a placeholder for saving and loading prompts from persistent storage. You can override the <code>save_to_storage</code> and <code>load_from_storage</code> methods to integrate with databases, cloud storage, or other persistent layers.</p> <p>Here's how you can implement the save functionality:</p> <pre><code>def save_to_storage(self):\n    # Example of saving to a database or cloud storage\n    data = self.model_dump()\n    save_to_database(data)  # Custom function to save data\n</code></pre> <p>Similarly, you can implement a <code>load_from_storage</code> function to load the prompt from a storage location using its unique identifier (<code>id</code>).</p>"},{"location":"swarms/prompts/main/#full-example-code-with-all-methods","title":"Full Example code with all methods","text":"<pre><code>from swarms.prompts.prompt import Prompt\n\n# Example 1: Initializing a Financial Report Prompt\nfinancial_prompt = Prompt(\n    content=\"Q1 2024 Earnings Report: Initial Draft\", autosave=True\n)\n\n# Output the initial state of the prompt\nprint(\"\\n--- Example 1: Initializing Prompt ---\")\nprint(f\"Prompt ID: {financial_prompt.id}\")\nprint(f\"Content: {financial_prompt.content}\")\nprint(f\"Created At: {financial_prompt.created_at}\")\nprint(f\"Edit Count: {financial_prompt.edit_count}\")\nprint(f\"History: {financial_prompt.edit_history}\")\n\n\n# Example 2: Editing a Financial Report Prompt\nfinancial_prompt.edit_prompt(\n    \"Q1 2024 Earnings Report: Updated Revenue Figures\"\n)\n\n# Output the updated state of the prompt\nprint(\"\\n--- Example 2: Editing Prompt ---\")\nprint(f\"Content after edit: {financial_prompt.content}\")\nprint(f\"Edit Count: {financial_prompt.edit_count}\")\nprint(f\"History: {financial_prompt.edit_history}\")\n\n\n# Example 3: Rolling Back to a Previous Version\nfinancial_prompt.edit_prompt(\"Q1 2024 Earnings Report: Final Version\")\nfinancial_prompt.rollback(\n    1\n)  # Roll back to the second version (index 1)\n\n# Output the state after rollback\nprint(\"\\n--- Example 3: Rolling Back ---\")\nprint(f\"Content after rollback: {financial_prompt.content}\")\nprint(f\"Edit Count: {financial_prompt.edit_count}\")\nprint(f\"History: {financial_prompt.edit_history}\")\n\n\n# Example 4: Handling Invalid Rollback\nprint(\"\\n--- Example 4: Invalid Rollback ---\")\ntry:\n    financial_prompt.rollback(\n        5\n    )  # Attempt an invalid rollback (out of bounds)\nexcept IndexError as e:\n    print(f\"Error: {e}\")\n\n\n# Example 5: Preventing Duplicate Edits\nprint(\"\\n--- Example 5: Preventing Duplicate Edits ---\")\ntry:\n    financial_prompt.edit_prompt(\n        \"Q1 2024 Earnings Report: Updated Revenue Figures\"\n    )  # Duplicate content\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n\n# Example 6: Retrieving the Prompt Content as a String\nprint(\"\\n--- Example 6: Retrieving Prompt as String ---\")\ncurrent_content = financial_prompt.get_prompt()\nprint(f\"Current Prompt Content: {current_content}\")\n\n\n# Example 7: Simulating Financial Report Changes Over Time\nprint(\"\\n--- Example 7: Simulating Changes Over Time ---\")\n# Initialize a new prompt representing an initial financial report draft\nfinancial_prompt = Prompt(\n    content=\"Q2 2024 Earnings Report: Initial Draft\"\n)\n\n# Simulate several updates over time\nfinancial_prompt.edit_prompt(\n    \"Q2 2024 Earnings Report: Updated Forecasts\"\n)\nfinancial_prompt.edit_prompt(\n    \"Q2 2024 Earnings Report: Revenue Adjustments\"\n)\nfinancial_prompt.edit_prompt(\"Q2 2024 Earnings Report: Final Review\")\n\n# Display full history\nprint(f\"Final Content: {financial_prompt.content}\")\nprint(f\"Edit Count: {financial_prompt.edit_count}\")\nprint(f\"Edit History: {financial_prompt.edit_history}\")\n</code></pre>"},{"location":"swarms/prompts/main/#8-conclusion","title":"8. Conclusion","text":"<p>This guide covered how to effectively use the <code>Prompt</code> class in production environments, including core features like editing, version control, autosaving, and logging. By following the best practices outlined here, you can ensure that your prompts are managed efficiently, with minimal overhead and maximum flexibility.</p> <p>The <code>Prompt</code> class is designed with scalability and robustness in mind, making it a great choice for managing prompt content in multi-agent architectures or any application where dynamic prompt management is required. Feel free to extend the functionality to suit your needs, whether it's integrating with persistent storage or enhancing logging mechanisms.</p> <p>By using this architecture, you'll be able to scale your system effortlessly while maintaining detailed version control and history of every interaction with your prompts.</p>"},{"location":"swarms/structs/","title":"Introduction to Multi-Agent Collaboration","text":""},{"location":"swarms/structs/#benefits-of-multi-agent-collaboration","title":"\ud83d\ude80 Benefits of Multi-Agent Collaboration","text":"Fig. 1: Key benefits and structure of multi-agent collaboration"},{"location":"swarms/structs/#why-multi-agent-architectures","title":"Why Multi-Agent Architectures?","text":"<p>Multi-agent systems unlock new levels of intelligence, reliability, and efficiency by enabling agents to work together. Here are the core benefits:</p> <ol> <li>Reduction of Hallucination: Cross-verification between agents ensures more accurate, reliable outputs by reducing hallucination.</li> <li>Extended Memory: Agents share knowledge and task history, achieving collective long-term memory for smarter, more adaptive responses.</li> <li>Specialization &amp; Task Distribution: Delegating tasks to specialized agents boosts efficiency and quality.</li> <li>Parallel Processing: Multiple agents work simultaneously, greatly increasing speed and throughput.</li> <li>Scalability &amp; Adaptability: Systems can dynamically scale and adapt, maintaining efficiency as demands change.</li> </ol>"},{"location":"swarms/structs/#multi-agent-architectures-for-production-deployments","title":"\ud83c\udfd7\ufe0f Multi-Agent Architectures For Production Deployments","text":"<p><code>swarms</code> provides a variety of powerful, pre-built multi-agent architectures enabling you to orchestrate agents in various ways. Choose the right structure for your specific problem to build efficient and reliable production systems.</p> Architecture Description Best For SequentialWorkflow Agents execute tasks in a linear chain; one agent's output is the next one's input. Step-by-step processes like data transformation pipelines, report generation. ConcurrentWorkflow Agents run tasks simultaneously for maximum efficiency. High-throughput tasks like batch processing, parallel data analysis. AgentRearrange Dynamically maps complex relationships (e.g., <code>a -&gt; b, c</code>) between agents. Flexible and adaptive workflows, task distribution, dynamic routing. GraphWorkflow Orchestrates agents as nodes in a Directed Acyclic Graph (DAG). Complex projects with intricate dependencies, like software builds. MixtureOfAgents (MoA) Utilizes multiple expert agents in parallel and synthesizes their outputs. Complex problem-solving, achieving state-of-the-art performance through collaboration. GroupChat Agents collaborate and make decisions through a conversational interface. Real-time collaborative decision-making, negotiations, brainstorming. ForestSwarm Dynamically selects the most suitable agent or tree of agents for a given task. Task routing, optimizing for expertise, complex decision-making trees. SpreadSheetSwarm Manages thousands of agents concurrently, tracking tasks and outputs in a structured format. Massive-scale parallel operations, large-scale data generation and analysis. SwarmRouter Universal orchestrator that provides a single interface to run any type of swarm with dynamic selection. Simplifying complex workflows, switching between swarm strategies, unified multi-agent management. HierarchicalSwarm Director agent coordinates specialized worker agents in a hierarchy. Complex, multi-stage tasks, iterative refinement, enterprise workflows. Board of Directors Board of directors convenes to discuss, vote, and reach consensus on task distribution. Democratic decision-making, corporate governance, collective intelligence, strategic planning. Hybrid Hierarchical-Cluster Swarm (HHCS) Router agent distributes tasks to specialized swarms for parallel, hierarchical processing. Enterprise-scale, multi-domain, and highly complex workflows."},{"location":"swarms/structs/#hierarchicalswarm-example","title":"\ud83c\udfe2 HierarchicalSwarm Example","text":"<p>Hierarchical architectures enable structured, iterative, and scalable problem-solving by combining a director (or router) agent with specialized worker agents or swarms. Below are two key patterns:</p> <pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized agents\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research and analysis\",\n    model_name=\"gpt-4o\",\n)\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis and valuation\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the hierarchical swarm\nswarm = HierarchicalSwarm(\n    name=\"Financial-Analysis-Swarm\",\n    description=\"A hierarchical swarm for comprehensive financial analysis\",\n    agents=[research_agent, financial_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute a complex task\nresult = swarm.run(task=\"Analyze the market potential for Tesla (TSLA) stock\")\nprint(result)\n</code></pre> <p>Full HierarchicalSwarm Documentation \u2192</p>"},{"location":"swarms/structs/#board-of-directors-example","title":"\ud83c\udfdb\ufe0f Board of Directors Example","text":"<p>The Board of Directors provides a sophisticated democratic alternative to the single Director pattern, enabling collective decision-making through voting and consensus. This approach is ideal for corporate governance, strategic planning, and scenarios requiring multiple perspectives.</p> <pre><code>from swarms import Agent\nfrom swarms.structs.board_of_directors_swarm import (\n    BoardOfDirectorsSwarm,\n    BoardMember,\n    BoardMemberRole\n)\n\n# Create board members with specific roles\nchairman = Agent(\n    agent_name=\"Chairman\",\n    agent_description=\"Chairman of the Board responsible for leading meetings\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Chairman of the Board...\"\n)\n\nvice_chairman = Agent(\n    agent_name=\"Vice-Chairman\",\n    agent_description=\"Vice Chairman who supports the Chairman\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Vice Chairman...\"\n)\n\n# Create BoardMember objects with roles and expertise\nboard_members = [\n    BoardMember(chairman, BoardMemberRole.CHAIRMAN, 1.5, [\"leadership\", \"strategy\"]),\n    BoardMember(vice_chairman, BoardMemberRole.VICE_CHAIRMAN, 1.2, [\"operations\", \"coordination\"]),\n]\n\n# Create worker agents\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research and analysis\",\n    model_name=\"gpt-4o\",\n)\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis and valuation\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the Board of Directors swarm\nboard_swarm = BoardOfDirectorsSwarm(\n    name=\"Executive_Board_Swarm\",\n    description=\"Executive board with specialized roles for strategic decision-making\",\n    board_members=board_members,\n    agents=[research_agent, financial_agent],\n    max_loops=2,\n    verbose=True,\n    decision_threshold=0.6,\n    enable_voting=True,\n    enable_consensus=True,\n)\n\n# Execute a complex task with democratic decision-making\nresult = board_swarm.run(task=\"Analyze the market potential for Tesla (TSLA) stock\")\nprint(result)\n</code></pre> <p>Full Board of Directors Documentation \u2192</p>"},{"location":"swarms/structs/#sequentialworkflow","title":"SequentialWorkflow","text":"<p>A <code>SequentialWorkflow</code> executes tasks in a strict order, forming a pipeline where each agent builds upon the work of the previous one. <code>SequentialWorkflow</code> is Ideal for processes that have clear, ordered steps. This ensures that tasks with dependencies are handled correctly.</p> <pre><code>from swarms import Agent, SequentialWorkflow\n\n# Initialize agents for a 3-step process\n# 1. Generate an idea\nidea_generator = Agent(agent_name=\"IdeaGenerator\", system_prompt=\"Generate a unique startup idea.\", model_name=\"gpt-4o-mini\")\n# 2. Validate the idea\nvalidator = Agent(agent_name=\"Validator\", system_prompt=\"Take this startup idea and analyze its market viability.\", model_name=\"gpt-4o-mini\")\n# 3. Create a pitch\npitch_creator = Agent(agent_name=\"PitchCreator\", system_prompt=\"Write a 3-sentence elevator pitch for this validated startup idea.\", model_name=\"gpt-4o-mini\")\n\n# Create the sequential workflow\nworkflow = SequentialWorkflow(agents=[idea_generator, validator, pitch_creator])\n\n# Run the workflow\nelevator_pitch = workflow.run()\nprint(elevator_pitch)\n</code></pre>"},{"location":"swarms/structs/#concurrentworkflow-with-spreadsheetswarm","title":"ConcurrentWorkflow (with <code>SpreadSheetSwarm</code>)","text":"<p>A concurrent workflow runs multiple agents simultaneously. <code>SpreadSheetSwarm</code> is a powerful implementation that can manage thousands of concurrent agents and log their outputs to a CSV file. Use this architecture for high-throughput tasks that can be performed in parallel, drastically reducing execution time.</p> <pre><code>from swarms import Agent, SpreadSheetSwarm\n\n# Define a list of tasks (e.g., social media posts to generate)\nplatforms = [\"Twitter\", \"LinkedIn\", \"Instagram\"]\n\n# Create an agent for each task\nagents = [\n    Agent(\n        agent_name=f\"{platform}-Marketer\",\n        system_prompt=f\"Generate a real estate marketing post for {platform}.\",\n        model_name=\"gpt-4o-mini\",\n    )\n    for platform in platforms\n]\n\n# Initialize the swarm to run these agents concurrently\nswarm = SpreadSheetSwarm(\n    agents=agents,\n    autosave_on=True,\n    save_file_path=\"marketing_posts.csv\",\n)\n\n# Run the swarm with a single, shared task description\nproperty_description = \"A beautiful 3-bedroom house in sunny California.\"\nswarm.run(task=f\"Generate a post about: {property_description}\")\n# Check marketing_posts.csv for the results!\n</code></pre>"},{"location":"swarms/structs/#agentrearrange","title":"AgentRearrange","text":"<p>Inspired by <code>einsum</code>, <code>AgentRearrange</code> lets you define complex, non-linear relationships between agents using a simple string-based syntax. Learn more. This architecture is Perfect for orchestrating dynamic workflows where agents might work in parallel, sequence, or a combination of both.</p> <pre><code>from swarms import Agent, AgentRearrange\n\n# Define agents\nresearcher = Agent(agent_name=\"researcher\", model_name=\"gpt-4o-mini\")\nwriter = Agent(agent_name=\"writer\", model_name=\"gpt-4o-mini\")\neditor = Agent(agent_name=\"editor\", model_name=\"gpt-4o-mini\")\n\n# Define a flow: researcher sends work to both writer and editor simultaneously\n# This is a one-to-many relationship\nflow = \"researcher -&gt; writer, editor\"\n\n# Create the rearrangement system\nrearrange_system = AgentRearrange(\n    agents=[researcher, writer, editor],\n    flow=flow,\n)\n\n# Run the system\n# The researcher will generate content, and then both the writer and editor\n# will process that content in parallel.\noutputs = rearrange_system.run(\"Analyze the impact of AI on modern cinema.\")\nprint(outputs)\n</code></pre>"},{"location":"swarms/structs/#swarmrouter-the-universal-swarm-orchestrator","title":"SwarmRouter: The Universal Swarm Orchestrator","text":"<p>The <code>SwarmRouter</code> simplifies building complex workflows by providing a single interface to run any type of swarm. Instead of importing and managing different swarm classes, you can dynamically select the one you need just by changing the <code>swarm_type</code> parameter. Read the full documentation</p> <p>This makes your code cleaner and more flexible, allowing you to switch between different multi-agent strategies with ease. Here's a complete example that shows how to define agents and then use <code>SwarmRouter</code> to execute the same task using different collaborative strategies.</p> <pre><code>from swarms import Agent\nfrom swarms.structs.swarm_router import SwarmRouter, SwarmType\n\n# Define a few generic agents\nwriter = Agent(agent_name=\"Writer\", system_prompt=\"You are a creative writer.\", model_name=\"gpt-4o-mini\")\neditor = Agent(agent_name=\"Editor\", system_prompt=\"You are an expert editor for stories.\", model_name=\"gpt-4o-mini\")\nreviewer = Agent(agent_name=\"Reviewer\", system_prompt=\"You are a final reviewer who gives a score.\", model_name=\"gpt-4o-mini\")\n\n# The agents and task will be the same for all examples\nagents = [writer, editor, reviewer]\ntask = \"Write a short story about a robot who discovers music.\"\n\n# --- Example 1: SequentialWorkflow ---\n# Agents run one after another in a chain: Writer -&gt; Editor -&gt; Reviewer.\nprint(\"Running a Sequential Workflow...\")\nsequential_router = SwarmRouter(swarm_type=SwarmType.SequentialWorkflow, agents=agents)\nsequential_output = sequential_router.run(task)\nprint(f\"Final Sequential Output:\\n{sequential_output}\\n\")\n\n# --- Example 2: ConcurrentWorkflow ---\n# All agents receive the same initial task and run at the same time.\nprint(\"Running a Concurrent Workflow...\")\nconcurrent_router = SwarmRouter(swarm_type=SwarmType.ConcurrentWorkflow, agents=agents)\nconcurrent_outputs = concurrent_router.run(task)\n# This returns a dictionary of each agent's output\nfor agent_name, output in concurrent_outputs.items():\n    print(f\"Output from {agent_name}:\\n{output}\\n\")\n\n# --- Example 3: MixtureOfAgents ---\n# All agents run in parallel, and a special 'aggregator' agent synthesizes their outputs.\nprint(\"Running a Mixture of Agents Workflow...\")\naggregator = Agent(\n    agent_name=\"Aggregator\",\n    system_prompt=\"Combine the story, edits, and review into a final document.\",\n    model_name=\"gpt-4o-mini\"\n)\nmoa_router = SwarmRouter(\n    swarm_type=SwarmType.MixtureOfAgents,\n    agents=agents,\n    aggregator_agent=aggregator, # MoA requires an aggregator\n)\naggregated_output = moa_router.run(task)\nprint(f\"Final Aggregated Output:\\n{aggregated_output}\\n\")\n</code></pre> <p>The <code>SwarmRouter</code> is a powerful tool for simplifying multi-agent orchestration. It provides a consistent and flexible way to deploy different collaborative strategies, allowing you to build more sophisticated applications with less code.</p>"},{"location":"swarms/structs/#mixtureofagents-moa","title":"MixtureOfAgents (MoA)","text":"<p>The <code>MixtureOfAgents</code> architecture processes tasks by feeding them to multiple \"expert\" agents in parallel. Their diverse outputs are then synthesized by an aggregator agent to produce a final, high-quality result. Learn more here</p> <pre><code>from swarms import Agent, MixtureOfAgents\n\n# Define expert agents\nfinancial_analyst = Agent(agent_name=\"FinancialAnalyst\", system_prompt=\"Analyze financial data.\", model_name=\"gpt-4o-mini\")\nmarket_analyst = Agent(agent_name=\"MarketAnalyst\", system_prompt=\"Analyze market trends.\", model_name=\"gpt-4o-mini\")\nrisk_analyst = Agent(agent_name=\"RiskAnalyst\", system_prompt=\"Analyze investment risks.\", model_name=\"gpt-4o-mini\")\n\n# Define the aggregator agent\naggregator = Agent(\n    agent_name=\"InvestmentAdvisor\",\n    system_prompt=\"Synthesize the financial, market, and risk analyses to provide a final investment recommendation.\",\n    model_name=\"gpt-4o-mini\"\n)\n\n# Create the MoA swarm\nmoa_swarm = MixtureOfAgents(\n    agents=[financial_analyst, market_analyst, risk_analyst],\n    aggregator_agent=aggregator,\n)\n\n# Run the swarm\nrecommendation = moa_swarm.run(\"Should we invest in NVIDIA stock right now?\")\nprint(recommendation)\n</code></pre>"},{"location":"swarms/structs/#groupchat","title":"GroupChat","text":"<p><code>GroupChat</code> creates a conversational environment where multiple agents can interact, discuss, and collaboratively solve a problem. You can define the speaking order or let it be determined dynamically. This architecture is ideal for tasks that benefit from debate and multi-perspective reasoning, such as contract negotiation, brainstorming, or complex decision-making.</p> <pre><code>from swarms import Agent, GroupChat\n\n# Define agents for a debate\ntech_optimist = Agent(agent_name=\"TechOptimist\", system_prompt=\"Argue for the benefits of AI in society.\", model_name=\"gpt-4o-mini\")\ntech_critic = Agent(agent_name=\"TechCritic\", system_prompt=\"Argue against the unchecked advancement of AI.\", model_name=\"gpt-4o-mini\")\n\n# Create the group chat\nchat = GroupChat(\n    agents=[tech_optimist, tech_critic],\n    max_loops=4, # Limit the number of turns in the conversation\n)\n\n# Run the chat with an initial topic\nconversation_history = chat.run(\n    \"Let's discuss the societal impact of artificial intelligence.\"\n)\n\n# Print the full conversation\nfor message in conversation_history:\n    print(f\"[{message['agent_name']}]: {message['content']}\")\n</code></pre> <p>--</p>"},{"location":"swarms/structs/#connect-with-us","title":"Connect With Us","text":"<p>Join our community of agent engineers and researchers for technical support, cutting-edge updates, and exclusive access to world-class agent engineering insights!</p> Platform Description Link \ud83d\udcda Documentation Official documentation and guides docs.swarms.world \ud83d\udcdd Blog Latest updates and technical articles Medium \ud83d\udcac Discord Live chat and community support Join Discord \ud83d\udc26 Twitter Latest news and announcements @kyegomez \ud83d\udc65 LinkedIn Professional network and updates The Swarm Corporation \ud83d\udcfa YouTube Tutorials and demos Swarms Channel \ud83c\udfab Events Join our community events Sign up here \ud83d\ude80 Onboarding Session Get onboarded with Kye Gomez, creator and lead maintainer of Swarms Book Session"},{"location":"swarms/structs/abstractswarm/","title":"<code>BaseSwarm</code> Documentation","text":""},{"location":"swarms/structs/abstractswarm/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Class Definition</li> <li>Methods<ul> <li>communicate()</li> <li>run()</li> <li>arun()</li> <li>add_worker(worker)</li> <li>remove_worker(worker)</li> <li>broadcast(message, sender)</li> <li>reset()</li> <li>plan(task)</li> <li>direct_message(message, sender, recipient)</li> <li>autoscaler(num_workers, worker)</li> <li>get_worker_by_id(id)</li> <li>get_worker_by_name(name)</li> <li>assign_task(worker, task)</li> <li>get_all_tasks(worker, task)</li> <li>get_finished_tasks()</li> <li>get_pending_tasks()</li> <li>pause_worker(worker, worker_id)</li> <li>resume_worker(worker, worker_id)</li> <li>stop_worker(worker, worker_id)</li> <li>restart_worker(worker)</li> <li>scale_up(num_worker)</li> <li>scale_down(num_worker)</li> <li>scale_to(num_worker)</li> <li>get_all_workers()</li> <li>get_swarm_size()</li> <li>get_swarm_status()</li> <li>save_swarm_state()</li> </ul> </li> </ol>"},{"location":"swarms/structs/abstractswarm/#1-introduction","title":"1. Introduction","text":"<p>The Swarms library is designed to provide a framework for swarm simulation architectures. Swarms are collections of autonomous agents or workers that collaborate to perform tasks and achieve common goals. This documentation will guide you through the functionality and usage of the Swarms library, explaining the purpose and implementation details of the provided classes and methods.</p>"},{"location":"swarms/structs/abstractswarm/#2-class-definition","title":"2. Class Definition","text":""},{"location":"swarms/structs/abstractswarm/#baseswarm-class","title":"<code>BaseSwarm</code> Class","text":"<p>The <code>BaseSwarm</code> class is an abstract base class that serves as the foundation for swarm simulation architectures. It defines the core functionality and methods required to manage and interact with a swarm of workers.</p> <pre><code>from abc import ABC, abstractmethod\nfrom typing import List\n\nfrom swarms.swarms.base import AbstractWorker\n\n\nclass BaseSwarm(ABC):\n    \"\"\"\n    Abstract class for swarm simulation architectures\n\n    Methods:\n    ---------\n    ...\n    \"\"\"\n\n    # The class definition and constructor are provided here.\n\n    @abstractmethod\n    def __init__(self, workers: List[\"AbstractWorker\"]):\n        \"\"\"Initialize the swarm with workers\"\"\"\n\n    # Other abstract methods are listed here.\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#3-methods","title":"3. Methods","text":""},{"location":"swarms/structs/abstractswarm/#communicate","title":"<code>communicate()</code>","text":"<p>The <code>communicate()</code> method allows the swarm to exchange information through the orchestrator, protocols, and the universal communication layer.</p> <p>Usage Example 1:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.communicate()\n</code></pre> <p>Usage Example 2:</p> <pre><code># Another example of using the communicate method\nswarm = YourSwarmClass(workers)\nswarm.communicate()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#run","title":"<code>run()</code>","text":"<p>The <code>run()</code> method executes the swarm, initiating its activities.</p> <p>Usage Example 1:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.run()\n</code></pre> <p>Usage Example 2:</p> <pre><code># Another example of running the swarm\nswarm = YourSwarmClass(workers)\nswarm.run()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#arun","title":"<code>arun()</code>","text":"<p>The <code>arun()</code> method runs the swarm asynchronously, allowing for parallel execution of tasks.</p> <p>Usage Example 1:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.arun()\n</code></pre> <p>Usage Example 2:</p> <pre><code># Another example of running the swarm asynchronously\nswarm = YourSwarmClass(workers)\nswarm.arun()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#add_workerworker-abstractworker","title":"<code>add_worker(worker: \"AbstractWorker\")</code>","text":"<p>The <code>add_worker()</code> method adds a worker to the swarm.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be added to the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass([])\nworker = YourWorkerClass()\nswarm.add_worker(worker)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#remove_workerworker-abstractworker","title":"<code>remove_worker(worker: \"AbstractWorker\")</code>","text":"<p>The <code>remove_worker()</code> method removes a worker from the swarm.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be removed from the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_id(\"worker_id\")\nswarm.remove_worker(worker)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#broadcastmessage-str-sender-optionalabstractworker-none","title":"<code>broadcast(message: str, sender: Optional[\"AbstractWorker\"] = None)</code>","text":"<p>The <code>broadcast()</code> method sends a message to all workers in the swarm.</p> <p>Parameters: - <code>message</code> (str): The message to be broadcasted. - <code>sender</code> (Optional[AbstractWorker]): The sender of the message (optional).</p> <p>Usage Example 1:</p> <pre><code>swarm = YourSwarmClass(workers)\nmessage = \"Hello, everyone!\"\nswarm.broadcast(message)\n</code></pre> <p>Usage Example 2:</p> <pre><code># Another example of broadcasting a message\nswarm = YourSwarmClass(workers)\nmessage = \"Important announcement!\"\nsender = swarm.get_worker_by_name(\"Supervisor\")\nswarm.broadcast(message, sender)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#reset","title":"<code>reset()</code>","text":"<p>The <code>reset()</code> method resets the swarm to its initial state.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.reset()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#plantask-str","title":"<code>plan(task: str)</code>","text":"<p>The <code>plan()</code> method instructs workers to individually plan using a workflow or pipeline for a specified task.</p> <p>Parameters: - <code>task</code> (str): The task for which workers should plan.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\ntask = \"Perform data analysis\"\nswarm.plan(task)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#direct_messagemessage-str-sender-abstractworker-recipient-abstractworker","title":"<code>direct_message(message: str, sender: \"AbstractWorker\", recipient: \"AbstractWorker\")</code>","text":"<p>The <code>direct_message()</code> method sends a direct message from one worker to another.</p> <p>Parameters: - <code>message</code> (str): The message to be sent. - <code>sender</code> (AbstractWorker): The sender of the message. - <code>recipient</code> (AbstractWorker): The recipient of the message.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nsender = swarm.get_worker_by_name(\"Worker1\")\nrecipient = swarm.get_worker_by_name(\"Worker2\")\nmessage = \"Hello\n\n, Worker2!\"\nswarm.direct_message(message, sender, recipient)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#autoscalernum_workers-int-worker-listabstractworker","title":"<code>autoscaler(num_workers: int, worker: List[\"AbstractWorker\"])</code>","text":"<p>The <code>autoscaler()</code> method acts as an autoscaler, dynamically adjusting the number of workers based on system load or other criteria.</p> <p>Parameters: - <code>num_workers</code> (int): The desired number of workers. - <code>worker</code> (List[AbstractWorker]): A list of workers to be managed by the autoscaler.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass([])\nworkers = [YourWorkerClass() for _ in range(10)]\nswarm.autoscaler(5, workers)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_worker_by_idid-str-abstractworker","title":"<code>get_worker_by_id(id: str) -&gt; \"AbstractWorker\"</code>","text":"<p>The <code>get_worker_by_id()</code> method locates a worker in the swarm by their ID.</p> <p>Parameters: - <code>id</code> (str): The ID of the worker to locate.</p> <p>Returns: - <code>AbstractWorker</code>: The worker with the specified ID.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker_id = \"worker_123\"\nworker = swarm.get_worker_by_id(worker_id)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_worker_by_namename-str-abstractworker","title":"<code>get_worker_by_name(name: str) -&gt; \"AbstractWorker\"</code>","text":"<p>The <code>get_worker_by_name()</code> method locates a worker in the swarm by their name.</p> <p>Parameters: - <code>name</code> (str): The name of the worker to locate.</p> <p>Returns: - <code>AbstractWorker</code>: The worker with the specified name.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker_name = \"Alice\"\nworker = swarm.get_worker_by_name(worker_name)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#assign_taskworker-abstractworker-task-any-dict","title":"<code>assign_task(worker: \"AbstractWorker\", task: Any) -&gt; Dict</code>","text":"<p>The <code>assign_task()</code> method assigns a task to a specific worker.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to whom the task should be assigned. - <code>task</code> (Any): The task to be assigned.</p> <p>Returns: - <code>Dict</code>: A dictionary indicating the status of the task assignment.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\ntask = \"Perform data analysis\"\nresult = swarm.assign_task(worker, task)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_all_tasksworker-abstractworker-task-any","title":"<code>get_all_tasks(worker: \"AbstractWorker\", task: Any)</code>","text":"<p>The <code>get_all_tasks()</code> method retrieves all tasks assigned to a specific worker.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker for whom tasks should be retrieved. - <code>task</code> (Any): The task to be retrieved.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\ntasks = swarm.get_all_tasks(worker, \"data analysis\")\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_finished_tasks-listdict","title":"<code>get_finished_tasks() -&gt; List[Dict]</code>","text":"<p>The <code>get_finished_tasks()</code> method retrieves all tasks that have been completed by the workers in the swarm.</p> <p>Returns: - <code>List[Dict]</code>: A list of dictionaries representing finished tasks.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nfinished_tasks = swarm.get_finished_tasks()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_pending_tasks-listdict","title":"<code>get_pending_tasks() -&gt; List[Dict]</code>","text":"<p>The <code>get_pending_tasks()</code> method retrieves all tasks that are pending or yet to be completed by the workers in the swarm.</p> <p>Returns: - <code>List[Dict]</code>: A list of dictionaries representing pending tasks.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\npending_tasks = swarm.get_pending_tasks()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#pause_workerworker-abstractworker-worker_id-str","title":"<code>pause_worker(worker: \"AbstractWorker\", worker_id: str)</code>","text":"<p>The <code>pause_worker()</code> method pauses a specific worker, temporarily suspending their activities.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be paused. - <code>worker_id</code> (str): The ID of the worker to be paused.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\nworker_id = \"worker_123\"\nswarm.pause_worker(worker, worker_id)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#resume_workerworker-abstractworker-worker_id-str","title":"<code>resume_worker(worker: \"AbstractWorker\", worker_id: str)</code>","text":"<p>The <code>resume_worker()</code> method resumes a paused worker, allowing them to continue their activities.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be resumed. - <code>worker_id</code> (str): The ID of the worker to be resumed.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\nworker_id = \"worker_123\"\nswarm.resume_worker(worker, worker_id)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#stop_workerworker-abstractworker-worker_id-str","title":"<code>stop_worker(worker: \"AbstractWorker\", worker_id: str)</code>","text":"<p>The <code>stop_worker()</code> method stops a specific worker, terminating their activities.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be stopped. - <code>worker_id</code> (str): The ID of the worker to be stopped.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\nworker_id = \"worker_123\"\nswarm.stop_worker(worker, worker_id)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#restart_workerworker-abstractworker","title":"<code>restart_worker(worker: \"AbstractWorker\")</code>","text":"<p>The <code>restart_worker()</code> method restarts a worker, resetting them to their initial state.</p> <p>Parameters: - <code>worker</code> (AbstractWorker): The worker to be restarted.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nworker = swarm.get_worker_by_name(\"Worker1\")\nswarm.restart_worker(worker)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#scale_upnum_worker-int","title":"<code>scale_up(num_worker: int)</code>","text":"<p>The <code>scale_up()</code> method increases the number of workers in the swarm.</p> <p>Parameters: - <code>num_worker</code> (int): The number of workers to add to the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.scale_up(5)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#scale_downnum_worker-int","title":"<code>scale_down(num_worker: int)</code>","text":"<p>The <code>scale_down()</code> method decreases the number of workers in the swarm.</p> <p>Parameters: - <code>num_worker</code> (int): The number of workers to remove from the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.scale_down(3)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#scale_tonum_worker-int","title":"<code>scale_to(num_worker: int)</code>","text":"<p>The <code>scale_to()</code> method scales the swarm to a specific number of workers.</p> <p>Parameters: - <code>num_worker</code> (int): The desired number of workers.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.scale_to(10)\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get","title":"`get","text":"<p>_all_workers() -&gt; List[\"AbstractWorker\"]` </p> <p>The <code>get_all_workers()</code> method retrieves a list of all workers in the swarm.</p> <p>Returns: - <code>List[AbstractWorker]</code>: A list of all workers in the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nall_workers = swarm.get_all_workers()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_swarm_size-int","title":"<code>get_swarm_size() -&gt; int</code>","text":"<p>The <code>get_swarm_size()</code> method returns the size of the swarm, which is the total number of workers.</p> <p>Returns: - <code>int</code>: The size of the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm_size = swarm.get_swarm_size()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#get_swarm_status-dict","title":"<code>get_swarm_status() -&gt; Dict</code>","text":"<p>The <code>get_swarm_status()</code> method provides information about the current status of the swarm.</p> <p>Returns: - <code>Dict</code>: A dictionary containing various status indicators for the swarm.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm_status = swarm.get_swarm_status()\n</code></pre>"},{"location":"swarms/structs/abstractswarm/#save_swarm_state","title":"<code>save_swarm_state()</code>","text":"<p>The <code>save_swarm_state()</code> method allows you to save the current state of the swarm, including worker configurations and task assignments.</p> <p>Usage Example:</p> <pre><code>swarm = YourSwarmClass(workers)\nswarm.save_swarm_state()\n</code></pre> <p>This comprehensive documentation covers the Swarms library, including the <code>BaseSwarm</code> class and its methods. You can use this documentation as a guide to understanding and effectively utilizing the Swarms framework for swarm simulation architectures. Feel free to explore further and adapt the library to your specific use cases.</p>"},{"location":"swarms/structs/agent/","title":"<code>Agent</code>","text":"<p>Swarm Agent is a powerful autonomous agent framework designed to connect Language Models (LLMs) with various tools and long-term memory. This class provides the ability to ingest and process various types of documents such as PDFs, text files, Markdown files, JSON files, and more. The Agent structure offers a wide range of features to enhance the capabilities of LLMs and facilitate efficient task execution.</p>"},{"location":"swarms/structs/agent/#overview","title":"Overview","text":"<p>The <code>Agent</code> class establishes a conversational loop with a language model, allowing for interactive task execution, feedback collection, and dynamic response generation. It includes features such as:</p> <ol> <li>Conversational Loop: Enables back-and-forth interaction with the model.</li> <li>Feedback Collection: Allows users to provide feedback on generated responses.</li> <li>Stoppable Conversation: Supports custom stopping conditions for the conversation.</li> <li>Retry Mechanism: Implements a retry system for handling issues in response generation.</li> <li>Tool Integration: Supports the integration of various tools for enhanced capabilities.</li> <li>Long-term Memory Management: Incorporates vector databases for efficient information retrieval.</li> <li>Document Ingestion: Processes various document types for information extraction.</li> <li>Interactive Mode: Allows real-time communication with the agent.</li> <li>Sentiment Analysis: Evaluates the sentiment of generated responses.</li> <li>Output Filtering and Cleaning: Ensures generated responses meet specific criteria.</li> <li>Asynchronous and Concurrent Execution: Supports efficient parallelization of tasks.</li> <li>Planning and Reasoning: Implements techniques like algorithm of thoughts for enhanced decision-making.</li> </ol>"},{"location":"swarms/structs/agent/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Task Initiation] --&gt;|Receives Task| B[Initial LLM Processing]\n    B --&gt;|Interprets Task| C[Tool Usage]\n    C --&gt;|Calls Tools| D[Function 1]\n    C --&gt;|Calls Tools| E[Function 2]\n    D --&gt;|Returns Data| C\n    E --&gt;|Returns Data| C\n    C --&gt;|Provides Data| F[Memory Interaction]\n    F --&gt;|Stores and Retrieves Data| G[RAG System]\n    G --&gt;|ChromaDB/Pinecone| H[Enhanced Data]\n    F --&gt;|Provides Enhanced Data| I[Final LLM Processing]\n    I --&gt;|Generates Final Response| J[Output]\n    C --&gt;|No Tools Available| K[Skip Tool Usage]\n    K --&gt;|Proceeds to Memory Interaction| F\n    F --&gt;|No Memory Available| L[Skip Memory Interaction]\n    L --&gt;|Proceeds to Final LLM Processing| I</code></pre>"},{"location":"swarms/structs/agent/#agent-attributes","title":"<code>Agent</code> Attributes","text":"Attribute Description <code>id</code> Unique identifier for the agent instance. <code>llm</code> Language model instance used by the agent. <code>template</code> Template used for formatting responses. <code>max_loops</code> Maximum number of loops the agent can run. <code>stopping_condition</code> Callable function determining when to stop looping. <code>loop_interval</code> Interval (in seconds) between loops. <code>retry_attempts</code> Number of retry attempts for failed LLM calls. <code>retry_interval</code> Interval (in seconds) between retry attempts. <code>return_history</code> Boolean indicating whether to return conversation history. <code>stopping_token</code> Token that stops the agent from looping when present in the response. <code>dynamic_loops</code> Boolean indicating whether to dynamically determine the number of loops. <code>interactive</code> Boolean indicating whether to run in interactive mode. <code>dashboard</code> Boolean indicating whether to display a dashboard. <code>agent_name</code> Name of the agent instance. <code>agent_description</code> Description of the agent instance. <code>system_prompt</code> System prompt used to initialize the conversation. <code>tools</code> List of callable functions representing tools the agent can use. <code>dynamic_temperature_enabled</code> Boolean indicating whether to dynamically adjust the LLM's temperature. <code>sop</code> Standard operating procedure for the agent. <code>sop_list</code> List of strings representing the standard operating procedure. <code>saved_state_path</code> File path for saving and loading the agent's state. <code>autosave</code> Boolean indicating whether to automatically save the agent's state. <code>context_length</code> Maximum length of the context window (in tokens) for the LLM. <code>user_name</code> Name used to represent the user in the conversation. <code>self_healing_enabled</code> Boolean indicating whether to attempt self-healing in case of errors. <code>code_interpreter</code> Boolean indicating whether to interpret and execute code snippets. <code>multi_modal</code> Boolean indicating whether to support multimodal inputs. <code>pdf_path</code> File path of a PDF document to be ingested. <code>list_of_pdf</code> List of file paths for PDF documents to be ingested. <code>tokenizer</code> Instance of a tokenizer used for token counting and management. <code>long_term_memory</code> Instance of a <code>BaseVectorDatabase</code> implementation for long-term memory management. <code>preset_stopping_token</code> Boolean indicating whether to use a preset stopping token. <code>traceback</code> Object used for traceback handling. <code>traceback_handlers</code> List of traceback handlers. <code>streaming_on</code> Boolean indicating whether to stream responses. <code>docs</code> List of document paths or contents to be ingested. <code>docs_folder</code> Path to a folder containing documents to be ingested. <code>verbose</code> Boolean indicating whether to print verbose output. <code>parser</code> Callable function used for parsing input data. <code>best_of_n</code> Integer indicating the number of best responses to generate. <code>callback</code> Callable function to be called after each agent loop. <code>metadata</code> Dictionary containing metadata for the agent. <code>callbacks</code> List of callable functions to be called during execution. <code>logger_handler</code> Handler for logging messages. <code>search_algorithm</code> Callable function for long-term memory retrieval. <code>logs_to_filename</code> File path for logging agent activities. <code>evaluator</code> Callable function for evaluating the agent's responses. <code>stopping_func</code> Callable function used as a stopping condition. <code>custom_loop_condition</code> Callable function used as a custom loop condition. <code>sentiment_threshold</code> Float value representing the sentiment threshold for evaluating responses. <code>custom_exit_command</code> String representing a custom command for exiting the agent's loop. <code>sentiment_analyzer</code> Callable function for sentiment analysis on outputs. <code>limit_tokens_from_string</code> Callable function for limiting the number of tokens in a string. <code>custom_tools_prompt</code> Callable function for generating a custom prompt for tool usage. <code>tool_schema</code> Data structure representing the schema for the agent's tools. <code>output_type</code> Type representing the expected output type of responses. <code>function_calling_type</code> String representing the type of function calling. <code>output_cleaner</code> Callable function for cleaning the agent's output. <code>function_calling_format_type</code> String representing the format type for function calling. <code>list_base_models</code> List of base models used for generating tool schemas. <code>metadata_output_type</code> String representing the output type for metadata. <code>state_save_file_type</code> String representing the file type for saving the agent's state. <code>chain_of_thoughts</code> Boolean indicating whether to use the chain of thoughts technique. <code>algorithm_of_thoughts</code> Boolean indicating whether to use the algorithm of thoughts technique. <code>tree_of_thoughts</code> Boolean indicating whether to use the tree of thoughts technique. <code>tool_choice</code> String representing the method for tool selection. <code>execute_tool</code> Boolean indicating whether to execute tools. <code>rules</code> String representing the rules for the agent's behavior. <code>planning</code> Boolean indicating whether to perform planning. <code>planning_prompt</code> String representing the prompt for planning. <code>device</code> String representing the device on which the agent should run. <code>custom_planning_prompt</code> String representing a custom prompt for planning. <code>memory_chunk_size</code> Integer representing the maximum size of memory chunks for long-term memory retrieval. <code>agent_ops_on</code> Boolean indicating whether agent operations should be enabled. <code>return_step_meta</code> Boolean indicating whether to return JSON of all steps and additional metadata. <code>output_type</code> Literal type indicating whether to output \"string\", \"str\", \"list\", \"json\", \"dict\", or \"yaml\". <code>time_created</code> Float representing the time the agent was created. <code>tags</code> Optional list of strings for tagging the agent. <code>use_cases</code> Optional list of dictionaries describing use cases for the agent. <code>step_pool</code> List of Step objects representing the agent's execution steps. <code>print_every_step</code> Boolean indicating whether to print every step of execution. <code>agent_output</code> ManySteps object containing the agent's output and metadata. <code>executor_workers</code> Integer representing the number of executor workers for concurrent operations. <code>data_memory</code> Optional callable for data memory operations. <code>load_yaml_path</code> String representing the path to a YAML file for loading configurations. <code>auto_generate_prompt</code> Boolean indicating whether to automatically generate prompts. <code>rag_every_loop</code> Boolean indicating whether to query RAG database for context on every loop <code>plan_enabled</code> Boolean indicating whether planning functionality is enabled <code>artifacts_on</code> Boolean indicating whether to save artifacts from agent execution <code>artifacts_output_path</code> File path where artifacts should be saved <code>artifacts_file_extension</code> File extension to use for saved artifacts <code>device</code> Device to run computations on (\"cpu\" or \"gpu\") <code>all_cores</code> Boolean indicating whether to use all CPU cores <code>device_id</code> ID of the GPU device to use if running on GPU <code>scheduled_run_date</code> Optional datetime for scheduling future agent runs"},{"location":"swarms/structs/agent/#agent-methods","title":"<code>Agent</code> Methods","text":"Method Description Inputs Usage Example <code>run(task, img=None, is_last=False, device=\"cpu\", device_id=0, all_cores=True, *args, **kwargs)</code> Runs the autonomous agent loop to complete the given task. <code>task</code> (str): The task to be performed.<code>img</code> (str, optional): Path to an image file.<code>is_last</code> (bool): Whether this is the last task.<code>device</code> (str): Device to run on (\"cpu\" or \"gpu\").<code>device_id</code> (int): ID of the GPU to use.<code>all_cores</code> (bool): Whether to use all CPU cores.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>response = agent.run(\"Generate a report on financial performance.\")</code> <code>__call__(task, img=None, *args, **kwargs)</code> Alternative way to call the <code>run</code> method. Same as <code>run</code>. <code>response = agent(\"Generate a report on financial performance.\")</code> <code>parse_and_execute_tools(response, *args, **kwargs)</code> Parses the agent's response and executes any tools mentioned in it. <code>response</code> (str): The agent's response to be parsed.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent.parse_and_execute_tools(response)</code> <code>add_memory(message)</code> Adds a message to the agent's memory. <code>message</code> (str): The message to add. <code>agent.add_memory(\"Important information\")</code> <code>plan(task, *args, **kwargs)</code> Plans the execution of a task. <code>task</code> (str): The task to plan.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent.plan(\"Analyze market trends\")</code> <code>run_concurrent(task, *args, **kwargs)</code> Runs a task concurrently. <code>task</code> (str): The task to run.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>response = await agent.run_concurrent(\"Concurrent task\")</code> <code>run_concurrent_tasks(tasks, *args, **kwargs)</code> Runs multiple tasks concurrently. <code>tasks</code> (List[str]): List of tasks to run.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>responses = agent.run_concurrent_tasks([\"Task 1\", \"Task 2\"])</code> <code>bulk_run(inputs)</code> Generates responses for multiple input sets. <code>inputs</code> (List[Dict[str, Any]]): List of input dictionaries. <code>responses = agent.bulk_run([{\"task\": \"Task 1\"}, {\"task\": \"Task 2\"}])</code> <code>save()</code> Saves the agent's history to a file. None <code>agent.save()</code> <code>load(file_path)</code> Loads the agent's history from a file. <code>file_path</code> (str): Path to the file. <code>agent.load(\"agent_history.json\")</code> <code>graceful_shutdown()</code> Gracefully shuts down the system, saving the state. None <code>agent.graceful_shutdown()</code> <code>analyze_feedback()</code> Analyzes the feedback for issues. None <code>agent.analyze_feedback()</code> <code>undo_last()</code> Undoes the last response and returns the previous state. None <code>previous_state, message = agent.undo_last()</code> <code>add_response_filter(filter_word)</code> Adds a response filter to filter out certain words. <code>filter_word</code> (str): Word to filter. <code>agent.add_response_filter(\"sensitive\")</code> <code>apply_response_filters(response)</code> Applies response filters to the given response. <code>response</code> (str): Response to filter. <code>filtered_response = agent.apply_response_filters(response)</code> <code>filtered_run(task)</code> Runs a task with response filtering applied. <code>task</code> (str): Task to run. <code>response = agent.filtered_run(\"Generate a report\")</code> <code>save_to_yaml(file_path)</code> Saves the agent to a YAML file. <code>file_path</code> (str): Path to save the YAML file. <code>agent.save_to_yaml(\"agent_config.yaml\")</code> <code>get_llm_parameters()</code> Returns the parameters of the language model. None <code>llm_params = agent.get_llm_parameters()</code> <code>save_state(file_path, *args, **kwargs)</code> Saves the current state of the agent to a JSON file. <code>file_path</code> (str): Path to save the JSON file.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent.save_state(\"agent_state.json\")</code> <code>update_system_prompt(system_prompt)</code> Updates the system prompt. <code>system_prompt</code> (str): New system prompt. <code>agent.update_system_prompt(\"New system instructions\")</code> <code>update_max_loops(max_loops)</code> Updates the maximum number of loops. <code>max_loops</code> (int): New maximum number of loops. <code>agent.update_max_loops(5)</code> <code>update_loop_interval(loop_interval)</code> Updates the loop interval. <code>loop_interval</code> (int): New loop interval. <code>agent.update_loop_interval(2)</code> <code>update_retry_attempts(retry_attempts)</code> Updates the number of retry attempts. <code>retry_attempts</code> (int): New number of retry attempts. <code>agent.update_retry_attempts(3)</code> <code>update_retry_interval(retry_interval)</code> Updates the retry interval. <code>retry_interval</code> (int): New retry interval. <code>agent.update_retry_interval(5)</code> <code>reset()</code> Resets the agent's memory. None <code>agent.reset()</code> <code>ingest_docs(docs, *args, **kwargs)</code> Ingests documents into the agent's memory. <code>docs</code> (List[str]): List of document paths.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent.ingest_docs([\"doc1.pdf\", \"doc2.txt\"])</code> <code>ingest_pdf(pdf)</code> Ingests a PDF document into the agent's memory. <code>pdf</code> (str): Path to the PDF file. <code>agent.ingest_pdf(\"document.pdf\")</code> <code>receive_message(name, message)</code> Receives a message and adds it to the agent's memory. <code>name</code> (str): Name of the sender.<code>message</code> (str): Content of the message. <code>agent.receive_message(\"User\", \"Hello, agent!\")</code> <code>send_agent_message(agent_name, message, *args, **kwargs)</code> Sends a message from the agent to a user. <code>agent_name</code> (str): Name of the agent.<code>message</code> (str): Message to send.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>response = agent.send_agent_message(\"AgentX\", \"Task completed\")</code> <code>add_tool(tool)</code> Adds a tool to the agent's toolset. <code>tool</code> (Callable): Tool to add. <code>agent.add_tool(my_custom_tool)</code> <code>add_tools(tools)</code> Adds multiple tools to the agent's toolset. <code>tools</code> (List[Callable]): List of tools to add. <code>agent.add_tools([tool1, tool2])</code> <code>remove_tool(tool)</code> Removes a tool from the agent's toolset. Method -------- ------------- -------- ---------------- <code>remove_tool(tool)</code> Removes a tool from the agent's toolset. <code>tool</code> (Callable): Tool to remove. <code>agent.remove_tool(my_custom_tool)</code> <code>remove_tools(tools)</code> Removes multiple tools from the agent's toolset. <code>tools</code> (List[Callable]): List of tools to remove. <code>agent.remove_tools([tool1, tool2])</code> <code>get_docs_from_doc_folders()</code> Retrieves and processes documents from the specified folder. None <code>agent.get_docs_from_doc_folders()</code> <code>memory_query(task, *args, **kwargs)</code> Queries the long-term memory for relevant information. <code>task</code> (str): The task or query.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>result = agent.memory_query(\"Find information about X\")</code> <code>sentiment_analysis_handler(response)</code> Performs sentiment analysis on the given response. <code>response</code> (str): The response to analyze. <code>agent.sentiment_analysis_handler(\"Great job!\")</code> <code>count_and_shorten_context_window(history, *args, **kwargs)</code> Counts tokens and shortens the context window if necessary. <code>history</code> (str): The conversation history.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>shortened_history = agent.count_and_shorten_context_window(history)</code> <code>output_cleaner_and_output_type(response, *args, **kwargs)</code> Cleans and formats the output based on specified type. <code>response</code> (str): The response to clean and format.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>cleaned_response = agent.output_cleaner_and_output_type(response)</code> <code>stream_response(response, delay=0.001)</code> Streams the response token by token. <code>response</code> (str): The response to stream.<code>delay</code> (float): Delay between tokens. <code>agent.stream_response(\"This is a streamed response\")</code> <code>dynamic_context_window()</code> Dynamically adjusts the context window. None <code>agent.dynamic_context_window()</code> <code>check_available_tokens()</code> Checks and returns the number of available tokens. None <code>available_tokens = agent.check_available_tokens()</code> <code>tokens_checks()</code> Performs token checks and returns available tokens. None <code>token_info = agent.tokens_checks()</code> <code>truncate_string_by_tokens(input_string, limit)</code> Truncates a string to fit within a token limit. <code>input_string</code> (str): String to truncate.<code>limit</code> (int): Token limit. <code>truncated_string = agent.truncate_string_by_tokens(\"Long string\", 100)</code> <code>tokens_operations(input_string)</code> Performs various token-related operations on the input string. <code>input_string</code> (str): String to process. <code>processed_string = agent.tokens_operations(\"Input string\")</code> <code>parse_function_call_and_execute(response)</code> Parses a function call from the response and executes it. <code>response</code> (str): Response containing the function call. <code>result = agent.parse_function_call_and_execute(response)</code> <code>llm_output_parser(response)</code> Parses the output from the language model. <code>response</code> (Any): Response from the LLM. <code>parsed_response = agent.llm_output_parser(llm_output)</code> <code>log_step_metadata(loop, task, response)</code> Logs metadata for each step of the agent's execution. <code>loop</code> (int): Current loop number.<code>task</code> (str): Current task.<code>response</code> (str): Agent's response. <code>agent.log_step_metadata(1, \"Analyze data\", \"Analysis complete\")</code> <code>to_dict()</code> Converts the agent's attributes to a dictionary. None <code>agent_dict = agent.to_dict()</code> <code>to_json(indent=4, *args, **kwargs)</code> Converts the agent's attributes to a JSON string. <code>indent</code> (int): Indentation for JSON.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent_json = agent.to_json()</code> <code>to_yaml(indent=4, *args, **kwargs)</code> Converts the agent's attributes to a YAML string. <code>indent</code> (int): Indentation for YAML.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent_yaml = agent.to_yaml()</code> <code>to_toml(*args, **kwargs)</code> Converts the agent's attributes to a TOML string. <code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>agent_toml = agent.to_toml()</code> <code>model_dump_json()</code> Saves the agent model to a JSON file in the workspace directory. None <code>agent.model_dump_json()</code> <code>model_dump_yaml()</code> Saves the agent model to a YAML file in the workspace directory. None <code>agent.model_dump_yaml()</code> <code>log_agent_data()</code> Logs the agent's data to an external API. None <code>agent.log_agent_data()</code> <code>handle_tool_schema_ops()</code> Handles operations related to tool schemas. None <code>agent.handle_tool_schema_ops()</code> <code>call_llm(task, *args, **kwargs)</code> Calls the appropriate method on the language model. <code>task</code> (str): Task for the LLM.<code>*args</code>, <code>**kwargs</code>: Additional arguments. <code>response = agent.call_llm(\"Generate text\")</code> <code>handle_sop_ops()</code> Handles operations related to standard operating procedures. None <code>agent.handle_sop_ops()</code> <code>agent_output_type(responses)</code> Processes and returns the agent's output based on the specified output type. <code>responses</code> (list): List of responses. <code>formatted_output = agent.agent_output_type(responses)</code> <code>check_if_no_prompt_then_autogenerate(task)</code> Checks if a system prompt is not set and auto-generates one if needed. <code>task</code> (str): The task to use for generating a prompt. <code>agent.check_if_no_prompt_then_autogenerate(\"Analyze data\")</code> <code>check_if_no_prompt_then_autogenerate(task)</code> Checks if auto_generate_prompt is enabled and generates a prompt by combining agent name, description and system prompt <code>task</code> (str, optional): Task to use as fallback <code>agent.check_if_no_prompt_then_autogenerate(\"Analyze data\")</code> <code>handle_artifacts(response, output_path, extension)</code> Handles saving artifacts from agent execution <code>response</code> (str): Agent response<code>output_path</code> (str): Output path<code>extension</code> (str): File extension <code>agent.handle_artifacts(response, \"outputs/\", \".txt\")</code>"},{"location":"swarms/structs/agent/#updated-run-method","title":"Updated Run Method","text":"<p>Update the run method documentation to include new parameters:</p> Method Description Inputs Usage Example <code>run(task, img=None, is_last=False, device=\"cpu\", device_id=0, all_cores=True, scheduled_run_date=None)</code> Runs the agent with specified parameters <code>task</code> (str): Task to run<code>img</code> (str, optional): Image path<code>is_last</code> (bool): If this is last task<code>device</code> (str): Device to use<code>device_id</code> (int): GPU ID<code>all_cores</code> (bool): Use all CPU cores<code>scheduled_run_date</code> (datetime, optional): Future run date <code>agent.run(\"Analyze data\", device=\"gpu\", device_id=0)</code>"},{"location":"swarms/structs/agent/#getting-started","title":"Getting Started","text":"<p>To use the Swarm Agent, first install the required dependencies:</p> <pre><code>pip3 install -U swarms\n</code></pre> <p>Then, you can initialize and use the agent as follows:</p> <pre><code>from swarms.structs.agent import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT\n\n# Initialize the Financial Analysis Agent with GPT-4o-mini model\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"finance_agent.json\",\n    user_name=\"swarms_corp\",\n    retry_attempts=1,\n    context_length=200000,\n    return_step_meta=False,\n    output_type=\"str\",\n)\n\n# Run the agent\nresponse = agent.run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\"\n)\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/structs/agent/#tool-integration","title":"Tool Integration","text":"<p>To integrate tools with the Swarm <code>Agent</code>, you can pass a list of callable functions with types and doc strings to the <code>tools</code> parameter when initializing the <code>Agent</code> instance. The agent will automatically convert these functions into an OpenAI function calling schema and make them available for use during task execution.</p>"},{"location":"swarms/structs/agent/#requirements-for-a-tool","title":"Requirements for a tool","text":"<ul> <li>Function</li> <li>With types</li> <li>with doc strings</li> </ul> <pre><code>from swarms import Agent\nfrom swarm_models import OpenAIChat\nimport subprocess\n\ndef terminal(code: str):\n    \"\"\"\n    Run code in the terminal.\n\n    Args:\n        code (str): The code to run in the terminal.\n\n    Returns:\n        str: The output of the code.\n    \"\"\"\n    out = subprocess.run(code, shell=True, capture_output=True, text=True).stdout\n    return str(out)\n\n# Initialize the agent with a tool\nagent = Agent(\n    agent_name=\"Terminal-Agent\",\n    llm=OpenAIChat(api_key=os.getenv(\"OPENAI_API_KEY\")),\n    tools=[terminal],\n    system_prompt=\"You are an agent that can execute terminal commands. Use the tools provided to assist the user.\",\n)\n\n# Run the agent\nresponse = agent.run(\"List the contents of the current directory\")\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent/#long-term-memory-management","title":"Long-term Memory Management","text":"<p>The Swarm Agent supports integration with vector databases for long-term memory management. Here's an example using ChromaDB:</p> <pre><code>from swarms import Agent\nfrom swarm_models import Anthropic\nfrom swarms_memory import ChromaDB\n\n# Initialize ChromaDB\nchromadb = ChromaDB(\n    metric=\"cosine\",\n    output_dir=\"finance_agent_rag\",\n)\n\n# Initialize the agent with long-term memory\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    llm=Anthropic(anthropic_api_key=os.getenv(\"ANTHROPIC_API_KEY\")),\n    long_term_memory=chromadb,\n    system_prompt=\"You are a financial analysis agent with access to long-term memory.\",\n)\n\n# Run the agent\nresponse = agent.run(\"What are the components of a startup's stock incentive equity plan?\")\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent/#interactive-mode","title":"Interactive Mode","text":"<p>To enable interactive mode, set the <code>interactive</code> parameter to <code>True</code> when initializing the <code>Agent</code>:</p> <pre><code>agent = Agent(\n    agent_name=\"Interactive-Agent\",\n    llm=OpenAIChat(api_key=os.getenv(\"OPENAI_API_KEY\")),\n    interactive=True,\n    system_prompt=\"You are an interactive agent. Engage in a conversation with the user.\",\n)\n\n# Run the agent in interactive mode\nagent.run(\"Let's start a conversation\")\n</code></pre>"},{"location":"swarms/structs/agent/#sentiment-analysis","title":"Sentiment Analysis","text":"<p>To perform sentiment analysis on the agent's outputs, you can provide a sentiment analyzer function:</p> <pre><code>from textblob import TextBlob\n\ndef sentiment_analyzer(text):\n    analysis = TextBlob(text)\n    return analysis.sentiment.polarity\n\nagent = Agent(\n    agent_name=\"Sentiment-Analysis-Agent\",\n    llm=OpenAIChat(api_key=os.getenv(\"OPENAI_API_KEY\")),\n    sentiment_analyzer=sentiment_analyzer,\n    sentiment_threshold=0.5,\n    system_prompt=\"You are an agent that generates responses with sentiment analysis.\",\n)\n\nresponse = agent.run(\"Generate a positive statement about AI\")\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent/#undo-functionality","title":"Undo Functionality","text":"<pre><code># Feature 2: Undo functionality\nresponse = agent.run(\"Another task\")\nprint(f\"Response: {response}\")\nprevious_state, message = agent.undo_last()\nprint(message)\n</code></pre>"},{"location":"swarms/structs/agent/#response-filtering","title":"Response Filtering","text":"<pre><code># Feature 3: Response filtering\nagent.add_response_filter(\"report\")\nresponse = agent.filtered_run(\"Generate a report on finance\")\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent/#saving-and-loading-state","title":"Saving and Loading State","text":"<pre><code># Save the agent state\nagent.save_state('saved_flow.json')\n\n# Load the agent state\nagent = Agent(llm=llm_instance, max_loops=5)\nagent.load('saved_flow.json')\nagent.run(\"Continue with the task\")\n</code></pre>"},{"location":"swarms/structs/agent/#async-and-concurrent-execution","title":"Async and Concurrent Execution","text":"<pre><code># Run a task concurrently\nresponse = await agent.run_concurrent(\"Concurrent task\")\nprint(response)\n\n# Run multiple tasks concurrently\ntasks = [\n    {\"task\": \"Task 1\"},\n    {\"task\": \"Task 2\", \"img\": \"path/to/image.jpg\"},\n    {\"task\": \"Task 3\", \"custom_param\": 42}\n]\nresponses = agent.bulk_run(tasks)\nprint(responses)\n</code></pre>"},{"location":"swarms/structs/agent/#various-other-settings","title":"Various other settings","text":"<pre><code># # Convert the agent object to a dictionary\nprint(agent.to_dict())\nprint(agent.to_toml())\nprint(agent.model_dump_json())\nprint(agent.model_dump_yaml())\n\n# Ingest documents into the agent's knowledge base\nagent.ingest_docs(\"your_pdf_path.pdf\")\n\n# Receive a message from a user and process it\nagent.receive_message(name=\"agent_name\", message=\"message\")\n\n# Send a message from the agent to a user\nagent.send_agent_message(agent_name=\"agent_name\", message=\"message\")\n\n# Ingest multiple documents into the agent's knowledge base\nagent.ingest_docs(\"your_pdf_path.pdf\", \"your_csv_path.csv\")\n\n# Run the agent with a filtered system prompt\nagent.filtered_run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\"\n)\n\n# Run the agent with multiple system prompts\nagent.bulk_run(\n    [\n        \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\",\n        \"Another system prompt\",\n    ]\n)\n\n# Add a memory to the agent\nagent.add_memory(\"Add a memory to the agent\")\n\n# Check the number of available tokens for the agent\nagent.check_available_tokens()\n\n# Perform token checks for the agent\nagent.tokens_checks()\n\n# Print the dashboard of the agent\nagent.print_dashboard()\n\n\n# Fetch all the documents from the doc folders\nagent.get_docs_from_doc_folders()\n\n# Dump the model to a JSON file\nagent.model_dump_json()\nprint(agent.to_toml())\n</code></pre>"},{"location":"swarms/structs/agent/#auto-generate-prompt-cpu-execution","title":"Auto Generate Prompt + CPU Execution","text":"<pre><code>import os\nfrom swarms import Agent\nfrom swarm_models import OpenAIChat\n\nfrom dotenv import load_dotenv\n\n# Load environment variables\nload_dotenv()\n\n# Retrieve the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Initialize the model for OpenAI Chat\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\n# Initialize the agent with automated prompt engineering enabled\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=None,  # System prompt is dynamically generated\n    agent_description=None,\n    llm=model,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=False,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"finance_agent.json\",\n    user_name=\"Human:\",\n    return_step_meta=False,\n    output_type=\"string\",\n    streaming_on=False,\n    auto_generate_prompt=True,  # Enable automated prompt engineering\n)\n\n# Run the agent with a task description and specify the device\nagent.run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria\",\n    ## Will design a system prompt based on the task if description and system prompt are None\n    device=\"cpu\",\n)\n\n# Print the dynamically generated system prompt\nprint(agent.system_prompt)\n</code></pre>"},{"location":"swarms/structs/agent/#agent-structured-outputs","title":"Agent Structured Outputs","text":"<ul> <li>Create a structured output schema for the agent [List[Dict]]</li> <li>Input in the <code>tools_list_dictionary</code> parameter</li> <li>Output is a dictionary</li> <li>Use the <code>str_to_dict</code> function to convert the output to a dictionary <pre><code>from dotenv import load_dotenv\n\nfrom swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\nfrom swarms.utils.str_to_dict import str_to_dict\n\nload_dotenv()\n\ntools = [\n    {\n        \"type\": \"function\",\n        \"function\": {\n            \"name\": \"get_stock_price\",\n            \"description\": \"Retrieve the current stock price and related information for a specified company.\",\n            \"parameters\": {\n                \"type\": \"object\",\n                \"properties\": {\n                    \"ticker\": {\n                        \"type\": \"string\",\n                        \"description\": \"The stock ticker symbol of the company, e.g. AAPL for Apple Inc.\",\n                    },\n                    \"include_history\": {\n                        \"type\": \"boolean\",\n                        \"description\": \"Indicates whether to include historical price data along with the current price.\",\n                    },\n                    \"time\": {\n                        \"type\": \"string\",\n                        \"format\": \"date-time\",\n                        \"description\": \"Optional parameter to specify the time for which the stock data is requested, in ISO 8601 format.\",\n                    },\n                },\n                \"required\": [\n                    \"ticker\",\n                    \"include_history\",\n                    \"time\",\n                ],\n            },\n        },\n    }\n]\n\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"Personal finance advisor agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=1,\n    tools_list_dictionary=tools,\n)\n\nout = agent.run(\n    \"What is the current stock price for Apple Inc. (AAPL)? Include historical price data.\",\n)\n\nprint(out)\n\nprint(type(out))\n\nprint(str_to_dict(out))\n\nprint(type(str_to_dict(out)))\n</code></pre></li> </ul>"},{"location":"swarms/structs/agent/#best-practices","title":"Best Practices","text":"<ol> <li>Always provide a clear and concise <code>system_prompt</code> to guide the agent's behavior.</li> <li>Use <code>tools</code> to extend the agent's capabilities for specific tasks.</li> <li>Implement error handling and utilize the <code>retry_attempts</code> feature for robust execution.</li> <li>Leverage <code>long_term_memory</code> for tasks that require persistent information.</li> <li>Use <code>interactive</code> mode for real-time conversations and <code>dashboard</code> for monitoring.</li> <li>Implement <code>sentiment_analysis</code> for applications requiring tone management.</li> <li>Utilize <code>autosave</code> and <code>save</code>/<code>load</code> methods for continuity across sessions.</li> <li>Optimize token usage with <code>dynamic_context_window</code> and <code>tokens_checks</code> methods.</li> <li>Use <code>concurrent</code> and <code>async</code> methods for performance-critical applications.</li> <li>Regularly review and analyze feedback using the <code>analyze_feedback</code> method.</li> <li>Use <code>artifacts_on</code> to save important outputs from agent execution</li> <li>Configure <code>device</code> and <code>device_id</code> appropriately for optimal performance</li> <li>Enable <code>rag_every_loop</code> when continuous context from long-term memory is needed</li> <li>Use <code>scheduled_run_date</code> for automated task scheduling</li> </ol> <p>By following these guidelines and leveraging the Swarm Agent's extensive features, you can create powerful, flexible, and efficient autonomous agents for a wide range of applications.</p>"},{"location":"swarms/structs/agent_docs_v1/","title":"<code>Agent</code> Documentation","text":"<p>Swarm Agent is a powerful autonomous agent framework designed to connect Language Models (LLMs) with various tools and long-term memory. This class provides the ability to ingest and process various types of documents such as PDFs, text files, Markdown files, JSON files, and more. The Agent structure offers a wide range of features to enhance the capabilities of LLMs and facilitate efficient task execution.</p> <ol> <li> <p>Conversational Loop: It establishes a conversational loop with a language model. This means it allows you to interact with the model in a back-and-forth manner, taking turns in the conversation.</p> </li> <li> <p>Feedback Collection: The class allows users to provide feedback on the responses generated by the model. This feedback can be valuable for training and improving the model's responses over time.</p> </li> <li> <p>Stoppable Conversation: You can define custom stopping conditions for the conversation, allowing you to stop the interaction based on specific criteria. For example, you can stop the conversation if a certain keyword is detected in the responses.</p> </li> <li> <p>Retry Mechanism: The class includes a retry mechanism that can be helpful if there are issues generating responses from the model. It attempts to generate a response multiple times before raising an error.</p> </li> </ol>"},{"location":"swarms/structs/agent_docs_v1/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Task Initiation] --&gt;|Receives Task| B[Initial LLM Processing]\n    B --&gt;|Interprets Task| C[Tool Usage]\n    C --&gt;|Calls Tools| D[Function 1]\n    C --&gt;|Calls Tools| E[Function 2]\n    D --&gt;|Returns Data| C\n    E --&gt;|Returns Data| C\n    C --&gt;|Provides Data| F[Memory Interaction]\n    F --&gt;|Stores and Retrieves Data| G[RAG System]\n    G --&gt;|ChromaDB/Pinecone| H[Enhanced Data]\n    F --&gt;|Provides Enhanced Data| I[Final LLM Processing]\n    I --&gt;|Generates Final Response| J[Output]\n    C --&gt;|No Tools Available| K[Skip Tool Usage]\n    K --&gt;|Proceeds to Memory Interaction| F\n    F --&gt;|No Memory Available| L[Skip Memory Interaction]\n    L --&gt;|Proceeds to Final LLM Processing| I</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#agent-attributes","title":"<code>Agent</code> Attributes","text":"Attribute Description <code>id</code> A unique identifier for the agent instance. <code>llm</code> The language model instance used by the agent. <code>template</code> The template used for formatting responses. <code>max_loops</code> The maximum number of loops the agent can run. <code>stopping_condition</code> A callable function that determines when the agent should stop looping. <code>loop_interval</code> The interval (in seconds) between loops. <code>retry_attempts</code> The number of retry attempts for failed LLM calls. <code>retry_interval</code> The interval (in seconds) between retry attempts. <code>return_history</code> A boolean indicating whether the agent should return the conversation history. <code>stopping_token</code> A token that, when present in the response, stops the agent from looping. <code>dynamic_loops</code> A boolean indicating whether the agent should dynamically determine the number of loops. <code>interactive</code> A boolean indicating whether the agent should run in interactive mode. <code>dashboard</code> A boolean indicating whether the agent should display a dashboard. <code>agent_name</code> The name of the agent instance. <code>agent_description</code> A description of the agent instance. <code>system_prompt</code> The system prompt used to initialize the conversation. <code>tools</code> A list of callable functions representing tools the agent can use. <code>dynamic_temperature_enabled</code> A boolean indicating whether the agent should dynamically adjust the temperature of the LLM. <code>sop</code> The standard operating procedure for the agent. <code>sop_list</code> A list of strings representing the standard operating procedure. <code>saved_state_path</code> The file path for saving and loading the agent's state. <code>autosave</code> A boolean indicating whether the agent should automatically save its state. <code>context_length</code> The maximum length of the context window (in tokens) for the LLM. <code>user_name</code> The name used to represent the user in the conversation. <code>self_healing_enabled</code> A boolean indicating whether the agent should attempt to self-heal in case of errors. <code>code_interpreter</code> A boolean indicating whether the agent should interpret and execute code snippets. <code>multi_modal</code> A boolean indicating whether the agent should support multimodal inputs (e.g., text and images). <code>pdf_path</code> The file path of a PDF document to be ingested. <code>list_of_pdf</code> A list of file paths for PDF documents to be ingested. <code>tokenizer</code> An instance of a tokenizer used for token counting and management. <code>long_term_memory</code> An instance of a <code>BaseVectorDatabase</code> implementation for long-term memory management. <code>preset_stopping_token</code> A boolean indicating whether the agent should use a preset stopping token. <code>traceback</code> An object used for traceback handling. <code>traceback_handlers</code> A list of traceback handlers. <code>streaming_on</code> A boolean indicating whether the agent should stream its responses. <code>docs</code> A list of document paths or contents to be ingested. <code>docs_folder</code> The path to a folder containing documents to be ingested. <code>verbose</code> A boolean indicating whether the agent should print verbose output. <code>parser</code> A callable function used for parsing input data. <code>best_of_n</code> An integer indicating the number of best responses to generate (for sampling). <code>callback</code> A callable function to be called after each agent loop. <code>metadata</code> A dictionary containing metadata for the agent. <code>callbacks</code> A list of callable functions to be called during the agent's execution. <code>logger_handler</code> A handler for logging messages. <code>search_algorithm</code> A callable function representing the search algorithm for long-term memory retrieval. <code>logs_to_filename</code> The file path for logging agent activities. <code>evaluator</code> A callable function used for evaluating the agent's responses. <code>output_json</code> A boolean indicating whether the agent's output should be in JSON format. <code>stopping_func</code> A callable function used as a stopping condition for the agent. <code>custom_loop_condition</code> A callable function used as a custom loop condition for the agent. <code>sentiment_threshold</code> A float value representing the sentiment threshold for evaluating responses. <code>custom_exit_command</code> A string representing a custom command for exiting the agent's loop. <code>sentiment_analyzer</code> A callable function used for sentiment analysis on the agent's outputs. <code>limit_tokens_from_string</code> A callable function used for limiting the number of tokens in a string. <code>custom_tools_prompt</code> A callable function used for generating a custom prompt for tool usage. <code>tool_schema</code> A data structure representing the schema for the agent's tools. <code>output_type</code> A type representing the expected output type of the agent's responses. <code>function_calling_type</code> A string representing the type of function calling (e.g., \"json\"). <code>output_cleaner</code> A callable function used for cleaning the agent's output. <code>function_calling_format_type</code> A string representing the format type for function calling (e.g., \"OpenAI\"). <code>list_base_models</code> A list of base models used for generating tool schemas. <code>metadata_output_type</code> A string representing the output type for metadata. <code>state_save_file_type</code> A string representing the file type for saving the agent's state (e.g., \"json\", \"yaml\"). <code>chain_of_thoughts</code> A boolean indicating whether the agent should use the chain of thoughts technique. <code>algorithm_of_thoughts</code> A boolean indicating whether the agent should use the algorithm of thoughts technique. <code>tree_of_thoughts</code> A boolean indicating whether the agent should use the tree of thoughts technique. <code>tool_choice</code> A string representing the method for tool selection (e.g., \"auto\"). <code>execute_tool</code> A boolean indicating whether the agent should execute tools. <code>rules</code> A string representing the rules for the agent's behavior. <code>planning</code> A boolean indicating whether the agent should perform planning. <code>planning_prompt</code> A string representing the prompt for planning. <code>device</code> A string representing the device on which the agent should run. <code>custom_planning_prompt</code> A string representing a custom prompt for planning. <code>memory_chunk_size</code> An integer representing the maximum size of memory chunks for long-term memory retrieval. <code>agent_ops_on</code> A boolean indicating whether agent operations should be enabled. <code>return_step_meta</code> A boolean indicating whether or not to return JSON of all the steps and additional metadata <code>output_type</code> A Literal type indicating whether to output \"string\", \"str\", \"list\", \"json\", \"dict\", \"yaml\""},{"location":"swarms/structs/agent_docs_v1/#agent-methods","title":"<code>Agent</code> Methods","text":"Method Description Inputs Usage Example <code>run(task, img=None, *args, **kwargs)</code> Runs the autonomous agent loop to complete the given task. <code>task</code> (str): The task to be performed.<code>img</code> (str, optional): Path to an image file, if the task involves image processing.<code>*args</code>, <code>**kwargs</code>: Additional arguments to pass to the language model. <code>response = agent.run(\"Generate a report on financial performance.\")</code> <code>__call__(task, img=None, *args, **kwargs)</code> An alternative way to call the <code>run</code> method. Same as <code>run</code>. <code>response = agent(\"Generate a report on financial performance.\")</code> <code>parse_and_execute_tools(response, *args, **kwargs)</code> Parses the agent's response and executes any tools mentioned in it. <code>response</code> (str): The agent's response to be parsed.<code>*args</code>, <code>**kwargs</code>: Additional arguments to pass to the tool execution. <code>agent.parse_and_execute_tools(response)</code> <code>long_term_memory_prompt(query, *args, **kwargs)</code> Generates a prompt for querying the agent's long-term memory. <code>query</code> (str): The query to search for in long-term memory.<code>*args</code>, <code>**kwargs</code>: Additional arguments to pass to the long-term memory retrieval. <code>memory_retrieval = agent.long_term_memory_prompt(\"financial performance\")</code> <code>add_memory(message)</code> Adds a message to the agent's memory. <code>message</code> (str): The message"},{"location":"swarms/structs/agent_docs_v1/#features","title":"Features","text":"<ul> <li>Language Model Integration: The Swarm Agent allows seamless integration with different language models, enabling users to leverage the power of state-of-the-art models.</li> <li>Tool Integration: The framework supports the integration of various tools, enabling the agent to perform a wide range of tasks, from code execution to data analysis and beyond.</li> <li>Long-term Memory Management: The Swarm Agent incorporates long-term memory management capabilities, allowing it to store and retrieve relevant information for effective decision-making and task execution.</li> <li>Document Ingestion: The agent can ingest and process various types of documents, including PDFs, text files, Markdown files, JSON files, and more, enabling it to extract relevant information for task completion.</li> <li>Interactive Mode: Users can interact with the agent in an interactive mode, enabling real-time communication and task execution.</li> <li>Dashboard: The framework provides a visual dashboard for monitoring the agent's performance and activities.</li> <li>Dynamic Temperature Control: The Swarm Agent supports dynamic temperature control, allowing for adjustments to the model's output diversity during task execution.</li> <li>Autosave and State Management: The agent can save its state automatically, enabling seamless resumption of tasks after interruptions or system restarts.</li> <li>Self-Healing and Error Handling: The framework incorporates self-healing and error-handling mechanisms to ensure robust and reliable operation.</li> <li>Code Interpretation: The agent can interpret and execute code snippets, expanding its capabilities for tasks involving programming or scripting.</li> <li>Multimodal Support: The framework supports multimodal inputs, enabling the agent to process and reason about various data types, such as text, images, and audio.</li> <li>Tokenization and Token Management: The Swarm Agent provides tokenization capabilities, enabling efficient management of token usage and context window truncation.</li> <li>Sentiment Analysis: The agent can perform sentiment analysis on its generated outputs, allowing for evaluation and adjustment of responses based on sentiment thresholds.</li> <li>Output Filtering and Cleaning: The framework supports output filtering and cleaning, ensuring that generated responses adhere to specific criteria or guidelines.</li> <li>Asynchronous and Concurrent Execution: The Swarm Agent supports asynchronous and concurrent task execution, enabling efficient parallelization and scaling of operations.</li> <li>Planning and Reasoning: The agent can engage in planning and reasoning processes, leveraging techniques such as algorithm of thoughts and chain of thoughts to enhance decision-making and task execution.</li> <li>Agent Operations and Monitoring: The framework provides integration with agent operations and monitoring tools, enabling real-time monitoring and management of the agent's activities.</li> </ul>"},{"location":"swarms/structs/agent_docs_v1/#getting-started","title":"Getting Started","text":"<p>First run the following:</p> <pre><code>pip3 install -U swarms\n</code></pre> <p>And, then now you can get started with the following:</p> <pre><code>import os\nfrom swarms import Agent\nfrom swarm_models import OpenAIChat\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Create an instance of the OpenAIChat class\nmodel = OpenAIChat(\n    api_key=api_key, model_name=\"gpt-4o-mini\", temperature=0.1\n)\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent_sas_chicken_eej\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"finance_agent.json\",\n    user_name=\"swarms_corp\",\n    retry_attempts=1,\n    context_length=200000,\n    return_step_meta=False,\n    output_type=\"str\",\n)\n\n\nagent.run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria\"\n)\nprint(out)\n</code></pre> <p>This example initializes an instance of the <code>Agent</code> class with an OpenAI language model and a maximum of 3 loops. The <code>run()</code> method is then called with a task to generate a report on financial performance, and the agent's response is printed.</p>"},{"location":"swarms/structs/agent_docs_v1/#advanced-usage","title":"Advanced Usage","text":"<p>The Swarm Agent provides numerous advanced features and customization options. Here are a few examples of how to leverage these features:</p>"},{"location":"swarms/structs/agent_docs_v1/#tool-integration","title":"Tool Integration","text":"<p>To integrate tools with the Swarm Agent, you can pass a list of callable functions with types and doc strings to the <code>tools</code> parameter when initializing the <code>Agent</code> instance. The agent will automatically convert these functions into an OpenAI function calling schema and make them available for use during task execution.</p>"},{"location":"swarms/structs/agent_docs_v1/#requirements-for-a-tool","title":"Requirements for a tool","text":"<ul> <li>Function</li> <li>With types</li> <li>with doc strings</li> </ul> <pre><code>from swarms import Agent\nfrom swarm_models import OpenAIChat\nfrom swarms_memory import ChromaDB\nimport subprocess\nimport os\n\n# Making an instance of the ChromaDB class\nmemory = ChromaDB(\n    metric=\"cosine\",\n    n_results=3,\n    output_dir=\"results\",\n    docs_folder=\"docs\",\n)\n\n# Model\nmodel = OpenAIChat(\n    api_key=os.getenv(\"OPENAI_API_KEY\"),\n    model_name=\"gpt-4o-mini\",\n    temperature=0.1,\n)\n\n\n# Tools in swarms are simple python functions and docstrings\ndef terminal(\n    code: str,\n):\n    \"\"\"\n    Run code in the terminal.\n\n    Args:\n        code (str): The code to run in the terminal.\n\n    Returns:\n        str: The output of the code.\n    \"\"\"\n    out = subprocess.run(\n        code, shell=True, capture_output=True, text=True\n    ).stdout\n    return str(out)\n\n\ndef browser(query: str):\n    \"\"\"\n    Search the query in the browser with the `browser` tool.\n\n    Args:\n        query (str): The query to search in the browser.\n\n    Returns:\n        str: The search results.\n    \"\"\"\n    import webbrowser\n\n    url = f\"https://www.google.com/search?q={query}\"\n    webbrowser.open(url)\n    return f\"Searching for {query} in the browser.\"\n\n\ndef create_file(file_path: str, content: str):\n    \"\"\"\n    Create a file using the file editor tool.\n\n    Args:\n        file_path (str): The path to the file.\n        content (str): The content to write to the file.\n\n    Returns:\n        str: The result of the file creation operation.\n    \"\"\"\n    with open(file_path, \"w\") as file:\n        file.write(content)\n    return f\"File {file_path} created successfully.\"\n\n\ndef file_editor(file_path: str, mode: str, content: str):\n    \"\"\"\n    Edit a file using the file editor tool.\n\n    Args:\n        file_path (str): The path to the file.\n        mode (str): The mode to open the file in.\n        content (str): The content to write to the file.\n\n    Returns:\n        str: The result of the file editing operation.\n    \"\"\"\n    with open(file_path, mode) as file:\n        file.write(content)\n    return f\"File {file_path} edited successfully.\"\n\n\n# Agent\nagent = Agent(\n    agent_name=\"Devin\",\n    system_prompt=(\n        \"Autonomous agent that can interact with humans and other\"\n        \" agents. Be Helpful and Kind. Use the tools provided to\"\n        \" assist the user. Return all code in markdown format.\"\n    ),\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    interactive=True,\n    tools=[terminal, browser, file_editor, create_file],\n    streaming=True,\n    long_term_memory=memory,\n)\n\n# Run the agent\nout = agent(\n    \"Create a CSV file with the latest tax rates for C corporations in the following ten states and the District of Columbia: Alabama, California, Florida, Georgia, Illinois, New York, North Carolina, Ohio, Texas, and Washington.\"\n)\nprint(out)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#long-term-memory-management","title":"Long-term Memory Management","text":"<p>The Swarm Agent supports integration with various vector databases for long-term memory management. You can pass an instance of a <code>BaseVectorDatabase</code> implementation to the <code>long_term_memory</code> parameter when initializing the <code>Agent</code>.</p> <pre><code>import os\n\nfrom swarms_memory import ChromaDB\n\nfrom swarms import Agent\nfrom swarm_models import Anthropic\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\n\n# Initilaize the chromadb client\nchromadb = ChromaDB(\n    metric=\"cosine\",\n    output_dir=\"fiance_agent_rag\",\n    # docs_folder=\"artifacts\", # Folder of your documents\n)\n\n# Model\nmodel = Anthropic(anthropic_api_key=os.getenv(\"ANTHROPIC_API_KEY\"))\n\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    agent_description=\"Agent creates \",\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"finance_agent.json\",\n    user_name=\"swarms_corp\",\n    retry_attempts=3,\n    context_length=200000,\n    long_term_memory=chromadb,\n)\n\n\nagent.run(\n    \"What are the components of a startups stock incentive equity plan\"\n)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#document-ingestion","title":"Document Ingestion","text":"<p>The Swarm Agent can ingest various types of documents, such as PDFs, text files, Markdown files, and JSON files. You can pass a list of document paths or contents to the <code>docs</code> parameter when initializing the <code>Agent</code>.</p> <pre><code>from swarms.structs import Agent\n\n# Initialize the agent with documents\nagent = Agent(llm=llm, max_loops=3, docs=[\"path/to/doc1.pdf\", \"path/to/doc2.txt\"])\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#interactive-mode","title":"Interactive Mode","text":"<p>The Swarm Agent supports an interactive mode, where users can engage in real-time communication with the agent. To enable interactive mode, set the <code>interactive</code> parameter to <code>True</code> when initializing the <code>Agent</code>.</p> <pre><code>from swarms.structs import Agent\n\n# Initialize the agent in interactive mode\nagent = Agent(llm=llm, max_loops=3, interactive=True)\n\n# Run the agent in interactive mode\nagent.interactive_run()\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#sentiment-analysis","title":"Sentiment Analysis","text":"<p>The Swarm Agent can perform sentiment analysis on its generated outputs using a sentiment analyzer function. You can pass a callable function to the <code>sentiment_analyzer</code> parameter when initializing the <code>Agent</code>.</p> <pre><code>from swarms.structs import Agent\nfrom my_sentiment_analyzer import sentiment_analyzer_function\n\n# Initialize the agent with a sentiment analyzer\nagent = Agent(\n    agent_name = \"sentiment-analyzer-agent-01\", system_prompt=\"...\"\n    llm=llm, max_loops=3, sentiment_analyzer=sentiment_analyzer_function)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#undo-functionality","title":"Undo Functionality","text":"<pre><code># Feature 2: Undo functionality\nresponse = agent.run(\"Another task\")\nprint(f\"Response: {response}\")\nprevious_state, message = agent.undo_last()\nprint(message)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#response-filtering","title":"Response Filtering","text":"<pre><code># Feature 3: Response filtering\nagent.add_response_filter(\"report\")\nresponse = agent.filtered_run(\"Generate a report on finance\")\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#saving-and-loading-state","title":"Saving and Loading State","text":"<pre><code># Save the agent state\nagent.save_state('saved_flow.json')\n\n# Load the agent state\nagent = Agent(llm=llm_instance, max_loops=5)\nagent.load('saved_flow.json')\nagent.run(\"Continue with the task\")\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#async-and-concurrent-execution","title":"Async and Concurrent Execution","text":"<pre><code># Run a task concurrently\nresponse = await agent.run_concurrent(\"Concurrent task\")\nprint(response)\n\n# Run multiple tasks concurrently\ntasks = [\n    {\"task\": \"Task 1\"},\n    {\"task\": \"Task 2\", \"img\": \"path/to/image.jpg\"},\n    {\"task\": \"Task 3\", \"custom_param\": 42}\n]\nresponses = agent.bulk_run(tasks)\nprint(responses)\n</code></pre>"},{"location":"swarms/structs/agent_docs_v1/#various-other-settings","title":"Various other settings","text":"<pre><code># # Convert the agent object to a dictionary\nprint(agent.to_dict())\nprint(agent.to_toml())\nprint(agent.model_dump_json())\nprint(agent.model_dump_yaml())\n\n# Ingest documents into the agent's knowledge base\nagent.ingest_docs(\"your_pdf_path.pdf\")\n\n# Receive a message from a user and process it\nagent.receive_message(name=\"agent_name\", message=\"message\")\n\n# Send a message from the agent to a user\nagent.send_agent_message(agent_name=\"agent_name\", message=\"message\")\n\n# Ingest multiple documents into the agent's knowledge base\nagent.ingest_docs(\"your_pdf_path.pdf\", \"your_csv_path.csv\")\n\n# Run the agent with a filtered system prompt\nagent.filtered_run(\n    \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\"\n)\n\n# Run the agent with multiple system prompts\nagent.bulk_run(\n    [\n        \"How can I establish a ROTH IRA to buy stocks and get a tax break? What are the criteria?\",\n        \"Another system prompt\",\n    ]\n)\n\n# Add a memory to the agent\nagent.add_memory(\"Add a memory to the agent\")\n\n# Check the number of available tokens for the agent\nagent.check_available_tokens()\n\n# Perform token checks for the agent\nagent.tokens_checks()\n\n# Print the dashboard of the agent\nagent.print_dashboard()\n\n\n# Fetch all the documents from the doc folders\nagent.get_docs_from_doc_folders()\n\n# Activate agent ops\n\n# Dump the model to a JSON file\nagent.model_dump_json()\nprint(agent.to_toml())\n</code></pre>"},{"location":"swarms/structs/agent_mcp/","title":"Agent MCP Integration Guide","text":"<ul> <li> <p> Direct MCP Server Connection</p> <p>Connect agents to MCP servers via URL for seamless integration</p> <p> Quick Start</p> </li> <li> <p> Dynamic Tool Discovery</p> <p>Automatically fetch and utilize tools from MCP servers</p> <p> Tool Discovery</p> </li> <li> <p> Real-time Communication</p> <p>Server-sent Events (SSE) for live data streaming</p> <p> Configuration</p> </li> <li> <p> Structured Output</p> <p>Process and format responses with multiple output types</p> <p> Examples</p> </li> </ul>"},{"location":"swarms/structs/agent_mcp/#overview","title":"Overview","text":"<p>The Model Context Protocol (MCP) integration enables Swarms agents to dynamically connect to external tools and services through a standardized protocol. This powerful feature expands agent capabilities by providing access to APIs, databases, and specialized services.</p> <p>What is MCP?</p> <p>The Model Context Protocol is a standardized way for AI agents to interact with external tools and services, providing a consistent interface for tool discovery and execution.</p>"},{"location":"swarms/structs/agent_mcp/#features-matrix","title":"Features Matrix","text":"\u2705 Current Capabilities\ud83d\udea7 In Development Feature Status Description Direct MCP Connection \u2705 Ready Connect via URL to MCP servers Tool Discovery \u2705 Ready Auto-fetch available tools SSE Communication \u2705 Ready Real-time server communication Multiple Tool Execution \u2705 Ready Execute multiple tools per session Structured Output \u2705 Ready Format responses in multiple types Feature Status Expected MCPConnection Model \ud83d\udea7 Development Q1 2024 Multiple Server Support \ud83d\udea7 Planned Q2 2024 Parallel Function Calling \ud83d\udea7 Research Q2 2024 Auto-discovery \ud83d\udea7 Planned Q3 2024"},{"location":"swarms/structs/agent_mcp/#quick-start","title":"Quick Start","text":"<p>Prerequisites</p> System RequirementsInstallation <ul> <li>Python 3.8+</li> <li>Swarms framework</li> <li>Running MCP server</li> </ul> <pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#step-1-basic-agent-setup","title":"Step 1: Basic Agent Setup","text":"<p>Simple MCP Agent</p> <pre><code>from swarms import Agent\n\n# Initialize agent with MCP integration\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    agent_description=\"AI-powered financial advisor\",\n    max_loops=1,\n    mcp_url=\"http://localhost:8000/sse\",  # Your MCP server\n    output_type=\"all\",\n)\n\n# Execute task using MCP tools\nresult = agent.run(\n    \"Get current Bitcoin price and analyze market trends\"\n)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#step-2-advanced-configuration","title":"Step 2: Advanced Configuration","text":"<p>Production-Ready Setup</p> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT\n\nagent = Agent(\n    agent_name=\"Advanced-Financial-Agent\",\n    agent_description=\"Comprehensive market analysis agent\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=3,\n    mcp_url=\"http://production-server:8000/sse\",\n    output_type=\"json\",\n    # Additional parameters for production\n    temperature=0.1,\n    verbose=True,\n)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#integration-flow","title":"Integration Flow","text":"<p>The following diagram illustrates the complete MCP integration workflow:</p> <pre><code>graph TD\n    A[\ud83d\ude80 Agent Receives Task] --&gt; B[\ud83d\udd17 Connect to MCP Server]\n    B --&gt; C[\ud83d\udd0d Discover Available Tools]\n    C --&gt; D[\ud83e\udde0 Analyze Task Requirements]\n    D --&gt; E[\ud83d\udcdd Generate Tool Request]\n    E --&gt; F[\ud83d\udce4 Send to MCP Server]\n    F --&gt; G[\u2699\ufe0f Server Processes Request]\n    G --&gt; H[\ud83d\udce5 Receive Response]\n    H --&gt; I[\ud83d\udd04 Process &amp; Validate]\n    I --&gt; J[\ud83d\udcca Summarize Results]\n    J --&gt; K[\u2705 Return Final Output]\n\n    class A,K startEnd\n    class D,I,J process\n    class F,G,H communication</code></pre>"},{"location":"swarms/structs/agent_mcp/#detailed-process-breakdown","title":"Detailed Process Breakdown","text":"<p>Process Steps</p> 1-3: Initialization4-6: Execution7-9: Processing10-11: Completion <p>Task Initiation - Agent receives user query</p> <p>Server Connection - Establish MCP server link</p> <p>Tool Discovery - Fetch available tool schemas</p> <p>Task Analysis - Determine required tools</p> <p>Request Generation - Create structured API calls</p> <p>Server Communication - Send requests via SSE</p> <p>Server Processing - MCP server executes tools</p> <p>Response Handling - Receive and validate data</p> <p>Result Processing - Parse and structure output</p> <p>Summarization - Generate user-friendly summary</p> <p>Final Output - Return complete response</p>"},{"location":"swarms/structs/agent_mcp/#configuration-options","title":"Configuration Options","text":""},{"location":"swarms/structs/agent_mcp/#agent-parameters","title":"Agent Parameters","text":"<p>Configuration Reference</p> Parameter Type Description Default Example <code>mcp_url</code> <code>str</code> MCP server endpoint <code>None</code> <code>\"http://localhost:8000/sse\"</code> <code>output_type</code> <code>str</code> Response format <code>\"str\"</code> <code>\"json\"</code>, <code>\"all\"</code>, <code>\"dict\"</code> <code>max_loops</code> <code>int</code> Execution iterations <code>1</code> <code>3</code> <code>temperature</code> <code>float</code> Response creativity <code>0.1</code> <code>0.1-1.0</code> <code>verbose</code> <code>bool</code> Debug logging <code>False</code> <code>True</code>"},{"location":"swarms/structs/agent_mcp/#example-implementations","title":"Example Implementations","text":""},{"location":"swarms/structs/agent_mcp/#cryptocurrency-trading-agent","title":"Cryptocurrency Trading Agent","text":"<p>Crypto Price Monitor</p> <pre><code>from swarms import Agent\n\ncrypto_agent = Agent(\n    agent_name=\"Crypto-Trading-Agent\",\n    agent_description=\"Real-time cryptocurrency market analyzer\",\n    max_loops=2,\n    mcp_url=\"http://crypto-server:8000/sse\",\n    output_type=\"json\",\n    temperature=0.1,\n)\n\n# Multi-exchange price comparison\nresult = crypto_agent.run(\n    \"\"\"\n    Compare Bitcoin and Ethereum prices across OKX and HTX exchanges.\n    Calculate arbitrage opportunities and provide trading recommendations.\n    \"\"\"\n)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#financial-analysis-suite","title":"Financial Analysis Suite","text":"<p>Advanced Financial Agent</p> <pre><code>from swarms import Agent\nfrom swarms.prompts.finance_agent_sys_prompt import FINANCIAL_AGENT_SYS_PROMPT\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analysis-Suite\",\n    agent_description=\"Comprehensive financial market analyst\",\n    system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n    max_loops=4,\n    mcp_url=\"http://finance-api:8000/sse\",\n    output_type=\"all\",\n    temperature=0.2,\n)\n\n# Complex market analysis\nanalysis = financial_agent.run(\n    \"\"\"\n    Perform a comprehensive analysis of Tesla (TSLA) stock:\n    1. Current price and technical indicators\n    2. Recent news sentiment analysis\n    3. Competitor comparison (GM, Ford)\n    4. Investment recommendation with risk assessment\n    \"\"\"\n)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#custom-industry-agent","title":"Custom Industry Agent","text":"<p>Healthcare Data Agent</p> <pre><code>from swarms import Agent\n\nhealthcare_agent = Agent(\n    agent_name=\"Healthcare-Data-Agent\",\n    agent_description=\"Medical data analysis and research assistant\",\n    max_loops=3,\n    mcp_url=\"http://medical-api:8000/sse\",\n    output_type=\"dict\",\n    system_prompt=\"\"\"\n    You are a healthcare data analyst. Use available medical databases\n    and research tools to provide accurate, evidence-based information.\n    Always cite sources and include confidence levels.\n    \"\"\",\n)\n\nresearch = healthcare_agent.run(\n    \"Research latest treatments for Type 2 diabetes and their efficacy rates\"\n)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#mcp-server-development","title":"MCP Server Development","text":""},{"location":"swarms/structs/agent_mcp/#fastmcp-server-example","title":"FastMCP Server Example","text":"<p>Building a Custom MCP Server</p> <pre><code>from mcp.server.fastmcp import FastMCP\nimport requests\nfrom typing import Optional\nimport asyncio\n\n# Initialize MCP server\nmcp = FastMCP(\"crypto_analysis_server\")\n\n@mcp.tool(\n    name=\"get_crypto_price\",\n    description=\"Fetch current cryptocurrency price with market data\",\n)\ndef get_crypto_price(\n    symbol: str, \n    currency: str = \"USD\",\n    include_24h_change: bool = True\n) -&gt; dict:\n    \"\"\"\n    Get real-time cryptocurrency price and market data.\n\n    Args:\n        symbol: Cryptocurrency symbol (e.g., BTC, ETH)\n        currency: Target currency for price (default: USD)\n        include_24h_change: Include 24-hour price change data\n    \"\"\"\n    try:\n        url = f\"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": symbol.lower(),\n            \"vs_currencies\": currency.lower(),\n            \"include_24hr_change\": include_24h_change\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n        return {\n            \"symbol\": symbol.upper(),\n            \"price\": data[symbol.lower()][currency.lower()],\n            \"currency\": currency.upper(),\n            \"change_24h\": data[symbol.lower()].get(\"24h_change\", 0),\n            \"timestamp\": \"2024-01-15T10:30:00Z\"\n        }\n\n    except Exception as e:\n        return {\"error\": f\"Failed to fetch price: {str(e)}\"}\n\n@mcp.tool(\n    name=\"analyze_market_sentiment\",\n    description=\"Analyze cryptocurrency market sentiment from social media\",\n)\ndef analyze_market_sentiment(symbol: str, timeframe: str = \"24h\") -&gt; dict:\n    \"\"\"Analyze market sentiment for a cryptocurrency.\"\"\"\n    # Implement sentiment analysis logic\n    return {\n        \"symbol\": symbol,\n        \"sentiment_score\": 0.75,\n        \"sentiment\": \"Bullish\",\n        \"confidence\": 0.85,\n        \"timeframe\": timeframe\n    }\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"sse\")\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#server-best-practices","title":"Server Best Practices","text":"<p>Server Development Guidelines</p> \ud83c\udfd7\ufe0f Architecture\ud83d\udd12 Security\u26a1 Performance <ul> <li>Modular Design: Separate tools into logical modules</li> <li>Error Handling: Implement comprehensive error responses</li> <li>Async Support: Use async/await for better performance</li> <li>Type Hints: Include proper type annotations</li> </ul> <ul> <li>Input Validation: Sanitize all user inputs</li> <li>Rate Limiting: Implement request throttling</li> <li>Authentication: Add API key validation</li> <li>Logging: Log all requests and responses</li> </ul> <ul> <li>Caching: Cache frequently requested data</li> <li>Connection Pooling: Reuse database connections</li> <li>Timeouts: Set appropriate request timeouts</li> <li>Load Testing: Test under realistic load</li> </ul>"},{"location":"swarms/structs/agent_mcp/#current-limitations","title":"Current Limitations","text":"<p>Important Limitations</p>"},{"location":"swarms/structs/agent_mcp/#mcpconnection-model","title":"\ud83d\udea7 MCPConnection Model","text":"<p>The enhanced connection model is under development:</p> <pre><code># \u274c Not available yet\nfrom swarms.schemas.mcp_schemas import MCPConnection\n\nmcp_config = MCPConnection(\n    url=\"http://server:8000/sse\",\n    headers={\"Authorization\": \"Bearer token\"},\n    timeout=30,\n    retry_attempts=3\n)\n\n# \u2705 Use direct URL instead\nmcp_url = \"http://server:8000/sse\"\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#single-server-limitation","title":"\ud83d\udea7 Single Server Limitation","text":"<p>Currently supports one server per agent:</p> <pre><code># \u274c Multiple servers not supported\nmcp_servers = [\n    \"http://server1:8000/sse\",\n    \"http://server2:8000/sse\"\n]\n\n# \u2705 Single server only\nmcp_url = \"http://primary-server:8000/sse\"\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#sequential-execution","title":"\ud83d\udea7 Sequential Execution","text":"<p>Tools execute sequentially, not in parallel:</p> <pre><code># Current: tool1() \u2192 tool2() \u2192 tool3()\n# Future: tool1() | tool2() | tool3() (parallel)\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms/structs/agent_mcp/#common-issues-solutions","title":"Common Issues &amp; Solutions","text":"<p>Connection Problems</p> Server UnreachableAuthentication ErrorsSSL/TLS Issues <p>Symptoms: Connection timeout or refused</p> <p>Solutions: <pre><code># Check server status\ncurl -I http://localhost:8000/sse\n\n# Verify port is open\nnetstat -tulpn | grep :8000\n\n# Test network connectivity\nping your-server-host\n</code></pre></p> <p>Symptoms: 401/403 HTTP errors</p> <p>Solutions: <pre><code># Verify API credentials\nheaders = {\"Authorization\": \"Bearer your-token\"}\n\n# Check token expiration\n# Validate permissions\n</code></pre></p> <p>Symptoms: Certificate errors</p> <p>Solutions: <pre><code># For development only\nimport ssl\nssl._create_default_https_context = ssl._create_unverified_context\n</code></pre></p> <p>Tool Discovery Failures</p> Empty Tool ListSchema Validation Errors <p>Symptoms: No tools found from server</p> <p>Debugging: <pre><code># Check server tool registration\n@mcp.tool(name=\"tool_name\", description=\"...\")\ndef your_tool():\n    pass\n\n# Verify server startup logs\n# Check tool endpoint responses\n</code></pre></p> <p>Symptoms: Invalid tool parameters</p> <p>Solutions: <pre><code># Ensure proper type hints\ndef tool(param: str, optional: int = 0) -&gt; dict:\n    return {\"result\": \"success\"}\n\n# Validate parameter types\n# Check required vs optional parameters\n</code></pre></p> <p>Performance Issues</p> Slow Response TimesMemory Usage <p>Symptoms: Long wait times for responses</p> <p>Optimization: <pre><code># Increase timeout\nagent = Agent(\n    mcp_url=\"http://server:8000/sse\",\n    timeout=60,  # seconds\n)\n\n# Optimize server performance\n# Use connection pooling\n# Implement caching\n</code></pre></p> <p>Symptoms: High memory consumption</p> <p>Solutions: <pre><code># Limit max_loops\nagent = Agent(max_loops=2)\n\n# Use streaming for large responses\n# Implement garbage collection\n</code></pre></p>"},{"location":"swarms/structs/agent_mcp/#debugging-tools","title":"Debugging Tools","text":"<p>Debug Configuration</p> <pre><code>import logging\n\n# Enable debug logging\nlogging.basicConfig(level=logging.DEBUG)\n\nagent = Agent(\n    agent_name=\"Debug-Agent\",\n    mcp_url=\"http://localhost:8000/sse\",\n    verbose=True,  # Enable verbose output\n    output_type=\"all\",  # Get full execution trace\n)\n\n# Monitor network traffic\n# Check server logs\n# Use profiling tools\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#security-best-practices","title":"Security Best Practices","text":""},{"location":"swarms/structs/agent_mcp/#authentication-authorization","title":"Authentication &amp; Authorization","text":"<p>Security Checklist</p> \ud83d\udd11 Authentication\ud83d\udee1\ufe0f Authorization\ud83d\udd12 Data Protection <ul> <li>API Keys: Use strong, unique API keys</li> <li>Token Rotation: Implement automatic token refresh</li> <li>Encryption: Use HTTPS for all communications</li> <li>Storage: Secure credential storage (environment variables)</li> </ul> <ul> <li>Role-Based Access: Implement user role restrictions</li> <li>Tool Permissions: Limit tool access per user/agent</li> <li>Rate Limiting: Prevent abuse with request limits</li> <li>Audit Logging: Log all tool executions</li> </ul> <ul> <li>Input Sanitization: Validate all user inputs</li> <li>Output Filtering: Sanitize sensitive data in responses</li> <li>Encryption: Encrypt sensitive data in transit/rest</li> <li>Compliance: Follow industry standards (GDPR, HIPAA)</li> </ul>"},{"location":"swarms/structs/agent_mcp/#secure-configuration","title":"Secure Configuration","text":"<p>Production Security Setup</p> <pre><code>import os\nfrom swarms import Agent\n\n# Secure configuration\nagent = Agent(\n    agent_name=\"Production-Agent\",\n    mcp_url=os.getenv(\"MCP_SERVER_URL\"),  # From environment\n    # Additional security headers would go here when MCPConnection is available\n    verbose=False,  # Disable verbose logging in production\n    output_type=\"json\",  # Structured output only\n)\n\n# Environment variables (.env file)\n\"\"\"\nMCP_SERVER_URL=https://secure-server.company.com/sse\nMCP_API_KEY=your-secure-api-key\nMCP_TIMEOUT=30\n\"\"\"\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#performance-optimization","title":"Performance Optimization","text":""},{"location":"swarms/structs/agent_mcp/#agent-optimization","title":"Agent Optimization","text":"<p>Performance Tips</p> \u26a1 Configuration\ud83d\udd04 Caching\ud83d\udcca Monitoring <pre><code># Optimized agent settings\nagent = Agent(\n    max_loops=2,  # Limit iterations\n    temperature=0.1,  # Reduce randomness\n    output_type=\"json\",  # Structured output\n    # Future: connection_pool_size=10\n)\n</code></pre> <pre><code># Implement response caching\nfrom functools import lru_cache\n\n@lru_cache(maxsize=100)\ndef cached_mcp_call(query):\n    return agent.run(query)\n</code></pre> <pre><code>import time\n\nstart_time = time.time()\nresult = agent.run(\"query\")\nexecution_time = time.time() - start_time\n\nprint(f\"Execution time: {execution_time:.2f}s\")\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#server-optimization","title":"Server Optimization","text":"<p>Server Performance</p> <pre><code>from mcp.server.fastmcp import FastMCP\nimport asyncio\nfrom concurrent.futures import ThreadPoolExecutor\n\nmcp = FastMCP(\"optimized_server\")\n\n# Async tool with thread pool\n@mcp.tool(name=\"async_heavy_task\")\nasync def heavy_computation(data: str) -&gt; dict:\n    loop = asyncio.get_event_loop()\n    with ThreadPoolExecutor() as executor:\n        result = await loop.run_in_executor(\n            executor, process_heavy_task, data\n        )\n    return result\n\ndef process_heavy_task(data):\n    # CPU-intensive processing\n    return {\"processed\": data}\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#future-roadmap","title":"Future Roadmap","text":""},{"location":"swarms/structs/agent_mcp/#upcoming-features","title":"Upcoming Features","text":"<p>Development Timeline</p> 1 Week2 Week3 Week <ul> <li>MCPConnection Model - Enhanced configuration</li> <li>Authentication Support - Built-in auth mechanisms</li> <li>Error Recovery - Automatic retry logic</li> <li>Connection Pooling - Improved performance</li> </ul> <ul> <li>Multiple Server Support - Connect to multiple MCPs</li> <li>Parallel Execution - Concurrent tool calling</li> <li>Load Balancing - Distribute requests across servers</li> <li>Advanced Monitoring - Real-time metrics</li> </ul> <ul> <li>Auto-discovery - Automatic server detection</li> <li>Workflow Engine - Complex task orchestration</li> <li>Plugin System - Custom MCP extensions</li> <li>Cloud Integration - Native cloud provider support</li> </ul>"},{"location":"swarms/structs/agent_mcp/#contributing","title":"Contributing","text":"<p>Get Involved</p> <p>We welcome contributions to improve MCP integration:</p> <ul> <li>Bug Reports: GitHub Issues</li> <li>Feature Requests: Discussions</li> <li>Code Contributions: Pull Requests</li> <li>Documentation: Help improve these docs</li> </ul>"},{"location":"swarms/structs/agent_mcp/#support-resources","title":"Support &amp; Resources","text":""},{"location":"swarms/structs/agent_mcp/#getting-help","title":"Getting Help","text":"<p>Need Assistance?</p> \ud83d\udcda Documentation\ud83d\udcac Community\ud83d\udd27 Development <ul> <li>Official Docs</li> <li>Tutorials</li> </ul> <ul> <li>Discord Server</li> <li>GitHub Discussions</li> </ul> <ul> <li>GitHub Repository</li> <li>Example Projects</li> <li>Contributing Guide</li> </ul>"},{"location":"swarms/structs/agent_mcp/#quick-reference","title":"Quick Reference","text":"<p>Cheat Sheet</p> <pre><code># Basic setup\nfrom swarms import Agent\n\nagent = Agent(\n    agent_name=\"Your-Agent\",\n    mcp_url=\"http://localhost:8000/sse\",\n    output_type=\"json\",\n    max_loops=2\n)\n\n# Execute task\nresult = agent.run(\"Your query here\")\n\n# Common patterns\ncrypto_query = \"Get Bitcoin price\"\nanalysis_query = \"Analyze Tesla stock performance\"\nresearch_query = \"Research recent AI developments\"\n</code></pre>"},{"location":"swarms/structs/agent_mcp/#conclusion","title":"Conclusion","text":"<p>The MCP integration brings powerful external tool connectivity to Swarms agents, enabling them to access real-world data and services through a standardized protocol. While some advanced features are still in development, the current implementation provides robust functionality for most use cases.</p> <p>Ready to Start?</p> <p>Begin with the Quick Start section and explore the examples to see MCP integration in action. As new features become available, this documentation will be updated with the latest capabilities and best practices.</p> <p>Stay Updated</p> <p>Join our Discord community to stay informed about new MCP features and connect with other developers building amazing agent applications.</p> <ul> <li> <p> Quick Start</p> <p>Get up and running with MCP integration in minutes</p> </li> <li> <p> Examples</p> <p>Explore real-world implementations and use cases</p> </li> <li> <p> Configuration</p> <p>Learn about all available configuration options</p> </li> <li> <p> Troubleshooting</p> <p>Solve common issues and optimize performance</p> </li> </ul>"},{"location":"swarms/structs/agent_multi_agent_communication/","title":"Agent Multi-Agent Communication Methods","text":"<p>The Agent class provides powerful built-in methods for facilitating communication and collaboration between multiple agents. These methods enable agents to talk to each other, pass information, and coordinate complex multi-agent workflows seamlessly.</p>"},{"location":"swarms/structs/agent_multi_agent_communication/#overview","title":"Overview","text":"<p>Multi-agent communication is essential for building sophisticated AI systems where different agents need to collaborate, share information, and coordinate their actions. The Agent class provides several methods to facilitate this communication:</p> Method Purpose Use Case <code>talk_to</code> Direct communication between two agents Agent handoffs, expert consultation <code>talk_to_multiple_agents</code> Concurrent communication with multiple agents Broadcasting, consensus building <code>receive_message</code> Process incoming messages from other agents Message handling, task delegation <code>send_agent_message</code> Send formatted messages to other agents Direct messaging, notifications"},{"location":"swarms/structs/agent_multi_agent_communication/#features","title":"Features","text":"Feature Description Direct Agent Communication Enable one-to-one conversations between agents Concurrent Multi-Agent Communication Broadcast messages to multiple agents simultaneously Message Processing Handle incoming messages with contextual formatting Error Handling Robust error handling for failed communications Threading Support Efficient concurrent processing using ThreadPoolExecutor Flexible Parameters Support for images, custom arguments, and kwargs"},{"location":"swarms/structs/agent_multi_agent_communication/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/agent_multi_agent_communication/#talk_toagent-task-imgnone-args-kwargs","title":"<code>talk_to(agent, task, img=None, *args, **kwargs)</code>","text":"<p>Enables direct communication between the current agent and another agent. The method processes the task, generates a response, and then passes that response to the target agent.</p> <p>Parameters:</p> Parameter Type Default Description <code>agent</code> <code>Any</code> Required The target agent instance to communicate with <code>task</code> <code>str</code> Required The task or message to send to the agent <code>img</code> <code>str</code> <code>None</code> Optional image path for multimodal communication <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments <p>Returns: <code>Any</code> - The response from the target agent</p> <p>Usage Example:</p> <pre><code>from swarms import Agent\n\n# Create two specialized agents\nresearcher = Agent(\n    agent_name=\"Research-Agent\",\n    system_prompt=\"You are a research specialist focused on gathering and analyzing information.\",\n    max_loops=1,\n)\n\nanalyst = Agent(\n    agent_name=\"Analysis-Agent\", \n    system_prompt=\"You are an analytical specialist focused on interpreting research data.\",\n    max_loops=1,\n)\n\n# Agent communication\nresearch_result = researcher.talk_to(\n    agent=analyst,\n    task=\"Analyze the market trends for renewable energy stocks\"\n)\n\nprint(research_result)\n</code></pre>"},{"location":"swarms/structs/agent_multi_agent_communication/#talk_to_multiple_agentsagents-task-args-kwargs","title":"<code>talk_to_multiple_agents(agents, task, *args, **kwargs)</code>","text":"<p>Enables concurrent communication with multiple agents using ThreadPoolExecutor for efficient parallel processing.</p> <p>Parameters:</p> Parameter Type Default Description <code>agents</code> <code>List[Union[Any, Callable]]</code> Required List of agent instances to communicate with <code>task</code> <code>str</code> Required The task or message to send to all agents <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments <p>Returns: <code>List[Any]</code> - List of responses from all agents (or None for failed communications)</p> <p>Usage Example:</p> <pre><code>from swarms import Agent\n\n# Create multiple specialized agents\nagents = [\n    Agent(\n        agent_name=\"Financial-Analyst\",\n        system_prompt=\"You are a financial analysis expert.\",\n        max_loops=1,\n    ),\n    Agent(\n        agent_name=\"Risk-Assessor\", \n        system_prompt=\"You are a risk assessment specialist.\",\n        max_loops=1,\n    ),\n    Agent(\n        agent_name=\"Market-Researcher\",\n        system_prompt=\"You are a market research expert.\",\n        max_loops=1,\n    )\n]\n\ncoordinator = Agent(\n    agent_name=\"Coordinator-Agent\",\n    system_prompt=\"You coordinate multi-agent analysis.\",\n    max_loops=1,\n)\n\n# Broadcast to multiple agents\nresponses = coordinator.talk_to_multiple_agents(\n    agents=agents,\n    task=\"Evaluate the investment potential of Tesla stock\"\n)\n\n# Process responses\nfor i, response in enumerate(responses):\n    if response:\n        print(f\"Agent {i+1} Response: {response}\")\n    else:\n        print(f\"Agent {i+1} failed to respond\")\n</code></pre>"},{"location":"swarms/structs/agent_multi_agent_communication/#receive_messageagent_name-task-args-kwargs","title":"<code>receive_message(agent_name, task, *args, **kwargs)</code>","text":"<p>Processes incoming messages from other agents with proper context formatting.</p> <p>Parameters:</p> Parameter Type Default Description <code>agent_name</code> <code>str</code> Required Name of the sending agent <code>task</code> <code>str</code> Required The message content <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments <p>Returns: <code>Any</code> - The agent's response to the received message</p> <p>Usage Example:</p> <pre><code>from swarms import Agent\n\n# Create an agent that can receive messages\nrecipient_agent = Agent(\n    agent_name=\"Support-Agent\",\n    system_prompt=\"You provide helpful support and assistance.\",\n    max_loops=1,\n)\n\n# Simulate receiving a message from another agent\nresponse = recipient_agent.receive_message(\n    agent_name=\"Customer-Service-Agent\",\n    task=\"A customer is asking about refund policies. Can you help?\"\n)\n\nprint(response)\n</code></pre>"},{"location":"swarms/structs/agent_multi_agent_communication/#send_agent_messageagent_name-message-args-kwargs","title":"<code>send_agent_message(agent_name, message, *args, **kwargs)</code>","text":"<p>Sends a formatted message from the current agent to a specified target agent.</p> <p>Parameters:</p> Parameter Type Default Description <code>agent_name</code> <code>str</code> Required Name of the target agent <code>message</code> <code>str</code> Required The message to send <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments <p>Returns: <code>Any</code> - The result of sending the message</p> <p>Usage Example:</p> <pre><code>from swarms import Agent\n\nsender_agent = Agent(\n    agent_name=\"Notification-Agent\",\n    system_prompt=\"You send notifications and updates.\",\n    max_loops=1,\n)\n\n# Send a message to another agent\nresult = sender_agent.send_agent_message(\n    agent_name=\"Task-Manager-Agent\",\n    message=\"Task XYZ has been completed successfully\"\n)\n\nprint(result)\n</code></pre> <p>This comprehensive guide covers all aspects of multi-agent communication using the Agent class methods. These methods provide the foundation for building sophisticated multi-agent systems with robust communication capabilities. </p>"},{"location":"swarms/structs/agent_rearrange/","title":"<code>AgentRearrange</code> Class","text":"<p>The <code>AgentRearrange</code> class represents a swarm of agents for rearranging tasks. It allows you to create a swarm of agents, add or remove agents from the swarm, and run the swarm to process tasks based on a specified flow pattern.</p>"},{"location":"swarms/structs/agent_rearrange/#attributes","title":"Attributes","text":"Attribute Type Description <code>id</code> <code>str</code> Unique identifier for the swarm <code>name</code> <code>str</code> Name of the swarm <code>description</code> <code>str</code> Description of the swarm's purpose <code>agents</code> <code>dict</code> Dictionary mapping agent names to Agent objects <code>flow</code> <code>str</code> Flow pattern defining task execution order <code>max_loops</code> <code>int</code> Maximum number of execution loops <code>verbose</code> <code>bool</code> Whether to enable verbose logging <code>memory_system</code> <code>BaseVectorDatabase</code> Memory system for storing agent interactions <code>human_in_the_loop</code> <code>bool</code> Whether human intervention is enabled <code>custom_human_in_the_loop</code> <code>Callable</code> Custom function for human intervention <code>return_json</code> <code>bool</code> Whether to return output in JSON format <code>output_type</code> <code>OutputType</code> Format of output (\"all\", \"final\", \"list\", or \"dict\") <code>docs</code> <code>List[str]</code> List of document paths to add to agent prompts <code>doc_folder</code> <code>str</code> Folder path containing documents to add to agent prompts <code>swarm_history</code> <code>dict</code> History of agent interactions"},{"location":"swarms/structs/agent_rearrange/#methods","title":"Methods","text":""},{"location":"swarms/structs/agent_rearrange/#__init__self-agents-listagent-none-flow-str-none-max_loops-int-1-verbose-bool-true","title":"<code>__init__(self, agents: List[Agent] = None, flow: str = None, max_loops: int = 1, verbose: bool = True)</code>","text":"<p>Initializes the <code>AgentRearrange</code> object.</p> Parameter Type Description <code>agents</code> <code>List[Agent]</code> (optional) A list of <code>Agent</code> objects. Defaults to <code>None</code>. <code>flow</code> <code>str</code> (optional) The flow pattern of the tasks. Defaults to <code>None</code>. <code>max_loops</code> <code>int</code> (optional) The maximum number of loops for the agents to run. Defaults to <code>1</code>. <code>verbose</code> <code>bool</code> (optional) Whether to enable verbose logging or not. Defaults to <code>True</code>."},{"location":"swarms/structs/agent_rearrange/#add_agentself-agent-agent","title":"<code>add_agent(self, agent: Agent)</code>","text":"<p>Adds an agent to the swarm.</p> Parameter Type Description <code>agent</code> <code>Agent</code> The agent to be added."},{"location":"swarms/structs/agent_rearrange/#remove_agentself-agent_name-str","title":"<code>remove_agent(self, agent_name: str)</code>","text":"<p>Removes an agent from the swarm.</p> Parameter Type Description <code>agent_name</code> <code>str</code> The name of the agent to be removed."},{"location":"swarms/structs/agent_rearrange/#add_agentsself-agents-listagent","title":"<code>add_agents(self, agents: List[Agent])</code>","text":"<p>Adds multiple agents to the swarm.</p> Parameter Type Description <code>agents</code> <code>List[Agent]</code> A list of <code>Agent</code> objects."},{"location":"swarms/structs/agent_rearrange/#validate_flowself","title":"<code>validate_flow(self)</code>","text":"<p>Validates the flow pattern.</p> <p>Raises:</p> <ul> <li><code>ValueError</code>: If the flow pattern is incorrectly formatted or contains duplicate agent names.</li> </ul> <p>Returns:</p> <ul> <li><code>bool</code>: <code>True</code> if the flow pattern is valid.</li> </ul>"},{"location":"swarms/structs/agent_rearrange/#runself-task-str-none-img-str-none-device-str-cpu-device_id-int-1-all_cores-bool-true-all_gpus-bool-false-args-kwargs","title":"<code>run(self, task: str = None, img: str = None, device: str = \"cpu\", device_id: int = 1, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)</code>","text":"<p>Executes the agent rearrangement task with specified compute resources.</p> Parameter Type Description <code>task</code> <code>str</code> The task to execute <code>img</code> <code>str</code> Path to input image if required <code>device</code> <code>str</code> Computing device to use ('cpu' or 'gpu') <code>device_id</code> <code>int</code> ID of specific device to use <code>all_cores</code> <code>bool</code> Whether to use all CPU cores <code>all_gpus</code> <code>bool</code> Whether to use all available GPUs <p>Returns:</p> <ul> <li><code>str</code>: The final processed task.</li> </ul>"},{"location":"swarms/structs/agent_rearrange/#batch_runself-tasks-liststr-img-optionalliststr-none-batch_size-int-10-device-str-cpu-device_id-int-none-all_cores-bool-true-all_gpus-bool-false-args-kwargs","title":"<code>batch_run(self, tasks: List[str], img: Optional[List[str]] = None, batch_size: int = 10, device: str = \"cpu\", device_id: int = None, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)</code>","text":"<p>Process multiple tasks in batches.</p> Parameter Type Description <code>tasks</code> <code>List[str]</code> List of tasks to process <code>img</code> <code>List[str]</code> Optional list of images corresponding to tasks <code>batch_size</code> <code>int</code> Number of tasks to process simultaneously <code>device</code> <code>str</code> Computing device to use <code>device_id</code> <code>int</code> Specific device ID if applicable <code>all_cores</code> <code>bool</code> Whether to use all CPU cores <code>all_gpus</code> <code>bool</code> Whether to use all available GPUs"},{"location":"swarms/structs/agent_rearrange/#concurrent_runself-tasks-liststr-img-optionalliststr-none-max_workers-optionalint-none-device-str-cpu-device_id-int-none-all_cores-bool-true-all_gpus-bool-false-args-kwargs","title":"<code>concurrent_run(self, tasks: List[str], img: Optional[List[str]] = None, max_workers: Optional[int] = None, device: str = \"cpu\", device_id: int = None, all_cores: bool = True, all_gpus: bool = False, *args, **kwargs)</code>","text":"<p>Process multiple tasks concurrently using ThreadPoolExecutor.</p> Parameter Type Description <code>tasks</code> <code>List[str]</code> List of tasks to process <code>img</code> <code>List[str]</code> Optional list of images corresponding to tasks <code>max_workers</code> <code>int</code> Maximum number of worker threads <code>device</code> <code>str</code> Computing device to use <code>device_id</code> <code>int</code> Specific device ID if applicable <code>all_cores</code> <code>bool</code> Whether to use all CPU cores <code>all_gpus</code> <code>bool</code> Whether to use all available GPUs"},{"location":"swarms/structs/agent_rearrange/#documentation-for-rearrange-function","title":"Documentation for <code>rearrange</code> Function","text":"<p>======================================</p> <p>The <code>rearrange</code> function is a helper function that rearranges the given list of agents based on the specified flow.</p>"},{"location":"swarms/structs/agent_rearrange/#parameters","title":"Parameters","text":"Parameter Type Description <code>agents</code> <code>List[Agent]</code> The list of agents to be rearranged. <code>flow</code> <code>str</code> The flow used for rearranging the agents. <code>task</code> <code>str</code> (optional) The task to be performed during rearrangement. Defaults to <code>None</code>. <code>*args</code> - Additional positional arguments. <code>**kwargs</code> - Additional keyword arguments."},{"location":"swarms/structs/agent_rearrange/#returns","title":"Returns","text":"<p>The result of running the agent system with the specified task.</p>"},{"location":"swarms/structs/agent_rearrange/#example","title":"Example","text":"<pre><code>agents = [agent1, agent2, agent3]\nflow = \"agent1 -&gt; agent2, agent3\"\ntask = \"Perform a task\"\nrearrange(agents, flow, task)\n</code></pre>"},{"location":"swarms/structs/agent_rearrange/#example-usage","title":"Example Usage","text":"<p>Here's an example of how to use the <code>AgentRearrange</code> class and the <code>rearrange</code> function:</p> <pre><code>from swarms import Agent, AgentRearrange\nfrom typing import List\n\n# Initialize the director agent\ndirector = Agent(\n    agent_name=\"Accounting Director\",\n    system_prompt=\"Directs the accounting tasks for the workers\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accounting_director.json\",\n)\n\n# Initialize worker 1\nworker1 = Agent(\n    agent_name=\"Accountant 1\",\n    system_prompt=\"Processes financial transactions and prepares financial statements\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\n# Initialize worker 2\nworker2 = Agent(\n    agent_name=\"Accountant 2\",\n    system_prompt=\"Performs audits and ensures compliance with financial regulations\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n# Create a list of agents\nagents = [director, worker1, worker2]\n\n# Define the flow pattern\nflow = \"Accounting Director -&gt; Accountant 1 -&gt; Accountant 2\"\n\n# Using AgentRearrange class\nagent_system = AgentRearrange(agents=agents, flow=flow)\noutput = agent_system.run(\"Process monthly financial statements\")\nprint(output)\n</code></pre> <p>In this example, we first initialize three agents: <code>director</code>, <code>worker1</code>, and <code>worker2</code>. Then, we create a list of these agents and define the flow pattern <code>\"Director -&gt; Worker1 -&gt; Worker2\"</code>.</p> <p>We can use the <code>AgentRearrange</code> class by creating an instance of it with the list of agents and the flow pattern. We then call the <code>run</code> method with the initial task, and it will execute the agents in the specified order, passing the output of one agent as the input to the next agent.</p> <p>Alternatively, we can use the <code>rearrange</code> function by passing the list of agents, the flow pattern, and the initial task as arguments.</p> <p>Both the <code>AgentRearrange</code> class and the <code>rearrange</code> function will return the final output after processing the task through the agents according to the specified flow pattern.</p>"},{"location":"swarms/structs/agent_rearrange/#error-handling","title":"Error Handling","text":"<p>The <code>AgentRearrange</code> class includes error handling mechanisms to validate the flow pattern. If the flow pattern is incorrectly formatted or contains duplicate agent names, a <code>ValueError</code> will be raised with an appropriate error message.</p>"},{"location":"swarms/structs/agent_rearrange/#example_1","title":"Example:","text":"<pre><code># Invalid flow pattern\ninvalid_flow = \"Director-&gt;Worker1,Worker2-&gt;Worker3\"\nagent_system = AgentRearrange(agents=agents, flow=invalid_flow)\noutput = agent_system.run(\"Some task\")`\n</code></pre> <p>This will raise a <code>ValueError</code> with the message <code>\"Agent 'Worker3' is not registered.\"</code>.</p>"},{"location":"swarms/structs/agent_rearrange/#parallel-and-sequential-processing","title":"Parallel and Sequential Processing","text":"<p>The <code>AgentRearrange</code> class supports both parallel and sequential processing of tasks based on the specified flow pattern. If the flow pattern includes multiple agents separated by commas (e.g., <code>\"agent1, agent2\"</code>), the agents will be executed in parallel, and their outputs will be concatenated with a semicolon (<code>;</code>). If the flow pattern includes a single agent, it will be executed sequentially.</p>"},{"location":"swarms/structs/agent_rearrange/#parallel-processing","title":"Parallel processing","text":"<p><code>parallel_flow = \"Worker1, Worker2 -&gt; Director\"</code></p>"},{"location":"swarms/structs/agent_rearrange/#sequential-processing","title":"Sequential processing","text":"<p><code>sequential_flow = \"Worker1 -&gt; Worker2 -&gt; Director\"</code></p> <p>In the <code>parallel_flow</code> example, <code>Worker1</code> and <code>Worker2</code> will be executed in parallel, and their outputs will be concatenated and passed to <code>Director</code>. In the <code>sequential_flow</code> example, <code>Worker1</code> will be executed first, and its output will be passed to <code>Worker2</code>, and then the output of <code>Worker2</code> will be passed to <code>Director</code>.</p>"},{"location":"swarms/structs/agent_rearrange/#logging","title":"Logging","text":"<p>The <code>AgentRearrange</code> class includes logging capabilities using the <code>loguru</code> library. If <code>verbose</code> is set to <code>True</code> during initialization, a log file named <code>agent_rearrange.log</code> will be created, and log messages will be written to it. You can use this log file to track the execution of the agents and any potential issues or errors that may occur.</p> <pre><code>2023-05-08 10:30:15.456 | INFO     | agent_rearrange:__init__:34 - Adding agent Director to the swarm.\n2023-05-08 10:30:15.457 | INFO     | agent_rearrange:__init__:34 - Adding agent Worker1 to the swarm.\n2023-05-08 10:30:15.457 | INFO     | agent_rearrange:__init__:34 - Adding agent Worker2 to the swarm.\n2023-05-08 10:30:15.458 | INFO     | agent_rearrange:run:118 - Running agents in parallel: ['Worker1', 'Worker2']\n2023-05-08 10:30:15.459 | INFO     | agent_rearrange:run:121 - Running agents sequentially: ['Director']`\n</code></pre>"},{"location":"swarms/structs/agent_rearrange/#additional-parameters","title":"Additional Parameters","text":"<p>The <code>AgentRearrange</code> class also accepts additional parameters that can be passed to the <code>run</code> method using <code>*args</code> and <code>**kwargs</code>. These parameters will be forwarded to the individual agents during execution.</p> <p><code>agent_system = AgentRearrange(agents=agents, flow=flow)</code> <code>output = agent_system.run(\"Some task\", max_tokens=200, temperature=0.7)</code></p> <p>In this example, the <code>max_tokens</code> and <code>temperature</code> parameters will be passed to each agent during execution.</p>"},{"location":"swarms/structs/agent_rearrange/#customization","title":"Customization","text":"<p>The <code>AgentRearrange</code> class and the <code>rearrange</code> function can be customized and extended to suit specific use cases. For example, you can create custom agents by inheriting from the <code>Agent</code> class and implementing custom logic for task processing. You can then add these custom agents to the swarm and define the flow pattern accordingly.</p> <p>Additionally, you can modify the <code>run</code> method of the <code>AgentRearrange</code> class to implement custom logic for task processing and agent interaction.</p>"},{"location":"swarms/structs/agent_rearrange/#limitations","title":"Limitations","text":"<p>It's important to note that the <code>AgentRearrange</code> class and the <code>rearrange</code> function rely on the individual agents to process tasks correctly. The quality of the output will depend on the capabilities and configurations of the agents used in the swarm. Additionally, the <code>AgentRearrange</code> class does not provide any mechanisms for task prioritization or load balancing among the agents.</p>"},{"location":"swarms/structs/agent_rearrange/#conclusion","title":"Conclusion","text":"<p>The <code>AgentRearrange</code> class and the <code>rearrange</code> function provide a flexible and extensible framework for orchestrating swarms of agents to process tasks based on a specified flow pattern. By combining the capabilities of individual agents, you can create complex workflows and leverage the strengths of different agents to tackle various tasks efficiently.</p> <p>While the current implementation offers basic functionality for agent rearrangement, there is room for future improvements and customizations to enhance the system's capabilities and cater to more specific use cases.</p> <p>Whether you're working on natural language processing tasks, data analysis, or any other domain where agent-based systems can be beneficial, the <code>AgentRearrange</code> class and the <code>rearrange</code> function provide a solid foundation for building and experimenting with swarm-based solutions.</p>"},{"location":"swarms/structs/agent_registry/","title":"AgentRegistry Documentation","text":"<p>The <code>AgentRegistry</code> class is designed to manage a collection of agents, providing methods for adding, deleting, updating, and querying agents. This class ensures thread-safe operations on the registry, making it suitable for concurrent environments. Additionally, the <code>AgentModel</code> class is a Pydantic model used for validating and storing agent information.</p>"},{"location":"swarms/structs/agent_registry/#attributes","title":"Attributes","text":""},{"location":"swarms/structs/agent_registry/#agentmodel","title":"AgentModel","text":"Attribute Type Description <code>agent_id</code> <code>str</code> The unique identifier for the agent. <code>agent</code> <code>Agent</code> The agent object."},{"location":"swarms/structs/agent_registry/#agentregistry","title":"AgentRegistry","text":"Attribute Type Description <code>agents</code> <code>Dict[str, AgentModel]</code> A dictionary mapping agent IDs to <code>AgentModel</code> instances. <code>lock</code> <code>Lock</code> A threading lock for thread-safe operations."},{"location":"swarms/structs/agent_registry/#methods","title":"Methods","text":""},{"location":"swarms/structs/agent_registry/#__init__self","title":"<code>__init__(self)</code>","text":"<p>Initializes the <code>AgentRegistry</code> object.</p> <ul> <li>Usage Example: <pre><code>registry = AgentRegistry()\n</code></pre></li> </ul>"},{"location":"swarms/structs/agent_registry/#addself-agent_id-str-agent-agent-none","title":"<code>add(self, agent_id: str, agent: Agent) -&gt; None</code>","text":"<p>Adds a new agent to the registry.</p> <ul> <li>Parameters:</li> <li><code>agent_id</code> (<code>str</code>): The unique identifier for the agent.</li> <li> <p><code>agent</code> (<code>Agent</code>): The agent to add.</p> </li> <li> <p>Raises:</p> </li> <li><code>ValueError</code>: If the agent ID already exists in the registry.</li> <li> <p><code>ValidationError</code>: If the input data is invalid.</p> </li> <li> <p>Usage Example: <pre><code>agent = Agent(agent_name=\"Agent1\")\nregistry.add(\"agent_1\", agent)\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#deleteself-agent_id-str-none","title":"<code>delete(self, agent_id: str) -&gt; None</code>","text":"<p>Deletes an agent from the registry.</p> <ul> <li>Parameters:</li> <li> <p><code>agent_id</code> (<code>str</code>): The unique identifier for the agent to delete.</p> </li> <li> <p>Raises:</p> </li> <li> <p><code>KeyError</code>: If the agent ID does not exist in the registry.</p> </li> <li> <p>Usage Example: <pre><code>registry.delete(\"agent_1\")\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#update_agentself-agent_id-str-new_agent-agent-none","title":"<code>update_agent(self, agent_id: str, new_agent: Agent) -&gt; None</code>","text":"<p>Updates an existing agent in the registry.</p> <ul> <li>Parameters:</li> <li><code>agent_id</code> (<code>str</code>): The unique identifier for the agent to update.</li> <li> <p><code>new_agent</code> (<code>Agent</code>): The new agent to replace the existing one.</p> </li> <li> <p>Raises:</p> </li> <li><code>KeyError</code>: If the agent ID does not exist in the registry.</li> <li> <p><code>ValidationError</code>: If the input data is invalid.</p> </li> <li> <p>Usage Example: <pre><code>new_agent = Agent(agent_name=\"UpdatedAgent\")\nregistry.update_agent(\"agent_1\", new_agent)\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#getself-agent_id-str-agent","title":"<code>get(self, agent_id: str) -&gt; Agent</code>","text":"<p>Retrieves an agent from the registry.</p> <ul> <li>Parameters:</li> <li> <p><code>agent_id</code> (<code>str</code>): The unique identifier for the agent to retrieve.</p> </li> <li> <p>Returns:</p> </li> <li> <p><code>Agent</code>: The agent associated with the given agent ID.</p> </li> <li> <p>Raises:</p> </li> <li> <p><code>KeyError</code>: If the agent ID does not exist in the registry.</p> </li> <li> <p>Usage Example: <pre><code>agent = registry.get(\"agent_1\")\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#list_agentsself-liststr","title":"<code>list_agents(self) -&gt; List[str]</code>","text":"<p>Lists all agent identifiers in the registry.</p> <ul> <li>Returns:</li> <li> <p><code>List[str]</code>: A list of all agent identifiers.</p> </li> <li> <p>Usage Example: <pre><code>agent_ids = registry.list_agents()\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#queryself-condition-optionalcallableagent-bool-none-listagent","title":"<code>query(self, condition: Optional[Callable[[Agent], bool]] = None) -&gt; List[Agent]</code>","text":"<p>Queries agents based on a condition.</p> <ul> <li>Parameters:</li> <li> <p><code>condition</code> (<code>Optional[Callable[[Agent], bool]]</code>): A function that takes an agent and returns a boolean indicating whether the agent meets the condition. Defaults to <code>None</code>.</p> </li> <li> <p>Returns:</p> </li> <li> <p><code>List[Agent]</code>: A list of agents that meet the condition.</p> </li> <li> <p>Usage Example: <pre><code>def is_active(agent):\n    return agent.is_active\n\nactive_agents = registry.query(is_active)\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#find_agent_by_nameself-agent_name-str-agent","title":"<code>find_agent_by_name(self, agent_name: str) -&gt; Agent</code>","text":"<p>Finds an agent by its name.</p> <ul> <li>Parameters:</li> <li> <p><code>agent_name</code> (<code>str</code>): The name of the agent to find.</p> </li> <li> <p>Returns:</p> </li> <li> <p><code>Agent</code>: The agent with the specified name.</p> </li> <li> <p>Usage Example: <pre><code>agent = registry.find_agent_by_name(\"Agent1\")\n</code></pre></p> </li> </ul>"},{"location":"swarms/structs/agent_registry/#full-example","title":"Full Example","text":"<pre><code>from swarms.structs.agent_registry import AgentRegistry\nfrom swarms import Agent, OpenAIChat, Anthropic\n\n# Initialize the agents\ngrowth_agent1 = Agent(\n  agent_name=\"Marketing Specialist\",\n  system_prompt=\"You're the marketing specialist, your purpose is to help companies grow by improving their marketing strategies!\",\n  agent_description=\"Improve a company's marketing strategies!\",\n  llm=OpenAIChat(),\n  max_loops=\"auto\",\n  autosave=True,\n  dashboard=False,\n  verbose=True,\n  streaming_on=True,\n  saved_state_path=\"marketing_specialist.json\",\n  stopping_token=\"Stop!\",\n  interactive=True,\n  context_length=1000,\n)\n\ngrowth_agent2 = Agent(\n  agent_name=\"Sales Specialist\",\n  system_prompt=\"You're the sales specialist, your purpose is to help companies grow by improving their sales strategies!\",\n  agent_description=\"Improve a company's sales strategies!\",\n  llm=Anthropic(),\n  max_loops=\"auto\",\n  autosave=True,\n  dashboard=False,\n  verbose=True,\n  streaming_on=True,\n  saved_state_path=\"sales_specialist.json\",\n  stopping_token=\"Stop!\",\n  interactive=True,\n  context_length=1000,\n)\n\ngrowth_agent3 = Agent(\n  agent_name=\"Product Development Specialist\",\n  system_prompt=\"You're the product development specialist, your purpose is to help companies grow by improving their product development strategies!\",\n  agent_description=\"Improve a company's product development strategies!\",\n  llm=Anthropic(),\n  max_loops=\"auto\",\n  autosave=True,\n  dashboard=False,\n  verbose=True,\n  streaming_on=True,\n  saved_state_path=\"product_development_specialist.json\",\n  stopping_token=\"Stop!\",\n  interactive=True,\n  context_length=1000,\n)\n\ngrowth_agent4 = Agent(\n  agent_name=\"Customer Service Specialist\",\n  system_prompt=\"You're the customer service specialist, your purpose is to help companies grow by improving their customer service strategies!\",\n  agent_description=\"Improve a company's customer service strategies!\",\n  llm=OpenAIChat(),\n  max_loops=\"auto\",\n  autosave=True,\n  dashboard=False,\n  verbose=True,\n  streaming_on=True,\n  saved_state_path=\"customer_service_specialist.json\",\n  stopping_token=\"Stop!\",\n  interactive=True,\n  context_length=1000,\n)\n\n\n# Register the agents\\\nregistry = AgentRegistry()\n\n# Register the agents\nregistry.add(\"Marketing Specialist\", growth_agent1)\nregistry.add(\"Sales Specialist\", growth_agent2)\nregistry.add(\"Product Development Specialist\", growth_agent3)\nregistry.add(\"Customer Service Specialist\", growth_agent4)\n</code></pre>"},{"location":"swarms/structs/agent_registry/#logging-and-error-handling","title":"Logging and Error Handling","text":"<p>Each method in the <code>AgentRegistry</code> class includes logging to track the execution flow and captures errors to provide detailed information in case of failures. This is crucial for debugging and ensuring smooth operation of the registry. The <code>report_error</code> function is used for reporting exceptions that occur during method execution.</p>"},{"location":"swarms/structs/agent_registry/#additional-tips","title":"Additional Tips","text":"<ul> <li>Ensure that agents provided to the <code>AgentRegistry</code> are properly initialized and configured to handle the tasks they will receive.</li> <li>Utilize the logging information to monitor and debug the registry operations.</li> <li>Use the <code>lock</code> attribute to ensure thread-safe operations when accessing or modifying the registry.</li> </ul>"},{"location":"swarms/structs/artifact/","title":"swarms.structs Documentation","text":""},{"location":"swarms/structs/artifact/#introduction","title":"Introduction","text":"<p>The swarms.structs library provides a collection of classes for representing artifacts and their attributes. This documentation will provide an overview of the <code>Artifact</code> class, its attributes, functionality, and usage examples.</p>"},{"location":"swarms/structs/artifact/#artifact-class","title":"Artifact Class","text":"<p>The <code>Artifact</code> class represents an artifact and its attributes. It inherits from the <code>BaseModel</code> class and includes the following attributes:</p>"},{"location":"swarms/structs/artifact/#attributes","title":"Attributes","text":"<ol> <li><code>artifact_id (str)</code>: Id of the artifact.</li> <li><code>file_name (str)</code>: Filename of the artifact.</li> <li><code>relative_path (str, optional)</code>: Relative path of the artifact in the agent's workspace.</li> </ol> <p>These attributes are crucial for identifying and managing different artifacts within a given context.</p>"},{"location":"swarms/structs/artifact/#class-definition","title":"Class Definition","text":"<p>The <code>Artifact</code> class can be defined as follows:</p> <pre><code>class Artifact(BaseModel):\n    \"\"\"\n    Represents an artifact.\n\n    Attributes:\n        artifact_id (str): Id of the artifact.\n        file_name (str): Filename of the artifact.\n        relative_path (str, optional): Relative path of the artifact in the agent's workspace.\n    \"\"\"\n\n    artifact_id: str = Field(\n        ...,\n        description=\"Id of the artifact\",\n        example=\"b225e278-8b4c-4f99-a696-8facf19f0e56\",\n    )\n    file_name: str = Field(\n        ..., description=\"Filename of the artifact\", example=\"main.py\"\n    )\n    relative_path: Optional[str] = Field(\n        None,\n        description=(\"Relative path of the artifact in the agent's workspace\"),\n        example=\"python/code/\",\n    )\n</code></pre> <p>The <code>Artifact</code> class defines the mandatory and optional attributes and provides corresponding descriptions along with example values.</p>"},{"location":"swarms/structs/artifact/#functionality-and-usage","title":"Functionality and Usage","text":"<p>The <code>Artifact</code> class encapsulates the information and attributes representing an artifact. It provides a structured and organized way to manage artifacts within a given context.</p>"},{"location":"swarms/structs/artifact/#example-1-creating-an-artifact-instance","title":"Example 1: Creating an Artifact instance","text":"<p>To create an instance of the <code>Artifact</code> class, you can simply initialize it with the required attributes. Here's an example:</p> <pre><code>from swarms.structs import Artifact\n\nartifact_instance = Artifact(\n    artifact_id=\"b225e278-8b4c-4f99-a696-8facf19f0e56\",\n    file_name=\"main.py\",\n    relative_path=\"python/code/\",\n)\n</code></pre> <p>In this example, we create an instance of the <code>Artifact</code> class with the specified artifact details.</p>"},{"location":"swarms/structs/artifact/#example-2-accessing-artifact-attributes","title":"Example 2: Accessing Artifact attributes","text":"<p>You can access the attributes of the <code>Artifact</code> instance using dot notation. Here's how you can access the file name of the artifact:</p> <pre><code>print(artifact_instance.file_name)\n# Output: \"main.py\"\n</code></pre>"},{"location":"swarms/structs/artifact/#example-3-handling-optional-attributes","title":"Example 3: Handling optional attributes","text":"<p>If the <code>relative_path</code> attribute is not provided during artifact creation, it will default to <code>None</code>. Here's an example:</p> <pre><code>artifact_instance_no_path = Artifact(\n    artifact_id=\"c280s347-9b7d-3c68-m337-7abvf50j23k\", file_name=\"script.js\"\n)\n\nprint(artifact_instance_no_path.relative_path)\n# Output: None\n</code></pre> <p>By providing default values for optional attributes, the <code>Artifact</code> class allows flexibility in defining artifact instances.</p>"},{"location":"swarms/structs/artifact/#additional-information-and-tips","title":"Additional Information and Tips","text":"<p>The <code>Artifact</code> class represents a powerful and flexible means of handling various artifacts with different attributes. By utilizing this class, users can organize, manage, and streamline their artifacts with ease.</p>"},{"location":"swarms/structs/artifact/#references-and-resources","title":"References and Resources","text":"<p>For further details and references related to the swarms.structs library and the <code>Artifact</code> class, refer to the official documentation.</p> <p>This comprehensive documentation provides an in-depth understanding of the <code>Artifact</code> class, its attributes, functionality, and usage examples. By following the detailed examples and explanations, developers can effectively leverage the capabilities of the <code>Artifact</code> class within their projects.</p>"},{"location":"swarms/structs/auto_agent_builder/","title":"Agent Builder","text":"<p>The Agent Builder is a powerful class that automatically builds and manages swarms of AI agents. It provides a flexible and extensible framework for creating, coordinating, and executing multiple AI agents working together to accomplish complex tasks.</p>"},{"location":"swarms/structs/auto_agent_builder/#overview","title":"Overview","text":"<p>The Agent Builder uses a boss agent to delegate work and create new specialized agents as needed. It's designed to be production-ready with robust error handling, logging, and configuration options.</p>"},{"location":"swarms/structs/auto_agent_builder/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[Agent Builder] --&gt; B[Configuration]\n    A --&gt; C[Agent Creation]\n    A --&gt; D[Task Execution]\n\n    B --&gt; B1[Name]\n    B --&gt; B2[Description]\n    B --&gt; B3[Model Settings]\n\n    C --&gt; C1[Agent Pool]\n    C --&gt; C2[Agent Registry]\n    C --&gt; C3[Agent Configuration]\n\n    D --&gt; D1[Task Distribution]\n    D --&gt; D2[Result Collection]\n    D --&gt; D3[Error Handling]\n\n    C1 --&gt; E[Specialized Agents]\n    C2 --&gt; E\n    C3 --&gt; E\n\n    E --&gt; F[Task Execution]\n    F --&gt; G[Results]</code></pre>"},{"location":"swarms/structs/auto_agent_builder/#class-structure","title":"Class Structure","text":""},{"location":"swarms/structs/auto_agent_builder/#agentsbuilder-class","title":"AgentsBuilder Class","text":"Parameter Type Default Description name str \"swarm-creator-01\" The name of the swarm description str \"This is a swarm that creates swarms\" A description of the swarm's purpose verbose bool True Whether to output detailed logs max_loops int 1 Maximum number of execution loops model_name str \"gpt-4o\" The model to use for agent creation return_dictionary bool True Whether to return results as a dictionary system_prompt str BOSS_SYSTEM_PROMPT The system prompt for the boss agent"},{"location":"swarms/structs/auto_agent_builder/#methods","title":"Methods","text":"Method Description Parameters Returns run Run the swarm on a given task task: str, image_url: str = None, *args, **kwargs Tuple[List[Agent], int] _create_agents Create necessary agents for a task task: str, *args, **kwargs List[Agent] build_agent Build a single agent with specifications agent_name: str, agent_description: str, agent_system_prompt: str, max_loops: int = 1, model_name: str = \"gpt-4o\", dynamic_temperature_enabled: bool = True, auto_generate_prompt: bool = False, role: str = \"worker\", max_tokens: int = 8192, temperature: float = 0.5 Agent"},{"location":"swarms/structs/auto_agent_builder/#enterprise-use-cases","title":"Enterprise Use Cases","text":""},{"location":"swarms/structs/auto_agent_builder/#1-customer-service-automation","title":"1. Customer Service Automation","text":"<ul> <li> <p>Create specialized agents for different aspects of customer service</p> </li> <li> <p>Handle ticket routing, response generation, and escalation</p> </li> <li> <p>Maintain consistent service quality across channels</p> </li> </ul>"},{"location":"swarms/structs/auto_agent_builder/#2-data-analysis-pipeline","title":"2. Data Analysis Pipeline","text":"<ul> <li> <p>Build agents for data collection, cleaning, analysis, and visualization</p> </li> <li> <p>Automate complex data processing workflows</p> </li> <li> <p>Generate insights and reports automatically</p> </li> </ul>"},{"location":"swarms/structs/auto_agent_builder/#3-content-creation-and-management","title":"3. Content Creation and Management","text":"<ul> <li> <p>Deploy agents for content research, writing, editing, and publishing</p> </li> <li> <p>Maintain brand consistency across content</p> </li> <li> <p>Automate content scheduling and distribution</p> </li> </ul>"},{"location":"swarms/structs/auto_agent_builder/#4-process-automation","title":"4. Process Automation","text":"<ul> <li> <p>Create agents for workflow automation</p> </li> <li> <p>Handle document processing and routing</p> </li> <li> <p>Manage approval chains and notifications</p> </li> </ul>"},{"location":"swarms/structs/auto_agent_builder/#5-research-and-development","title":"5. Research and Development","text":"<ul> <li> <p>Build agents for literature review, experiment design, and data collection</p> </li> <li> <p>Automate research documentation and reporting</p> </li> <li> <p>Facilitate collaboration between research teams</p> </li> </ul>"},{"location":"swarms/structs/auto_agent_builder/#example-usage","title":"Example Usage","text":"<pre><code>from swarms import AgentsBuilder\n\n# Initialize the agent builder\nagents_builder = AgentsBuilder(\n    name=\"enterprise-automation\",\n    description=\"Enterprise workflow automation swarm\",\n    verbose=True\n)\n\n# Define a use-case for building agents\ntask = \"Develop a swarm of agents to automate the generation of personalized marketing strategies based on customer data and market trends\"\n\n# Run the swarm\nagents = agents_builder.run(task)\n\n# Access results\nprint(agents)\n</code></pre>"},{"location":"swarms/structs/auto_agent_builder/#best-practices","title":"Best Practices","text":"<ol> <li>Error Handling</li> <li>Always implement proper error handling for agent failures</li> <li>Use retry mechanisms for transient failures</li> <li> <p>Log all errors for debugging and monitoring</p> </li> <li> <p>Resource Management</p> </li> <li>Monitor agent resource usage</li> <li>Implement rate limiting for API calls</li> <li> <p>Use connection pooling for database operations</p> </li> <li> <p>Security</p> </li> <li>Implement proper authentication and authorization</li> <li>Secure sensitive data and API keys</li> <li> <p>Follow least privilege principle for agent permissions</p> </li> <li> <p>Monitoring and Logging</p> </li> <li>Implement comprehensive logging</li> <li>Monitor agent performance metrics</li> <li> <p>Set up alerts for critical failures</p> </li> <li> <p>Scalability</p> </li> <li>Design for horizontal scaling</li> <li>Implement load balancing</li> <li>Use distributed systems when needed</li> </ol>"},{"location":"swarms/structs/auto_agent_builder/#integration-patterns","title":"Integration Patterns","text":"<pre><code>graph LR\n    A[External System] --&gt; B[API Gateway]\n    B --&gt; C[Agent Builder]\n    C --&gt; D[Agent Pool]\n    D --&gt; E[Specialized Agents]\n    E --&gt; F[External Services]\n\n    subgraph \"Monitoring\"\n        G[Logs]\n        H[Metrics]\n        I[Alerts]\n    end\n\n    C --&gt; G\n    C --&gt; H\n    C --&gt; I</code></pre>"},{"location":"swarms/structs/auto_agent_builder/#performance-considerations","title":"Performance Considerations","text":"<ol> <li>Agent Pool Management</li> <li>Implement connection pooling</li> <li>Use caching for frequently accessed data</li> <li> <p>Optimize agent creation and destruction</p> </li> <li> <p>Task Distribution</p> </li> <li>Implement load balancing</li> <li>Use priority queues for task scheduling</li> <li> <p>Handle task timeouts and retries</p> </li> <li> <p>Resource Optimization</p> </li> <li>Monitor memory usage</li> <li>Implement garbage collection</li> <li>Use efficient data structures</li> </ol>"},{"location":"swarms/structs/auto_agent_builder/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>Agent Creation Failures</li> <li>Check API credentials</li> <li>Verify model availability</li> <li> <p>Review system prompts</p> </li> <li> <p>Performance Issues</p> </li> <li>Monitor resource usage</li> <li>Check network latency</li> <li> <p>Review agent configurations</p> </li> <li> <p>Integration Problems</p> </li> <li>Verify API endpoints</li> <li>Check authentication</li> <li>Review data formats</li> </ol>"},{"location":"swarms/structs/auto_swarm/","title":"AutoSwarm","text":"<p>The <code>AutoSwarm</code> class represents a swarm of agents that can be created and managed automatically. This class leverages the <code>AutoSwarmRouter</code> to route tasks to appropriate swarms and supports custom preprocessing, routing, and postprocessing of tasks. It is designed to handle complex workflows efficiently.</p>"},{"location":"swarms/structs/auto_swarm/#key-concepts","title":"Key Concepts","text":"<ul> <li>Swarm: A group of agents working together to complete tasks.</li> <li>Routing: Directing tasks to the appropriate swarm based on specific criteria.</li> <li>Preprocessing and Postprocessing: Customizable functions to handle tasks before and after routing.</li> <li>Event Loop: Managing the execution of tasks in a loop.</li> </ul>"},{"location":"swarms/structs/auto_swarm/#attributes","title":"Attributes","text":""},{"location":"swarms/structs/auto_swarm/#arguments","title":"Arguments","text":"Argument Type Default Description <code>name</code> <code>Optional[str]</code> <code>None</code> The name of the swarm. <code>description</code> <code>Optional[str]</code> <code>None</code> The description of the swarm. <code>verbose</code> <code>bool</code> <code>False</code> Whether to enable verbose mode. <code>custom_params</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Custom parameters for the swarm. <code>custom_preprocess</code> <code>Optional[Callable]</code> <code>None</code> Custom preprocessing function for tasks. <code>custom_postprocess</code> <code>Optional[Callable]</code> <code>None</code> Custom postprocessing function for task results. <code>custom_router</code> <code>Optional[Callable]</code> <code>None</code> Custom routing function for tasks. <code>max_loops</code> <code>int</code> <code>1</code> The maximum number of loops to run the workflow."},{"location":"swarms/structs/auto_swarm/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>Optional[str]</code> The name of the swarm. <code>description</code> <code>Optional[str]</code> The description of the swarm. <code>verbose</code> <code>bool</code> Whether to enable verbose mode. <code>custom_params</code> <code>Optional[Dict[str, Any]]</code> Custom parameters for the swarm. <code>custom_preprocess</code> <code>Optional[Callable]</code> Custom preprocessing function for tasks. <code>custom_postprocess</code> <code>Optional[Callable]</code> Custom postprocessing function for task results. <code>custom_router</code> <code>Optional[Callable]</code> Custom routing function for tasks. <code>max_loops</code> <code>int</code> The maximum number of loops to run the workflow. <code>router</code> <code>AutoSwarmRouter</code> The router for managing task routing."},{"location":"swarms/structs/auto_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/auto_swarm/#init_logging","title":"init_logging","text":"<p>Initializes logging for the <code>AutoSwarm</code>.</p> <p>Examples:</p> <pre><code>swarm = AutoSwarm(name=\"example_swarm\", verbose=True)\nswarm.init_logging()\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#run","title":"run","text":"<p>Runs the swarm simulation.</p> <p>Arguments:</p> Parameter Type Default Description <code>task</code> <code>str</code> <code>None</code> The task to be executed. <code>*args</code> Additional arguments. <code>**kwargs</code> Additional keyword arguments. <p>Returns:</p> Return Type Description <code>Any</code> The result of the executed task. <p>Raises:</p> <ul> <li><code>Exception</code>: If any error occurs during task execution.</li> </ul> <p>Examples:</p> <pre><code>swarm = AutoSwarm(name=\"example_swarm\", max_loops=3)\nresult = swarm.run(task=\"example_task\")\nprint(result)\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#list_all_swarms","title":"list_all_swarms","text":"<p>Lists all available swarms and their descriptions.</p> <p>Examples:</p> <pre><code>swarm = AutoSwarm(name=\"example_swarm\", max_loops=3)\nswarm.list_all_swarms()\n# Output:\n# INFO: Swarm Name: swarm1 || Swarm Description: Description of swarm1\n# INFO: Swarm Name: swarm2 || Swarm Description: Description of swarm2\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#additional-examples","title":"Additional Examples","text":""},{"location":"swarms/structs/auto_swarm/#example-1-custom-preprocessing-and-postprocessing","title":"Example 1: Custom Preprocessing and Postprocessing","text":"<pre><code>def custom_preprocess(task, *args, **kwargs):\n    # Custom preprocessing logic\n    task = task.upper()\n    return task, args, kwargs\n\ndef custom_postprocess(result):\n    # Custom postprocessing logic\n    return result.lower()\n\nswarm = AutoSwarm(\n    name=\"example_swarm\",\n    custom_preprocess=custom_preprocess,\n    custom_postprocess=custom_postprocess,\n    max_loops=3\n)\n\n# Running a task with custom preprocessing and postprocessing\nresult = swarm.run(task=\"example_task\")\nprint(result)  # Output will be the processed result\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#example-2-custom-router-function","title":"Example 2: Custom Router Function","text":"<pre><code>def custom_router(swarm, task, *args, **kwargs):\n    # Custom routing logic\n    if \"specific\" in task:\n        return swarm.router.swarm_dict[\"specific_swarm\"].run(task, *args, **kwargs)\n    return swarm.router.swarm_dict[\"default_swarm\"].run(task, *args, **kwargs)\n\nswarm = AutoSwarm(\n    name=\"example_swarm\",\n    custom_router=custom_router,\n    max_loops=3\n)\n\n# Running a task with custom routing\nresult = swarm.run(task=\"specific_task\")\nprint(result)  # Output will be the result of the routed task\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#example-3-verbose-mode","title":"Example 3: Verbose Mode","text":"<pre><code>swarm = AutoSwarm(\n    name=\"example_swarm\",\n    verbose=True,\n    max_loops=3\n)\n\n# Running a task with verbose mode enabled\nresult = swarm.run(task=\"example_task\")\n# Output will include detailed logs of the task execution process\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#full-example-4","title":"Full Example 4:","text":"<p>First create a class with BaseSwarm -&gt; Then wrap it in the router -&gt; then pass that to the <code>AutoSwarm</code></p> <pre><code>from swarms import BaseSwarm, AutoSwarmRouter, AutoSwarm\n\n\nclass FinancialReportSummarization(BaseSwarm):\n    def __init__(self, name: str = None, *args, **kwargs):\n        super().__init__()\n\n    def run(self, task, *args, **kwargs):\n        return task\n\n\n# Add swarm to router\nrouter = AutoSwarmRouter(swarms=[FinancialReportSummarization])\n\n# Create AutoSwarm Instance\nautoswarm = AutoSwarm(\n    name=\"kyegomez/FinancialReportSummarization\",\n    description=\"A swarm for financial document summarizing and generation\",\n    verbose=True,\n    router=router,\n)\n\n# Run the AutoSwarm\nautoswarm.run(\"Analyze these documents and give me a summary:\")\n</code></pre>"},{"location":"swarms/structs/auto_swarm/#summary","title":"Summary","text":"<p>The <code>AutoSwarm</code> class provides a robust framework for managing and executing tasks using a swarm of agents. With customizable preprocessing, routing, and postprocessing functions, it is highly adaptable to various workflows and can handle complex task execution scenarios efficiently. The integration with <code>AutoSwarmRouter</code> enhances its flexibility, making it a powerful tool for dynamic task management.</p>"},{"location":"swarms/structs/auto_swarm_builder/","title":"AutoSwarmBuilder Documentation","text":"<p>The <code>AutoSwarmBuilder</code> is a powerful class that automatically builds and manages swarms of AI agents to accomplish complex tasks. It uses a boss agent to delegate work and create specialized agents as needed.</p>"},{"location":"swarms/structs/auto_swarm_builder/#overview","title":"Overview","text":"<p>The AutoSwarmBuilder is designed to:</p> <ul> <li> <p>Automatically create and coordinate multiple AI agents</p> </li> <li> <p>Delegate tasks to specialized agents</p> </li> <li> <p>Manage communication between agents</p> </li> <li> <p>Handle complex workflows through a swarm router</p> </li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#parameters","title":"Parameters","text":"Parameter Type Default Description name str None The name of the swarm description str None A description of the swarm's purpose verbose bool True Whether to output detailed logs max_loops int 1 Maximum number of execution loops random_models bool True Whether to use random models for agents"},{"location":"swarms/structs/auto_swarm_builder/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/auto_swarm_builder/#runtask-str-args-kwargs","title":"run(task: str, *args, **kwargs)","text":"<p>Executes the swarm on a given task.</p> <p>Parameters:</p> <ul> <li> <p><code>task</code> (str): The task to execute</p> </li> <li> <p><code>*args</code>: Additional positional arguments</p> </li> <li> <p><code>**kwargs</code>: Additional keyword arguments</p> </li> </ul> <p>Returns:</p> <ul> <li>The result of the swarm execution</li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#create_agentstask-str","title":"create_agents(task: str)","text":"<p>Creates specialized agents for a given task.</p> <p>Parameters:</p> <ul> <li><code>task</code> (str): The task to create agents for</li> </ul> <p>Returns:</p> <ul> <li>List[Agent]: List of created agents</li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#build_agentagent_name-str-agent_description-str-agent_system_prompt-str","title":"build_agent(agent_name: str, agent_description: str, agent_system_prompt: str)","text":"<p>Builds a single agent with specified parameters.</p> <p>Parameters: - <code>agent_name</code> (str): Name of the agent</p> <ul> <li> <p><code>agent_description</code> (str): Description of the agent</p> </li> <li> <p><code>agent_system_prompt</code> (str): System prompt for the agent</p> </li> </ul> <p>Returns:</p> <ul> <li>Agent: The constructed agent</li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#batch_runtasks-liststr","title":"batch_run(tasks: List[str])","text":"<p>Executes the swarm on multiple tasks.</p> <p>Parameters:</p> <ul> <li><code>tasks</code> (List[str]): List of tasks to execute</li> </ul> <p>Returns:</p> <ul> <li>List[Any]: Results from each task execution</li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#examples","title":"Examples","text":""},{"location":"swarms/structs/auto_swarm_builder/#example-1-content-creation-swarm","title":"Example 1: Content Creation Swarm","text":"<pre><code>from swarms.structs.auto_swarm_builder import AutoSwarmBuilder\n\n# Initialize the swarm builder\nswarm = AutoSwarmBuilder(\n    name=\"Content Creation Swarm\",\n    description=\"A swarm specialized in creating high-quality content\"\n)\n\n# Run the swarm on a content creation task\nresult = swarm.run(\n    \"Create a comprehensive blog post about artificial intelligence in healthcare, \"\n    \"including current applications, future trends, and ethical considerations.\"\n)\n</code></pre>"},{"location":"swarms/structs/auto_swarm_builder/#example-2-data-analysis-swarm","title":"Example 2: Data Analysis Swarm","text":"<pre><code>from swarms.structs.auto_swarm_builder import AutoSwarmBuilder\n\n# Initialize the swarm builder\nswarm = AutoSwarmBuilder(\n    name=\"Data Analysis Swarm\",\n    description=\"A swarm specialized in data analysis and visualization\"\n)\n\n# Run the swarm on a data analysis task\nresult = swarm.run(\n    \"Analyze the provided sales data and create a detailed report with visualizations \"\n    \"showing trends, patterns, and recommendations for improvement.\"\n)\n</code></pre>"},{"location":"swarms/structs/auto_swarm_builder/#example-3-batch-processing-multiple-tasks","title":"Example 3: Batch Processing Multiple Tasks","text":"<pre><code>from swarms.structs.auto_swarm_builder import AutoSwarmBuilder\n\n# Initialize the swarm builder\nswarm = AutoSwarmBuilder(\n    name=\"Multi-Task Swarm\",\n    description=\"A swarm capable of handling multiple diverse tasks\"\n)\n\n# Define multiple tasks\ntasks = [\n    \"Create a marketing strategy for a new product launch\",\n    \"Analyze customer feedback and generate improvement suggestions\",\n    \"Develop a project timeline for the next quarter\"\n]\n\n# Run the swarm on all tasks\nresults = swarm.batch_run(tasks)\n</code></pre>"},{"location":"swarms/structs/auto_swarm_builder/#best-practices","title":"Best Practices","text":"<p>Task Definition</p> <ul> <li> <p>Provide clear, specific task descriptions</p> </li> <li> <p>Include any relevant context or constraints</p> </li> <li> <p>Specify expected output format if needed</p> </li> </ul> <p>Configuration</p> <ul> <li> <p>Set appropriate <code>max_loops</code> based on task complexity</p> </li> <li> <p>Use <code>verbose=True</code> during development for debugging</p> </li> <li> <p>Consider using <code>random_models=True</code> for diverse agent capabilities</p> </li> </ul> <p>Error Handling</p> <ul> <li> <p>The class includes comprehensive error handling</p> </li> <li> <p>All methods include try-catch blocks with detailed logging</p> </li> <li> <p>Errors are propagated with full stack traces for debugging</p> </li> </ul>"},{"location":"swarms/structs/auto_swarm_builder/#notes","title":"Notes","text":"<p>Architecture</p> <ul> <li> <p>The AutoSwarmBuilder uses a sophisticated boss agent system to coordinate tasks</p> </li> <li> <p>Agents are created dynamically based on task requirements</p> </li> <li> <p>The system includes built-in logging and error handling</p> </li> <li> <p>Results are returned in a structured format for easy processing</p> </li> </ul>"},{"location":"swarms/structs/auto_swarm_router/","title":"AutoSwarmRouter","text":"<p>The <code>AutoSwarmRouter</code> class is designed to route tasks to the appropriate swarm based on the provided name. This class allows for customization of preprocessing, routing, and postprocessing of tasks, making it highly adaptable to various workflows and requirements.</p>"},{"location":"swarms/structs/auto_swarm_router/#key-concepts","title":"Key Concepts","text":"<ul> <li>Routing: Directing tasks to the appropriate swarm based on specific criteria.</li> <li>Preprocessing and Postprocessing: Customizable functions to handle tasks before and after routing.</li> <li>Swarms: Collections of <code>BaseSwarm</code> objects that perform the tasks.</li> </ul>"},{"location":"swarms/structs/auto_swarm_router/#attributes","title":"Attributes","text":""},{"location":"swarms/structs/auto_swarm_router/#arguments","title":"Arguments","text":"Argument Type Default Description <code>name</code> <code>Optional[str]</code> <code>None</code> The name of the router. <code>description</code> <code>Optional[str]</code> <code>None</code> The description of the router. <code>verbose</code> <code>bool</code> <code>False</code> Whether to enable verbose mode. <code>custom_params</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Custom parameters for the router. <code>swarms</code> <code>Sequence[BaseSwarm]</code> <code>None</code> A list of <code>BaseSwarm</code> objects. <code>custom_preprocess</code> <code>Optional[Callable]</code> <code>None</code> Custom preprocessing function for tasks. <code>custom_postprocess</code> <code>Optional[Callable]</code> <code>None</code> Custom postprocessing function for task results. <code>custom_router</code> <code>Optional[Callable]</code> <code>None</code> Custom routing function for tasks."},{"location":"swarms/structs/auto_swarm_router/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>Optional[str]</code> The name of the router. <code>description</code> <code>Optional[str]</code> The description of the router. <code>verbose</code> <code>bool</code> Whether to enable verbose mode. <code>custom_params</code> <code>Optional[Dict[str, Any]]</code> Custom parameters for the router. <code>swarms</code> <code>Sequence[BaseSwarm]</code> A list of <code>BaseSwarm</code> objects. <code>custom_preprocess</code> <code>Optional[Callable]</code> Custom preprocessing function for tasks. <code>custom_postprocess</code> <code>Optional[Callable]</code> Custom postprocessing function for task results. <code>custom_router</code> <code>Optional[Callable]</code> Custom routing function for tasks. <code>swarm_dict</code> <code>Dict[str, BaseSwarm]</code> A dictionary of swarms keyed by their name."},{"location":"swarms/structs/auto_swarm_router/#methods","title":"Methods","text":""},{"location":"swarms/structs/auto_swarm_router/#run","title":"run","text":"<p>Executes the swarm simulation and routes the task to the appropriate swarm.</p> <p>Arguments:</p> Parameter Type Default Description <code>task</code> <code>str</code> <code>None</code> The task to be executed. <code>*args</code> Additional arguments. <code>**kwargs</code> Additional keyword arguments. <p>Returns:</p> Return Type Description <code>Any</code> The result of the routed task. <p>Raises:</p> <ul> <li><code>ValueError</code>: If the specified swarm is not found.</li> <li><code>Exception</code>: If any error occurs during task routing or execution.</li> </ul> <p>Examples:</p> <pre><code>router = AutoSwarmRouter(name=\"example_router\", swarms=[swarm1, swarm2])\n\n# Running a task\nresult = router.run(task=\"example_task\")\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#len_of_swarms","title":"len_of_swarms","text":"<p>Prints the number of swarms available in the router.</p> <p>Examples:</p> <pre><code>router = AutoSwarmRouter(name=\"example_router\", swarms=[swarm1, swarm2])\n\n# Printing the number of swarms\nrouter.len_of_swarms()  # Output: 2\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#list_available_swarms","title":"list_available_swarms","text":"<p>Logs the available swarms and their descriptions.</p> <p>Examples:</p> <pre><code>router = AutoSwarmRouter(name=\"example_router\", swarms=[swarm1, swarm2])\n\n# Listing available swarms\nrouter.list_available_swarms()\n# Output:\n# INFO: Swarm Name: swarm1 || Swarm Description: Description of swarm1\n# INFO: Swarm Name: swarm2 || Swarm Description: Description of swarm2\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#additional-examples","title":"Additional Examples","text":""},{"location":"swarms/structs/auto_swarm_router/#example-1-custom-preprocessing-and-postprocessing","title":"Example 1: Custom Preprocessing and Postprocessing","text":"<pre><code>def custom_preprocess(task, *args, **kwargs):\n    # Custom preprocessing logic\n    task = task.upper()\n    return task, args, kwargs\n\ndef custom_postprocess(result):\n    # Custom postprocessing logic\n    return result.lower()\n\nrouter = AutoSwarmRouter(\n    name=\"example_router\",\n    swarms=[swarm1, swarm2],\n    custom_preprocess=custom_preprocess,\n    custom_postprocess=custom_postprocess\n)\n\n# Running a task with custom preprocessing and postprocessing\nresult = router.run(task=\"example_task\")\nprint(result)  # Output will be the processed result\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#example-2-custom-router-function","title":"Example 2: Custom Router Function","text":"<pre><code>def custom_router(router, task, *args, **kwargs):\n    # Custom routing logic\n    if \"specific\" in task:\n        return router.swarm_dict[\"specific_swarm\"].run(task, *args, **kwargs)\n    return router.swarm_dict[\"default_swarm\"].run(task, *args, **kwargs)\n\nrouter = AutoSwarmRouter(\n    name=\"example_router\",\n    swarms=[default_swarm, specific_swarm],\n    custom_router=custom_router\n)\n\n# Running a task with custom routing\nresult = router.run(task=\"specific_task\")\nprint(result)  # Output will be the result of the routed task\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#example-3-verbose-mode","title":"Example 3: Verbose Mode","text":"<pre><code>router = AutoSwarmRouter(\n    name=\"example_router\",\n    swarms=[swarm1, swarm2],\n    verbose=True\n)\n\n# Running a task with verbose mode enabled\nresult = router.run(task=\"example_task\")\n# Output will include detailed logs of the task routing and execution process\n</code></pre>"},{"location":"swarms/structs/auto_swarm_router/#summary","title":"Summary","text":"<p>The <code>AutoSwarmRouter</code> class provides a flexible and customizable approach to routing tasks to appropriate swarms, supporting custom preprocessing, routing, and postprocessing functions. This makes it a powerful tool for managing complex workflows that require dynamic task handling and execution.</p>"},{"location":"swarms/structs/basestructure/","title":"Module/Function Name: BaseStructure","text":""},{"location":"swarms/structs/basestructure/#introduction","title":"Introduction:","text":"<p>The <code>BaseStructure</code> module contains the basic structure and attributes required for running machine learning models and associated metadata, error logging, artifact saving/loading, and relevant event logging. </p> <p>The module provides the flexibility to save and load the model metadata, log errors, save artifacts, and maintain a log for multiple events associated with multiple threads and batched operations. The key attributes of the module include name, description, save_metadata_path, and save_error_path.</p>"},{"location":"swarms/structs/basestructure/#class-definition","title":"Class Definition:","text":""},{"location":"swarms/structs/basestructure/#arguments","title":"Arguments:","text":"Argument Type Description name str (Optional) The name of the structure. description str (Optional) A description of the structure. save_metadata bool A boolean flag to enable or disable metadata saving. save_artifact_path str (Optional) The path to save artifacts. save_metadata_path str (Optional) The path to save metadata. save_error_path str (Optional) The path to save errors."},{"location":"swarms/structs/basestructure/#methods","title":"Methods:","text":""},{"location":"swarms/structs/basestructure/#1-run","title":"1. run","text":"<p>Runs the structure.</p>"},{"location":"swarms/structs/basestructure/#2-save_to_file","title":"2. save_to_file","text":"<p>Saves data to a file. * data: Value to be saved. * file_path: Path where the data is to be saved.</p>"},{"location":"swarms/structs/basestructure/#3-load_from_file","title":"3. load_from_file","text":"<p>Loads data from a file. * file_path: Path from where the data is to be loaded.</p>"},{"location":"swarms/structs/basestructure/#4-save_metadata","title":"4. save_metadata","text":"<p>Saves metadata to a file. * metadata: Data to be saved as metadata.</p>"},{"location":"swarms/structs/basestructure/#5-load_metadata","title":"5. load_metadata","text":"<p>Loads metadata from a file.</p>"},{"location":"swarms/structs/basestructure/#6-log_error","title":"6. log_error","text":"<p>Logs error to a file.</p>"},{"location":"swarms/structs/basestructure/#7-save_artifact","title":"7. save_artifact","text":"<p>Saves artifact to a file. * artifact: The artifact to be saved. * artifact_name: Name of the artifact.</p>"},{"location":"swarms/structs/basestructure/#8-load_artifact","title":"8. load_artifact","text":"<p>Loads artifact from a file. * artifact_name: Name of the artifact.</p>"},{"location":"swarms/structs/basestructure/#9-log_event","title":"9. log_event","text":"<p>Logs an event to a file. * event: The event to be logged. * event_type: Type of the event (optional, defaults to \"INFO\").</p>"},{"location":"swarms/structs/basestructure/#10-run_async","title":"10. run_async","text":"<p>Runs the structure asynchronously.</p>"},{"location":"swarms/structs/basestructure/#11-save_metadata_async","title":"11. save_metadata_async","text":"<p>Saves metadata to a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#12-load_metadata_async","title":"12. load_metadata_async","text":"<p>Loads metadata from a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#13-log_error_async","title":"13. log_error_async","text":"<p>Logs error to a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#14-save_artifact_async","title":"14. save_artifact_async","text":"<p>Saves artifact to a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#15-load_artifact_async","title":"15. load_artifact_async","text":"<p>Loads artifact from a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#16-log_event_async","title":"16. log_event_async","text":"<p>Logs an event to a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#17-asave_to_file","title":"17. asave_to_file","text":"<p>Saves data to a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#18-aload_from_file","title":"18. aload_from_file","text":"<p>Loads data from a file asynchronously.</p>"},{"location":"swarms/structs/basestructure/#19-run_concurrent","title":"19. run_concurrent","text":"<p>Runs the structure concurrently.</p>"},{"location":"swarms/structs/basestructure/#20-compress_data","title":"20. compress_data","text":"<p>Compresses data.</p>"},{"location":"swarms/structs/basestructure/#21-decompres_data","title":"21. decompres_data","text":"<p>Decompresses data.</p>"},{"location":"swarms/structs/basestructure/#22-run_batched","title":"22. run_batched","text":"<p>Runs batched data. </p>"},{"location":"swarms/structs/basestructure/#examples","title":"Examples:","text":""},{"location":"swarms/structs/basestructure/#example-1-saving-metadata","title":"Example 1: Saving Metadata","text":"<pre><code>base_structure = BaseStructure(name=\"ExampleStructure\")\nmetadata = {\"key1\": \"value1\", \"key2\": \"value2\"}\nbase_structure.save_metadata(metadata)\n</code></pre>"},{"location":"swarms/structs/basestructure/#example-2-loading-artifact","title":"Example 2: Loading Artifact","text":"<pre><code>artifact_name = \"example_artifact\"\nartifact_data = base_structure.load_artifact(artifact_name)\n</code></pre>"},{"location":"swarms/structs/basestructure/#example-3-running-concurrently","title":"Example 3: Running Concurrently","text":"<pre><code>concurrent_data = [data1, data2, data3]\nresults = base_structure.run_concurrent(batched_data=concurrent_data)\n</code></pre>"},{"location":"swarms/structs/basestructure/#note","title":"Note:","text":"<p>The <code>BaseStructure</code> class is designed to provide a modular and extensible structure for managing metadata, logs, errors, and batched operations while running machine learning models. The class's methods offer asynchronous and concurrent execution capabilities, thus optimizing the performance of the associated applications and models. The module's attributes and methods cater to a wide range of use cases, making it an essential foundational component for machine learning and data-based applications.</p>"},{"location":"swarms/structs/basestructure/#conclusion","title":"Conclusion:","text":"<p>The <code>BaseStructure</code> module offers a robust and flexible foundation for managing machine learning model metadata, error logs, and event tracking, including asynchronous, concurrent, and batched operations. By leveraging the inherent capabilities of this class, developers can enhance the reliability, scalability, and performance of machine learning-based applications.</p>"},{"location":"swarms/structs/basestructure/#references","title":"References:","text":"<ul> <li>Python Concurrent Programming with <code>asyncio</code></li> <li>Understanding Thread Pool Executor in Python</li> <li>Documentation on <code>gzip</code> Module for Data Compression</li> </ul> <p>The above documentation provides detailed information about the <code>BaseStructure</code> module, including its functionality, attributes, methods, usage examples, and references to relevant resources for further exploration. This comprehensive documentation aims to deepen the users' understanding of the module's purpose and how it can be effectively utilized in practice.</p> <p>Please let me know if you need further elaboration on any specific aspect or functionality of the <code>BaseStructure</code> module.</p>"},{"location":"swarms/structs/concurrentworkflow/","title":"ConcurrentWorkflow Documentation","text":""},{"location":"swarms/structs/concurrentworkflow/#overview","title":"Overview","text":"<p>The <code>ConcurrentWorkflow</code> class is designed to facilitate the concurrent execution of multiple agents, each tasked with solving a specific query or problem. This class is particularly useful in scenarios where multiple agents need to work in parallel, allowing for efficient resource utilization and faster completion of tasks. The workflow manages the execution, collects metadata, and optionally saves the results in a structured format.</p>"},{"location":"swarms/structs/concurrentworkflow/#key-features","title":"Key Features","text":"<ul> <li>Concurrent Execution: Runs multiple agents simultaneously using Python's <code>ThreadPoolExecutor</code></li> <li>Interactive Mode: Supports interactive task modification and execution</li> <li>Caching System: Implements LRU caching for repeated prompts</li> <li>Progress Tracking: Optional progress bar for task execution</li> <li>Enhanced Error Handling: Implements retry mechanism with exponential backoff</li> <li>Input Validation: Validates task inputs before execution</li> <li>Batch Processing: Supports running tasks in batches</li> <li>Metadata Collection: Gathers detailed metadata about each agent's execution</li> <li>Customizable Output: Allows saving metadata to file or returning as string/dictionary</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#class-definition","title":"Class Definition","text":""},{"location":"swarms/structs/concurrentworkflow/#attributes","title":"Attributes","text":"Attribute Type Description <code>name</code> <code>str</code> The name of the workflow. Defaults to <code>\"ConcurrentWorkflow\"</code>. <code>description</code> <code>str</code> A brief description of the workflow. <code>agents</code> <code>List[Agent]</code> A list of agents to be executed concurrently. <code>metadata_output_path</code> <code>str</code> Path to save the metadata output. Defaults to <code>\"agent_metadata.json\"</code>. <code>auto_save</code> <code>bool</code> Flag indicating whether to automatically save the metadata. <code>output_type</code> <code>str</code> The type of output format. Defaults to <code>\"dict\"</code>. <code>max_loops</code> <code>int</code> Maximum number of loops for each agent. Defaults to <code>1</code>. <code>return_str_on</code> <code>bool</code> Flag to return output as string. Defaults to <code>False</code>. <code>auto_generate_prompts</code> <code>bool</code> Flag indicating whether to auto-generate prompts for agents. <code>return_entire_history</code> <code>bool</code> Flag to return entire conversation history. Defaults to <code>False</code>. <code>interactive</code> <code>bool</code> Flag indicating whether to enable interactive mode. Defaults to <code>False</code>. <code>cache_size</code> <code>int</code> The size of the cache. Defaults to <code>100</code>. <code>max_retries</code> <code>int</code> The maximum number of retry attempts. Defaults to <code>3</code>. <code>retry_delay</code> <code>float</code> The delay between retry attempts in seconds. Defaults to <code>1.0</code>. <code>show_progress</code> <code>bool</code> Flag indicating whether to show progress. Defaults to <code>False</code>. <code>_cache</code> <code>dict</code> The cache for storing agent outputs. <code>_progress_bar</code> <code>tqdm</code> The progress bar for tracking execution."},{"location":"swarms/structs/concurrentworkflow/#methods","title":"Methods","text":""},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflow__init__","title":"ConcurrentWorkflow.__init__","text":"<p>Initializes the <code>ConcurrentWorkflow</code> class with the provided parameters.</p>"},{"location":"swarms/structs/concurrentworkflow/#parameters","title":"Parameters","text":"Parameter Type Default Value Description <code>name</code> <code>str</code> <code>\"ConcurrentWorkflow\"</code> The name of the workflow. <code>description</code> <code>str</code> <code>\"Execution of multiple agents concurrently\"</code> A brief description of the workflow. <code>agents</code> <code>List[Agent]</code> <code>[]</code> A list of agents to be executed concurrently. <code>metadata_output_path</code> <code>str</code> <code>\"agent_metadata.json\"</code> Path to save the metadata output. <code>auto_save</code> <code>bool</code> <code>True</code> Flag indicating whether to automatically save the metadata. <code>output_type</code> <code>str</code> <code>\"dict\"</code> The type of output format. <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of loops for each agent. <code>return_str_on</code> <code>bool</code> <code>False</code> Flag to return output as string. <code>auto_generate_prompts</code> <code>bool</code> <code>False</code> Flag indicating whether to auto-generate prompts for agents. <code>return_entire_history</code> <code>bool</code> <code>False</code> Flag to return entire conversation history. <code>interactive</code> <code>bool</code> <code>False</code> Flag indicating whether to enable interactive mode. <code>cache_size</code> <code>int</code> <code>100</code> The size of the cache. <code>max_retries</code> <code>int</code> <code>3</code> The maximum number of retry attempts. <code>retry_delay</code> <code>float</code> <code>1.0</code> The delay between retry attempts in seconds. <code>show_progress</code> <code>bool</code> <code>False</code> Flag indicating whether to show progress."},{"location":"swarms/structs/concurrentworkflow/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the list of agents is empty or if the description is empty.</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowdisable_agent_prints","title":"ConcurrentWorkflow.disable_agent_prints","text":"<p>Disables print statements for all agents in the workflow.</p> <pre><code>workflow.disable_agent_prints()\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowactivate_auto_prompt_engineering","title":"ConcurrentWorkflow.activate_auto_prompt_engineering","text":"<p>Activates the auto-generate prompts feature for all agents in the workflow.</p> <pre><code>workflow.activate_auto_prompt_engineering()\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowenable_progress_bar","title":"ConcurrentWorkflow.enable_progress_bar","text":"<p>Enables the progress bar display for task execution.</p> <pre><code>workflow.enable_progress_bar()\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowdisable_progress_bar","title":"ConcurrentWorkflow.disable_progress_bar","text":"<p>Disables the progress bar display.</p> <pre><code>workflow.disable_progress_bar()\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowclear_cache","title":"ConcurrentWorkflow.clear_cache","text":"<p>Clears the task cache.</p> <pre><code>workflow.clear_cache()\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowget_cache_stats","title":"ConcurrentWorkflow.get_cache_stats","text":"<p>Gets cache statistics.</p>"},{"location":"swarms/structs/concurrentworkflow/#returns","title":"Returns","text":"<ul> <li><code>Dict[str, int]</code>: A dictionary containing cache statistics.</li> </ul> <pre><code>stats = workflow.get_cache_stats()\nprint(stats)  # {'cache_size': 5, 'max_cache_size': 100}\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowrun","title":"ConcurrentWorkflow.run","text":"<p>Executes the workflow for the provided task.</p>"},{"location":"swarms/structs/concurrentworkflow/#parameters_1","title":"Parameters","text":"Parameter Type Description <code>task</code> <code>Optional[str]</code> The task or query to give to all agents. <code>img</code> <code>Optional[str]</code> The image to be processed by the agents. <code>*args</code> <code>tuple</code> Additional positional arguments. <code>**kwargs</code> <code>dict</code> Additional keyword arguments."},{"location":"swarms/structs/concurrentworkflow/#returns_1","title":"Returns","text":"<ul> <li><code>Any</code>: The result of the execution, format depends on output_type and return_entire_history settings.</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code>: If an invalid device is specified.</li> <li><code>Exception</code>: If any other error occurs during execution.</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#concurrentworkflowrun_batched","title":"ConcurrentWorkflow.run_batched","text":"<p>Runs the workflow for a batch of tasks.</p>"},{"location":"swarms/structs/concurrentworkflow/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>tasks</code> <code>List[str]</code> A list of tasks or queries to give to all agents."},{"location":"swarms/structs/concurrentworkflow/#returns_2","title":"Returns","text":"<ul> <li><code>List[Any]</code>: A list of results for each task.</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/concurrentworkflow/#example-1-basic-usage-with-interactive-mode","title":"Example 1: Basic Usage with Interactive Mode","text":"<pre><code>from swarms import Agent, ConcurrentWorkflow\n\n# Initialize agents\nagents = [\n    Agent(\n        agent_name=f\"Agent-{i}\",\n        system_prompt=\"You are a helpful assistant.\",\n        model_name=\"gpt-4\",\n        max_loops=1,\n    )\n    for i in range(3)\n]\n\n# Initialize workflow with interactive mode\nworkflow = ConcurrentWorkflow(\n    name=\"Interactive Workflow\",\n    agents=agents,\n    interactive=True,\n    show_progress=True,\n    cache_size=100,\n    max_retries=3,\n    retry_delay=1.0\n)\n\n# Run workflow\ntask = \"What are the benefits of using Python for data analysis?\"\nresult = workflow.run(task)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#example-2-batch-processing-with-progress-bar","title":"Example 2: Batch Processing with Progress Bar","text":"<pre><code># Initialize workflow\nworkflow = ConcurrentWorkflow(\n    name=\"Batch Processing Workflow\",\n    agents=agents,\n    show_progress=True,\n    auto_save=True\n)\n\n# Define tasks\ntasks = [\n    \"Analyze the impact of climate change on agriculture\",\n    \"Evaluate renewable energy solutions\",\n    \"Assess water conservation strategies\"\n]\n\n# Run batch processing\nresults = workflow.run_batched(tasks)\n\n# Process results\nfor task, result in zip(tasks, results):\n    print(f\"Task: {task}\")\n    print(f\"Result: {result}\\n\")\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#example-3-error-handling-and-retries","title":"Example 3: Error Handling and Retries","text":"<pre><code>import logging\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\n\n# Initialize workflow with retry settings\nworkflow = ConcurrentWorkflow(\n    name=\"Reliable Workflow\",\n    agents=agents,\n    max_retries=3,\n    retry_delay=1.0,\n    show_progress=True\n)\n\n# Run workflow with error handling\ntry:\n    task = \"Generate a comprehensive market analysis report\"\n    result = workflow.run(task)\n    print(result)\nexcept Exception as e:\n    logging.error(f\"An error occurred: {str(e)}\")\n</code></pre>"},{"location":"swarms/structs/concurrentworkflow/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ul> <li>Agent Initialization: Ensure all agents are correctly initialized with required configurations.</li> <li>Interactive Mode: Use interactive mode for tasks requiring user input or modification.</li> <li>Caching: Utilize the caching system for repeated tasks to improve performance.</li> <li>Progress Tracking: Enable progress bar for long-running tasks to monitor execution.</li> <li>Error Handling: Implement proper error handling and use retry mechanism for reliability.</li> <li>Resource Management: Monitor cache size and clear when necessary.</li> <li>Batch Processing: Use batch processing for multiple related tasks.</li> <li>Logging: Implement detailed logging for debugging and monitoring.</li> </ul>"},{"location":"swarms/structs/concurrentworkflow/#references-and-resources","title":"References and Resources","text":"<ul> <li>Python's ThreadPoolExecutor Documentation</li> <li>tqdm Progress Bar Documentation</li> <li>Python's functools.lru_cache Documentation</li> <li>Loguru for Logging in Python</li> </ul>"},{"location":"swarms/structs/conversation/","title":"Module/Class Name: Conversation","text":""},{"location":"swarms/structs/conversation/#introduction","title":"Introduction","text":"<p>The <code>Conversation</code> class is a powerful tool for managing and structuring conversation data in a Python program. It enables you to create, manipulate, and analyze conversations easily with support for multiple storage backends including persistent databases. This documentation provides a comprehensive understanding of the <code>Conversation</code> class, its attributes, methods, and how to effectively use it with different storage backends.</p>"},{"location":"swarms/structs/conversation/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Class Definition</li> <li>Initialization Parameters</li> <li>Backend Configuration</li> <li>Methods</li> <li>Examples</li> </ol>"},{"location":"swarms/structs/conversation/#1-class-definition","title":"1. Class Definition","text":""},{"location":"swarms/structs/conversation/#overview","title":"Overview","text":"<p>The <code>Conversation</code> class is designed to manage conversations by keeping track of messages and their attributes. It offers methods for adding, deleting, updating, querying, and displaying messages within the conversation. Additionally, it supports exporting and importing conversations, searching for specific keywords, and more.</p> <p>New in this version: The class now supports multiple storage backends for persistent conversation storage:</p> <ul> <li>\"in-memory\": Default memory-based storage (no persistence)</li> <li>\"mem0\": Memory-based storage with mem0 integration (requires: <code>pip install mem0ai</code>)</li> <li>\"supabase\": PostgreSQL-based storage using Supabase (requires: <code>pip install supabase</code>)</li> <li>\"redis\": Redis-based storage (requires: <code>pip install redis</code>)</li> <li>\"sqlite\": SQLite-based storage (built-in to Python)</li> <li>\"duckdb\": DuckDB-based storage (requires: <code>pip install duckdb</code>)</li> <li>\"pulsar\": Apache Pulsar messaging backend (requires: <code>pip install pulsar-client</code>)</li> </ul> <p>All backends use lazy loading - database dependencies are only imported when the specific backend is instantiated. Each backend provides helpful error messages if required packages are not installed.</p>"},{"location":"swarms/structs/conversation/#attributes","title":"Attributes","text":"Attribute Type Description id str Unique identifier for the conversation name str Name of the conversation system_prompt Optional[str] System prompt for the conversation time_enabled bool Flag to enable time tracking for messages autosave bool Flag to enable automatic saving save_enabled bool Flag to control if saving is enabled save_filepath str File path for saving conversation history load_filepath str File path for loading conversation history conversation_history list List storing conversation messages tokenizer Callable Tokenizer for counting tokens context_length int Maximum tokens allowed in conversation rules str Rules for the conversation custom_rules_prompt str Custom prompt for rules user str User identifier for messages save_as_yaml bool Flag to save as YAML save_as_json_bool bool Flag to save as JSON token_count bool Flag to enable token counting message_id_on bool Flag to enable message IDs backend str Storage backend type backend_instance Any The actual backend instance conversations_dir str Directory to store conversations"},{"location":"swarms/structs/conversation/#2-initialization-parameters","title":"2. Initialization Parameters","text":"Parameter Type Default Description id str generated Unique conversation ID name str None Name of the conversation system_prompt Optional[str] None System prompt for the conversation time_enabled bool False Enable time tracking autosave bool False Enable automatic saving save_enabled bool False Control if saving is enabled save_filepath str None File path for saving load_filepath str None File path for loading tokenizer Callable None Tokenizer for counting tokens context_length int 8192 Maximum tokens allowed rules str None Conversation rules custom_rules_prompt str None Custom rules prompt user str \"User:\" User identifier save_as_yaml bool False Save as YAML save_as_json_bool bool False Save as JSON token_count bool True Enable token counting message_id_on bool False Enable message IDs provider Literal[\"mem0\", \"in-memory\"] \"in-memory\" Legacy storage provider backend Optional[str] None Storage backend (takes precedence over provider) conversations_dir Optional[str] None Directory for conversations"},{"location":"swarms/structs/conversation/#3-backend-configuration","title":"3. Backend Configuration","text":""},{"location":"swarms/structs/conversation/#backend-specific-parameters","title":"Backend-Specific Parameters","text":""},{"location":"swarms/structs/conversation/#supabase-backend","title":"Supabase Backend","text":"Parameter Type Default Description supabase_url Optional[str] None Supabase project URL supabase_key Optional[str] None Supabase API key table_name str \"conversations\" Database table name <p>Environment variables: <code>SUPABASE_URL</code>, <code>SUPABASE_ANON_KEY</code></p>"},{"location":"swarms/structs/conversation/#redis-backend","title":"Redis Backend","text":"Parameter Type Default Description redis_host str \"localhost\" Redis server host redis_port int 6379 Redis server port redis_db int 0 Redis database number redis_password Optional[str] None Redis password use_embedded_redis bool True Use embedded Redis persist_redis bool True Enable Redis persistence auto_persist bool True Auto-persist data redis_data_dir Optional[str] None Redis data directory"},{"location":"swarms/structs/conversation/#sqliteduckdb-backend","title":"SQLite/DuckDB Backend","text":"Parameter Type Default Description db_path Optional[str] None Database file path"},{"location":"swarms/structs/conversation/#pulsar-backend","title":"Pulsar Backend","text":"Parameter Type Default Description pulsar_url str \"pulsar://localhost:6650\" Pulsar server URL topic str f\"conversation-{id}\" Pulsar topic name"},{"location":"swarms/structs/conversation/#backend-selection","title":"Backend Selection","text":"<p>The <code>backend</code> parameter takes precedence over the legacy <code>provider</code> parameter:</p> <pre><code># Legacy way (still supported)\nconversation = Conversation(provider=\"in-memory\")\n\n# New way (recommended)\nconversation = Conversation(backend=\"supabase\")\nconversation = Conversation(backend=\"redis\")\nconversation = Conversation(backend=\"sqlite\")\n</code></pre>"},{"location":"swarms/structs/conversation/#4-methods","title":"4. Methods","text":""},{"location":"swarms/structs/conversation/#addrole-str-content-unionstr-dict-list-metadata-optionaldict-none","title":"<code>add(role: str, content: Union[str, dict, list], metadata: Optional[dict] = None)</code>","text":"<p>Adds a message to the conversation history.</p> Parameter Type Description role str Role of the speaker content Union[str, dict, list] Message content metadata Optional[dict] Additional metadata <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello, how are you?\")\nconversation.add(\"assistant\", \"I'm doing well, thank you!\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#add_multiple_messagesroles-liststr-contents-listunionstr-dict-list","title":"<code>add_multiple_messages(roles: List[str], contents: List[Union[str, dict, list]])</code>","text":"<p>Adds multiple messages to the conversation history.</p> Parameter Type Description roles List[str] List of speaker roles contents List[Union[str, dict, list]] List of message contents <p>Example: <pre><code>conversation = Conversation()\nconversation.add_multiple_messages(\n    [\"user\", \"assistant\"],\n    [\"Hello!\", \"Hi there!\"]\n)\n</code></pre></p>"},{"location":"swarms/structs/conversation/#deleteindex-str","title":"<code>delete(index: str)</code>","text":"<p>Deletes a message from the conversation history.</p> Parameter Type Description index str Index of message to delete <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.delete(0)  # Deletes the first message\n</code></pre></p>"},{"location":"swarms/structs/conversation/#updateindex-str-role-str-content-unionstr-dict","title":"<code>update(index: str, role: str, content: Union[str, dict])</code>","text":"<p>Updates a message in the conversation history.</p> Parameter Type Description index str Index of message to update role str New role of speaker content Union[str, dict] New message content <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.update(0, \"user\", \"Hi there!\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#queryindex-str","title":"<code>query(index: str)</code>","text":"<p>Retrieves a message from the conversation history.</p> Parameter Type Description index str Index of message to query <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nmessage = conversation.query(0)\n</code></pre></p>"},{"location":"swarms/structs/conversation/#searchkeyword-str","title":"<code>search(keyword: str)</code>","text":"<p>Searches for messages containing a keyword.</p> Parameter Type Description keyword str Keyword to search for <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello world\")\nresults = conversation.search(\"world\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#display_conversationdetailed-bool-false","title":"<code>display_conversation(detailed: bool = False)</code>","text":"<p>Displays the conversation history.</p> Parameter Type Description detailed bool Show detailed information <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.display_conversation(detailed=True)\n</code></pre></p>"},{"location":"swarms/structs/conversation/#export_conversationfilename-str","title":"<code>export_conversation(filename: str)</code>","text":"<p>Exports conversation history to a file.</p> Parameter Type Description filename str Output file path <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.export_conversation(\"chat.txt\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#import_conversationfilename-str","title":"<code>import_conversation(filename: str)</code>","text":"<p>Imports conversation history from a file.</p> Parameter Type Description filename str Input file path <p>Example: <pre><code>conversation = Conversation()\nconversation.import_conversation(\"chat.txt\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#count_messages_by_role","title":"<code>count_messages_by_role()</code>","text":"<p>Counts messages by role.</p> <p>Returns: Dict[str, int]</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.add(\"assistant\", \"Hi\")\ncounts = conversation.count_messages_by_role()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_history_as_string","title":"<code>return_history_as_string()</code>","text":"<p>Returns conversation history as a string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nhistory = conversation.return_history_as_string()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#save_as_jsonfilename-str","title":"<code>save_as_json(filename: str)</code>","text":"<p>Saves conversation history as JSON.</p> Parameter Type Description filename str Output JSON file path <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.save_as_json(\"chat.json\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#load_from_jsonfilename-str","title":"<code>load_from_json(filename: str)</code>","text":"<p>Loads conversation history from JSON.</p> Parameter Type Description filename str Input JSON file path <p>Example: <pre><code>conversation = Conversation()\nconversation.load_from_json(\"chat.json\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#truncate_memory_with_tokenizer","title":"<code>truncate_memory_with_tokenizer()</code>","text":"<p>Truncates conversation history based on token limit.</p> <p>Example: <pre><code>conversation = Conversation(tokenizer=some_tokenizer)\nconversation.truncate_memory_with_tokenizer()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#clear","title":"<code>clear()</code>","text":"<p>Clears the conversation history.</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.clear()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#to_json","title":"<code>to_json()</code>","text":"<p>Converts conversation history to JSON string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\njson_str = conversation.to_json()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#to_dict","title":"<code>to_dict()</code>","text":"<p>Converts conversation history to dictionary.</p> <p>Returns: list</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\ndict_data = conversation.to_dict()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#to_yaml","title":"<code>to_yaml()</code>","text":"<p>Converts conversation history to YAML string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nyaml_str = conversation.to_yaml()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#get_visible_messagesagent-agent-turn-int","title":"<code>get_visible_messages(agent: \"Agent\", turn: int)</code>","text":"<p>Gets visible messages for an agent at a specific turn.</p> Parameter Type Description agent Agent The agent turn int Turn number <p>Returns: List[Dict]</p> <p>Example: <pre><code>conversation = Conversation()\nvisible_msgs = conversation.get_visible_messages(agent, 1)\n</code></pre></p>"},{"location":"swarms/structs/conversation/#get_last_message_as_string","title":"<code>get_last_message_as_string()</code>","text":"<p>Gets the last message as a string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nlast_msg = conversation.get_last_message_as_string()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_messages_as_list","title":"<code>return_messages_as_list()</code>","text":"<p>Returns messages as a list of strings.</p> <p>Returns: List[str]</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nmessages = conversation.return_messages_as_list()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_messages_as_dictionary","title":"<code>return_messages_as_dictionary()</code>","text":"<p>Returns messages as a list of dictionaries.</p> <p>Returns: List[Dict]</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nmessages = conversation.return_messages_as_dictionary()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#add_tool_output_to_agentrole-str-tool_output-dict","title":"<code>add_tool_output_to_agent(role: str, tool_output: dict)</code>","text":"<p>Adds tool output to conversation.</p> Parameter Type Description role str Role of the tool tool_output dict Tool output to add <p>Example: <pre><code>conversation = Conversation()\nconversation.add_tool_output_to_agent(\"tool\", {\"result\": \"success\"})\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_json","title":"<code>return_json()</code>","text":"<p>Returns conversation as JSON string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\njson_str = conversation.return_json()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#get_final_message","title":"<code>get_final_message()</code>","text":"<p>Gets the final message.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nfinal_msg = conversation.get_final_message()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#get_final_message_content","title":"<code>get_final_message_content()</code>","text":"<p>Gets content of final message.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\ncontent = conversation.get_final_message_content()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_all_except_first","title":"<code>return_all_except_first()</code>","text":"<p>Returns all messages except first.</p> <p>Returns: List[Dict]</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"system\", \"Start\")\nconversation.add(\"user\", \"Hello\")\nmessages = conversation.return_all_except_first()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#return_all_except_first_string","title":"<code>return_all_except_first_string()</code>","text":"<p>Returns all messages except first as string.</p> <p>Returns: str</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"system\", \"Start\")\nconversation.add(\"user\", \"Hello\")\nmessages = conversation.return_all_except_first_string()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#batch_addmessages-listdict","title":"<code>batch_add(messages: List[dict])</code>","text":"<p>Adds multiple messages in batch.</p> Parameter Type Description messages List[dict] List of messages to add <p>Example: <pre><code>conversation = Conversation()\nconversation.batch_add([\n    {\"role\": \"user\", \"content\": \"Hello\"},\n    {\"role\": \"assistant\", \"content\": \"Hi\"}\n])\n</code></pre></p>"},{"location":"swarms/structs/conversation/#get_cache_stats","title":"<code>get_cache_stats()</code>","text":"<p>Gets cache usage statistics.</p> <p>Returns: Dict[str, int]</p> <p>Example: <pre><code>conversation = Conversation()\nstats = conversation.get_cache_stats()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#load_conversationname-str-conversations_dir-optionalstr-none","title":"<code>load_conversation(name: str, conversations_dir: Optional[str] = None)</code>","text":"<p>Loads a conversation from cache.</p> Parameter Type Description name str Name of conversation conversations_dir Optional[str] Directory containing conversations <p>Returns: Conversation</p> <p>Example: <pre><code>conversation = Conversation.load_conversation(\"my_chat\")\n</code></pre></p>"},{"location":"swarms/structs/conversation/#list_cached_conversationsconversations_dir-optionalstr-none","title":"<code>list_cached_conversations(conversations_dir: Optional[str] = None)</code>","text":"<p>Lists all cached conversations.</p> Parameter Type Description conversations_dir Optional[str] Directory containing conversations <p>Returns: List[str]</p> <p>Example: <pre><code>conversations = Conversation.list_cached_conversations()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#clear_memory","title":"<code>clear_memory()</code>","text":"<p>Clears the conversation memory.</p> <p>Example: <pre><code>conversation = Conversation()\nconversation.add(\"user\", \"Hello\")\nconversation.clear_memory()\n</code></pre></p>"},{"location":"swarms/structs/conversation/#5-examples","title":"5. Examples","text":""},{"location":"swarms/structs/conversation/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms.structs import Conversation\n\n# Create a new conversation with in-memory storage\nconversation = Conversation(\n    name=\"my_chat\",\n    system_prompt=\"You are a helpful assistant\",\n    time_enabled=True\n)\n\n# Add messages\nconversation.add(\"user\", \"Hello!\")\nconversation.add(\"assistant\", \"Hi there!\")\n\n# Display conversation\nconversation.display_conversation()\n\n# Save conversation (in-memory only saves to file)\nconversation.save_as_json(\"my_chat.json\")\n</code></pre>"},{"location":"swarms/structs/conversation/#using-supabase-backend","title":"Using Supabase Backend","text":"<pre><code>import os\nfrom swarms.structs import Conversation\n\n# Using environment variables\nos.environ[\"SUPABASE_URL\"] = \"https://your-project.supabase.co\"\nos.environ[\"SUPABASE_ANON_KEY\"] = \"your-anon-key\"\n\nconversation = Conversation(\n    name=\"supabase_chat\",\n    backend=\"supabase\",\n    system_prompt=\"You are a helpful assistant\",\n    time_enabled=True\n)\n\n# Or using explicit parameters\nconversation = Conversation(\n    name=\"supabase_chat\",\n    backend=\"supabase\",\n    supabase_url=\"https://your-project.supabase.co\",\n    supabase_key=\"your-anon-key\",\n    system_prompt=\"You are a helpful assistant\",\n    time_enabled=True\n)\n\n# Add messages (automatically stored in Supabase)\nconversation.add(\"user\", \"Hello!\")\nconversation.add(\"assistant\", \"Hi there!\")\n\n# All operations work transparently with the backend\nconversation.display_conversation()\nresults = conversation.search(\"Hello\")\n</code></pre>"},{"location":"swarms/structs/conversation/#using-redis-backend","title":"Using Redis Backend","text":"<pre><code>from swarms.structs import Conversation\n\n# Using Redis with default settings\nconversation = Conversation(\n    name=\"redis_chat\",\n    backend=\"redis\",\n    system_prompt=\"You are a helpful assistant\"\n)\n\n# Using Redis with custom configuration\nconversation = Conversation(\n    name=\"redis_chat\",\n    backend=\"redis\",\n    redis_host=\"localhost\",\n    redis_port=6379,\n    redis_db=0,\n    redis_password=\"mypassword\",\n    system_prompt=\"You are a helpful assistant\"\n)\n\nconversation.add(\"user\", \"Hello Redis!\")\nconversation.add(\"assistant\", \"Hello from Redis backend!\")\n</code></pre>"},{"location":"swarms/structs/conversation/#using-sqlite-backend","title":"Using SQLite Backend","text":"<pre><code>from swarms.structs import Conversation\n\n# SQLite with default database file\nconversation = Conversation(\n    name=\"sqlite_chat\",\n    backend=\"sqlite\",\n    system_prompt=\"You are a helpful assistant\"\n)\n\n# SQLite with custom database path\nconversation = Conversation(\n    name=\"sqlite_chat\",\n    backend=\"sqlite\",\n    db_path=\"/path/to/my/conversations.db\",\n    system_prompt=\"You are a helpful assistant\"\n)\n\nconversation.add(\"user\", \"Hello SQLite!\")\nconversation.add(\"assistant\", \"Hello from SQLite backend!\")\n</code></pre>"},{"location":"swarms/structs/conversation/#advanced-usage-with-multi-agent-systems","title":"Advanced Usage with Multi-Agent Systems","text":"<pre><code>import os\nfrom swarms.structs import Agent, Conversation\nfrom swarms.structs.multi_agent_exec import run_agents_concurrently\n\n# Set up Supabase backend for persistent storage\nconversation = Conversation(\n    name=\"multi_agent_research\",\n    backend=\"supabase\",\n    supabase_url=os.getenv(\"SUPABASE_URL\"),\n    supabase_key=os.getenv(\"SUPABASE_ANON_KEY\"),\n    system_prompt=\"Multi-agent collaboration session\",\n    time_enabled=True\n)\n\n# Create specialized agents\ndata_analyst = Agent(\n    agent_name=\"DataAnalyst\",\n    system_prompt=\"You are a senior data analyst...\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1\n)\n\nresearcher = Agent(\n    agent_name=\"ResearchSpecialist\", \n    system_prompt=\"You are a research specialist...\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1\n)\n\n# Run agents and store results in persistent backend\ntask = \"Analyze the current state of AI in healthcare\"\nresults = run_agents_concurrently(agents=[data_analyst, researcher], task=task)\n\n# Store results in conversation (automatically persisted)\nfor result, agent in zip(results, [data_analyst, researcher]):\n    conversation.add(content=result, role=agent.agent_name)\n\n# Conversation is automatically saved to Supabase\nprint(f\"Conversation stored with {len(conversation.to_dict())} messages\")\n</code></pre>"},{"location":"swarms/structs/conversation/#error-handling-and-fallbacks","title":"Error Handling and Fallbacks","text":"<pre><code>from swarms.structs import Conversation\n\ntry:\n    # Attempt to use Supabase backend\n    conversation = Conversation(\n        name=\"fallback_test\",\n        backend=\"supabase\",\n        supabase_url=\"https://your-project.supabase.co\",\n        supabase_key=\"your-key\"\n    )\n    print(\"\u2705 Supabase backend initialized successfully\")\nexcept ImportError as e:\n    print(f\"\u274c Supabase not available: {e}\")\n    # Automatic fallback to in-memory storage\n    conversation = Conversation(\n        name=\"fallback_test\",\n        backend=\"in-memory\"\n    )\n    print(\"\ud83d\udca1 Falling back to in-memory storage\")\n\n# Usage remains the same regardless of backend\nconversation.add(\"user\", \"Hello!\")\nconversation.add(\"assistant\", \"Hi there!\")\n</code></pre>"},{"location":"swarms/structs/conversation/#loading-and-managing-conversations","title":"Loading and Managing Conversations","text":"<pre><code>from swarms.structs import Conversation\n\n# List all saved conversations\nconversations = Conversation.list_conversations()\nfor conv in conversations:\n    print(f\"ID: {conv['id']}, Name: {conv['name']}, Created: {conv['created_at']}\")\n\n# Load a specific conversation\nconversation = Conversation.load_conversation(\"my_conversation_name\")\n\n# Load conversation from specific file\nconversation = Conversation.load_conversation(\n    \"my_chat\",\n    load_filepath=\"/path/to/conversation.json\"\n)\n</code></pre>"},{"location":"swarms/structs/conversation/#backend-comparison","title":"Backend Comparison","text":"<pre><code># In-memory: Fast, no persistence\nconv_memory = Conversation(backend=\"in-memory\")\n\n# SQLite: Local file-based persistence\nconv_sqlite = Conversation(backend=\"sqlite\", db_path=\"conversations.db\")\n\n# Redis: Distributed caching, high performance\nconv_redis = Conversation(backend=\"redis\", redis_host=\"localhost\")\n\n# Supabase: Cloud PostgreSQL, real-time features\nconv_supabase = Conversation(\n    backend=\"supabase\", \n    supabase_url=\"https://project.supabase.co\",\n    supabase_key=\"your-key\"\n)\n\n# DuckDB: Analytical workloads, columnar storage\nconv_duckdb = Conversation(backend=\"duckdb\", db_path=\"analytics.duckdb\")\n</code></pre>"},{"location":"swarms/structs/conversation/#error-handling","title":"Error Handling","text":"<p>The conversation class provides graceful error handling:</p> <ul> <li>Missing Dependencies: Clear error messages with installation instructions</li> <li>Backend Failures: Automatic fallback to in-memory storage</li> <li>Network Issues: Retry logic and connection management</li> <li>Data Corruption: Validation and recovery mechanisms</li> </ul> <p>Example error message: <pre><code>Backend 'supabase' dependencies not available. Install with: pip install supabase\n</code></pre></p>"},{"location":"swarms/structs/conversation/#migration-guide","title":"Migration Guide","text":""},{"location":"swarms/structs/conversation/#from-provider-to-backend","title":"From Provider to Backend","text":"<pre><code># Old way\nconversation = Conversation(provider=\"in-memory\")\n\n# New way (recommended)\nconversation = Conversation(backend=\"in-memory\")\n\n# Both work, but backend takes precedence\nconversation = Conversation(\n    provider=\"in-memory\",  # Ignored\n    backend=\"supabase\"     # Used\n)\n</code></pre>"},{"location":"swarms/structs/conversation/#conclusion","title":"Conclusion","text":"<p>The <code>Conversation</code> class provides a comprehensive set of tools for managing conversations in Python applications with full backend flexibility. It supports various storage backends, lazy loading, token counting, caching, and multiple export/import formats. The class is designed to be flexible and extensible, making it suitable for a wide range of use cases from simple chat applications to complex conversational AI systems with persistent storage requirements.</p> <p>Choose the appropriate backend based on your needs: - in-memory: Development and testing - sqlite: Local applications and small-scale deployments - redis: Distributed applications requiring high performance - supabase: Cloud applications with real-time requirements - duckdb: Analytics and data science workloads - pulsar: Event-driven architectures and streaming applications</p>"},{"location":"swarms/structs/council_of_judges/","title":"CouncilAsAJudge","text":"<p>The <code>CouncilAsAJudge</code> is a sophisticated evaluation system that employs multiple AI agents to assess model responses across various dimensions. It provides comprehensive, multi-dimensional analysis of AI model outputs through parallel evaluation and aggregation.</p>"},{"location":"swarms/structs/council_of_judges/#overview","title":"Overview","text":"<p>The <code>CouncilAsAJudge</code> implements a council of specialized AI agents that evaluate different aspects of a model's response. Each agent focuses on a specific dimension of evaluation, and their findings are aggregated into a comprehensive report.</p> <pre><code>graph TD\n    A[User Query] --&gt; B[Base Agent]\n    B --&gt; C[Model Response]\n    C --&gt; D[CouncilAsAJudge]\n\n    subgraph \"Evaluation Dimensions\"\n        D --&gt; E1[Accuracy Agent]\n        D --&gt; E2[Helpfulness Agent]\n        D --&gt; E3[Harmlessness Agent]\n        D --&gt; E4[Coherence Agent]\n        D --&gt; E5[Conciseness Agent]\n        D --&gt; E6[Instruction Adherence Agent]\n    end\n\n    E1 --&gt; F[Evaluation Aggregation]\n    E2 --&gt; F\n    E3 --&gt; F\n    E4 --&gt; F\n    E5 --&gt; F\n    E6 --&gt; F\n\n    F --&gt; G[Comprehensive Report]\n\n    style D fill:#f9f,stroke:#333,stroke-width:2px\n    style F fill:#bbf,stroke:#333,stroke-width:2px</code></pre>"},{"location":"swarms/structs/council_of_judges/#key-features","title":"Key Features","text":"<ul> <li>Parallel evaluation across multiple dimensions</li> <li>Caching system for improved performance</li> <li>Dynamic model selection</li> <li>Comprehensive evaluation metrics</li> <li>Thread-safe execution</li> <li>Detailed technical analysis</li> </ul>"},{"location":"swarms/structs/council_of_judges/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms import Agent, CouncilAsAJudge\n\n# Create a base agent\nbase_agent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"You are a financial expert helping users understand and establish ROTH IRAs.\",\n    model_name=\"claude-opus-4-20250514\",\n    max_loops=1,\n)\n\n# Run the base agent\nuser_query = \"How can I establish a ROTH IRA to buy stocks and get a tax break?\"\nmodel_output = base_agent.run(user_query)\n\n# Create and run the council\npanel = CouncilAsAJudge()\nresults = panel.run(user_query, model_output)\nprint(results)\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/structs/council_of_judges/#custom-model-configuration","title":"Custom Model Configuration","text":"<pre><code>from swarms import CouncilAsAJudge\n\n# Initialize with custom model\ncouncil = CouncilAsAJudge(\n    model_name=\"anthropic/claude-3-sonnet-20240229\",\n    output_type=\"all\",\n    cache_size=256,\n    max_workers=4,\n    random_model_name=False\n)\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#parallel-processing-configuration","title":"Parallel Processing Configuration","text":"<pre><code>from swarms import CouncilAsAJudge\n\n# Configure parallel processing\ncouncil = CouncilAsAJudge(\n    max_workers=8,  # Custom number of worker threads\n    random_model_name=True  # Enable dynamic model selection\n)\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#evaluation-dimensions","title":"Evaluation Dimensions","text":"<p>The council evaluates responses across six key dimensions:</p> Dimension Evaluation Criteria Accuracy \u2022 Factual correctness\u2022 Source credibility\u2022 Temporal consistency\u2022 Technical accuracy Helpfulness \u2022 Problem-solving efficacy\u2022 Solution feasibility\u2022 Context inclusion\u2022 Proactive addressing of follow-ups Harmlessness \u2022 Safety assessment\u2022 Ethical considerations\u2022 Age-appropriateness\u2022 Content sensitivity Coherence \u2022 Structural integrity\u2022 Logical flow\u2022 Information hierarchy\u2022 Transition effectiveness Conciseness \u2022 Communication efficiency\u2022 Information density\u2022 Redundancy elimination\u2022 Focus maintenance Instruction Adherence \u2022 Requirement coverage\u2022 Constraint compliance\u2022 Format matching\u2022 Scope appropriateness"},{"location":"swarms/structs/council_of_judges/#api-reference","title":"API Reference","text":""},{"location":"swarms/structs/council_of_judges/#councilasajudge_1","title":"CouncilAsAJudge","text":"<pre><code>class CouncilAsAJudge:\n    def __init__(\n        self,\n        id: str = swarm_id(),\n        name: str = \"CouncilAsAJudge\",\n        description: str = \"Evaluates the model's response across multiple dimensions\",\n        model_name: str = \"gpt-4o-mini\",\n        output_type: str = \"all\",\n        cache_size: int = 128,\n        max_workers: int = None,\n        random_model_name: bool = True,\n    )\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#parameters","title":"Parameters","text":"<ul> <li><code>id</code> (str): Unique identifier for the council</li> <li><code>name</code> (str): Display name of the council</li> <li><code>description</code> (str): Description of the council's purpose</li> <li><code>model_name</code> (str): Name of the model to use for evaluations</li> <li><code>output_type</code> (str): Type of output to return</li> <li><code>cache_size</code> (int): Size of the LRU cache for prompts</li> <li><code>max_workers</code> (int): Maximum number of worker threads</li> <li><code>random_model_name</code> (bool): Whether to use random model selection</li> </ul>"},{"location":"swarms/structs/council_of_judges/#methods","title":"Methods","text":""},{"location":"swarms/structs/council_of_judges/#run","title":"run","text":"<pre><code>def run(self, task: str, model_response: str) -&gt; None\n</code></pre> <p>Evaluates a model response across all dimensions.</p>"},{"location":"swarms/structs/council_of_judges/#parameters_1","title":"Parameters","text":"<ul> <li><code>task</code> (str): Original user prompt</li> <li><code>model_response</code> (str): Model's response to evaluate</li> </ul>"},{"location":"swarms/structs/council_of_judges/#returns","title":"Returns","text":"<ul> <li>Comprehensive evaluation report</li> </ul>"},{"location":"swarms/structs/council_of_judges/#examples","title":"Examples","text":""},{"location":"swarms/structs/council_of_judges/#financial-analysis-example","title":"Financial Analysis Example","text":"<pre><code>from swarms import Agent, CouncilAsAJudge\n\n# Create financial analysis agent\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=\"You are a financial expert helping users understand and establish ROTH IRAs.\",\n    model_name=\"claude-opus-4-20250514\",\n    max_loops=1,\n)\n\n# Run analysis\nquery = \"How can I establish a ROTH IRA to buy stocks and get a tax break?\"\nresponse = financial_agent.run(query)\n\n# Evaluate response\ncouncil = CouncilAsAJudge()\nevaluation = council.run(query, response)\nprint(evaluation)\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#technical-documentation-example","title":"Technical Documentation Example","text":"<pre><code>from swarms import Agent, CouncilAsAJudge\n\n# Create documentation agent\ndoc_agent = Agent(\n    agent_name=\"Documentation-Agent\",\n    system_prompt=\"You are a technical documentation expert.\",\n    model_name=\"gpt-4\",\n    max_loops=1,\n)\n\n# Generate documentation\nquery = \"Explain how to implement a REST API using FastAPI\"\nresponse = doc_agent.run(query)\n\n# Evaluate documentation quality\ncouncil = CouncilAsAJudge(\n    model_name=\"anthropic/claude-3-sonnet-20240229\",\n    output_type=\"all\"\n)\nevaluation = council.run(query, response)\nprint(evaluation)\n</code></pre>"},{"location":"swarms/structs/council_of_judges/#best-practices","title":"Best Practices","text":""},{"location":"swarms/structs/council_of_judges/#model-selection","title":"Model Selection","text":"<p>Model Selection Best Practices</p> <ul> <li>Choose appropriate models for your use case</li> <li>Consider using random model selection for diverse evaluations</li> <li>Match model capabilities to evaluation requirements</li> </ul>"},{"location":"swarms/structs/council_of_judges/#performance-optimization","title":"Performance Optimization","text":"<p>Performance Tips</p> <ul> <li>Adjust cache size based on memory constraints</li> <li>Configure worker threads based on CPU cores</li> <li>Monitor memory usage with large responses</li> </ul>"},{"location":"swarms/structs/council_of_judges/#error-handling","title":"Error Handling","text":"<p>Error Handling Guidelines</p> <ul> <li>Implement proper exception handling</li> <li>Monitor evaluation failures</li> <li>Log evaluation results for analysis</li> </ul>"},{"location":"swarms/structs/council_of_judges/#resource-management","title":"Resource Management","text":"<p>Resource Management</p> <ul> <li>Clean up resources after evaluation</li> <li>Monitor thread pool usage</li> <li>Implement proper shutdown procedures</li> </ul>"},{"location":"swarms/structs/council_of_judges/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms/structs/council_of_judges/#memory-issues","title":"Memory Issues","text":"<p>Memory Problems</p> <p>If you encounter memory-related problems:</p> <ul> <li>Reduce cache size</li> <li>Decrease number of worker threads</li> <li>Process smaller chunks of text</li> </ul>"},{"location":"swarms/structs/council_of_judges/#performance-problems","title":"Performance Problems","text":"<p>Performance Issues</p> <p>To improve performance:</p> <ul> <li>Increase cache size</li> <li>Adjust worker thread count</li> <li>Use more efficient models</li> </ul>"},{"location":"swarms/structs/council_of_judges/#evaluation-failures","title":"Evaluation Failures","text":"<p>Evaluation Issues</p> <p>When evaluations fail:</p> <ul> <li>Check model availability</li> <li>Verify input format</li> <li>Monitor error logs</li> </ul>"},{"location":"swarms/structs/council_of_judges/#contributing","title":"Contributing","text":"<p>Contributing</p> <p>Contributions are welcome! Please feel free to submit a Pull Request.</p>"},{"location":"swarms/structs/council_of_judges/#license","title":"License","text":"<p>License</p> <p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"swarms/structs/create_new_swarm/","title":"How to Add a New Swarm Class","text":"<p>This guide provides comprehensive step-by-step instructions for developers to create and add a new swarm. It emphasizes the importance of adhering to best practices, using proper type hints, and documenting code thoroughly to ensure maintainability, scalability, and clarity in your implementations.</p>"},{"location":"swarms/structs/create_new_swarm/#overview","title":"Overview","text":"<p>A Swarm class enables developers to manage and coordinate multiple agents working together to accomplish complex tasks efficiently. Each Swarm must:</p> <ul> <li>Contain a <code>run(task: str, img: str, *args, **kwargs)</code> method, which serves as the primary execution method for tasks.</li> <li>Include <code>name</code>, <code>description</code>, and <code>agents</code> parameters.</li> <li>Ensure <code>agents</code> is a list of callables, with each callable adhering to specific requirements for dynamic agent behavior.</li> <li>Follow type-hinting and documentation best practices to maintain code clarity and reliability.</li> </ul> <p>Each Agent within the swarm must:</p> <ul> <li>Contain <code>agent_name</code>, <code>system_prompt</code>, and a <code>run</code> method.</li> <li>Follow similar type hinting and documentation standards to ensure consistency and readability.</li> </ul> <p>By adhering to these requirements, you can create robust, reusable, and modular swarms that streamline task management and enhance collaborative functionality. Developers are also encouraged to contribute their swarms back to the open-source community by submitting a pull request to the Swarms repository at https://github.com/kyegomez/swarms.</p>"},{"location":"swarms/structs/create_new_swarm/#creating-a-swarm-class","title":"Creating a Swarm Class","text":"<p>Below is a detailed template for creating a Swarm class. Ensure that all elements are documented and clearly defined:</p> <pre><code>from typing import Callable, Any, List\n\nclass MySwarm:\n    \"\"\"\n    A custom swarm class to manage and execute tasks with multiple agents.\n\n    Attributes:\n        name (str): The name of the swarm.\n        description (str): A brief description of the swarm's purpose.\n        agents (List[Callable]): A list of callables representing the agents to be utilized.\n    \"\"\"\n\n    def __init__(self, name: str, description: str, agents: List[Callable]):\n        \"\"\"\n        Initialize the Swarm with its name, description, and agents.\n\n        Args:\n            name (str): The name of the swarm.\n            description (str): A description of the swarm.\n            agents (List[Callable]): A list of callables that provide the agents for the swarm.\n        \"\"\"\n        self.name = name\n        self.description = description\n        self.agents = agents\n\n    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Execute a task using the swarm and its agents.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input.\n            *args: Additional positional arguments for customization.\n            **kwargs: Additional keyword arguments for fine-tuning behavior.\n\n        Returns:\n            Any: The result of the task execution, aggregated from all agents.\n        \"\"\"\n        results = []\n        for agent in self.agents:\n            result = agent.run(task, img, *args, **kwargs)\n            results.append(result)\n        return results\n</code></pre> <p>This Swarm class serves as the main orchestrator for coordinating agents and running tasks dynamically and flexibly.</p>"},{"location":"swarms/structs/create_new_swarm/#creating-an-agent-class","title":"Creating an Agent Class","text":"<p>Each agent must follow a well-defined structure to ensure compatibility with the swarm. Below is an example of an agent class:</p> <pre><code>class Agent:\n    \"\"\"\n    A single agent class to handle specific tasks assigned by the swarm.\n\n    Attributes:\n        agent_name (str): The name of the agent.\n        system_prompt (str): The system prompt guiding the agent's behavior and purpose.\n    \"\"\"\n\n    def __init__(self, agent_name: str, system_prompt: str):\n        \"\"\"\n        Initialize the agent with its name and system prompt.\n\n        Args:\n            agent_name (str): The name of the agent.\n            system_prompt (str): The guiding prompt for the agent.\n        \"\"\"\n        self.agent_name = agent_name\n        self.system_prompt = system_prompt\n\n    def run(self, task: str, img: str, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Execute a specific task assigned to the agent.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input for processing.\n            *args: Additional positional arguments for task details.\n            **kwargs: Additional keyword arguments for extended functionality.\n\n        Returns:\n            Any: The result of the task execution, which can be customized.\n        \"\"\"\n        # Example implementation (to be customized by developer)\n        return f\"Agent {self.agent_name} executed task: {task}\"\n</code></pre> <p>This structure ensures that each agent can independently handle tasks and integrate seamlessly into a swarm.</p>"},{"location":"swarms/structs/create_new_swarm/#adding-your-swarm-to-a-project","title":"Adding Your Swarm to a Project","text":""},{"location":"swarms/structs/create_new_swarm/#step-1-define-your-agents","title":"Step 1: Define Your Agents","text":"<p>Create one or more instances of the <code>Agent</code> class to serve as components of your swarm. For example:</p> <pre><code>def create_agents():\n    return [\n        Agent(agent_name=\"Agent1\", system_prompt=\"Analyze the image and summarize results.\"),\n        Agent(agent_name=\"Agent2\", system_prompt=\"Detect objects and highlight key features.\"),\n    ]\n</code></pre>"},{"location":"swarms/structs/create_new_swarm/#step-2-implement-your-swarm","title":"Step 2: Implement Your Swarm","text":"<p>Create an instance of your Swarm class, defining its name, description, and associated agents:</p> <pre><code>my_swarm = MySwarm(\n    name=\"Image Analysis Swarm\",\n    description=\"A swarm designed to analyze images and perform a range of related tasks.\",\n    agents=create_agents()\n)\n</code></pre>"},{"location":"swarms/structs/create_new_swarm/#step-3-execute-tasks","title":"Step 3: Execute Tasks","text":"<p>Call the <code>run</code> method of your swarm, passing in the required parameters for execution:</p> <pre><code>results = my_swarm.run(task=\"Analyze image content\", img=\"path/to/image.jpg\")\nprint(results)\n</code></pre> <p>This simple flow allows you to dynamically utilize agents for diverse operations and ensures efficient task execution.</p>"},{"location":"swarms/structs/create_new_swarm/#best-practices","title":"Best Practices","text":"<p>To ensure your swarm implementation is efficient and maintainable, follow these best practices:</p> <ol> <li> <p>Type Annotations:    Use precise type hints for parameters and return types to improve code readability and support static analysis tools.</p> </li> <li> <p>Comprehensive Documentation:    Include clear and detailed docstrings for all classes, methods, and attributes to ensure your code is understandable.</p> </li> <li> <p>Thorough Testing:    Test your swarm and agents with various tasks to verify correctness and identify potential edge cases.</p> </li> <li> <p>Modular Design:    Keep your swarm and agent logic modular, enabling reuse and easy extensions for future enhancements.</p> </li> <li> <p>Error Handling:    Implement robust error handling in the <code>run</code> methods to gracefully manage unexpected inputs or issues during execution.</p> </li> <li> <p>Code Review:    Regularly review and refactor your code to align with the latest best practices and maintain high quality.</p> </li> <li> <p>Scalability:    Design your swarm with scalability in mind, ensuring it can handle a large number of agents and complex tasks.</p> </li> <li> <p>Logging and Monitoring:    Include comprehensive logging to track task execution and monitor performance, enabling easier debugging and optimization.</p> </li> <li> <p>Open-Source Contributions:    Consider contributing your swarm to the Swarms repository to benefit the community. Submit a pull request at https://github.com/kyegomez/swarms.</p> </li> </ol>"},{"location":"swarms/structs/create_new_swarm/#example-output","title":"Example Output","text":"<p>Given the implementation above, executing a task might produce output such as:</p> <pre><code>[\n    \"Agent Agent1 executed task: Analyze image content\",\n    \"Agent Agent2 executed task: Analyze image content\"\n]\n</code></pre> <p>The modular design ensures that each agent contributes to the overall functionality of the swarm, allowing seamless scalability and dynamic task management.</p>"},{"location":"swarms/structs/create_new_swarm/#conclusion","title":"Conclusion","text":"<p>By following these guidelines, you can create swarms that are powerful, flexible, and maintainable. Leveraging the provided templates and best practices enables you to build efficient multi-agent systems capable of handling diverse and complex tasks. Proper structuring, thorough testing, and adherence to best practices will ensure your swarm integrates effectively into any project, delivering robust and reliable performance. Furthermore, maintaining clear documentation and emphasizing modularity will help your implementation adapt to future needs and use cases. Empower your projects with a well-designed swarm architecture today, and consider submitting your swarm to the open-source community to foster collaboration and innovation.</p>"},{"location":"swarms/structs/custom_swarm/","title":"Building Custom Swarms: A Comprehensive Guide for Swarm Engineers","text":""},{"location":"swarms/structs/custom_swarm/#introduction","title":"Introduction","text":"<p>As artificial intelligence and machine learning continue to grow in complexity and applicability, building systems that can harness multiple agents to solve complex tasks becomes more critical. Swarm engineering enables AI agents to collaborate and solve problems autonomously in diverse fields such as finance, marketing, operations, and even creative industries.</p> <p>This comprehensive guide covers how to build a custom swarm system that integrates multiple agents into a cohesive system capable of solving tasks collaboratively. We'll cover everything from basic swarm structure to advanced features like conversation management, logging, error handling, and scalability.</p> <p>By the end of this guide, you will have a complete understanding of:</p> <ul> <li> <p>What swarms are and how they can be built</p> </li> <li> <p>How to create agents and integrate them into swarms</p> </li> <li> <p>How to implement proper conversation management for message storage</p> </li> <li> <p>Best practices for error handling, logging, and optimization</p> </li> <li> <p>How to make swarms scalable and production-ready</p> </li> </ul>"},{"location":"swarms/structs/custom_swarm/#overview-of-swarm-architecture","title":"Overview of Swarm Architecture","text":"<p>A Swarm refers to a collection of agents that collaborate to solve a problem. Each agent in the swarm performs part of the task, either independently or by communicating with other agents. Swarms are ideal for:</p> <ul> <li> <p>Scalability: You can add or remove agents dynamically based on the task's complexity</p> </li> <li> <p>Flexibility: Each agent can be designed to specialize in different parts of the problem, offering modularity</p> </li> <li> <p>Autonomy: Agents in a swarm can operate autonomously, reducing the need for constant supervision</p> </li> <li> <p>Conversation Management: All interactions are tracked and stored for analysis and continuity</p> </li> </ul>"},{"location":"swarms/structs/custom_swarm/#core-requirements-for-swarm-classes","title":"Core Requirements for Swarm Classes","text":"<p>Every Swarm class must adhere to these fundamental requirements:</p>"},{"location":"swarms/structs/custom_swarm/#required-methods-and-attributes","title":"Required Methods and Attributes","text":"<ul> <li> <p><code>run(task: str, img: str, *args, **kwargs)</code> method: The primary execution method for tasks</p> </li> <li> <p><code>name</code>: A descriptive name for the swarm</p> </li> <li> <p><code>description</code>: A clear description of the swarm's purpose</p> </li> <li> <p><code>agents</code>: A list of callables representing the agents</p> </li> <li> <p><code>conversation</code>: A conversation structure for message storage and history management</p> </li> </ul>"},{"location":"swarms/structs/custom_swarm/#required-agent-structure","title":"Required Agent Structure","text":"<p>Each Agent within the swarm must contain:</p> <ul> <li> <p><code>agent_name</code>: Unique identifier for the agent</p> </li> <li> <p><code>system_prompt</code>: Instructions that guide the agent's behavior</p> </li> <li> <p><code>run</code> method: Method to execute tasks assigned to the agent</p> </li> </ul>"},{"location":"swarms/structs/custom_swarm/#setting-up-the-foundation","title":"Setting Up the Foundation","text":""},{"location":"swarms/structs/custom_swarm/#required-dependencies","title":"Required Dependencies","text":"<pre><code>from typing import List, Union, Any, Optional, Callable\nfrom loguru import logger\nfrom swarms.structs.base_swarm import BaseSwarm\nfrom swarms.structs.conversation import Conversation\nfrom swarms.structs.agent import Agent\nimport concurrent.futures\nimport os\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#custom-exception-handling","title":"Custom Exception Handling","text":"<pre><code>class SwarmExecutionError(Exception):\n    \"\"\"Custom exception for handling swarm execution errors.\"\"\"\n    pass\n\nclass AgentValidationError(Exception):\n    \"\"\"Custom exception for agent validation errors.\"\"\"\n    pass\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#building-the-custom-swarm-class","title":"Building the Custom Swarm Class","text":""},{"location":"swarms/structs/custom_swarm/#basic-swarm-structure","title":"Basic Swarm Structure","text":"<pre><code>class CustomSwarm(BaseSwarm):\n    \"\"\"\n    A custom swarm class to manage and execute tasks with multiple agents.\n\n    This swarm integrates conversation management for tracking all agent interactions,\n    provides error handling, and supports both sequential and concurrent execution.\n\n    Attributes:\n        name (str): The name of the swarm.\n        description (str): A brief description of the swarm's purpose.\n        agents (List[Callable]): A list of callables representing the agents.\n        conversation (Conversation): Conversation management for message storage.\n        max_workers (int): Maximum number of concurrent workers for parallel execution.\n        autosave_conversation (bool): Whether to automatically save conversation history.\n    \"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        description: str,\n        agents: List[Callable],\n        max_workers: int = 4,\n        autosave_conversation: bool = True,\n        conversation_config: Optional[dict] = None,\n    ):\n        \"\"\"\n        Initialize the CustomSwarm with its name, description, and agents.\n\n        Args:\n            name (str): The name of the swarm.\n            description (str): A description of the swarm.\n            agents (List[Callable]): A list of callables that provide the agents for the swarm.\n            max_workers (int): Maximum number of concurrent workers.\n            autosave_conversation (bool): Whether to automatically save conversations.\n            conversation_config (dict): Configuration for conversation management.\n        \"\"\"\n        super().__init__(name=name, description=description, agents=agents)\n        self.name = name\n        self.description = description\n        self.agents = agents\n        self.max_workers = max_workers\n        self.autosave_conversation = autosave_conversation\n\n        # Initialize conversation management\n        # See: https://docs.swarms.world/swarms/structs/conversation/\n        conversation_config = conversation_config or {}\n        self.conversation = Conversation(\n            id=f\"swarm_{name}_{int(time.time())}\",\n            name=f\"{name}_conversation\",\n            autosave=autosave_conversation,\n            save_enabled=True,\n            time_enabled=True,\n            **conversation_config\n        )\n\n        # Validate agents and log initialization\n        self.validate_agents()\n        logger.info(f\"\ud83d\ude80 CustomSwarm '{self.name}' initialized with {len(self.agents)} agents\")\n\n        # Add swarm initialization to conversation history\n        self.conversation.add(\n            role=\"System\",\n            content=f\"Swarm '{self.name}' initialized with {len(self.agents)} agents: {[getattr(agent, 'agent_name', 'Unknown') for agent in self.agents]}\"\n        )\n\n    def validate_agents(self):\n        \"\"\"\n        Validates that each agent has the required methods and attributes.\n\n        Raises:\n            AgentValidationError: If any agent fails validation.\n        \"\"\"\n        for i, agent in enumerate(self.agents):\n            # Check for required run method\n            if not hasattr(agent, 'run'):\n                raise AgentValidationError(f\"Agent at index {i} does not have a 'run' method.\")\n\n            # Check for agent_name attribute\n            if not hasattr(agent, 'agent_name'):\n                logger.warning(f\"Agent at index {i} does not have 'agent_name' attribute. Using 'Agent_{i}'\")\n                agent.agent_name = f\"Agent_{i}\"\n\n            logger.info(f\"\u2705 Agent '{agent.agent_name}' validated successfully.\")\n\n    def run(self, task: str, img: str = None, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Execute a task using the swarm and its agents with conversation tracking.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input (optional).\n            *args: Additional positional arguments for customization.\n            **kwargs: Additional keyword arguments for fine-tuning behavior.\n\n        Returns:\n            Any: The result of the task execution, aggregated from all agents.\n        \"\"\"\n        logger.info(f\"\ud83c\udfaf Running task '{task}' across {len(self.agents)} agents in swarm '{self.name}'\")\n\n        # Add task to conversation history\n        self.conversation.add(\n            role=\"User\",\n            content=f\"Task: {task}\" + (f\" | Image: {img}\" if img else \"\"),\n            category=\"input\"\n        )\n\n        try:\n            # Execute task across all agents\n            results = self._execute_agents(task, img, *args, **kwargs)\n\n            # Add results to conversation\n            self.conversation.add(\n                role=\"Swarm\",\n                content=f\"Task completed successfully. Processed by {len(results)} agents.\",\n                category=\"output\"\n            )\n\n            logger.success(f\"\u2705 Task completed successfully by swarm '{self.name}'\")\n            return results\n\n        except Exception as e:\n            error_msg = f\"\u274c Task execution failed in swarm '{self.name}': {str(e)}\"\n            logger.error(error_msg)\n\n            # Add error to conversation\n            self.conversation.add(\n                role=\"System\",\n                content=f\"Error: {error_msg}\",\n                category=\"error\"\n            )\n\n            raise SwarmExecutionError(error_msg)\n\n    def _execute_agents(self, task: str, img: str = None, *args, **kwargs) -&gt; List[Any]:\n        \"\"\"\n        Execute the task across all agents with proper conversation tracking.\n\n        Args:\n            task (str): The task to execute.\n            img (str): Optional image input.\n\n        Returns:\n            List[Any]: Results from all agents.\n        \"\"\"\n        results = []\n\n        for agent in self.agents:\n            try:\n                # Execute agent task\n                result = agent.run(task, img, *args, **kwargs)\n                results.append(result)\n\n                # Add agent response to conversation\n                self.conversation.add(\n                    role=agent.agent_name,\n                    content=result,\n                    category=\"agent_output\"\n                )\n\n                logger.info(f\"\u2705 Agent '{agent.agent_name}' completed task successfully\")\n\n            except Exception as e:\n                error_msg = f\"Agent '{agent.agent_name}' failed: {str(e)}\"\n                logger.error(error_msg)\n\n                # Add agent error to conversation\n                self.conversation.add(\n                    role=agent.agent_name,\n                    content=f\"Error: {error_msg}\",\n                    category=\"agent_error\"\n                )\n\n                # Continue with other agents but log the failure\n                results.append(f\"FAILED: {error_msg}\")\n\n        return results\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#enhanced-swarm-with-concurrent-execution","title":"Enhanced Swarm with Concurrent Execution","text":"<pre><code>    def run_concurrent(self, task: str, img: str = None, *args: Any, **kwargs: Any) -&gt; List[Any]:\n        \"\"\"\n        Execute a task using concurrent execution for better performance.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input (optional).\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            List[Any]: Results from all agents executed concurrently.\n        \"\"\"\n        logger.info(f\"\ud83d\ude80 Running task concurrently across {len(self.agents)} agents\")\n\n        # Add task to conversation\n        self.conversation.add(\n            role=\"User\",\n            content=f\"Concurrent Task: {task}\" + (f\" | Image: {img}\" if img else \"\"),\n            category=\"input\"\n        )\n\n        results = []\n\n        with concurrent.futures.ThreadPoolExecutor(max_workers=self.max_workers) as executor:\n            # Submit all agent tasks\n            future_to_agent = {\n                executor.submit(self._run_single_agent, agent, task, img, *args, **kwargs): agent\n                for agent in self.agents\n            }\n\n            # Collect results as they complete\n            for future in concurrent.futures.as_completed(future_to_agent):\n                agent = future_to_agent[future]\n                try:\n                    result = future.result()\n                    results.append(result)\n\n                    # Add to conversation\n                    self.conversation.add(\n                        role=agent.agent_name,\n                        content=result,\n                        category=\"agent_output\"\n                    )\n\n                except Exception as e:\n                    error_msg = f\"Concurrent execution failed for agent '{agent.agent_name}': {str(e)}\"\n                    logger.error(error_msg)\n                    results.append(f\"FAILED: {error_msg}\")\n\n                    # Add error to conversation\n                    self.conversation.add(\n                        role=agent.agent_name,\n                        content=f\"Error: {error_msg}\",\n                        category=\"agent_error\"\n                    )\n\n        # Add completion summary\n        self.conversation.add(\n            role=\"Swarm\",\n            content=f\"Concurrent task completed. {len(results)} agents processed.\",\n            category=\"output\"\n        )\n\n        return results\n\n    def _run_single_agent(self, agent: Callable, task: str, img: str = None, *args, **kwargs) -&gt; Any:\n        \"\"\"\n        Execute a single agent with error handling.\n\n        Args:\n            agent: The agent to execute.\n            task (str): The task to execute.\n            img (str): Optional image input.\n\n        Returns:\n            Any: The agent's result.\n        \"\"\"\n        try:\n            return agent.run(task, img, *args, **kwargs)\n        except Exception as e:\n            logger.error(f\"Agent '{getattr(agent, 'agent_name', 'Unknown')}' execution failed: {str(e)}\")\n            raise\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#advanced-features","title":"Advanced Features","text":"<pre><code>    def run_with_retries(self, task: str, img: str = None, retries: int = 3, *args, **kwargs) -&gt; List[Any]:\n        \"\"\"\n        Execute a task with retry logic for failed agents.\n\n        Args:\n            task (str): The task to execute.\n            img (str): Optional image input.\n            retries (int): Number of retries for failed agents.\n\n        Returns:\n            List[Any]: Results from all agents with retry attempts.\n        \"\"\"\n        logger.info(f\"\ud83d\udd04 Running task with {retries} retries per agent\")\n\n        # Add task to conversation\n        self.conversation.add(\n            role=\"User\",\n            content=f\"Task with retries ({retries}): {task}\",\n            category=\"input\"\n        )\n\n        results = []\n\n        for agent in self.agents:\n            attempt = 0\n            success = False\n\n            while attempt &lt;= retries and not success:\n                try:\n                    result = agent.run(task, img, *args, **kwargs)\n                    results.append(result)\n                    success = True\n\n                    # Add successful result to conversation\n                    self.conversation.add(\n                        role=agent.agent_name,\n                        content=result,\n                        category=\"agent_output\"\n                    )\n\n                    if attempt &gt; 0:\n                        logger.success(f\"\u2705 Agent '{agent.agent_name}' succeeded on attempt {attempt + 1}\")\n\n                except Exception as e:\n                    attempt += 1\n                    error_msg = f\"Agent '{agent.agent_name}' failed on attempt {attempt}: {str(e)}\"\n                    logger.warning(error_msg)\n\n                    # Add retry attempt to conversation\n                    self.conversation.add(\n                        role=agent.agent_name,\n                        content=f\"Retry attempt {attempt}: {error_msg}\",\n                        category=\"agent_retry\"\n                    )\n\n                    if attempt &gt; retries:\n                        final_error = f\"Agent '{agent.agent_name}' exhausted all {retries} retries\"\n                        logger.error(final_error)\n                        results.append(f\"FAILED: {final_error}\")\n\n                        # Add final failure to conversation\n                        self.conversation.add(\n                            role=agent.agent_name,\n                            content=final_error,\n                            category=\"agent_error\"\n                        )\n\n        return results\n\n    def get_conversation_summary(self) -&gt; dict:\n        \"\"\"\n        Get a summary of the conversation history and agent performance.\n\n        Returns:\n            dict: Summary of conversation statistics and agent performance.\n        \"\"\"\n        # Get conversation statistics\n        message_counts = self.conversation.count_messages_by_role()\n\n        # Count categories\n        category_counts = {}\n        for message in self.conversation.conversation_history:\n            category = message.get(\"category\", \"uncategorized\")\n            category_counts[category] = category_counts.get(category, 0) + 1\n\n        # Get token counts if available\n        token_summary = self.conversation.export_and_count_categories()\n\n        return {\n            \"swarm_name\": self.name,\n            \"total_messages\": len(self.conversation.conversation_history),\n            \"messages_by_role\": message_counts,\n            \"messages_by_category\": category_counts,\n            \"token_summary\": token_summary,\n            \"conversation_id\": self.conversation.id,\n        }\n\n    def export_conversation(self, filepath: str = None) -&gt; str:\n        \"\"\"\n        Export the conversation history to a file.\n\n        Args:\n            filepath (str): Optional custom filepath for export.\n\n        Returns:\n            str: The filepath where the conversation was saved.\n        \"\"\"\n        if filepath is None:\n            filepath = f\"conversations/{self.name}_{self.conversation.id}.json\"\n\n        self.conversation.export_conversation(filepath)\n        logger.info(f\"\ud83d\udcc4 Conversation exported to: {filepath}\")\n        return filepath\n\n    def display_conversation(self, detailed: bool = True):\n        \"\"\"\n        Display the conversation history in a formatted way.\n\n        Args:\n            detailed (bool): Whether to show detailed information.\n        \"\"\"\n        logger.info(f\"\ud83d\udcac Displaying conversation for swarm: {self.name}\")\n        self.conversation.display_conversation(detailed=detailed)\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#creating-agents-for-your-swarm","title":"Creating Agents for Your Swarm","text":""},{"location":"swarms/structs/custom_swarm/#basic-agent-structure","title":"Basic Agent Structure","text":"<pre><code>class CustomAgent:\n    \"\"\"\n    A custom agent class that integrates with the swarm conversation system.\n\n    Attributes:\n        agent_name (str): The name of the agent.\n        system_prompt (str): The system prompt guiding the agent's behavior.\n        conversation (Optional[Conversation]): Shared conversation for context.\n    \"\"\"\n\n    def __init__(\n        self, \n        agent_name: str, \n        system_prompt: str,\n        conversation: Optional[Conversation] = None\n    ):\n        \"\"\"\n        Initialize the agent with its name and system prompt.\n\n        Args:\n            agent_name (str): The name of the agent.\n            system_prompt (str): The guiding prompt for the agent.\n            conversation (Optional[Conversation]): Shared conversation context.\n        \"\"\"\n        self.agent_name = agent_name\n        self.system_prompt = system_prompt\n        self.conversation = conversation\n\n    def run(self, task: str, img: str = None, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Execute a specific task assigned to the agent.\n\n        Args:\n            task (str): The task description.\n            img (str): The image input for processing.\n            *args: Additional positional arguments.\n            **kwargs: Additional keyword arguments.\n\n        Returns:\n            Any: The result of the task execution.\n        \"\"\"\n        # Add context from shared conversation if available\n        context = \"\"\n        if self.conversation:\n            context = f\"Previous context: {self.conversation.get_last_message_as_string()}\\n\\n\"\n\n        # Process the task (implement your custom logic here)\n        result = f\"Agent {self.agent_name} processed: {context}{task}\"\n\n        logger.info(f\"\ud83e\udd16 Agent '{self.agent_name}' completed task\")\n        return result\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#using-swarms-framework-agents","title":"Using Swarms Framework Agents","text":"<p>You can also use the built-in Agent class from the Swarms framework:</p> <pre><code>from swarms.structs.agent import Agent\n\ndef create_financial_agent() -&gt; Agent:\n    \"\"\"Create a financial analysis agent.\"\"\"\n    return Agent(\n        agent_name=\"FinancialAnalyst\",\n        system_prompt=\"You are a financial analyst specializing in market analysis and risk assessment.\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1,\n    )\n\ndef create_marketing_agent() -&gt; Agent:\n    \"\"\"Create a marketing analysis agent.\"\"\"\n    return Agent(\n        agent_name=\"MarketingSpecialist\", \n        system_prompt=\"You are a marketing specialist focused on campaign analysis and customer insights.\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1,\n    )\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#complete-implementation-example","title":"Complete Implementation Example","text":""},{"location":"swarms/structs/custom_swarm/#setting-up-your-swarm","title":"Setting Up Your Swarm","text":"<pre><code>import time\nfrom typing import List\n\ndef create_multi_domain_swarm() -&gt; CustomSwarm:\n    \"\"\"\n    Create a comprehensive multi-domain analysis swarm.\n\n    Returns:\n        CustomSwarm: A configured swarm with multiple specialized agents.\n    \"\"\"\n    # Create agents\n    agents = [\n        create_financial_agent(),\n        create_marketing_agent(),\n        Agent(\n            agent_name=\"OperationsAnalyst\",\n            system_prompt=\"You are an operations analyst specializing in process optimization and efficiency.\",\n            model_name=\"gpt-4o-mini\",\n            max_loops=1,\n        ),\n    ]\n\n    # Configure conversation settings\n    conversation_config = {\n        \"backend\": \"sqlite\",  # Use SQLite for persistent storage\n        \"db_path\": f\"conversations/swarm_conversations.db\",\n        \"time_enabled\": True,\n        \"token_count\": True,\n    }\n\n    # Create the swarm\n    swarm = CustomSwarm(\n        name=\"MultiDomainAnalysisSwarm\",\n        description=\"A comprehensive swarm for financial, marketing, and operations analysis\",\n        agents=agents,\n        max_workers=3,\n        autosave_conversation=True,\n        conversation_config=conversation_config,\n    )\n\n    return swarm\n\n# Usage example\nif __name__ == \"__main__\":\n    # Create and initialize the swarm\n    swarm = create_multi_domain_swarm()\n\n    # Execute a complex analysis task\n    task = \"\"\"\n    Analyze the Q3 2024 performance data for our company:\n    - Revenue: $2.5M (up 15% from Q2)\n\n    - Customer acquisition: 1,200 new customers\n\n    - Marketing spend: $150K\n\n    - Operational costs: $800K\n\n\n    Provide insights from financial, marketing, and operations perspectives.\n    \"\"\"\n\n    # Run the analysis\n    results = swarm.run(task)\n\n    # Display results\n    print(\"\\n\" + \"=\"*50)\n    print(\"SWARM ANALYSIS RESULTS\")\n    print(\"=\"*50)\n\n    for i, result in enumerate(results):\n        agent_name = swarm.agents[i].agent_name\n        print(f\"\\n\ud83e\udd16 {agent_name}:\")\n        print(f\"\ud83d\udcca {result}\")\n\n    # Get conversation summary\n    summary = swarm.get_conversation_summary()\n    print(f\"\\n\ud83d\udcc8 Conversation Summary:\")\n    print(f\"   Total messages: {summary['total_messages']}\")\n    print(f\"   Total tokens: {summary['token_summary']['total_tokens']}\")\n\n    # Export conversation for later analysis\n    export_path = swarm.export_conversation()\n    print(f\"\ud83d\udcbe Conversation saved to: {export_path}\")\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#advanced-usage-with-concurrent-execution","title":"Advanced Usage with Concurrent Execution","text":"<pre><code>def run_batch_analysis():\n    \"\"\"Example of running multiple tasks concurrently.\"\"\"\n    swarm = create_multi_domain_swarm()\n\n    tasks = [\n        \"Analyze Q1 financial performance\",\n        \"Evaluate marketing campaign effectiveness\", \n        \"Review operational efficiency metrics\",\n        \"Assess customer satisfaction trends\",\n    ]\n\n    # Process all tasks concurrently\n    all_results = []\n    for task in tasks:\n        results = swarm.run_concurrent(task)\n        all_results.append({\"task\": task, \"results\": results})\n\n    return all_results\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#conversation-management-integration","title":"Conversation Management Integration","text":"<p>The swarm uses the Swarms framework's Conversation structure for comprehensive message storage and management. This provides:</p>"},{"location":"swarms/structs/custom_swarm/#key-features","title":"Key Features","text":"<ul> <li> <p>Persistent Storage: Multiple backend options (SQLite, Redis, Supabase, etc.)</p> </li> <li> <p>Message Categorization: Organize messages by type (input, output, error, etc.)</p> </li> <li> <p>Token Tracking: Monitor token usage across conversations</p> </li> <li> <p>Export/Import: Save and load conversation histories</p> </li> <li> <p>Search Capabilities: Find specific messages or content</p> </li> </ul>"},{"location":"swarms/structs/custom_swarm/#conversation-configuration-options","title":"Conversation Configuration Options","text":"<pre><code>conversation_config = {\n    # Backend storage options\n    \"backend\": \"sqlite\",  # or \"redis\", \"supabase\", \"duckdb\", \"in-memory\"\n\n    # File-based storage\n    \"db_path\": \"conversations/swarm_data.db\",\n\n    # Redis configuration (if using Redis backend)\n    \"redis_host\": \"localhost\",\n    \"redis_port\": 6379,\n\n    # Features\n    \"time_enabled\": True,     # Add timestamps to messages\n    \"token_count\": True,      # Track token usage\n    \"autosave\": True,         # Automatically save conversations\n    \"save_enabled\": True,     # Enable saving functionality\n}\n</code></pre>"},{"location":"swarms/structs/custom_swarm/#accessing-conversation-data","title":"Accessing Conversation Data","text":"<pre><code># Get conversation history\nhistory = swarm.conversation.return_history_as_string()\n\n# Search for specific content\nfinancial_messages = swarm.conversation.search(\"financial\")\n\n# Export conversation data\nswarm.conversation.export_conversation(\"analysis_session.json\")\n\n# Get conversation statistics\nstats = swarm.conversation.count_messages_by_role()\ntoken_usage = swarm.conversation.export_and_count_categories()\n</code></pre> <p>For complete documentation on conversation management, see the Conversation Structure Documentation.</p>"},{"location":"swarms/structs/custom_swarm/#conclusion","title":"Conclusion","text":"<p>Building custom swarms with proper conversation management enables you to create powerful, scalable, and maintainable multi-agent systems. The integration with the Swarms framework's conversation structure provides:</p> <ul> <li> <p>Complete audit trail of all agent interactions</p> </li> <li> <p>Persistent storage options for different deployment scenarios  </p> </li> <li> <p>Performance monitoring through token and message tracking</p> </li> <li> <p>Easy debugging with searchable conversation history</p> </li> <li> <p>Scalable architecture that grows with your needs</p> </li> </ul> <p>By following the patterns and best practices outlined in this guide, you can create robust swarms that handle complex tasks efficiently while maintaining full visibility into their operations.</p>"},{"location":"swarms/structs/custom_swarm/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Always implement conversation management for tracking and auditing</li> <li>Use proper error handling and retries for production resilience  </li> <li>Implement monitoring and logging for observability</li> <li>Design for scalability with concurrent execution patterns</li> <li>Test thoroughly with unit tests and integration tests</li> <li>Configure appropriately for your deployment environment</li> </ol> <p>For more advanced patterns and examples, explore the Swarms Examples and consider contributing your custom swarms back to the community by submitting a pull request to the Swarms repository.</p>"},{"location":"swarms/structs/custom_swarm/#additional-resources","title":"Additional Resources","text":"<ul> <li> <p>Conversation Structure Documentation - Complete guide to conversation management</p> </li> <li> <p>Agent Documentation - Learn about creating and configuring agents</p> </li> <li> <p>Multi-Agent Architectures - Explore other swarm patterns and architectures</p> </li> <li> <p>Examples Repository - Real-world swarm implementations</p> </li> <li> <p>Swarms Framework GitHub - Source code and contributions</p> </li> </ul>"},{"location":"swarms/structs/deep_research_swarm/","title":"Deep Research Swarm","text":"<p>Overview</p> <p>The Deep Research Swarm is a powerful, production-grade research system that conducts comprehensive analysis across multiple domains using parallel processing and advanced AI agents.</p> <p>Key Features:</p> <ul> <li> <p>Parallel search processing</p> </li> <li> <p>Multi-agent research coordination</p> </li> <li> <p>Advanced information synthesis</p> </li> <li> <p>Automated query generation</p> </li> <li> <p>Concurrent task execution</p> </li> </ul>"},{"location":"swarms/structs/deep_research_swarm/#getting-started","title":"Getting Started","text":"<p>Quick Installation</p> <pre><code>pip install swarms\n</code></pre> Basic UsageBatch Processing <pre><code>from swarms.structs import DeepResearchSwarm\n\n# Initialize the swarm\nswarm = DeepResearchSwarm(\n    name=\"MyResearchSwarm\",\n    output_type=\"json\",\n    max_loops=1\n)\n\n# Run a single research task\nresults = swarm.run(\"What are the latest developments in quantum computing?\")\n</code></pre> <pre><code># Run multiple research tasks in parallel\ntasks = [\n    \"What are the environmental impacts of electric vehicles?\",\n    \"How is AI being used in drug discovery?\",\n]\nbatch_results = swarm.batched_run(tasks)\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#configuration","title":"Configuration","text":"<p>Constructor Arguments</p> Parameter Type Default Description <code>name</code> str \"DeepResearchSwarm\" Name identifier for the swarm <code>description</code> str \"A swarm that conducts...\" Description of the swarm's purpose <code>research_agent</code> Agent research_agent Custom research agent instance <code>max_loops</code> int 1 Maximum number of research iterations <code>nice_print</code> bool True Enable formatted console output <code>output_type</code> str \"json\" Output format (\"json\" or \"string\") <code>max_workers</code> int CPU_COUNT * 2 Maximum concurrent threads <code>token_count</code> bool False Enable token counting <code>research_model_name</code> str \"gpt-4o-mini\" Model to use for research"},{"location":"swarms/structs/deep_research_swarm/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/deep_research_swarm/#run","title":"Run","text":"<p>Single Task Execution</p> <pre><code>results = swarm.run(\"What are the latest breakthroughs in fusion energy?\")\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#batched-run","title":"Batched Run","text":"<p>Parallel Task Execution</p> <pre><code>tasks = [\n    \"What are current AI safety initiatives?\",\n    \"How is CRISPR being used in agriculture?\",\n]\nresults = swarm.batched_run(tasks)\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#step","title":"Step","text":"<p>Single Step Execution</p> <pre><code>results = swarm.step(\"Analyze recent developments in renewable energy storage\")\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#domain-specific-examples","title":"Domain-Specific Examples","text":"Scientific ResearchMarket ResearchNews AnalysisMedical Research <pre><code>science_swarm = DeepResearchSwarm(\n    name=\"ScienceSwarm\",\n    output_type=\"json\",\n    max_loops=2  # More iterations for thorough research\n)\n\nresults = science_swarm.run(\n    \"What are the latest experimental results in quantum entanglement?\"\n)\n</code></pre> <pre><code>market_swarm = DeepResearchSwarm(\n    name=\"MarketSwarm\",\n    output_type=\"json\"\n)\n\nresults = market_swarm.run(\n    \"What are the emerging trends in electric vehicle battery technology market?\"\n)\n</code></pre> <pre><code>news_swarm = DeepResearchSwarm(\n    name=\"NewsSwarm\",\n    output_type=\"string\"  # Human-readable output\n)\n\nresults = news_swarm.run(\n    \"What are the global economic impacts of recent geopolitical events?\"\n)\n</code></pre> <pre><code>medical_swarm = DeepResearchSwarm(\n    name=\"MedicalSwarm\",\n    max_loops=2\n)\n\nresults = medical_swarm.run(\n    \"What are the latest clinical trials for Alzheimer's treatment?\"\n)\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#advanced-features","title":"Advanced Features","text":"Custom Research Agent <pre><code>from swarms import Agent\n\ncustom_agent = Agent(\n    agent_name=\"SpecializedResearcher\",\n    system_prompt=\"Your specialized prompt here\",\n    model_name=\"gpt-4\"\n)\n\nswarm = DeepResearchSwarm(\n    research_agent=custom_agent,\n    max_loops=2\n)\n</code></pre> Parallel Processing Control <pre><code>swarm = DeepResearchSwarm(\n    max_workers=8,  # Limit to 8 concurrent threads\n    nice_print=False  # Disable console output for production\n)\n</code></pre>"},{"location":"swarms/structs/deep_research_swarm/#best-practices","title":"Best Practices","text":"<p>Recommended Practices</p> <ol> <li>Query Formulation: Be specific and clear in your research queries</li> <li>Resource Management: Adjust <code>max_workers</code> based on your system's capabilities</li> <li>Output Handling: Use appropriate <code>output_type</code> for your use case</li> <li>Error Handling: Implement try-catch blocks around swarm operations</li> <li>Model Selection: Choose appropriate models based on research complexity</li> </ol>"},{"location":"swarms/structs/deep_research_swarm/#limitations","title":"Limitations","text":"<p>Known Limitations</p> <ul> <li> <p>Requires valid API keys for external services</p> </li> <li> <p>Performance depends on system resources</p> </li> <li> <p>Rate limits may apply to external API calls</p> </li> <li> <p>Token limits apply to model responses</p> </li> </ul>"},{"location":"swarms/structs/diy_your_own_agent/","title":"Create your own agent with <code>Agent</code> class","text":"<p>The Agent class is a powerful and flexible tool that empowers AI agents to build their own custom agents, tailored to their specific needs.</p> <p>This comprehensive guide will explore the process of inheriting from the Agent class, enabling agents to create their own custom agent classes. By leveraging the rich features and extensibility of the Agent class, agents can imbue their offspring agents with unique capabilities, specialized toolsets, and tailored decision-making processes.</p>"},{"location":"swarms/structs/diy_your_own_agent/#understanding-the-agent-class","title":"Understanding the Agent Class","text":"<p>Before we dive into the intricacies of creating custom agent classes, let's revisit the foundational elements of the Agent class itself. The Agent class is a versatile and feature-rich class designed to streamline the process of building and managing AI agents. It acts as a backbone, connecting language models (LLMs) with various tools, long-term memory, and a wide range of customization options.</p>"},{"location":"swarms/structs/diy_your_own_agent/#key-features-of-the-agent-class","title":"Key Features of the Agent Class","text":"<p>The Agent class offers a plethora of features that can be inherited and extended by custom agent classes. Here are some of the key features that make the Agent class a powerful foundation:</p> <p>1. Language Model Integration: The Agent class supports seamless integration with popular language models such as LangChain, HuggingFace Transformers, and Autogen, allowing custom agent classes to leverage the power of state-of-the-art language models.</p> <p>2. Tool Integration: One of the standout features of the Agent class is its ability to integrate with various tools. Custom agent classes can inherit this capability and incorporate specialized tools tailored to their specific use cases.</p> <p>3. Long-Term Memory: The Agent class provides built-in support for long-term memory, enabling custom agent classes to retain and access information from previous interactions, essential for maintaining context and learning from past experiences.</p> <p>4. Customizable Prompts and Standard Operating Procedures (SOPs): The Agent class allows you to define custom prompts and Standard Operating Procedures (SOPs) that guide an agent's behavior and decision-making process. Custom agent classes can inherit and extend these prompts and SOPs to align with their unique objectives and requirements.</p> <p>5. Interactive and Dashboard Modes: The Agent class supports interactive and dashboard modes, enabling real-time monitoring and interaction with agents. Custom agent classes can inherit these modes, facilitating efficient development, debugging, and user interaction.</p> <p>6. Autosave and State Management: With the Agent class, agents can easily save and load their state, including configuration, memory, and history. Custom agent classes can inherit this capability, ensuring seamless task continuation and enabling efficient collaboration among team members.</p> <p>7. Response Filtering: The Agent class provides built-in response filtering capabilities, allowing agents to filter out or replace specific words or phrases in their responses. Custom agent classes can inherit and extend this feature to ensure compliance with content moderation policies or specific guidelines.</p> <p>8. Code Execution and Multimodal Support: The Agent class supports code execution and multimodal input/output, enabling agents to process and generate code, as well as handle various data formats such as images, audio, and video. Custom agent classes can inherit and specialize these capabilities for their unique use cases.</p> <p>9. Extensibility and Customization: The Agent class is designed to be highly extensible and customizable, allowing agents to tailor its behavior, add custom functionality, and integrate with external libraries and APIs. Custom agent classes can leverage this extensibility to introduce specialized features and capabilities.</p>"},{"location":"swarms/structs/diy_your_own_agent/#creating-a-custom-agent-class","title":"Creating a Custom Agent Class","text":"<p>Now that we have a solid understanding of the Agent class and its features, let's dive into the process of creating a custom agent class by inheriting from the Agent class. Throughout this process, we'll explore how agents can leverage and extend the existing functionality, while introducing specialized features and capabilities tailored to their unique requirements.</p>"},{"location":"swarms/structs/diy_your_own_agent/#step-1-inherit-from-the-agent-class","title":"Step 1: Inherit from the Agent Class","text":"<p>The first step in creating a custom agent class is to inherit from the Agent class. This will provide your custom agent class with the foundational features and capabilities of the Agent class, which can then be extended and customized as needed. The new agent class must have a <code>run(task: str)</code> method to run the entire agent. It is encouraged to have <code>step(task: str)</code> method that completes one step of the agent and then build the <code>run(task: str)</code> method.</p> <pre><code>from swarms import Agent\n\nclass MyCustomAgent(Agent):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Add custom initialization logic here\n\n    def run(self, task: str) -&gt; \n        ...\n</code></pre> <p>In the example above, we define a new class <code>MyCustomAgent</code> that inherits from the <code>Agent</code> class. Within the <code>__init__</code> method, we call the parent class's <code>__init__</code> method using <code>super().__init__(*args, **kwargs)</code>, which ensures that the parent class's initialization logic is executed. You can then add any custom initialization logic specific to your custom agent class.</p>"},{"location":"swarms/structs/diy_your_own_agent/#step-2-customize-the-agents-behavior","title":"Step 2: Customize the Agent's Behavior","text":"<p>One of the key advantages of inheriting from the Agent class is the ability to customize the agent's behavior according to your specific requirements. This can be achieved by overriding or extending the existing methods, or by introducing new methods altogether.</p> <pre><code>from swarms import Agent\n\n\nclass MyCustomAgent(Agent):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom initialization logic\n\n\u00a0 \u00a0 def custom_method(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Implement custom logic here\n\n\u00a0 \u00a0 \u00a0 \u00a0 pass\n\n\u00a0 \u00a0 def run(self, task, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Customize the run method\n\n\u00a0 \u00a0 \u00a0 \u00a0 response = super().run(task, *args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Additional custom logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 return response\n</code></pre> <p>In the example above, we introduce a new <code>custom_method</code> that can encapsulate any specialized logic or functionality specific to your custom agent class. Additionally, we override the <code>run</code> method, which is responsible for executing the agent's main task loop. Within the overridden <code>run</code> method, you can call the parent class's <code>run</code> method using <code>super().run(task, *args, **kwargs)</code> and then introduce any additional custom logic before or after the parent method's execution.</p>"},{"location":"swarms/structs/diy_your_own_agent/#step-3-extend-memory-management","title":"Step 3: Extend Memory Management","text":"<p>The Agent class provides built-in support for long-term memory, allowing agents to retain and access information from previous interactions. Custom agent classes can inherit and extend this capability by introducing specialized memory management techniques.</p> <pre><code>from swarms_memory import BaseVectorDatabase\nfrom swarms import Agent\n\n\nclass CustomMemory(BaseVectorDatabase):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom memory initialization logic\n\n\u00a0 \u00a0 def query(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom memory query logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 return result\n\nclass MyCustomAgent(Agent):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom initialization logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 self.long_term_memory = CustomMemory()\n\n\u00a0 \u00a0 def run(self, task, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Customize the run method\n\n\u00a0 \u00a0 \u00a0 \u00a0 response = super().run(task, *args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Utilize custom memory\n\n\u00a0 \u00a0 \u00a0 \u00a0 memory_result = self.long_term_memory.query(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Process memory result\n\n\u00a0 \u00a0 \u00a0 \u00a0 return response\n</code></pre> <p>In the example above, we define a new <code>CustomMemory</code> class that inherits from the <code>BaseVectorDatabase</code> class provided by the Agent class framework. Within the <code>CustomMemory</code> class, you can implement specialized memory management logic, such as custom indexing, retrieval, and storage mechanisms.</p> <p>Next, within the <code>MyCustomAgent</code> class, we initialize an instance of the <code>CustomMemory</code> class and assign it to the <code>self.long_term_memory</code> attribute. This custom memory instance can then be utilized within the overridden <code>run</code> method, where you can query the memory and process the results as needed.</p>"},{"location":"swarms/structs/diy_your_own_agent/#step-5-introduce-custom-prompts-and-standard-operating-procedures-sops","title":"Step 5: Introduce Custom Prompts and Standard Operating Procedures (SOPs)","text":"<p>The Agent class allows you to define custom prompts and Standard Operating Procedures (SOPs) that guide an agent's behavior and decision-making process. Custom agent classes can inherit and extend these prompts and SOPs to align with their unique objectives and requirements.</p> <pre><code>from swarms import Agent\n\n\nclass MyCustomAgent(Agent):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom initialization logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 self.custom_sop = \"Custom SOP for MyCustomAgent...\"\n\n\u00a0 \u00a0 \u00a0 \u00a0 self.custom_prompt = \"Custom prompt for MyCustomAgent...\"\n\n\u00a0 \u00a0 def run(self, task, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Customize the run method\n\n\u00a0 \u00a0 \u00a0 \u00a0 response = super().run(task, *args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Utilize custom prompts and SOPs\n\n\u00a0 \u00a0 \u00a0 \u00a0 custom_prompt = self.construct_dynamic_prompt(self.custom_prompt)\n\n\u00a0 \u00a0 \u00a0 \u00a0 custom_sop = self.construct_dynamic_sop(self.custom_sop)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Process custom prompts and SOPs\n\n\u00a0 \u00a0 \u00a0 \u00a0 return response\n\n\u00a0 \u00a0 def construct_dynamic_prompt(self, prompt):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom prompt construction logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 return prompt\n\n\u00a0 \u00a0 def construct_dynamic_sop(self, sop):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom SOP construction logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 return sop\n</code></pre> <p>In the example above, we define two new attributes within the <code>MyCustomAgent</code> class: <code>custom_sop</code> and <code>custom_prompt</code>. These attributes can be used to store custom prompts and SOPs specific to your custom agent class.</p> <p>Within the overridden <code>run</code> method, you can utilize these custom prompts and SOPs by calling the <code>construct_dynamic_prompt</code> and <code>construct_dynamic_sop</code> methods, which can be defined within the <code>MyCustomAgent</code> class to implement specialized prompt and SOP construction logic.</p>"},{"location":"swarms/structs/diy_your_own_agent/#step-5-introduce-custom-response-handling","title":"Step 5: Introduce Custom Response Handling","text":"<p>The Agent class provides built-in response filtering capabilities, allowing agents to filter out or replace specific words or phrases in their responses. Custom agent classes can inherit and extend this feature to ensure compliance with content moderation policies or specific guidelines.</p> <pre><code>from swarms import Agent\n\n\nclass MyCustomAgent(Agent):\n\n\u00a0 \u00a0 def __init__(self, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 super().__init__(*args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom initialization logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 self.response_filters = [\"filter_word_1\", \"filter_word_2\"]\n\n\u00a0 \u00a0 def run(self, task, *args, **kwargs):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Customize the run method\n\n\u00a0 \u00a0 \u00a0 \u00a0 response = super().run(task, *args, **kwargs)\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Apply custom response filtering\n\n\u00a0 \u00a0 \u00a0 \u00a0 filtered_response = self.apply_response_filters(response)\n\n\u00a0 \u00a0 \u00a0 \u00a0 return filtered_response\n\n\u00a0 \u00a0 def apply_response_filters(self, response):\n\n\u00a0 \u00a0 \u00a0 \u00a0 # Custom response filtering logic\n\n\u00a0 \u00a0 \u00a0 \u00a0 for word in self.response_filters:\n\n\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 response = response.replace(word, \"[FILTERED]\")\n\n\u00a0 \u00a0 \u00a0 \u00a0 return response\n</code></pre> <p>In the example above, we define a new attribute <code>response_filters</code> within the <code>MyCustomAgent</code> class, which is a list of words or phrases that should be filtered out or replaced in the agent's responses.</p> <p>Within the overridden <code>run</code> method, we call the <code>apply_response_filters</code> method, which can be defined within the <code>MyCustomAgent</code> class to implement specialized response filtering logic. In the example, we iterate over the <code>response_filters</code> list and replace each filtered word or phrase with a placeholder string (<code>\"[FILTERED]\"</code>).</p>"},{"location":"swarms/structs/diy_your_own_agent/#advanced-customization-and-integration","title":"Advanced Customization and Integration","text":"<p>The Agent class and its inherited custom agent classes can be further extended and customized to suit specific requirements and integrate with external libraries, APIs, and services. Here are some advanced customization and integration examples:</p> <p>1. Multimodal Input/Output Integration: Custom agent classes can leverage the multimodal input/output capabilities of the Agent class and introduce specialized handling for various data formats such as images, audio, and video.</p> <p>2. Code Execution and Integration: The Agent class supports code execution, enabling agents to run and evaluate code snippets. Custom agent classes can inherit and extend this capability, introducing specialized code execution environments, sandboxing mechanisms, or integration with external code repositories or platforms.</p> <p>3. External API and Service Integration: Custom agent classes can integrate with external APIs and services, enabling agents to leverage specialized data sources, computational resources, or domain-specific services.</p> <p>4. Performance Optimization: Depending on the use case and requirements, custom agent classes can introduce performance optimizations, such as adjusting loop intervals, retry attempts, or enabling parallel execution for certain tasks.</p> <p>5. Logging and Monitoring: Custom agent classes can introduce specialized logging and monitoring mechanisms, enabling agents to track their performance, identify potential issues, and generate detailed reports or dashboards.</p> <p>6. Security and Privacy Enhancements: Custom agent classes can implement security and privacy enhancements, such as data encryption, access control mechanisms, or compliance with industry-specific regulations and standards.</p> <p>7. Distributed Execution and Scaling: Custom agent classes can be designed to support distributed execution and scaling, enabling agents to leverage cloud computing resources or distributed computing frameworks for handling large-scale tasks or high-concurrency workloads.</p> <p>By leveraging these advanced customization and integration capabilities, agents can create highly specialized and sophisticated custom agent classes tailored to their unique requirements and use cases.</p>"},{"location":"swarms/structs/diy_your_own_agent/#best-practices-and-considerations","title":"Best Practices and Considerations","text":"<p>While building custom agent classes by inheriting from the Agent class offers immense flexibility and power, it's essential to follow best practices and consider potential challenges and considerations:</p> <p>1. Maintainability and Documentation: As custom agent classes become more complex, it's crucial to prioritize maintainability and thorough documentation. Clear and concise code, comprehensive comments, and up-to-date documentation can significantly improve the long-term sustainability and collaboration efforts surrounding custom agent classes.</p> <p>2. Testing and Validation: Custom agent classes should undergo rigorous testing and validation to ensure their correctness, reliability, and adherence to expected behaviors. Establish a robust testing framework and continuously validate the agent's performance, particularly after introducing new features or integrations.</p> <p>3. Security and Privacy Considerations: When building custom agent classes, it's essential to consider security and privacy implications, especially if the agents will handle sensitive data or interact with critical systems. Implement appropriate security measures, such as access controls, data encryption, and secure communication protocols, to protect against potential vulnerabilities and ensure compliance with relevant regulations and standards.</p> <p>4. Scalability and Performance Monitoring: As custom agent classes are deployed and adopted, it's important to monitor their scalability and performance characteristics. Identify potential bottlenecks, resource constraints, or performance degradation, and implement appropriate optimization strategies or scaling mechanisms to ensure efficient and reliable operation.</p> <p>5. Collaboration and Knowledge Sharing: Building custom agent classes often involves collaboration among teams and stakeholders. Foster an environment of knowledge sharing, code reviews, and open communication to ensure that everyone involved understands the agent's capabilities, limitations, and intended use cases.</p> <p>6. Ethical Considerations: As AI agents become more advanced and autonomous, it's crucial to consider the ethical implications of their actions and decisions. Implement appropriate safeguards, oversight mechanisms, and ethical guidelines to ensure that custom agent classes operate in a responsible and transparent manner, aligning with ethical principles and societal values.</p> <p>7. Continuous Learning and Adaptation: The field of AI is rapidly evolving, with new techniques, tools, and best practices emerging regularly. Stay up-to-date with the latest developments and be prepared to adapt and refine your custom agent classes as new advancements become available.</p> <p>By following these best practices and considering potential challenges, agents can create robust, reliable, and ethical custom agent classes that meet their specific requirements while adhering to industry standards and best practices.</p>"},{"location":"swarms/structs/diy_your_own_agent/#conclusion","title":"Conclusion","text":"<p>In this comprehensive guide, we have explored the process of creating custom agent classes by inheriting from the powerful Agent class. We have covered the key features of the Agent class, walked through the step-by-step process of inheriting and extending its functionality, and discussed advanced customization and integration techniques.</p> <p>Building custom agent classes empowers AI agents to create tailored and specialized agents capable of tackling unique challenges and addressing specific domain requirements. By leveraging the rich features and extensibility of the Agent class, agents can imbue their offspring agents with unique capabilities, specialized toolsets, and tailored decision-making processes.</p> <p>Remember, the journey of building custom agent classes is an iterative and collaborative process that requires continuous learning, adaptation, and refinement.</p>"},{"location":"swarms/structs/forest_swarm/","title":"Forest Swarm","text":"<p>This documentation describes the ForestSwarm that organizes agents into trees. Each agent specializes in processing specific tasks. Trees are collections of agents, each assigned based on their relevance to a task through keyword extraction and embedding-based similarity.</p> <p>The architecture allows for efficient task assignment by selecting the most relevant agent from a set of trees. Tasks are processed asynchronously, with agents selected based on task relevance, calculated by the similarity of system prompts and task keywords.</p>"},{"location":"swarms/structs/forest_swarm/#module-path-swarmsstructstree_swarm","title":"Module Path: <code>swarms.structs.tree_swarm</code>","text":""},{"location":"swarms/structs/forest_swarm/#class-treeagent","title":"Class: <code>TreeAgent</code>","text":"<p><code>TreeAgent</code> represents an individual agent responsible for handling a specific task. Agents are initialized with a system prompt and are responsible for dynamically determining their relevance to a given task.</p>"},{"location":"swarms/structs/forest_swarm/#attributes","title":"Attributes","text":"Attribute Type Description <code>system_prompt</code> <code>str</code> A string that defines the agent's area of expertise and task-handling capability. <code>llm</code> <code>callable</code> The language model (LLM) used to process tasks (e.g., GPT-4). <code>agent_name</code> <code>str</code> The name of the agent. <code>system_prompt_embedding</code> <code>tensor</code> Embedding of the system prompt for similarity-based task matching. <code>relevant_keywords</code> <code>List[str]</code> Keywords dynamically extracted from the system prompt to assist in task matching. <code>distance</code> <code>Optional[float]</code> The computed distance between agents based on embedding similarity."},{"location":"swarms/structs/forest_swarm/#methods","title":"Methods","text":"Method Input Output Description <code>calculate_distance(other_agent: TreeAgent)</code> <code>other_agent: TreeAgent</code> <code>float</code> Calculates the cosine similarity between this agent and another agent. <code>run_task(task: str)</code> <code>task: str</code> <code>Any</code> Executes the task, logs the input/output, and returns the result. <code>is_relevant_for_task(task: str, threshold: float = 0.7)</code> <code>task: str, threshold: float</code> <code>bool</code> Checks if the agent is relevant for the task using keyword matching or embedding similarity."},{"location":"swarms/structs/forest_swarm/#class-tree","title":"Class: <code>Tree</code>","text":"<p><code>Tree</code> organizes multiple agents into a hierarchical structure, where agents are sorted based on their relevance to tasks.</p>"},{"location":"swarms/structs/forest_swarm/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>tree_name</code> <code>str</code> The name of the tree (represents a domain of agents, e.g., \"Financial Tree\"). <code>agents</code> <code>List[TreeAgent]</code> List of agents belonging to this tree."},{"location":"swarms/structs/forest_swarm/#methods_1","title":"Methods","text":"Method Input Output Description <code>calculate_agent_distances()</code> <code>None</code> <code>None</code> Calculates and assigns distances between agents based on similarity of prompts. <code>find_relevant_agent(task: str)</code> <code>task: str</code> <code>Optional[TreeAgent]</code> Finds the most relevant agent for a task based on keyword and embedding similarity. <code>log_tree_execution(task: str, selected_agent: TreeAgent, result: Any)</code> <code>task: str, selected_agent: TreeAgent, result: Any</code> <code>None</code> Logs details of the task execution by the selected agent."},{"location":"swarms/structs/forest_swarm/#class-forestswarm","title":"Class: <code>ForestSwarm</code>","text":"<p><code>ForestSwarm</code> is the main class responsible for managing multiple trees. It oversees task delegation by finding the most relevant tree and agent for a given task.</p>"},{"location":"swarms/structs/forest_swarm/#attributes_2","title":"Attributes","text":"Attribute Type Description <code>trees</code> <code>List[Tree]</code> List of trees containing agents organized by domain."},{"location":"swarms/structs/forest_swarm/#methods_2","title":"Methods","text":"Method Input Output Description <code>find_relevant_tree(task: str)</code> <code>task: str</code> <code>Optional[Tree]</code> Searches across all trees to find the most relevant tree based on task requirements. <code>run(task: str)</code> <code>task: str</code> <code>Any</code> Executes the task by finding the most relevant agent from the relevant tree."},{"location":"swarms/structs/forest_swarm/#full-code-example","title":"Full Code Example","text":"<pre><code>from swarms.structs.tree_swarm import TreeAgent, Tree, ForestSwarm\n# Example Usage:\n\n# Create agents with varying system prompts and dynamically generated distances/keywords\nagents_tree1 = [\n    TreeAgent(\n        system_prompt=\"Stock Analysis Agent\",\n        agent_name=\"Stock Analysis Agent\",\n    ),\n    TreeAgent(\n        system_prompt=\"Financial Planning Agent\",\n        agent_name=\"Financial Planning Agent\",\n    ),\n    TreeAgent(\n        agent_name=\"Retirement Strategy Agent\",\n        system_prompt=\"Retirement Strategy Agent\",\n    ),\n]\n\nagents_tree2 = [\n    TreeAgent(\n        system_prompt=\"Tax Filing Agent\",\n        agent_name=\"Tax Filing Agent\",\n    ),\n    TreeAgent(\n        system_prompt=\"Investment Strategy Agent\",\n        agent_name=\"Investment Strategy Agent\",\n    ),\n    TreeAgent(\n        system_prompt=\"ROTH IRA Agent\", agent_name=\"ROTH IRA Agent\"\n    ),\n]\n\n# Create trees\ntree1 = Tree(tree_name=\"Financial Tree\", agents=agents_tree1)\ntree2 = Tree(tree_name=\"Investment Tree\", agents=agents_tree2)\n\n# Create the ForestSwarm\nmulti_agent_structure = ForestSwarm(trees=[tree1, tree2])\n\n# Run a task\ntask = \"Our company is incorporated in delaware, how do we do our taxes for free?\"\noutput = multi_agent_structure.run(task)\nprint(output)\n</code></pre>"},{"location":"swarms/structs/forest_swarm/#example-workflow","title":"Example Workflow","text":"<ol> <li>Create Agents: Agents are initialized with varying system prompts, representing different areas of expertise (e.g., stock analysis, tax filing).</li> <li>Create Trees: Agents are grouped into trees, with each tree representing a domain (e.g., \"Financial Tree\", \"Investment Tree\").</li> <li>Run Task: When a task is submitted, the system traverses through all trees and finds the most relevant agent to handle the task.</li> <li>Task Execution: The selected agent processes the task, and the result is returned.</li> </ol> <pre><code>Task: \"Our company is incorporated in Delaware, how do we do our taxes for free?\"\n</code></pre> <p>Process: - The system searches through the <code>Financial Tree</code> and <code>Investment Tree</code>. - The most relevant agent (likely the \"Tax Filing Agent\") is selected based on keyword matching and prompt similarity. - The task is processed, and the result is logged and returned.</p>"},{"location":"swarms/structs/forest_swarm/#analysis-of-the-swarm-architecture","title":"Analysis of the Swarm Architecture","text":"<p>The Swarm Architecture leverages a hierarchical structure (forest) composed of individual trees, each containing agents specialized in specific domains. This design allows for:</p> <ul> <li>Modular and Scalable Organization: By separating agents into trees, it is easy to expand or contract the system by adding or removing trees or agents.</li> <li>Task Specialization: Each agent is specialized, which ensures that tasks are matched with the most appropriate agent based on relevance and expertise.</li> <li>Dynamic Matching: The architecture uses both keyword-based and embedding-based matching to assign tasks, ensuring a high level of accuracy in agent selection.</li> <li>Logging and Accountability: Each task execution is logged in detail, providing transparency and an audit trail of which agent handled which task and the results produced.</li> <li>Asynchronous Task Execution: The architecture can be adapted for asynchronous task processing, making it scalable and suitable for large-scale task handling in real-time systems.</li> </ul>"},{"location":"swarms/structs/forest_swarm/#mermaid-diagram-of-the-swarm-architecture","title":"Mermaid Diagram of the Swarm Architecture","text":"<pre><code>graph TD\n    A[ForestSwarm] --&gt; B[Financial Tree]\n    A --&gt; C[Investment Tree]\n\n    B --&gt; D[Stock Analysis Agent]\n    B --&gt; E[Financial Planning Agent]\n    B --&gt; F[Retirement Strategy Agent]\n\n    C --&gt; G[Tax Filing Agent]\n    C --&gt; H[Investment Strategy Agent]\n    C --&gt; I[ROTH IRA Agent]\n\n    subgraph Tree Agents\n        D[Stock Analysis Agent]\n        E[Financial Planning Agent]\n        F[Retirement Strategy Agent]\n        G[Tax Filing Agent]\n        H[Investment Strategy Agent]\n        I[ROTH IRA Agent]\n    end</code></pre>"},{"location":"swarms/structs/forest_swarm/#explanation-of-the-diagram","title":"Explanation of the Diagram","text":"<ul> <li>ForestSwarm: Represents the top-level structure managing multiple trees.</li> <li>Trees: In the example, two trees exist\u2014Financial Tree and Investment Tree\u2014each containing agents related to specific domains.</li> <li>Agents: Each agent within the tree is responsible for handling tasks in its area of expertise. Agents within a tree are organized based on their prompt similarity (distance).</li> </ul>"},{"location":"swarms/structs/forest_swarm/#summary","title":"Summary","text":"<p>This Multi-Agent Tree Structure provides an efficient, scalable, and accurate architecture for delegating and executing tasks based on domain-specific expertise. The combination of hierarchical organization, dynamic task matching, and logging ensures reliability, performance, and transparency in task execution.</p>"},{"location":"swarms/structs/graph_workflow/","title":"GraphWorkflow Documentation","text":"<p>The <code>GraphWorkflow</code> class is a pivotal part of the workflow management system, representing a directed graph where nodes signify tasks or agents and edges represent the flow or dependencies between these nodes. This class leverages the NetworkX library to manage and manipulate the directed graph, allowing users to create complex workflows with defined entry and end points.</p>"},{"location":"swarms/structs/graph_workflow/#attributes","title":"Attributes","text":"Attribute Type Description Default <code>nodes</code> <code>Dict[str, Node]</code> A dictionary of nodes in the graph, where the key is the node ID and the value is the Node object. <code>Field(default_factory=dict)</code> <code>edges</code> <code>List[Edge]</code> A list of edges in the graph, where each edge is represented by an Edge object. <code>Field(default_factory=list)</code> <code>entry_points</code> <code>List[str]</code> A list of node IDs that serve as entry points to the graph. <code>Field(default_factory=list)</code> <code>end_points</code> <code>List[str]</code> A list of node IDs that serve as end points of the graph. <code>Field(default_factory=list)</code> <code>graph</code> <code>nx.DiGraph</code> A directed graph object from the NetworkX library representing the workflow graph. <code>Field(default_factory=nx.DiGraph)</code> <code>max_loops</code> <code>int</code> Maximum number of times the workflow can loop during execution. <code>1</code>"},{"location":"swarms/structs/graph_workflow/#methods","title":"Methods","text":""},{"location":"swarms/structs/graph_workflow/#add_nodenode-node","title":"<code>add_node(node: Node)</code>","text":"<p>Adds a node to the workflow graph.</p> Parameter Type Description <code>node</code> <code>Node</code> The node object to be added. <p>Raises: - <code>ValueError</code>: If a node with the same ID already exists in the graph.</p>"},{"location":"swarms/structs/graph_workflow/#add_edgeedge-edge","title":"<code>add_edge(edge: Edge)</code>","text":"<p>Adds an edge to the workflow graph.</p> Parameter Type Description <code>edge</code> <code>Edge</code> The edge object to be added. <p>Raises: - <code>ValueError</code>: If either the source or target node of the edge does not exist in the graph.</p>"},{"location":"swarms/structs/graph_workflow/#set_entry_pointsentry_points-liststr","title":"<code>set_entry_points(entry_points: List[str])</code>","text":"<p>Sets the entry points of the workflow graph.</p> Parameter Type Description <code>entry_points</code> <code>List[str]</code> A list of node IDs to be set as entry points. <p>Raises: - <code>ValueError</code>: If any of the specified node IDs do not exist in the graph.</p>"},{"location":"swarms/structs/graph_workflow/#set_end_pointsend_points-liststr","title":"<code>set_end_points(end_points: List[str])</code>","text":"<p>Sets the end points of the workflow graph.</p> Parameter Type Description <code>end_points</code> <code>List[str]</code> A list of node IDs to be set as end points. <p>Raises: - <code>ValueError</code>: If any of the specified node IDs do not exist in the graph.</p>"},{"location":"swarms/structs/graph_workflow/#visualize-str","title":"<code>visualize() -&gt; str</code>","text":"<p>Generates a string representation of the workflow graph in the Mermaid syntax.</p> <p>Returns: - <code>str</code>: The Mermaid string representation of the workflow graph.</p>"},{"location":"swarms/structs/graph_workflow/#runtask-str-none-args-kwargs-dictstr-any","title":"<code>run(task: str = None, *args, **kwargs) -&gt; Dict[str, Any]</code>","text":"<p>Function to run the workflow graph.</p> Parameter Type Description <code>task</code> <code>str</code> The task to be executed by the workflow. <code>*args</code> Variable length argument list. <code>**kwargs</code> Arbitrary keyword arguments. <p>Returns: - <code>Dict[str, Any]</code>: A dictionary containing the results of the execution.</p> <p>Raises: - <code>ValueError</code>: If no entry points or end points are defined in the graph.</p>"},{"location":"swarms/structs/graph_workflow/#functionality-and-usage","title":"Functionality and Usage","text":""},{"location":"swarms/structs/graph_workflow/#adding-nodes","title":"Adding Nodes","text":"<p>The <code>add_node</code> method is used to add nodes to the graph. Each node must have a unique ID. If a node with the same ID already exists, a <code>ValueError</code> is raised.</p> <pre><code>wf_graph = GraphWorkflow()\nnode1 = Node(id=\"node1\", type=NodeType.TASK, callable=sample_task)\nwf_graph.add_node(node1)\n</code></pre>"},{"location":"swarms/structs/graph_workflow/#adding-edges","title":"Adding Edges","text":"<p>The <code>add_edge</code> method connects nodes with edges. Both the source and target nodes of the edge must already exist in the graph, otherwise a <code>ValueError</code> is raised.</p> <pre><code>edge1 = Edge(source=\"node1\", target=\"node2\")\nwf_graph.add_edge(edge1)\n</code></pre>"},{"location":"swarms/structs/graph_workflow/#setting-entry-and-end-points","title":"Setting Entry and End Points","text":"<p>The <code>set_entry_points</code> and <code>set_end_points</code> methods define which nodes are the starting and ending points of the workflow, respectively. If any specified node IDs do not exist, a <code>ValueError</code> is raised.</p> <pre><code>wf_graph.set_entry_points([\"node1\"])\nwf_graph.set_end_points([\"node2\"])\n</code></pre>"},{"location":"swarms/structs/graph_workflow/#visualizing-the-graph","title":"Visualizing the Graph","text":"<p>The <code>visualize</code> method generates a Mermaid string representation of the workflow graph. This can be useful for visualizing the workflow structure.</p> <pre><code>print(wf_graph.visualize())\n</code></pre>"},{"location":"swarms/structs/graph_workflow/#running-the-workflow","title":"Running the Workflow","text":"<p>The <code>run</code> method executes the workflow. It performs a topological sort of the graph to ensure nodes are executed in the correct order. The results of each node's execution are returned in a dictionary.</p> <pre><code>results = wf_graph.run()\nprint(\"Execution results:\", results)\n</code></pre>"},{"location":"swarms/structs/graph_workflow/#example-usage","title":"Example Usage","text":"<p>Below is a comprehensive example demonstrating the creation and execution of a workflow graph:</p> <pre><code>from swarms import Agent, Edge, GraphWorkflow, Node, NodeType\n\n# Initialize two agents with GPT-4o-mini model and desired parameters\nagent1 = Agent(\n    model_name=\"gpt-4o-mini\",\n    temperature=0.5,\n    max_tokens=4000,\n    max_loops=1,\n    autosave=True,\n    dashboard=True,\n)\nagent2 = Agent(\n    model_name=\"gpt-4o-mini\",\n    temperature=0.5,\n    max_tokens=4000,\n    max_loops=1,\n    autosave=True,\n    dashboard=True,\n)\n\ndef sample_task():\n    print(\"Running sample task\")\n    return \"Task completed\"\n\n# Build workflow graph\nwf_graph = GraphWorkflow()\nwf_graph.add_node(Node(id=\"agent1\", type=NodeType.AGENT, agent=agent1))\nwf_graph.add_node(Node(id=\"agent2\", type=NodeType.AGENT, agent=agent2))\nwf_graph.add_node(Node(id=\"task1\", type=NodeType.TASK, callable=sample_task))\n\nwf_graph.add_edge(Edge(source=\"agent1\", target=\"task1\"))\nwf_graph.add_edge(Edge(source=\"agent2\", target=\"task1\"))\n\nwf_graph.set_entry_points([\"agent1\", \"agent2\"])\nwf_graph.set_end_points([\"task1\"])\n\n# Visualize and run\nprint(wf_graph.visualize())\nresults = wf_graph.run()\nprint(\"Execution results:\", results)\n</code></pre> <p>In this example, we set up a workflow graph with two agents and one task. We define the entry and end points, visualize the graph, and then execute the workflow, capturing and printing the results.</p>"},{"location":"swarms/structs/graph_workflow/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Error Handling: The <code>GraphWorkflow</code> class includes error handling to ensure that invalid operations (such as adding duplicate nodes or edges with non-existent nodes) raise appropriate exceptions.</li> <li>Max Loops: The <code>max_loops</code> attribute allows the workflow to loop through the graph multiple times if needed. This can be useful for iterative tasks.</li> <li>Topological Sort: The workflow execution relies on a topological sort to ensure that nodes are processed in the correct order. This is particularly important in complex workflows with dependencies.</li> </ul>"},{"location":"swarms/structs/graph_workflow/#references-and-resources","title":"References and Resources","text":"<ul> <li>NetworkX Documentation</li> <li>Pydantic Documentation</li> <li>Mermaid Documentation</li> </ul>"},{"location":"swarms/structs/group_chat/","title":"GroupChat Swarm Documentation","text":"<p>A production-grade multi-agent system enabling sophisticated group conversations between AI agents with customizable speaking patterns, parallel processing capabilities, and comprehensive conversation tracking.</p>"},{"location":"swarms/structs/group_chat/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"swarms/structs/group_chat/#agent-parameters","title":"Agent Parameters","text":"Parameter Type Default Description agent_name str Required Unique identifier for the agent system_prompt str Required Role and behavior instructions llm Any Required Language model instance max_loops int 1 Maximum conversation turns autosave bool False Enable conversation saving dashboard bool False Enable monitoring dashboard verbose bool True Enable detailed logging dynamic_temperature bool True Enable dynamic temperature retry_attempts int 1 Failed request retry count context_length int 200000 Maximum context window output_type str \"string\" Response format type streaming_on bool False Enable streaming responses"},{"location":"swarms/structs/group_chat/#groupchat-parameters","title":"GroupChat Parameters","text":"Parameter Type Default Description name str \"GroupChat\" Chat group identifier description str \"\" Purpose description agents List[Agent] [] Participating agents speaker_fn Callable round_robin Speaker selection function max_loops int 10 Maximum conversation turns"},{"location":"swarms/structs/group_chat/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Core Concepts</li> <li>Basic Usage</li> <li>Advanced Configuration</li> <li>Speaker Functions</li> <li>Response Models</li> <li>Advanced Examples</li> <li>API Reference</li> <li>Best Practices</li> </ul>"},{"location":"swarms/structs/group_chat/#installation","title":"Installation","text":"<pre><code>pip3 install swarms swarm-models loguru\n</code></pre>"},{"location":"swarms/structs/group_chat/#core-concepts","title":"Core Concepts","text":"<p>The GroupChat system consists of several key components:</p> <ol> <li>Agents: Individual AI agents with specialized knowledge and roles</li> <li>Speaker Functions: Control mechanisms for conversation flow</li> <li>Chat History: Structured conversation tracking</li> <li>Response Models: Pydantic models for data validation</li> </ol>"},{"location":"swarms/structs/group_chat/#basic-usage","title":"Basic Usage","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarm_models import OpenAIChat\nfrom swarms import Agent, GroupChat, expertise_based\n\n\nif __name__ == \"__main__\":\n\n    load_dotenv()\n\n    # Get the OpenAI API key from the environment variable\n    api_key = os.getenv(\"OPENAI_API_KEY\")\n\n    # Create an instance of the OpenAIChat class\n    model = OpenAIChat(\n        openai_api_key=api_key,\n        model_name=\"gpt-4o-mini\",\n        temperature=0.1,\n    )\n\n    # Example agents\n    agent1 = Agent(\n        agent_name=\"Financial-Analysis-Agent\",\n        system_prompt=\"You are a financial analyst specializing in investment strategies.\",\n        llm=model,\n        max_loops=1,\n        autosave=False,\n        dashboard=False,\n        verbose=True,\n        dynamic_temperature_enabled=True,\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n        context_length=200000,\n        output_type=\"string\",\n        streaming_on=False,\n    )\n\n    agent2 = Agent(\n        agent_name=\"Tax-Adviser-Agent\",\n        system_prompt=\"You are a tax adviser who provides clear and concise guidance on tax-related queries.\",\n        llm=model,\n        max_loops=1,\n        autosave=False,\n        dashboard=False,\n        verbose=True,\n        dynamic_temperature_enabled=True,\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n        context_length=200000,\n        output_type=\"string\",\n        streaming_on=False,\n    )\n\n    agents = [agent1, agent2]\n\n    chat = GroupChat(\n        name=\"Investment Advisory\",\n        description=\"Financial and tax analysis group\",\n        agents=agents,\n        speaker_fn=expertise_based,\n    )\n\n    history = chat.run(\n        \"How to optimize tax strategy for investments?\"\n    )\n    print(history.model_dump_json(indent=2))\n</code></pre>"},{"location":"swarms/structs/group_chat/#speaker-functions","title":"Speaker Functions","text":""},{"location":"swarms/structs/group_chat/#built-in-functions","title":"Built-in Functions","text":"<pre><code>def round_robin(history: List[str], agent: Agent) -&gt; bool:\n    \"\"\"\n    Enables agents to speak in turns.\n    Returns True for each agent in sequence.\n    \"\"\"\n    return True\n\ndef expertise_based(history: List[str], agent: Agent) -&gt; bool:\n    \"\"\"\n    Enables agents to speak based on their expertise.\n    Returns True if agent's role matches conversation context.\n    \"\"\"\n    return agent.system_prompt.lower() in history[-1].lower() if history else True\n\ndef random_selection(history: List[str], agent: Agent) -&gt; bool:\n    \"\"\"\n    Randomly selects speaking agents.\n    Returns True/False with 50% probability.\n    \"\"\"\n    import random\n    return random.choice([True, False])\n\ndef most_recent(history: List[str], agent: Agent) -&gt; bool:\n    \"\"\"\n    Enables agents to respond to their mentions.\n    Returns True if agent was last speaker.\n    \"\"\"\n    return agent.agent_name == history[-1].split(\":\")[0].strip() if history else True\n</code></pre>"},{"location":"swarms/structs/group_chat/#custom-speaker-function-example","title":"Custom Speaker Function Example","text":"<pre><code>def custom_speaker(history: List[str], agent: Agent) -&gt; bool:\n    \"\"\"\n    Custom speaker function with complex logic.\n\n    Args:\n        history: Previous conversation messages\n        agent: Current agent being evaluated\n\n    Returns:\n        bool: Whether agent should speak\n    \"\"\"\n    # No history - let everyone speak\n    if not history:\n        return True\n\n    last_message = history[-1].lower()\n\n    # Check for agent expertise keywords\n    expertise_relevant = any(\n        keyword in last_message \n        for keyword in agent.expertise_keywords\n    )\n\n    # Check for direct mentions\n    mentioned = agent.agent_name.lower() in last_message\n\n    # Check if agent hasn't spoken recently\n    not_recent_speaker = not any(\n        agent.agent_name in msg \n        for msg in history[-3:]\n    )\n\n    return expertise_relevant or mentioned or not_recent_speaker\n\n# Usage\nchat = GroupChat(\n    agents=[agent1, agent2],\n    speaker_fn=custom_speaker\n)\n</code></pre>"},{"location":"swarms/structs/group_chat/#response-models","title":"Response Models","text":""},{"location":"swarms/structs/group_chat/#complete-schema","title":"Complete Schema","text":"<pre><code>class AgentResponse(BaseModel):\n    \"\"\"Individual agent response in a conversation turn\"\"\"\n    agent_name: str\n    role: str\n    message: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n    turn_number: int\n    preceding_context: List[str] = Field(default_factory=list)\n\nclass ChatTurn(BaseModel):\n    \"\"\"Single turn in the conversation\"\"\"\n    turn_number: int\n    responses: List[AgentResponse]\n    task: str\n    timestamp: datetime = Field(default_factory=datetime.now)\n\nclass ChatHistory(BaseModel):\n    \"\"\"Complete conversation history\"\"\"\n    turns: List[ChatTurn]\n    total_messages: int\n    name: str\n    description: str\n    start_time: datetime = Field(default_factory=datetime.now)\n</code></pre>"},{"location":"swarms/structs/group_chat/#advanced-examples","title":"Advanced Examples","text":""},{"location":"swarms/structs/group_chat/#multi-agent-analysis-team","title":"Multi-Agent Analysis Team","text":"<pre><code># Create specialized agents\ndata_analyst = Agent(\n    agent_name=\"Data-Analyst\",\n    system_prompt=\"You analyze numerical data and patterns\",\n    llm=model\n)\n\nmarket_expert = Agent(\n    agent_name=\"Market-Expert\",\n    system_prompt=\"You provide market insights and trends\",\n    llm=model\n)\n\nstrategy_advisor = Agent(\n    agent_name=\"Strategy-Advisor\",\n    system_prompt=\"You formulate strategic recommendations\",\n    llm=model\n)\n\n# Create analysis team\nanalysis_team = GroupChat(\n    name=\"Market Analysis Team\",\n    description=\"Comprehensive market analysis group\",\n    agents=[data_analyst, market_expert, strategy_advisor],\n    speaker_fn=expertise_based,\n    max_loops=15\n)\n\n# Run complex analysis\nhistory = analysis_team.run(\"\"\"\n    Analyze the current market conditions:\n    1. Identify key trends\n    2. Evaluate risks\n    3. Recommend investment strategy\n\"\"\")\n</code></pre>"},{"location":"swarms/structs/group_chat/#parallel-processing","title":"Parallel Processing","text":"<pre><code># Define multiple analysis tasks\ntasks = [\n    \"Analyze tech sector trends\",\n    \"Evaluate real estate market\",\n    \"Review commodity prices\",\n    \"Assess global economic indicators\"\n]\n\n# Run tasks concurrently\nhistories = chat.concurrent_run(tasks)\n\n# Process results\nfor task, history in zip(tasks, histories):\n    print(f\"\\nAnalysis for: {task}\")\n    for turn in history.turns:\n        for response in turn.responses:\n            print(f\"{response.agent_name}: {response.message}\")\n</code></pre>"},{"location":"swarms/structs/group_chat/#best-practices","title":"Best Practices","text":"<ol> <li>Agent Design</li> <li>Give agents clear, specific roles</li> <li>Use detailed system prompts</li> <li>Set appropriate context lengths</li> <li> <p>Enable retries for reliability</p> </li> <li> <p>Speaker Functions</p> </li> <li>Match function to use case</li> <li>Consider conversation flow</li> <li>Handle edge cases</li> <li> <p>Add appropriate logging</p> </li> <li> <p>Error Handling</p> </li> <li>Use try-except blocks</li> <li>Log errors appropriately</li> <li>Implement retry logic</li> <li> <p>Provide fallback responses</p> </li> <li> <p>Performance</p> </li> <li>Use concurrent processing for multiple tasks</li> <li>Monitor context lengths</li> <li>Implement proper cleanup</li> <li>Cache responses when appropriate</li> </ol>"},{"location":"swarms/structs/group_chat/#api-reference","title":"API Reference","text":""},{"location":"swarms/structs/group_chat/#groupchat-methods","title":"GroupChat Methods","text":"Method Description Arguments Returns run Run single conversation task: str ChatHistory batched_run Run multiple sequential tasks tasks: List[str] List[ChatHistory] concurrent_run Run multiple parallel tasks tasks: List[str] List[ChatHistory] get_recent_messages Get recent messages n: int = 3 List[str]"},{"location":"swarms/structs/group_chat/#agent-methods","title":"Agent Methods","text":"Method Description Returns run Process single task str generate_response Generate LLM response str save_context Save conversation context None"},{"location":"swarms/structs/heavy_swarm/","title":"HeavySwarm Documentation","text":"<p>HeavySwarm is a sophisticated multi-agent orchestration system that decomposes complex tasks into specialized questions and executes them using four specialized agents: Research, Analysis, Alternatives, and Verification. The results are then synthesized into a comprehensive response.</p> <p>Inspired by X.AI's Grok 4 heavy implementation, HeavySwarm provides robust task analysis through intelligent question generation, parallel execution, and comprehensive synthesis with real-time progress monitoring.</p>"},{"location":"swarms/structs/heavy_swarm/#architecture","title":"Architecture","text":""},{"location":"swarms/structs/heavy_swarm/#system-design","title":"System Design","text":"<p>The HeavySwarm follows a structured 5-phase workflow:</p> <ol> <li>Task Decomposition: Complex tasks are broken down into specialized questions</li> <li>Question Generation: AI-powered generation of role-specific questions</li> <li>Parallel Execution: Four specialized agents work concurrently</li> <li>Result Collection: Outputs are gathered and validated</li> <li>Synthesis: Integration into a comprehensive final response</li> </ol>"},{"location":"swarms/structs/heavy_swarm/#agent-specialization","title":"Agent Specialization","text":"<ul> <li>Research Agent: Comprehensive information gathering and synthesis</li> <li>Analysis Agent: Pattern recognition and statistical analysis</li> <li>Alternatives Agent: Creative problem-solving and strategic options</li> <li>Verification Agent: Validation, feasibility assessment, and quality assurance</li> <li>Synthesis Agent: Multi-perspective integration and executive reporting</li> </ul>"},{"location":"swarms/structs/heavy_swarm/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TB\n    subgraph \"HeavySwarm Architecture\"\n        A[Input Task] --&gt; B[Question Generation Agent]\n        B --&gt; C[Task Decomposition]\n\n        C --&gt; D[Research Agent]\n        C --&gt; E[Analysis Agent]\n        C --&gt; F[Alternatives Agent]\n        C --&gt; G[Verification Agent]\n\n        D --&gt; H[Parallel Execution Engine]\n        E --&gt; H\n        F --&gt; H\n        G --&gt; H\n\n        H --&gt; I[Result Collection]\n        I --&gt; J[Synthesis Agent]\n        J --&gt; K[Comprehensive Report]\n\n        subgraph \"Monitoring &amp; Control\"\n            L[Rich Dashboard]\n            M[Progress Tracking]\n            N[Error Handling]\n            O[Timeout Management]\n        end\n\n        H --&gt; L\n        H --&gt; M\n        H --&gt; N\n        H --&gt; O\n    end\n\n    subgraph \"Agent Specializations\"\n        D --&gt; D1[Information Gathering&lt;br/&gt;Market Research&lt;br/&gt;Data Collection]\n        E --&gt; E1[Statistical Analysis&lt;br/&gt;Pattern Recognition&lt;br/&gt;Predictive Modeling]\n        F --&gt; F1[Creative Solutions&lt;br/&gt;Strategic Options&lt;br/&gt;Innovation Ideation]\n        G --&gt; G1[Fact Checking&lt;br/&gt;Feasibility Assessment&lt;br/&gt;Quality Assurance]\n    end\n\n    style A fill:#ff6b6b\n    style K fill:#4ecdc4\n    style H fill:#45b7d1\n    style J fill:#96ceb4</code></pre>"},{"location":"swarms/structs/heavy_swarm/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/heavy_swarm/#quick-start","title":"Quick Start","text":"<pre><code>from swarms import HeavySwarm\n\n# Initialize the swarm\nswarm = HeavySwarm(\n    name=\"MarketAnalysisSwarm\",\n    description=\"Financial market analysis swarm\",\n    question_agent_model_name=\"gpt-4o-mini\",\n    worker_model_name=\"gpt-4o-mini\",\n    show_dashboard=True,\n    verbose=True\n)\n\n# Execute analysis\nresult = swarm.run(\"Analyze the current cryptocurrency market trends and investment opportunities\")\nprint(result)\n</code></pre>"},{"location":"swarms/structs/heavy_swarm/#api-reference","title":"API Reference","text":""},{"location":"swarms/structs/heavy_swarm/#heavyswarm-class","title":"HeavySwarm Class","text":""},{"location":"swarms/structs/heavy_swarm/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>name</code> <code>str</code> <code>\"HeavySwarm\"</code> Identifier name for the swarm instance <code>description</code> <code>str</code> <code>\"A swarm of agents...\"</code> Description of the swarm's purpose <code>agents</code> <code>List[Agent]</code> <code>None</code> Pre-configured agent list (unused - agents created internally) <code>timeout</code> <code>int</code> <code>300</code> Maximum execution time per agent in seconds <code>aggregation_strategy</code> <code>str</code> <code>\"synthesis\"</code> Strategy for result aggregation <code>loops_per_agent</code> <code>int</code> <code>1</code> Number of execution loops per agent <code>question_agent_model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Model for question generation <code>worker_model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Model for specialized worker agents <code>verbose</code> <code>bool</code> <code>False</code> Enable detailed logging output <code>max_workers</code> <code>int</code> <code>int(os.cpu_count() * 0.9)</code> Maximum concurrent workers <code>show_dashboard</code> <code>bool</code> <code>False</code> Enable rich dashboard visualization <code>agent_prints_on</code> <code>bool</code> <code>False</code> Enable individual agent output printing"},{"location":"swarms/structs/heavy_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/heavy_swarm/#runtask-str-img-str-none-str","title":"<code>run(task: str, img: str = None) -&gt; str</code>","text":"<p>Execute the complete HeavySwarm orchestration flow.</p> <p>Parameters:</p> <ul> <li> <p><code>task</code> (str): The main task to analyze and decompose</p> </li> <li> <p><code>img</code> (str, optional): Image input for visual analysis tasks</p> </li> </ul> <p>Returns: - <code>str</code>: Comprehensive final analysis from synthesis agent</p> <p>Example: <pre><code>result = swarm.run(\"Develop a go-to-market strategy for a new SaaS product\")\n</code></pre></p>"},{"location":"swarms/structs/heavy_swarm/#real-world-applications","title":"Real-World Applications","text":""},{"location":"swarms/structs/heavy_swarm/#financial-services","title":"Financial Services","text":"<pre><code># Market Analysis\nswarm = HeavySwarm(\n    name=\"FinanceSwarm\",\n    worker_model_name=\"gpt-4o\",\n    show_dashboard=True\n)\n\nresult = swarm.run(\"\"\"\nAnalyze the impact of recent Federal Reserve policy changes on:\n1. Bond markets and yield curves\n2. Equity market valuations\n3. Currency exchange rates\n4. Provide investment recommendations for institutional portfolios\n\"\"\")\n</code></pre>"},{"location":"swarms/structs/heavy_swarm/#use-cases","title":"Use-cases","text":"Use Case Description Portfolio optimization and risk assessment Optimize asset allocation and assess risks Market trend analysis and forecasting Analyze and predict market movements Regulatory compliance evaluation Evaluate adherence to financial regulations Investment strategy development Develop and refine investment strategies Credit risk analysis and modeling Analyze and model credit risk"},{"location":"swarms/structs/heavy_swarm/#healthcare-life-sciences","title":"Healthcare &amp; Life Sciences","text":"<pre><code># Clinical Research Analysis\nswarm = HeavySwarm(\n    name=\"HealthcareSwarm\",\n    worker_model_name=\"gpt-4o\",\n    timeout=600,\n    loops_per_agent=2\n)\n\nresult = swarm.run(\"\"\"\nEvaluate the potential of AI-driven personalized medicine:\n1. Current technological capabilities and limitations\n2. Regulatory landscape and approval pathways\n3. Market opportunities and competitive analysis\n4. Implementation strategies for healthcare systems\n\"\"\")\n</code></pre> <p>Use Cases:</p> Use Case Description Drug discovery and development analysis Analyze and accelerate drug R&amp;D processes Clinical trial optimization Improve design and efficiency of trials Healthcare policy evaluation Assess and inform healthcare policies Medical device market analysis Evaluate trends and opportunities in devices Patient outcome prediction modeling Predict and model patient health outcomes"},{"location":"swarms/structs/heavy_swarm/#technology-innovation","title":"Technology &amp; Innovation","text":"<pre><code># Tech Strategy Analysis\nswarm = HeavySwarm(\n    name=\"TechSwarm\",\n    worker_model_name=\"gpt-4o\",\n    show_dashboard=True,\n    verbose=True\n)\n\nresult = swarm.run(\"\"\"\nAssess the strategic implications of quantum computing adoption:\n1. Technical readiness and hardware developments\n2. Industry applications and use cases\n3. Competitive landscape and key players\n4. Investment and implementation roadmap\n\"\"\")\n</code></pre> <p>Use Cases:</p> Use Case Description Technology roadmap development Plan and prioritize technology initiatives Competitive intelligence gathering Analyze competitors and market trends Innovation pipeline analysis Evaluate and manage innovation projects Digital transformation strategy Develop and implement digital strategies Emerging technology assessment Assess new and disruptive technologies"},{"location":"swarms/structs/heavy_swarm/#manufacturing-supply-chain","title":"Manufacturing &amp; Supply Chain","text":"<pre><code># Supply Chain Optimization\nswarm = HeavySwarm(\n    name=\"ManufacturingSwarm\",\n    worker_model_name=\"gpt-4o\",\n    max_workers=8\n)\n\nresult = swarm.run(\"\"\"\nOptimize global supply chain resilience:\n1. Risk assessment and vulnerability analysis\n2. Alternative sourcing strategies\n3. Technology integration opportunities\n4. Cost-benefit analysis of proposed changes\n\"\"\")\n</code></pre> <p>Use Cases:</p> Use Case Description Supply chain risk management Identify and mitigate supply chain risks Manufacturing process optimization Improve efficiency and productivity Quality control system design Develop systems to ensure product quality Sustainability impact assessment Evaluate environmental and social impacts Logistics network optimization Enhance logistics and distribution networks"},{"location":"swarms/structs/heavy_swarm/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"swarms/structs/heavy_swarm/#custom-agent-configuration","title":"Custom Agent Configuration","text":"<pre><code># High-performance configuration\nswarm = HeavySwarm(\n    name=\"HighPerformanceSwarm\",\n    question_agent_model_name=\"gpt-4o\",\n    worker_model_name=\"gpt-4o\",\n    timeout=900,\n    loops_per_agent=3,\n    max_workers=12,\n    show_dashboard=True,\n    verbose=True\n)\n</code></pre>"},{"location":"swarms/structs/heavy_swarm/#troubleshooting","title":"Troubleshooting","text":"Issue Solution Agent Timeout Increase timeout parameter or reduce task complexity Model Rate Limits Implement backoff strategies or use different models Memory Usage Monitor system resources with large-scale operations Dashboard Performance Disable dashboard for batch processing"},{"location":"swarms/structs/heavy_swarm/#contributing","title":"Contributing","text":"<p>HeavySwarm is part of the Swarms ecosystem. Contributions are welcome for:</p> <ul> <li> <p>New agent specializations</p> </li> <li> <p>Performance optimizations</p> </li> <li> <p>Integration capabilities</p> </li> <li> <p>Documentation improvements</p> </li> </ul>"},{"location":"swarms/structs/heavy_swarm/#acknowledgments","title":"Acknowledgments","text":"<ul> <li> <p>Inspired by X.AI's Grok heavy implementation</p> </li> <li> <p>Built on the Swarms framework</p> </li> <li> <p>Utilizes Rich for dashboard visualization</p> </li> <li> <p>Powered by advanced language models</p> </li> </ul>"},{"location":"swarms/structs/hhcs/","title":"Hybrid Hierarchical-Cluster Swarm [HHCS]","text":"<p>The Hybrid Hierarchical-Cluster Swarm (HHCS) is an advanced AI orchestration architecture that combines hierarchical decision-making with parallel processing capabilities. HHCS enables complex task solving by dynamically routing tasks to specialized agent swarms based on their expertise and capabilities.</p>"},{"location":"swarms/structs/hhcs/#purpose","title":"Purpose","text":"<p>HHCS addresses the challenge of efficiently solving diverse and complex tasks by:</p> <ul> <li> <p>Intelligently routing tasks to the most appropriate specialized swarms</p> </li> <li> <p>Enabling parallel processing of multifaceted problems</p> </li> <li> <p>Maintaining a clear hierarchy for effective decision-making</p> </li> <li> <p>Combining outputs from multiple specialized agents for comprehensive solutions</p> </li> </ul>"},{"location":"swarms/structs/hhcs/#key-features","title":"Key Features","text":"<ul> <li> <p>Router-based task distribution: Central router agent analyzes incoming tasks and directs them to appropriate specialized swarms</p> </li> <li> <p>Hybrid architecture: Combines hierarchical control with clustered specialization</p> </li> <li> <p>Parallel processing: Multiple swarms can work simultaneously on different aspects of complex tasks</p> </li> <li> <p>Flexible swarm types: Supports both sequential and concurrent workflows within swarms</p> </li> <li> <p>Comprehensive result aggregation: Collects and combines outputs from all contributing swarms</p> </li> </ul>"},{"location":"swarms/structs/hhcs/#diagram","title":"Diagram","text":"<p>The HHCS architecture follows a hierarchical structure with the router agent at the top level, specialized swarms at the middle level, and individual agents at the bottom level.</p> <pre><code>flowchart TD\n    Start([Task Input]) --&gt; RouterAgent[Router Agent]\n    RouterAgent --&gt; Analysis{Task Analysis}\n\n    Analysis --&gt;|Analyze Requirements| Selection[Swarm Selection]\n    Selection --&gt;|Select Best Swarm| Route[Route Task]\n\n    Route --&gt; Swarm1[Swarm 1]\n    Route --&gt; Swarm2[Swarm 2]\n    Route --&gt; SwarmN[Swarm N...]\n\n    Swarm1 --&gt;|Process Task| Result1[Swarm 1 Output]\n    Swarm2 --&gt;|Process Task| Result2[Swarm 2 Output]\n    SwarmN --&gt;|Process Task| ResultN[Swarm N Output]\n\n    Result1 --&gt; Conversation[Conversation History]\n    Result2 --&gt; Conversation\n    ResultN --&gt; Conversation\n\n    Conversation --&gt; Output([Final Output])\n\n    subgraph Router Decision Process\n        Analysis\n        Selection\n    end\n\n    subgraph Parallel Task Processing\n        Swarm1\n        Swarm2\n        SwarmN\n    end\n\n    subgraph Results Collection\n        Result1\n        Result2\n        ResultN\n        Conversation\n    end</code></pre>"},{"location":"swarms/structs/hhcs/#hybridhierarchicalclusterswarm-constructor-arguments","title":"<code>HybridHierarchicalClusterSwarm</code> Constructor Arguments","text":"Parameter Type Default Description <code>name</code> string \"Hybrid Hierarchical-Cluster Swarm\" The name of the swarm instance <code>description</code> string \"A swarm that uses a hybrid hierarchical-peer model to solve complex tasks.\" Brief description of the swarm's functionality <code>swarms</code> List[SwarmRouter] [] List of available swarm routers <code>max_loops</code> integer 1 Maximum number of processing loops <code>output_type</code> string \"list\" Format for output (e.g., \"list\", \"json\") <code>router_agent_model_name</code> string \"gpt-4o-mini\" LLM model used by the router agent"},{"location":"swarms/structs/hhcs/#methods","title":"Methods","text":"Method Parameters Return Type Description <code>run</code> <code>task</code> (str) str Processes a single task through the swarm system <code>batched_run</code> <code>tasks</code> (List[str]) List[str] Processes multiple tasks in parallel <code>find_swarm_by_name</code> <code>swarm_name</code> (str) SwarmRouter Retrieves a swarm by its name <code>route_task</code> <code>swarm_name</code> (str), <code>task_description</code> (str) None Routes a task to a specific swarm <code>get_swarms_info</code> None str Returns formatted information about all available swarms"},{"location":"swarms/structs/hhcs/#full-example","title":"Full Example","text":"<pre><code>from swarms import Agent, SwarmRouter\nfrom swarms.structs.hybrid_hiearchical_peer_swarm import (\n    HybridHierarchicalClusterSwarm,\n)\n\n\n# Core Legal Agent Definitions with short, simple prompts\nlitigation_agent = Agent(\n    agent_name=\"Litigator\",\n    system_prompt=\"You handle lawsuits. Analyze facts, build arguments, and develop case strategy.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\ncorporate_agent = Agent(\n    agent_name=\"Corporate-Attorney\",\n    system_prompt=\"You handle business law. Advise on corporate structure, governance, and transactions.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nip_agent = Agent(\n    agent_name=\"IP-Attorney\",\n    system_prompt=\"You protect intellectual property. Handle patents, trademarks, copyrights, and trade secrets.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nemployment_agent = Agent(\n    agent_name=\"Employment-Attorney\",\n    system_prompt=\"You handle workplace matters. Address hiring, termination, discrimination, and labor issues.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\nparalegal_agent = Agent(\n    agent_name=\"Paralegal\",\n    system_prompt=\"You assist attorneys. Conduct research, draft documents, and organize case files.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\ndoc_review_agent = Agent(\n    agent_name=\"Document-Reviewer\",\n    system_prompt=\"You examine documents. Extract key information and identify relevant content.\",\n    model_name=\"groq/deepseek-r1-distill-qwen-32b\",\n    max_loops=1,\n)\n\n# Practice Area Swarm Routers\nlitigation_swarm = SwarmRouter(\n    name=\"litigation-practice\",\n    description=\"Handle all aspects of litigation\",\n    agents=[litigation_agent, paralegal_agent, doc_review_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\ncorporate_swarm = SwarmRouter(\n    name=\"corporate-practice\",\n    description=\"Handle business and corporate legal matters\",\n    agents=[corporate_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\nip_swarm = SwarmRouter(\n    name=\"ip-practice\",\n    description=\"Handle intellectual property matters\",\n    agents=[ip_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\nemployment_swarm = SwarmRouter(\n    name=\"employment-practice\",\n    description=\"Handle employment and labor law matters\",\n    agents=[employment_agent, paralegal_agent],\n    swarm_type=\"SequentialWorkflow\",\n)\n\n# Cross-functional Swarm Router\nm_and_a_swarm = SwarmRouter(\n    name=\"mergers-acquisitions\",\n    description=\"Handle mergers and acquisitions\",\n    agents=[\n        corporate_agent,\n        ip_agent,\n        employment_agent,\n        doc_review_agent,\n    ],\n    swarm_type=\"ConcurrentWorkflow\",\n)\n\ndispute_swarm = SwarmRouter(\n    name=\"dispute-resolution\",\n    description=\"Handle complex disputes requiring multiple specialties\",\n    agents=[litigation_agent, corporate_agent, doc_review_agent],\n    swarm_type=\"ConcurrentWorkflow\",\n)\n\n\nhybrid_hiearchical_swarm = HybridHierarchicalClusterSwarm(\n    name=\"hybrid-hiearchical-swarm\",\n    description=\"A hybrid hiearchical swarm that uses a hybrid hiearchical peer model to solve complex tasks.\",\n    swarms=[\n        litigation_swarm,\n        corporate_swarm,\n        ip_swarm,\n        employment_swarm,\n        m_and_a_swarm,\n        dispute_swarm,\n    ],\n    max_loops=1,\n    router_agent_model_name=\"gpt-4o-mini\",\n)\n\n\nif __name__ == \"__main__\":\n    hybrid_hiearchical_swarm.run(\n        \"What is the best way to file for a patent? for ai technology \"\n    )\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/","title":"<code>HierarchicalSwarm</code>","text":"<p>The <code>HierarchicalSwarm</code> is a sophisticated multi-agent orchestration system that implements a hierarchical workflow pattern. It consists of a director agent that coordinates and distributes tasks to specialized worker agents, creating a structured approach to complex problem-solving.</p>"},{"location":"swarms/structs/hierarchical_swarm/#overview","title":"Overview","text":"<p>The Hierarchical Swarm follows a clear workflow pattern:</p> <ol> <li>Task Reception: User provides a task to the swarm</li> <li>Planning: Director creates a comprehensive plan and distributes orders to agents</li> <li>Execution: Individual agents execute their assigned tasks</li> <li>Feedback Loop: Director evaluates results and issues new orders if needed (up to <code>max_loops</code>)</li> <li>Context Preservation: All conversation history and context is maintained throughout the process</li> </ol>"},{"location":"swarms/structs/hierarchical_swarm/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[User Task] --&gt; B[Director Agent]\n    B --&gt; C[Create Plan &amp; Orders]\n    C --&gt; D[Distribute to Agents]\n    D --&gt; E[Agent 1]\n    D --&gt; F[Agent 2]\n    D --&gt; G[Agent N]\n    E --&gt; H[Execute Task]\n    F --&gt; H\n    G --&gt; H\n    H --&gt; I[Report Results]\n    I --&gt; J[Director Evaluation]\n    J --&gt; K{More Loops?}\n    K --&gt;|Yes| C\n    K --&gt;|No| L[Final Output]</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#key-features","title":"Key Features","text":"<ul> <li>Hierarchical Coordination: Director agent orchestrates all operations</li> <li>Specialized Agents: Each agent has specific expertise and responsibilities</li> <li>Iterative Refinement: Multiple feedback loops for improved results</li> <li>Context Preservation: Full conversation history maintained</li> <li>Flexible Output Formats: Support for various output types (dict, str, list)</li> <li>Comprehensive Logging: Detailed logging for debugging and monitoring</li> </ul>"},{"location":"swarms/structs/hierarchical_swarm/#hierarchicalswarm-constructor","title":"<code>HierarchicalSwarm</code> Constructor","text":"Parameter Type Default Description <code>name</code> <code>str</code> <code>\"HierarchicalAgentSwarm\"</code> The name of the swarm instance <code>description</code> <code>str</code> <code>\"Distributed task swarm\"</code> Brief description of the swarm's functionality <code>director</code> <code>Optional[Union[Agent, Callable, Any]]</code> <code>None</code> The director agent that orchestrates tasks <code>agents</code> <code>List[Union[Agent, Callable, Any]]</code> <code>None</code> List of worker agents in the swarm <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of feedback loops between director and agents <code>output_type</code> <code>OutputType</code> <code>\"dict-all-except-first\"</code> Format for output (dict, str, list) <code>feedback_director_model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Model name for feedback director <code>director_name</code> <code>str</code> <code>\"Director\"</code> Name of the director agent <code>director_model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Model name for the director agent <code>verbose</code> <code>bool</code> <code>False</code> Enable detailed logging <code>add_collaboration_prompt</code> <code>bool</code> <code>True</code> Add collaboration prompts to agents <code>planning_director_agent</code> <code>Optional[Union[Agent, Callable, Any]]</code> <code>None</code> Optional planning agent for enhanced planning"},{"location":"swarms/structs/hierarchical_swarm/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/hierarchical_swarm/#runtask-imgnone-args-kwargs","title":"<code>run(task, img=None, *args, **kwargs)</code>","text":"<p>Executes the hierarchical swarm for a specified number of feedback loops, processing the task through multiple iterations for refinement and improvement.</p>"},{"location":"swarms/structs/hierarchical_swarm/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>task</code> <code>str</code> Required The initial task to be processed by the swarm <code>img</code> <code>str</code> <code>None</code> Optional image input for the agents <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments"},{"location":"swarms/structs/hierarchical_swarm/#returns","title":"Returns","text":"Type Description <code>Any</code> The formatted conversation history as output based on <code>output_type</code>"},{"location":"swarms/structs/hierarchical_swarm/#example","title":"Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized agents\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research and analysis\",\n    model_name=\"gpt-4o\",\n)\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis and valuation\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the hierarchical swarm\nswarm = HierarchicalSwarm(\n    name=\"Financial-Analysis-Swarm\",\n    description=\"A hierarchical swarm for comprehensive financial analysis\",\n    agents=[research_agent, financial_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute a complex task\ntask = \"Analyze the market potential for Tesla (TSLA) stock\"\nresult = swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#steptask-imgnone-args-kwargs","title":"<code>step(task, img=None, *args, **kwargs)</code>","text":"<p>Runs a single step of the hierarchical swarm, executing one complete cycle of planning, distribution, execution, and feedback.</p>"},{"location":"swarms/structs/hierarchical_swarm/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>task</code> <code>str</code> Required The task to be executed in this step <code>img</code> <code>str</code> <code>None</code> Optional image input for the agents <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments"},{"location":"swarms/structs/hierarchical_swarm/#returns_1","title":"Returns","text":"Type Description <code>str</code> Feedback from the director based on agent outputs"},{"location":"swarms/structs/hierarchical_swarm/#example_1","title":"Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create development agents\nfrontend_agent = Agent(\n    agent_name=\"Frontend-Developer\",\n    agent_description=\"Expert in React and modern web development\",\n    model_name=\"gpt-4o\",\n)\n\nbackend_agent = Agent(\n    agent_name=\"Backend-Developer\",\n    agent_description=\"Specialist in Node.js and API development\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the swarm\nswarm = HierarchicalSwarm(\n    name=\"Development-Swarm\",\n    description=\"A hierarchical swarm for software development\",\n    agents=[frontend_agent, backend_agent],\n    max_loops=1,\n    verbose=True,\n)\n\n# Execute a single step\ntask = \"Create a simple web app for file upload and download\"\nfeedback = swarm.step(task=task)\nprint(\"Director Feedback:\", feedback)\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#batched_runtasks-imgnone-args-kwargs","title":"<code>batched_run(tasks, img=None, *args, **kwargs)</code>","text":"<p>Executes the hierarchical swarm for a list of tasks, processing each task through the complete workflow.</p>"},{"location":"swarms/structs/hierarchical_swarm/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>tasks</code> <code>List[str]</code> Required List of tasks to be processed <code>img</code> <code>str</code> <code>None</code> Optional image input for the agents <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments"},{"location":"swarms/structs/hierarchical_swarm/#returns_2","title":"Returns","text":"Type Description <code>List[Any]</code> List of results for each task"},{"location":"swarms/structs/hierarchical_swarm/#example_2","title":"Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create analysis agents\nmarket_agent = Agent(\n    agent_name=\"Market-Analyst\",\n    agent_description=\"Expert in market analysis and trends\",\n    model_name=\"gpt-4o\",\n)\n\ntechnical_agent = Agent(\n    agent_name=\"Technical-Analyst\",\n    agent_description=\"Specialist in technical analysis and patterns\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the swarm\nswarm = HierarchicalSwarm(\n    name=\"Analysis-Swarm\",\n    description=\"A hierarchical swarm for comprehensive analysis\",\n    agents=[market_agent, technical_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute multiple tasks\ntasks = [\n    \"Analyze Apple (AAPL) stock performance\",\n    \"Evaluate Microsoft (MSFT) market position\",\n    \"Assess Google (GOOGL) competitive landscape\"\n]\n\nresults = swarm.batched_run(tasks=tasks)\nfor i, result in enumerate(results):\n    print(f\"Task {i+1} Result:\", result)\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#advanced-usage-examples","title":"Advanced Usage Examples","text":""},{"location":"swarms/structs/hierarchical_swarm/#financial-analysis-swarm","title":"Financial Analysis Swarm","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized financial agents\nmarket_research_agent = Agent(\n    agent_name=\"Market-Research-Specialist\",\n    agent_description=\"Expert in market research, trend analysis, and competitive intelligence\",\n    system_prompt=\"\"\"You are a senior market research specialist with expertise in:\n    - Market trend analysis and forecasting\n    - Competitive landscape assessment\n    - Consumer behavior analysis\n    - Industry report generation\n    - Market opportunity identification\n    - Risk assessment and mitigation strategies\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n)\n\nfinancial_analyst_agent = Agent(\n    agent_name=\"Financial-Analysis-Expert\",\n    agent_description=\"Specialist in financial statement analysis, valuation, and investment research\",\n    system_prompt=\"\"\"You are a senior financial analyst with deep expertise in:\n    - Financial statement analysis (income statement, balance sheet, cash flow)\n    - Valuation methodologies (DCF, comparable company analysis, precedent transactions)\n    - Investment research and due diligence\n    - Financial modeling and forecasting\n    - Risk assessment and portfolio analysis\n    - ESG (Environmental, Social, Governance) analysis\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n)\n\n# Initialize the hierarchical swarm\nfinancial_analysis_swarm = HierarchicalSwarm(\n    name=\"Financial-Analysis-Hierarchical-Swarm\",\n    description=\"A hierarchical swarm for comprehensive financial analysis with specialized agents\",\n    agents=[market_research_agent, financial_analyst_agent],\n    max_loops=2,\n    verbose=True,\n)\n\n# Execute financial analysis\ntask = \"Conduct a comprehensive analysis of Tesla (TSLA) stock including market position, financial health, and investment potential\"\nresult = financial_analysis_swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#development-department-swarm","title":"Development Department Swarm","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.hiearchical_swarm import HierarchicalSwarm\n\n# Create specialized development agents\nfrontend_developer_agent = Agent(\n    agent_name=\"Frontend-Developer\",\n    agent_description=\"Senior frontend developer expert in modern web technologies and user experience\",\n    system_prompt=\"\"\"You are a senior frontend developer with expertise in:\n    - Modern JavaScript frameworks (React, Vue, Angular)\n    - TypeScript and modern ES6+ features\n    - CSS frameworks and responsive design\n    - State management (Redux, Zustand, Context API)\n    - Web performance optimization\n    - Accessibility (WCAG) and SEO best practices\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n)\n\nbackend_developer_agent = Agent(\n    agent_name=\"Backend-Developer\",\n    agent_description=\"Senior backend developer specializing in server-side development and API design\",\n    system_prompt=\"\"\"You are a senior backend developer with expertise in:\n    - Server-side programming languages (Python, Node.js, Java, Go)\n    - Web frameworks (Django, Flask, Express, Spring Boot)\n    - Database design and optimization (SQL, NoSQL)\n    - API design and REST/GraphQL implementation\n    - Authentication and authorization systems\n    - Microservices architecture and containerization\"\"\",\n    model_name=\"claude-3-sonnet-20240229\",\n)\n\n# Initialize the development swarm\ndevelopment_department_swarm = HierarchicalSwarm(\n    name=\"Autonomous-Development-Department\",\n    description=\"A fully autonomous development department with specialized agents\",\n    agents=[frontend_developer_agent, backend_developer_agent],\n    max_loops=3,\n    verbose=True,\n)\n\n# Execute development project\ntask = \"Create a simple web app that allows users to upload a file and then download it. The app should be built with React and Node.js.\"\nresult = development_department_swarm.run(task=task)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/hierarchical_swarm/#output-types","title":"Output Types","text":"<p>The <code>HierarchicalSwarm</code> supports various output formats through the <code>output_type</code> parameter:</p> Output Type Description Use Case <code>\"dict-all-except-first\"</code> Returns all conversation history as a dictionary, excluding the first message Default format for comprehensive analysis <code>\"dict\"</code> Returns conversation history as a dictionary When you need structured data <code>\"str\"</code> Returns conversation history as a string For simple text output <code>\"list\"</code> Returns conversation history as a list For sequential processing"},{"location":"swarms/structs/hierarchical_swarm/#best-practices","title":"Best Practices","text":"<ol> <li>Agent Specialization: Create agents with specific, well-defined expertise areas</li> <li>Clear Task Descriptions: Provide detailed, actionable task descriptions</li> <li>Appropriate Loop Count: Set <code>max_loops</code> based on task complexity (1-3 for most tasks)</li> <li>Verbose Logging: Enable verbose mode during development for debugging</li> <li>Context Preservation: Leverage the built-in conversation history for continuity</li> <li>Error Handling: Implement proper error handling for production use</li> </ol>"},{"location":"swarms/structs/hierarchical_swarm/#error-handling","title":"Error Handling","text":"<p>The <code>HierarchicalSwarm</code> includes comprehensive error handling with detailed logging. Common issues and solutions:</p> <ul> <li>No Agents: Ensure at least one agent is provided</li> <li>Invalid Director: Verify the director agent is properly configured</li> <li>Max Loops: Set <code>max_loops</code> to a value greater than 0</li> <li>Model Issues: Check that all agents have valid model configurations</li> </ul>"},{"location":"swarms/structs/hierarchical_swarm/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Loop Optimization: Balance between thoroughness and performance with <code>max_loops</code></li> <li>Agent Count: More agents increase coordination overhead</li> <li>Model Selection: Choose appropriate models for your use case and budget</li> <li>Verbose Mode: Disable verbose logging in production for better performance </li> </ul>"},{"location":"swarms/structs/image_batch_agent/","title":"ImageAgentBatchProcessor Documentation","text":""},{"location":"swarms/structs/image_batch_agent/#overview","title":"Overview","text":"<p>The <code>ImageAgentBatchProcessor</code> is a high-performance parallel image processing system designed for running AI agents on multiple images concurrently. It provides robust error handling, logging, and flexible configuration options.</p>"},{"location":"swarms/structs/image_batch_agent/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#class-arguments","title":"Class Arguments","text":"Parameter Type Default Description agents Union[Agent, List[Agent], Callable, List[Callable]] Required Single agent or list of agents to process images max_workers int None Maximum number of parallel workers (defaults to 95% of CPU cores) supported_formats List[str] ['.jpg', '.jpeg', '.png'] List of supported image file extensions"},{"location":"swarms/structs/image_batch_agent/#methods","title":"Methods","text":""},{"location":"swarms/structs/image_batch_agent/#run","title":"run()","text":"<p>Description: Main method for processing multiple images in parallel with configured agents. Can handle single images, multiple images, or entire directories.</p> <p>Arguments:</p> Parameter Type Required Description image_paths Union[str, List[str], Path] Yes Single image path, list of paths, or directory path tasks Union[str, List[str]] Yes Single task or list of tasks to perform on each image <p>Returns: List[Dict[str, Any]] - List of processing results for each image</p> <p>Example:</p> <pre><code>from swarms import Agent\nfrom swarms.structs import ImageAgentBatchProcessor\nfrom pathlib import Path\n\n# Initialize agent and processor\nagent = Agent(api_key=\"your-api-key\", model=\"gpt-4-vision\")\nprocessor = ImageAgentBatchProcessor(agents=agent)\n\n# Example 1: Process single image\nresults = processor.run(\n    image_paths=\"path/to/image.jpg\",\n    tasks=\"Describe this image\"\n)\n\n# Example 2: Process multiple images\nresults = processor.run(\n    image_paths=[\"image1.jpg\", \"image2.jpg\"],\n    tasks=[\"Describe objects\", \"Identify colors\"]\n)\n\n# Example 3: Process directory\nresults = processor.run(\n    image_paths=Path(\"./images\"),\n    tasks=\"Analyze image content\"\n)\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#_validate_image_path","title":"_validate_image_path()","text":"<p>Description: Internal method that validates if an image path exists and has a supported format.</p> <p>Arguments:</p> Parameter Type Required Description image_path Union[str, Path] Yes Path to the image file to validate <p>Returns: Path - Validated Path object</p> <p>Example: <pre><code>from swarms.structs import ImageAgentBatchProcessor, ImageProcessingError\nfrom pathlib import Path\n\nprocessor = ImageAgentBatchProcessor(agents=agent)\n\ntry:\n    validated_path = processor._validate_image_path(\"image.jpg\")\n    print(f\"Valid image path: {validated_path}\")\nexcept ImageProcessingError as e:\n    print(f\"Invalid image path: {e}\")\n</code></pre></p>"},{"location":"swarms/structs/image_batch_agent/#_process_single_image","title":"_process_single_image()","text":"<p>Description: Internal method that processes a single image with one agent and one or more tasks.</p> <p>Arguments:</p> Parameter Type Required Description image_path Path Yes Path to the image to process tasks Union[str, List[str]] Yes Tasks to perform on the image agent Agent Yes Agent to use for processing <p>Returns: Dict[str, Any] - Processing results for the image</p> <p>Example:</p> <pre><code>from swarms import Agent\nfrom swarms.structs import ImageAgentBatchProcessor\nfrom pathlib import Path\n\nagent = Agent(api_key=\"your-api-key\", model=\"gpt-4-vision\")\nprocessor = ImageAgentBatchProcessor(agents=agent)\n\ntry:\n    result = processor._process_single_image(\n        image_path=Path(\"image.jpg\"),\n        tasks=[\"Describe image\", \"Identify objects\"],\n        agent=agent\n    )\n    print(f\"Processing results: {result}\")\nexcept Exception as e:\n    print(f\"Processing failed: {e}\")\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#call","title":"call()","text":"<p>Description: Makes the ImageAgentBatchProcessor callable like a function. Redirects to the run() method.</p> <p>Arguments:</p> Parameter Type Required Description *args Any No Variable length argument list passed to run() **kwargs Any No Keyword arguments passed to run() <p>Returns: List[Dict[str, Any]] - Same as run() method</p> <p>Example:</p> <pre><code>from swarms import Agent\nfrom swarms.structs import ImageAgentBatchProcessor\n\n# Initialize\nagent = Agent(api_key=\"your-api-key\", model=\"gpt-4-vision\")\nprocessor = ImageAgentBatchProcessor(agents=agent)\n\n# Using __call__\nresults = processor(\n    image_paths=[\"image1.jpg\", \"image2.jpg\"],\n    tasks=\"Describe the image\"\n)\n\n# This is equivalent to:\nresults = processor.run(\n    image_paths=[\"image1.jpg\", \"image2.jpg\"],\n    tasks=\"Describe the image\"\n)\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#return-format","title":"Return Format","text":"<p>The processor returns a list of dictionaries with the following structure:</p> <pre><code>{\n    \"image_path\": str,          # Path to the processed image\n    \"results\": {               # Results for each task\n        \"task_name\": result,   # Task-specific results\n    },\n    \"processing_time\": float   # Processing time in seconds\n}\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#complete-usage-examples","title":"Complete Usage Examples","text":""},{"location":"swarms/structs/image_batch_agent/#1-basic-usage-with-single-agent","title":"1. Basic Usage with Single Agent","text":"<pre><code>from swarms import Agent\nfrom swarms.structs import ImageAgentBatchProcessor\n\n# Initialize an agent\nagent = Agent(\n    api_key=\"your-api-key\",\n    model=\"gpt-4-vision\"\n)\n\n# Create processor\nprocessor = ImageAgentBatchProcessor(agents=agent)\n\n# Process single image\nresults = processor.run(\n    image_paths=\"path/to/image.jpg\",\n    tasks=\"Describe this image in detail\"\n)\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#2-processing-multiple-images-with-multiple-tasks","title":"2. Processing Multiple Images with Multiple Tasks","text":"<pre><code># Initialize with multiple agents\nagent1 = Agent(api_key=\"key1\", model=\"gpt-4-vision\")\nagent2 = Agent(api_key=\"key2\", model=\"claude-3\")\n\nprocessor = ImageAgentBatchProcessor(\n    agents=[agent1, agent2],\n    supported_formats=['.jpg', '.png', '.webp']\n)\n\n# Define multiple tasks\ntasks = [\n    \"Describe the main objects in the image\",\n    \"What is the dominant color?\",\n    \"Identify any text in the image\"\n]\n\n# Process a directory of images\nresults = processor.run(\n    image_paths=\"path/to/image/directory\",\n    tasks=tasks\n)\n\n# Process results\nfor result in results:\n    print(f\"Image: {result['image_path']}\")\n    for task, output in result['results'].items():\n        print(f\"Task: {task}\")\n        print(f\"Result: {output}\")\n    print(f\"Processing time: {result['processing_time']:.2f} seconds\")\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#3-custom-error-handling","title":"3. Custom Error Handling","text":"<pre><code>from swarms.structs import ImageAgentBatchProcessor, ImageProcessingError\n\ntry:\n    processor = ImageAgentBatchProcessor(agents=agent)\n    results = processor.run(\n        image_paths=[\"image1.jpg\", \"image2.png\", \"invalid.txt\"],\n        tasks=\"Analyze the image\"\n    )\nexcept ImageProcessingError as e:\n    print(f\"Image processing failed: {e}\")\nexcept InvalidAgentError as e:\n    print(f\"Agent configuration error: {e}\")\n</code></pre>"},{"location":"swarms/structs/image_batch_agent/#best-practices","title":"Best Practices","text":"Best Practice Description Resource Management \u2022 The processor automatically uses 95% of available CPU cores\u2022 For memory-intensive operations, consider reducing <code>max_workers</code> Error Handling \u2022 Always wrap processor calls in try-except blocks\u2022 Check the results for any error keys Task Design \u2022 Keep tasks focused and specific\u2022 Group related tasks together for efficiency Performance Optimization \u2022 Process images in batches for better throughput\u2022 Use multiple agents for different types of analysis"},{"location":"swarms/structs/image_batch_agent/#limitations","title":"Limitations","text":"Limitation Description File Format Support Only supports image file formats specified in <code>supported_formats</code> Agent Requirements Requires valid agent configurations Resource Scaling Memory usage scales with number of concurrent processes <p>This documentation provides a comprehensive guide to using the <code>ImageAgentBatchProcessor</code>. The class is designed to be both powerful and flexible, allowing for various use cases from simple image analysis to complex multi-agent processing pipelines.</p>"},{"location":"swarms/structs/interactive_groupchat/","title":"InteractiveGroupChat Documentation","text":"<p>The InteractiveGroupChat is a sophisticated multi-agent system that enables interactive conversations between users and AI agents using @mentions. This system allows users to direct tasks to specific agents and facilitates collaborative responses when multiple agents are mentioned.</p>"},{"location":"swarms/structs/interactive_groupchat/#features","title":"Features","text":"Feature Description @mentions Support Direct tasks to specific agents using @agent_name syntax Multi-Agent Collaboration Multiple mentioned agents can see and respond to each other's tasks Enhanced Collaborative Prompts Agents are trained to acknowledge, build upon, and synthesize each other's responses Speaker Functions Control the order in which agents respond (round robin, random, priority, custom) Dynamic Speaker Management Change speaker functions and priorities during runtime Random Dynamic Speaker Advanced speaker function that follows @mentions in agent responses Parallel and Sequential Strategies Support for both parallel and sequential agent execution Callable Function Support Supports both Agent instances and callable functions as chat participants Comprehensive Error Handling Custom error classes for different scenarios Conversation History Maintains a complete history of the conversation Flexible Output Formatting Configurable output format for conversation history Interactive Terminal Mode Full REPL interface for real-time chat with agents"},{"location":"swarms/structs/interactive_groupchat/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#methods-reference","title":"Methods Reference","text":""},{"location":"swarms/structs/interactive_groupchat/#constructor-__init__","title":"Constructor (<code>__init__</code>)","text":"<p>Description: Initializes a new InteractiveGroupChat instance with the specified configuration.</p> <p>Arguments:</p> Parameter Type Description Default <code>id</code> str Unique identifier for the chat auto-generated key <code>name</code> str Name of the group chat \"InteractiveGroupChat\" <code>description</code> str Description of the chat's purpose generic description <code>agents</code> List[Union[Agent, Callable]] List of participating agents empty list <code>max_loops</code> int Maximum conversation turns 1 <code>output_type</code> str Type of output format \"string\" <code>interactive</code> bool Whether to enable interactive mode False <code>speaker_function</code> Union[str, Callable] Function to determine speaking order round_robin_speaker <code>speaker_state</code> dict Initial state for speaker function {\"current_index\": 0} <p>Example:</p> <pre><code>from swarms import Agent, InteractiveGroupChat\n\n# Create agents\nfinancial_advisor = Agent(\n    agent_name=\"FinancialAdvisor\",\n    system_prompt=\"You are a financial advisor specializing in investment strategies.\",\n    model_name=\"gpt-4\"\n)\n\ntax_expert = Agent(\n    agent_name=\"TaxExpert\",\n    system_prompt=\"You are a tax expert providing tax-related guidance.\",\n    model_name=\"gpt-4\"\n)\n\n# Initialize group chat with speaker function\nfrom swarms.structs.interactive_groupchat import round_robin_speaker\n\nchat = InteractiveGroupChat(\n    id=\"finance-chat-001\",\n    name=\"Financial Advisory Team\",\n    description=\"Expert financial guidance team\",\n    agents=[financial_advisor, tax_expert],\n    max_loops=3,\n    output_type=\"string\",\n    interactive=True,\n    speaker_function=round_robin_speaker\n)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#run-method-run","title":"Run Method (<code>run</code>)","text":"<p>Description: Processes a task and gets responses from mentioned agents. This is the main method for sending tasks in non-interactive mode.</p> <p>Arguments:</p> <ul> <li><code>task</code> (str): The input task containing @mentions to agents</li> <li><code>img</code> (Optional[str]): Optional image for the task</li> <li><code>imgs</code> (Optional[List[str]]): Optional list of images for the task</li> </ul> <p>Returns:</p> <ul> <li>str: Formatted conversation history including agent responses</li> </ul> <p>Example: <pre><code># Single agent interaction\nresponse = chat.run(\"@FinancialAdvisor what are the best ETFs for 2024?\")\nprint(response)\n\n# Multiple agent collaboration\nresponse = chat.run(\"@FinancialAdvisor and @TaxExpert, how can I minimize taxes on my investments?\")\nprint(response)\n\n# With image input\nresponse = chat.run(\"@FinancialAdvisor analyze this chart\", img=\"chart.png\")\nprint(response)\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#start-interactive-session-start_interactive_session","title":"Start Interactive Session (<code>start_interactive_session</code>)","text":"<p>Description: Starts an interactive terminal session for real-time chat with agents. This creates a REPL (Read-Eval-Print Loop) interface.</p> <p>Arguments: None</p> <p>Features: - Real-time chat with agents using @mentions - View available agents and their descriptions - Change speaker functions during the session - Built-in help system - Graceful exit with 'exit' or 'quit' commands</p> <p>Example:</p> <pre><code># Initialize chat with interactive mode\nchat = InteractiveGroupChat(\n    agents=[financial_advisor, tax_expert],\n    interactive=True\n)\n\n# Start the interactive session\nchat.start_interactive_session()\n</code></pre> <p>Interactive Session Commands: - <code>@agent_name message</code> - Mention specific agents - <code>help</code> or <code>?</code> - Show help information - <code>speaker</code> - Change speaker function - <code>exit</code> or <code>quit</code> - End the session</p>"},{"location":"swarms/structs/interactive_groupchat/#set-speaker-function-set_speaker_function","title":"Set Speaker Function (<code>set_speaker_function</code>)","text":"<p>Description: </p> <p>Dynamically changes the speaker function and optional state during runtime.</p> <p>Arguments:</p> <ul> <li><code>speaker_function</code> (Union[str, Callable]): Function that determines speaking order</li> <li>String options: \"round-robin-speaker\", \"random-speaker\", \"priority-speaker\", \"random-dynamic-speaker\"</li> <li>Callable: Custom function that takes (agents: List[str], **kwargs) -&gt; str</li> <li><code>speaker_state</code> (dict, optional): State for the speaker function</li> </ul> <p>Example: <pre><code>from swarms.structs.interactive_groupchat import random_speaker, priority_speaker\n\n# Change to random speaker function\nchat.set_speaker_function(random_speaker)\n\n# Change to priority speaker with custom priorities\nchat.set_speaker_function(priority_speaker, {\"financial_advisor\": 3, \"tax_expert\": 2})\n\n# Change to random dynamic speaker\nchat.set_speaker_function(\"random-dynamic-speaker\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#get-available-speaker-functions-get_available_speaker_functions","title":"Get Available Speaker Functions (<code>get_available_speaker_functions</code>)","text":"<p>Description: </p> <p>Returns a list of all available built-in speaker function names.</p> <p>Arguments: None</p> <p>Returns:</p> <ul> <li>List[str]: List of available speaker function names</li> </ul> <p>Example: <pre><code>available_functions = chat.get_available_speaker_functions()\nprint(available_functions)\n# Output: ['round-robin-speaker', 'random-speaker', 'priority-speaker', 'random-dynamic-speaker']\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#get-current-speaker-function-get_current_speaker_function","title":"Get Current Speaker Function (<code>get_current_speaker_function</code>)","text":"<p>Description: </p> <p>Returns the name of the currently active speaker function.</p> <p>Arguments: None</p> <p>Returns:</p> <ul> <li>str: Name of the current speaker function, or \"custom\" if it's a custom function</li> </ul> <p>Example: <pre><code>current_function = chat.get_current_speaker_function()\nprint(current_function)  # Output: \"round-robin-speaker\"\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#set-priorities-set_priorities","title":"Set Priorities (<code>set_priorities</code>)","text":"<p>Description: </p> <p>Sets agent priorities for priority-based speaking order.</p> <p>Arguments:</p> <ul> <li><code>priorities</code> (dict): Dictionary mapping agent names to priority weights</li> </ul> <p>Example: <pre><code># Set agent priorities (higher numbers = higher priority)\nchat.set_priorities({\n    \"financial_advisor\": 5,\n    \"tax_expert\": 3,\n    \"investment_analyst\": 1\n})\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#set-dynamic-strategy-set_dynamic_strategy","title":"Set Dynamic Strategy (<code>set_dynamic_strategy</code>)","text":"<p>Description: </p> <p>Sets the strategy for the random-dynamic-speaker function.</p> <p>Arguments:</p> <ul> <li><code>strategy</code> (str): Either \"sequential\" or \"parallel\"</li> <li>\"sequential\": Process one agent at a time based on @mentions</li> <li>\"parallel\": Process all mentioned agents simultaneously</li> </ul> <p>Example: <pre><code># Set to sequential strategy (one agent at a time)\nchat.set_dynamic_strategy(\"sequential\")\n\n# Set to parallel strategy (all mentioned agents respond simultaneously)\nchat.set_dynamic_strategy(\"parallel\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#extract-mentions-_extract_mentions","title":"Extract Mentions (<code>_extract_mentions</code>)","text":"<p>Description: </p> <p>Internal method that extracts @mentions from a task. Used by the run method to identify which agents should respond.</p> <p>Arguments:</p> <ul> <li><code>task</code> (str): The input task to extract mentions from</li> </ul> <p>Returns:</p> <ul> <li>List[str]: List of mentioned agent names</li> </ul> <p>Example: <pre><code># Internal usage example (not typically called directly)\nchat = InteractiveGroupChat(agents=[financial_advisor, tax_expert])\nmentions = chat._extract_mentions(\"@FinancialAdvisor and @TaxExpert, please help\")\nprint(mentions)  # ['FinancialAdvisor', 'TaxExpert']\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#validate-initialization-_validate_initialization","title":"Validate Initialization (<code>_validate_initialization</code>)","text":"<p>Description: </p> <p>Internal method that validates the group chat configuration during initialization.</p> <p>Arguments: None</p> <p>Example:</p> <pre><code># Internal validation happens automatically during initialization\nchat = InteractiveGroupChat(\n    agents=[financial_advisor],  # Valid: at least one agent\n    max_loops=5  # Valid: positive number\n)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#setup-conversation-context-_setup_conversation_context","title":"Setup Conversation Context (<code>_setup_conversation_context</code>)","text":"<p>Description: </p> <p>Internal method that sets up the initial conversation context with group chat information.</p> <p>Arguments:</p> <p>None</p> <p>Example:</p> <pre><code># Context is automatically set up during initialization\nchat = InteractiveGroupChat(\n    name=\"Investment Team\",\n    description=\"Expert investment advice\",\n    agents=[financial_advisor, tax_expert]\n)\n# The conversation context now includes chat name, description, and agent info\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#update-agent-prompts-_update_agent_prompts","title":"Update Agent Prompts (<code>_update_agent_prompts</code>)","text":"<p>Description: </p> <p>Internal method that updates each agent's system prompt with information about other agents and the group chat. This includes enhanced collaborative instructions that teach agents how to acknowledge, build upon, and synthesize each other's responses.</p> <p>Arguments:</p> <p>None</p> <p>Example: <pre><code># Agent prompts are automatically updated during initialization\nchat = InteractiveGroupChat(agents=[financial_advisor, tax_expert])\n# Each agent now knows about the other participants and how to collaborate effectively\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#get-speaking-order-_get_speaking_order","title":"Get Speaking Order (<code>_get_speaking_order</code>)","text":"<p>Description: </p> <p>Internal method that determines the speaking order using the configured speaker function.</p> <p>Arguments:</p> <ul> <li><code>mentioned_agents</code> (List[str]): List of agent names that were mentioned</li> </ul> <p>Returns:</p> <ul> <li>List[str]: List of agent names in the order they should speak</li> </ul> <p>Example: <pre><code># Internal usage (not typically called directly)\nmentioned = [\"financial_advisor\", \"tax_expert\"]\norder = chat._get_speaking_order(mentioned)\nprint(order)  # Order determined by speaker function\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#speaker-functions","title":"Speaker Functions","text":"<p>InteractiveGroupChat supports various speaker functions that control the order in which agents respond when multiple agents are mentioned.</p>"},{"location":"swarms/structs/interactive_groupchat/#built-in-speaker-functions","title":"Built-in Speaker Functions","text":""},{"location":"swarms/structs/interactive_groupchat/#round-robin-speaker-round_robin_speaker","title":"Round Robin Speaker (<code>round_robin_speaker</code>)","text":"<p>Agents speak in a fixed order, cycling through the list in sequence.</p> <pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, round_robin_speaker\n\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=round_robin_speaker,\n    interactive=False,\n)\n</code></pre> <p>Behavior:</p> <ul> <li> <p>Agents speak in the order they were mentioned</p> </li> <li> <p>Maintains state between calls to continue the cycle</p> </li> <li> <p>Predictable and fair distribution of speaking turns</p> </li> </ul>"},{"location":"swarms/structs/interactive_groupchat/#random-speaker-random_speaker","title":"Random Speaker (<code>random_speaker</code>)","text":"<p>Agents speak in random order each time.</p> <pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, random_speaker\n\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=random_speaker,\n    interactive=False,\n)\n</code></pre> <p>Behavior:</p> <ul> <li> <p>Speaking order is randomized for each task</p> </li> <li> <p>Provides variety and prevents bias toward first-mentioned agents</p> </li> <li> <p>Good for brainstorming sessions</p> </li> </ul>"},{"location":"swarms/structs/interactive_groupchat/#priority-speaker-priority_speaker","title":"Priority Speaker (<code>priority_speaker</code>)","text":"<p>Agents speak based on priority weights assigned to each agent.</p> <pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, priority_speaker\n\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=priority_speaker,\n    speaker_state={\"priorities\": {\"financial_advisor\": 3, \"tax_expert\": 2, \"analyst\": 1}},\n    interactive=False,\n)\n</code></pre> <p>Behavior:</p> <ul> <li> <p>Higher priority agents speak first</p> </li> <li> <p>Uses weighted probability for selection</p> </li> <li> <p>Good for hierarchical teams or expert-led discussions</p> </li> </ul>"},{"location":"swarms/structs/interactive_groupchat/#random-dynamic-speaker-random_dynamic_speaker","title":"Random Dynamic Speaker (<code>random_dynamic_speaker</code>)","text":"<p>Advanced speaker function that follows @mentions in agent responses, enabling dynamic conversation flow.</p> <pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, random_dynamic_speaker\n\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=random_dynamic_speaker,\n    speaker_state={\"strategy\": \"parallel\"},  # or \"sequential\"\n    interactive=False,\n)\n</code></pre> <p>Behavior:</p> <ul> <li>First Call: Randomly selects an agent to start the conversation</li> <li>Subsequent Calls: Extracts @mentions from the previous agent's response and selects the next speaker(s)</li> <li>Two Strategies:</li> <li>Sequential: Processes one agent at a time based on @mentions</li> <li>Parallel: Processes all mentioned agents simultaneously</li> </ul> <p>Example Dynamic Flow: <pre><code># Agent A responds: \"I think @AgentB should analyze this data and @AgentC should review the methodology\"\n# With sequential strategy: Agent B speaks next\n# With parallel strategy: Both Agent B and Agent C speak simultaneously\n</code></pre></p> <p>Use Cases: - Complex problem-solving where agents need to delegate to specific experts - Dynamic workflows where the conversation flow depends on agent responses - Collaborative decision-making processes</p>"},{"location":"swarms/structs/interactive_groupchat/#custom-speaker-functions","title":"Custom Speaker Functions","text":"<p>You can create your own speaker functions to implement custom logic:</p> <pre><code>def custom_speaker(agents: List[str], **kwargs) -&gt; str:\n    \"\"\"\n    Custom speaker function that selects agents based on specific criteria.\n\n    Args:\n        agents: List of agent names\n        **kwargs: Additional arguments (context, time, etc.)\n\n    Returns:\n        Selected agent name\n    \"\"\"\n    # Your custom logic here\n    if \"urgent\" in kwargs.get(\"context\", \"\"):\n        return \"emergency_agent\" if \"emergency_agent\" in agents else agents[0]\n\n    # Default to first agent\n    return agents[0]\n\n# Use custom speaker function\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=custom_speaker,\n    interactive=False,\n)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#dynamic-speaker-function-changes","title":"Dynamic Speaker Function Changes","text":"<p>You can change the speaker function during runtime:</p> <pre><code># Start with round robin\nchat = InteractiveGroupChat(\n    agents=agents,\n    speaker_function=round_robin_speaker,\n    interactive=False,\n)\n\n# Change to random\nchat.set_speaker_function(random_speaker)\n\n# Change to priority with custom priorities\nchat.set_priorities({\"financial_advisor\": 5, \"tax_expert\": 3, \"analyst\": 1})\nchat.set_speaker_function(priority_speaker)\n\n# Change to dynamic speaker with parallel strategy\nchat.set_speaker_function(\"random-dynamic-speaker\")\nchat.set_dynamic_strategy(\"parallel\")\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#enhanced-collaborative-behavior","title":"Enhanced Collaborative Behavior","text":"<p>The InteractiveGroupChat now includes enhanced collaborative prompts that ensure agents work together effectively.</p>"},{"location":"swarms/structs/interactive_groupchat/#collaborative-response-protocol","title":"Collaborative Response Protocol","text":"<p>Every agent receives instructions to:</p> <ol> <li>Read and understand all previous responses from other agents</li> <li>Acknowledge what other agents have said</li> <li>Build upon previous insights rather than repeating information</li> <li>Synthesize multiple perspectives when possible</li> <li>Delegate appropriately using @mentions</li> </ol>"},{"location":"swarms/structs/interactive_groupchat/#response-structure","title":"Response Structure","text":"<p>Agents are guided to structure their responses as:</p> <ol> <li>ACKNOWLEDGE: \"I've reviewed the responses from @agent1 and @agent2...\"</li> <li>BUILD: \"Building on @agent1's analysis of the data...\"</li> <li>CONTRIBUTE: \"From my perspective, I would add...\"</li> <li>COLLABORATE: \"To get a complete picture, let me ask @agent3 to...\"</li> <li>SYNTHESIZE: \"Combining our insights, the key findings are...\"</li> </ol>"},{"location":"swarms/structs/interactive_groupchat/#example-collaborative-response","title":"Example Collaborative Response","text":"<pre><code>task = \"Analyze our Q3 performance. @analyst @researcher @strategist\"\n\n# Expected collaborative behavior:\n# Analyst: \"Based on the data analysis, I can see clear growth trends in Q3...\"\n# Researcher: \"Building on @analyst's data insights, I can add that market research shows...\"\n# Strategist: \"Synthesizing @analyst's data and @researcher's market insights, I recommend...\"\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#error-classes","title":"Error Classes","text":""},{"location":"swarms/structs/interactive_groupchat/#interactivegroupchaterror","title":"InteractiveGroupChatError","text":"<p>Description: </p> <p>Base exception class for InteractiveGroupChat errors.</p> <p>Example: <pre><code>try:\n    # Some operation that might fail\n    chat.run(\"@InvalidAgent hello\")\nexcept InteractiveGroupChatError as e:\n    print(f\"Chat error occurred: {e}\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#agentnotfounderror","title":"AgentNotFoundError","text":"<p>Description: </p> <p>Raised when a mentioned agent is not found in the group.</p> <p>Example: <pre><code>try:\n    chat.run(\"@NonExistentAgent hello!\")\nexcept AgentNotFoundError as e:\n    print(f\"Agent not found: {e}\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#nomentionedagentserror","title":"NoMentionedAgentsError","text":"<p>Description: </p> <p>Raised when no agents are mentioned in the task.</p> <p>Example:</p> <pre><code>try:\n    chat.run(\"Hello everyone!\")  # No @mentions\nexcept NoMentionedAgentsError as e:\n    print(f\"No agents mentioned: {e}\")\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#invalidtaskformaterror","title":"InvalidTaskFormatError","text":"<p>Description: </p> <p>Raised when the task format is invalid.</p> <p>Example: <pre><code>try:\n    chat.run(\"@Invalid@Format\")\nexcept InvalidTaskFormatError as e:\n    print(f\"Invalid task format: {e}\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#invalidspeakerfunctionerror","title":"InvalidSpeakerFunctionError","text":"<p>Description: </p> <p>Raised when an invalid speaker function is provided.</p> <p>Example: <pre><code>def invalid_speaker(agents, **kwargs):\n    return 123  # Should return string, not int\n\ntry:\n    chat = InteractiveGroupChat(\n        agents=agents,\n        speaker_function=invalid_speaker,\n    )\nexcept InvalidSpeakerFunctionError as e:\n    print(f\"Invalid speaker function: {e}\")\n</code></pre></p>"},{"location":"swarms/structs/interactive_groupchat/#best-practices","title":"Best Practices","text":"Best Practice Description Example Agent Naming Use clear, unique names for agents to avoid confusion <code>financial_advisor</code>, <code>tax_expert</code> Task Format Always use @mentions to direct tasks to specific agents <code>@financial_advisor What's your investment advice?</code> Speaker Functions Choose appropriate speaker functions for your use case Round robin for fairness, priority for expert-led discussions Dynamic Speaker Use random-dynamic-speaker for complex workflows with delegation When agents need to call on specific experts Strategy Selection Choose sequential for focused discussions, parallel for brainstorming Sequential for analysis, parallel for idea generation Collaborative Design Design agents with complementary expertise for better collaboration Analyst + Researcher + Strategist Error Handling Implement proper error handling for various scenarios <code>try/except</code> blocks for <code>AgentNotFoundError</code> Context Management Be aware that agents can see the full conversation history Monitor conversation length and relevance Resource Management Consider the number of agents and task length to optimize performance Limit max_loops and task size Dynamic Adaptation Change speaker functions based on different phases of work Round robin for brainstorming, priority for decision-making"},{"location":"swarms/structs/interactive_groupchat/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/interactive_groupchat/#basic-multi-agent-collaboration","title":"Basic Multi-Agent Collaboration","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.interactive_groupchat import InteractiveGroupChat, round_robin_speaker\n\n# Create specialized agents\nanalyst = Agent(\n    agent_name=\"analyst\",\n    system_prompt=\"You are a data analyst specializing in business intelligence.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\nresearcher = Agent(\n    agent_name=\"researcher\", \n    system_prompt=\"You are a market researcher with expertise in consumer behavior.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\nstrategist = Agent(\n    agent_name=\"strategist\",\n    system_prompt=\"You are a strategic consultant who synthesizes insights into actionable recommendations.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\n# Create collaborative group chat\nchat = InteractiveGroupChat(\n    name=\"Business Analysis Team\",\n    description=\"A collaborative team for comprehensive business analysis\",\n    agents=[analyst, researcher, strategist],\n    speaker_function=round_robin_speaker,\n    interactive=False,\n)\n\n# Collaborative analysis task\ntask = \"\"\"Analyze our company's Q3 performance. We have the following data:\n- Revenue: $2.5M (up 15% from Q2)\n- Customer acquisition cost: $45 (down 8% from Q2)\n- Market share: 3.2% (up 0.5% from Q2)\n\n@analyst @researcher @strategist please provide a comprehensive analysis.\"\"\"\n\nresponse = chat.run(task)\nprint(response)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#priority-based-expert-consultation","title":"Priority-Based Expert Consultation","text":"<pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, priority_speaker\n\n# Create expert agents with different priority levels\nsenior_expert = Agent(\n    agent_name=\"senior_expert\",\n    system_prompt=\"You are a senior consultant with 15+ years of experience.\",\n    llm=\"gpt-4\",\n)\n\njunior_expert = Agent(\n    agent_name=\"junior_expert\",\n    system_prompt=\"You are a junior consultant with 3 years of experience.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\nassistant = Agent(\n    agent_name=\"assistant\",\n    system_prompt=\"You are a research assistant who gathers supporting information.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\n# Create priority-based group chat\nchat = InteractiveGroupChat(\n    name=\"Expert Consultation Team\",\n    description=\"Expert-led consultation with collaborative input\",\n    agents=[senior_expert, junior_expert, assistant],\n    speaker_function=priority_speaker,\n    speaker_state={\"priorities\": {\"senior_expert\": 5, \"junior_expert\": 3, \"assistant\": 1}},\n    interactive=False,\n)\n\n# Expert consultation task\ntask = \"\"\"We need strategic advice on entering a new market. \n@senior_expert @junior_expert @assistant please provide your insights.\"\"\"\n\nresponse = chat.run(task)\nprint(response)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#dynamic-speaker-function-with-delegation","title":"Dynamic Speaker Function with Delegation","text":"<pre><code>from swarms.structs.interactive_groupchat import InteractiveGroupChat, random_dynamic_speaker\n\n# Create specialized medical agents\ncardiologist = Agent(\n    agent_name=\"cardiologist\",\n    system_prompt=\"You are a cardiologist specializing in heart conditions.\",\n    llm=\"gpt-4\",\n)\n\noncologist = Agent(\n    agent_name=\"oncologist\",\n    system_prompt=\"You are an oncologist specializing in cancer treatment.\",\n    llm=\"gpt-4\",\n)\n\nendocrinologist = Agent(\n    agent_name=\"endocrinologist\",\n    system_prompt=\"You are an endocrinologist specializing in hormone disorders.\",\n    llm=\"gpt-4\",\n)\n\n# Create dynamic group chat\nchat = InteractiveGroupChat(\n    name=\"Medical Panel Discussion\",\n    description=\"A collaborative panel of medical specialists\",\n    agents=[cardiologist, oncologist, endocrinologist],\n    speaker_function=random_dynamic_speaker,\n    speaker_state={\"strategy\": \"sequential\"},\n    interactive=False,\n)\n\n# Complex medical case with dynamic delegation\ncase = \"\"\"CASE PRESENTATION:\nA 65-year-old male with Type 2 diabetes, hypertension, and recent diagnosis of \nstage 3 colon cancer presents with chest pain and shortness of breath. \nECG shows ST-segment elevation. Recent blood work shows elevated blood glucose (280 mg/dL) \nand signs of infection (WBC 15,000, CRP elevated).\n\n@cardiologist @oncologist @endocrinologist please provide your assessment and treatment recommendations.\"\"\"\n\nresponse = chat.run(case)\nprint(response)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#dynamic-speaker-function-changes_1","title":"Dynamic Speaker Function Changes","text":"<pre><code>from swarms.structs.interactive_groupchat import (\n    InteractiveGroupChat, \n    round_robin_speaker, \n    random_speaker, \n    priority_speaker,\n    random_dynamic_speaker\n)\n\n# Create brainstorming agents\ncreative_agent = Agent(agent_name=\"creative\", system_prompt=\"You are a creative thinker.\")\nanalytical_agent = Agent(agent_name=\"analytical\", system_prompt=\"You are an analytical thinker.\")\npractical_agent = Agent(agent_name=\"practical\", system_prompt=\"You are a practical implementer.\")\n\nchat = InteractiveGroupChat(\n    name=\"Dynamic Team\",\n    agents=[creative_agent, analytical_agent, practical_agent],\n    speaker_function=round_robin_speaker,\n    interactive=False,\n)\n\n# Phase 1: Brainstorming (random order)\nchat.set_speaker_function(random_speaker)\ntask1 = \"Let's brainstorm new product ideas. @creative @analytical @practical\"\nresponse1 = chat.run(task1)\n\n# Phase 2: Analysis (priority order)\nchat.set_priorities({\"analytical\": 3, \"creative\": 2, \"practical\": 1})\nchat.set_speaker_function(priority_speaker)\ntask2 = \"Now let's analyze the feasibility of these ideas. @creative @analytical @practical\"\nresponse2 = chat.run(task2)\n\n# Phase 3: Dynamic delegation (agents mention each other)\nchat.set_speaker_function(random_dynamic_speaker)\nchat.set_dynamic_strategy(\"sequential\")\ntask3 = \"Let's plan implementation with dynamic delegation. @creative @analytical @practical\"\nresponse3 = chat.run(task3)\n\n# Phase 4: Final synthesis (round robin for equal input)\nchat.set_speaker_function(round_robin_speaker)\ntask4 = \"Finally, let's synthesize our findings. @creative @analytical @practical\"\nresponse4 = chat.run(task4)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#custom-speaker-function","title":"Custom Speaker Function","text":"<pre><code>def context_aware_speaker(agents: List[str], **kwargs) -&gt; str:\n    \"\"\"Custom speaker function that selects agents based on context.\"\"\"\n    context = kwargs.get(\"context\", \"\").lower()\n\n    if \"data\" in context or \"analysis\" in context:\n        return \"analyst\" if \"analyst\" in agents else agents[0]\n    elif \"market\" in context or \"research\" in context:\n        return \"researcher\" if \"researcher\" in agents else agents[0]\n    elif \"strategy\" in context or \"planning\" in context:\n        return \"strategist\" if \"strategist\" in agents else agents[0]\n    else:\n        return agents[0]\n\n# Use custom speaker function\nchat = InteractiveGroupChat(\n    name=\"Context-Aware Team\",\n    agents=[analyst, researcher, strategist],\n    speaker_function=context_aware_speaker,\n    interactive=False,\n)\n\n# The speaker function will automatically select the most appropriate agent\ntask = \"We need to analyze our market position and develop a strategy.\"\nresponse = chat.run(task)\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#interactive-session-with-enhanced-collaboration","title":"Interactive Session with Enhanced Collaboration","text":"<pre><code># Create agents designed for collaboration\ndata_scientist = Agent(\n    agent_name=\"data_scientist\",\n    system_prompt=\"You are a data scientist. When collaborating, always reference specific data points and build upon others' insights with quantitative support.\",\n    llm=\"gpt-4\",\n)\n\nbusiness_analyst = Agent(\n    agent_name=\"business_analyst\",\n    system_prompt=\"You are a business analyst. When collaborating, always connect business insights to practical implications and build upon data analysis with business context.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\nproduct_manager = Agent(\n    agent_name=\"product_manager\",\n    system_prompt=\"You are a product manager. When collaborating, always synthesize insights from all team members and provide actionable product recommendations.\",\n    llm=\"gpt-3.5-turbo\",\n)\n\n# Start interactive session\nchat = InteractiveGroupChat(\n    name=\"Product Development Team\",\n    description=\"A collaborative team for product development decisions\",\n    agents=[data_scientist, business_analyst, product_manager],\n    speaker_function=round_robin_speaker,\n    interactive=True,\n)\n\n# Start the interactive session\nchat.start_interactive_session()\n</code></pre>"},{"location":"swarms/structs/interactive_groupchat/#benefits-and-use-cases","title":"Benefits and Use Cases","text":""},{"location":"swarms/structs/interactive_groupchat/#benefits-of-enhanced-collaboration","title":"Benefits of Enhanced Collaboration","text":"<ol> <li>Reduced Redundancy: Agents don't repeat what others have already said</li> <li>Improved Synthesis: Multiple perspectives are integrated into coherent conclusions</li> <li>Better Delegation: Agents naturally delegate to appropriate experts</li> <li>Enhanced Problem Solving: Complex problems are addressed systematically</li> <li>More Natural Interactions: Agents respond like real team members</li> <li>Dynamic Workflows: Conversation flow adapts based on agent responses</li> <li>Flexible Execution: Support for both sequential and parallel processing</li> </ol>"},{"location":"swarms/structs/interactive_groupchat/#use-cases","title":"Use Cases","text":"Use Case Category Specific Use Case Agent Team Composition Recommended Speaker Function Business Analysis and Strategy Data Analysis Analyst + Researcher + Strategist Round Robin Market Research Multiple experts analyzing different aspects Random Dynamic Strategic Planning Expert-led discussions with collaborative input Priority Product Development Requirements Gathering Product Manager + Developer + Designer Round Robin Technical Architecture Senior + Junior developers with different expertise Priority User Experience UX Designer + Product Manager + Developer Random Dynamic Research and Development Scientific Research Multiple researchers with different specializations Random Dynamic Literature Review Different experts reviewing various aspects Round Robin Experimental Design Statistician + Domain Expert + Methodologist Priority Creative Projects Content Creation Writer + Editor + Designer Random Marketing Campaigns Creative + Analyst + Strategist Random Dynamic Design Projects Designer + Developer + Product Manager Round Robin Problem Solving Troubleshooting Technical + Business + User perspective experts Priority Crisis Management Emergency + Communication + Technical teams Priority Decision Making Executive + Analyst + Specialist Priority Medical Consultation Complex Cases Multiple specialists (Cardiologist + Oncologist + Endocrinologist) Random Dynamic Treatment Planning Senior + Junior doctors with different expertise Priority Research Review Multiple researchers reviewing different aspects Round Robin"},{"location":"swarms/structs/interactive_groupchat/#speaker-function-selection-guide","title":"Speaker Function Selection Guide","text":"Use Case Recommended Speaker Function Strategy Reasoning Team Meetings Round Robin N/A Ensures equal participation Brainstorming Random N/A Prevents bias and encourages creativity Expert Consultation Priority N/A Senior experts speak first Problem Solving Priority N/A Most relevant experts prioritize Creative Sessions Random N/A Encourages diverse perspectives Decision Making Priority N/A Decision makers speak first Research Review Round Robin N/A Equal contribution from all reviewers Complex Workflows Random Dynamic Sequential Follows natural conversation flow Parallel Analysis Random Dynamic Parallel Multiple agents work simultaneously Medical Panels Random Dynamic Sequential Specialists delegate to relevant experts Technical Architecture Random Dynamic Sequential Senior architects guide the discussion"},{"location":"swarms/structs/interactive_groupchat/#contributing","title":"Contributing","text":"<p>Contributions are welcome! Please read our contributing guidelines and submit pull requests to our GitHub repository.</p>"},{"location":"swarms/structs/interactive_groupchat/#license","title":"License","text":"<p>This project is licensed under the Apache License - see the LICENSE file for details. </p>"},{"location":"swarms/structs/majorityvoting/","title":"MajorityVoting Module Documentation","text":"<p>The <code>MajorityVoting</code> module provides a mechanism for performing majority voting among a group of agents. Majority voting is a decision rule that selects the option which has the majority of votes. This is particularly useful in systems where multiple agents provide responses to a query, and the most common response needs to be identified as the final output.</p>"},{"location":"swarms/structs/majorityvoting/#architecture","title":"Architecture","text":"<pre><code>graph TD\n    A[MajorityVoting System] --&gt; B[Initialize Agents]\n    B --&gt; C[Process Task]\n    C --&gt; D{Execution Mode}\n    D --&gt; E[Single Task]\n    D --&gt; F[Batch Tasks]\n    D --&gt; G[Concurrent Tasks]\n    D --&gt; H[Async Tasks]\n    E --&gt; I[Run Agents]\n    F --&gt; I\n    G --&gt; I\n    H --&gt; I\n    I --&gt; J[Collect Responses]\n    J --&gt; K[Consensus Analysis]\n    K --&gt; L{Consensus Agent?}\n    L --&gt;|Yes| M[Use Consensus Agent]\n    L --&gt;|No| N[Use Last Agent]\n    M --&gt; O[Final Output]\n    N --&gt; O\n    O --&gt; P[Save Conversation]</code></pre>"},{"location":"swarms/structs/majorityvoting/#key-concepts","title":"Key Concepts","text":"<ul> <li>Majority Voting: A method to determine the most common response from a set of answers.</li> <li>Agents: Entities (e.g., models, algorithms) that provide responses to tasks or queries.</li> <li>Output Parser: A function that processes the responses from the agents before performing the majority voting.</li> <li>Consensus Agent: An optional agent that analyzes the responses from all agents to determine the final consensus.</li> <li>Conversation History: A record of all agent interactions and responses during the voting process.</li> </ul>"},{"location":"swarms/structs/majorityvoting/#class-definition-majorityvoting","title":"Class Definition: <code>MajorityVoting</code>","text":""},{"location":"swarms/structs/majorityvoting/#parameters","title":"Parameters","text":"Parameter Type Description <code>name</code> <code>str</code> Name of the majority voting system. Default is \"MajorityVoting\". <code>description</code> <code>str</code> Description of the system. Default is \"A majority voting system for agents\". <code>agents</code> <code>List[Agent]</code> A list of agents to be used in the majority voting system. <code>output_parser</code> <code>Callable</code> Function to parse agent outputs. Default is <code>majority_voting</code> function. <code>consensus_agent</code> <code>Agent</code> Optional agent for analyzing consensus among responses. <code>autosave</code> <code>bool</code> Whether to autosave conversations. Default is <code>False</code>. <code>verbose</code> <code>bool</code> Whether to enable verbose logging. Default is <code>False</code>. <code>max_loops</code> <code>int</code> Maximum number of voting loops. Default is 1."},{"location":"swarms/structs/majorityvoting/#methods","title":"Methods","text":""},{"location":"swarms/structs/majorityvoting/#runtask-str-correct_answer-str-args-kwargs-listany","title":"<code>run(task: str, correct_answer: str, *args, **kwargs) -&gt; List[Any]</code>","text":"<p>Runs the majority voting system for a single task.</p> <p>Parameters: - <code>task</code> (str): The task to be performed by the agents - <code>correct_answer</code> (str): The correct answer for evaluation - <code>*args</code>, <code>**kwargs</code>: Additional arguments</p> <p>Returns: - List[Any]: The conversation history as a string, including the majority vote</p>"},{"location":"swarms/structs/majorityvoting/#batch_runtasks-liststr-args-kwargs-listany","title":"<code>batch_run(tasks: List[str], *args, **kwargs) -&gt; List[Any]</code>","text":"<p>Runs multiple tasks in sequence.</p> <p>Parameters: - <code>tasks</code> (List[str]): List of tasks to be performed - <code>*args</code>, <code>**kwargs</code>: Additional arguments</p> <p>Returns: - List[Any]: List of majority votes for each task</p>"},{"location":"swarms/structs/majorityvoting/#run_concurrentlytasks-liststr-args-kwargs-listany","title":"<code>run_concurrently(tasks: List[str], *args, **kwargs) -&gt; List[Any]</code>","text":"<p>Runs multiple tasks concurrently using thread pooling.</p> <p>Parameters: - <code>tasks</code> (List[str]): List of tasks to be performed - <code>*args</code>, <code>**kwargs</code>: Additional arguments</p> <p>Returns: - List[Any]: List of majority votes for each task</p>"},{"location":"swarms/structs/majorityvoting/#run_asynctasks-liststr-args-kwargs-listany","title":"<code>run_async(tasks: List[str], *args, **kwargs) -&gt; List[Any]</code>","text":"<p>Runs multiple tasks asynchronously using asyncio.</p> <p>Parameters: - <code>tasks</code> (List[str]): List of tasks to be performed - <code>*args</code>, <code>**kwargs</code>: Additional arguments</p> <p>Returns: - List[Any]: List of majority votes for each task</p>"},{"location":"swarms/structs/majorityvoting/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/majorityvoting/#example-1-basic-single-task-execution-with-modern-llms","title":"Example 1: Basic Single Task Execution with Modern LLMs","text":"<pre><code>from swarms import Agent, MajorityVoting\n\n# Initialize multiple agents with different specialties\nagents = [\n    Agent(\n        agent_name=\"Financial-Analysis-Agent\",\n        agent_description=\"Personal finance advisor focused on market analysis\",\n        system_prompt=\"You are a financial advisor specializing in market analysis and investment opportunities.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"Risk-Assessment-Agent\", \n        agent_description=\"Risk analysis and portfolio management expert\",\n        system_prompt=\"You are a risk assessment expert focused on evaluating investment risks and portfolio diversification.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"Tech-Investment-Agent\",\n        agent_description=\"Technology sector investment specialist\",\n        system_prompt=\"You are a technology investment specialist focused on AI, emerging tech, and growth opportunities.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    )\n]\n\n\nconsensus_agent = Agent(\n    agent_name=\"Consensus-Agent\",\n    agent_description=\"Consensus agent focused on analyzing investment advice\",\n    system_prompt=\"You are a consensus agent focused on analyzing investment advice and providing a final answer.\",\n    max_loops=1,\n    model_name=\"gpt-4o\"\n)\n\n# Create majority voting system\nmajority_voting = MajorityVoting(\n    name=\"Investment-Advisory-System\",\n    description=\"Multi-agent system for investment advice\",\n    agents=agents,\n    verbose=True,\n    consensus_agent=consensus_agent\n)\n\n# Run the analysis with majority voting\nresult = majority_voting.run(\n    task=\"Create a table of super high growth opportunities for AI. I have $40k to invest in ETFs, index funds, and more. Please create a table in markdown.\",\n    correct_answer=\"\"  # Optional evaluation metric\n)\n\nprint(result)\n</code></pre>"},{"location":"swarms/structs/majorityvoting/#batch-execution","title":"Batch Execution","text":"<pre><code>from swarms import Agent, MajorityVoting\n\n# Initialize multiple agents with different specialties\nagents = [\n    Agent(\n        agent_name=\"Financial-Analysis-Agent\",\n        agent_description=\"Personal finance advisor focused on market analysis\",\n        system_prompt=\"You are a financial advisor specializing in market analysis and investment opportunities.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"Risk-Assessment-Agent\", \n        agent_description=\"Risk analysis and portfolio management expert\",\n        system_prompt=\"You are a risk assessment expert focused on evaluating investment risks and portfolio diversification.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"Tech-Investment-Agent\",\n        agent_description=\"Technology sector investment specialist\",\n        system_prompt=\"You are a technology investment specialist focused on AI, emerging tech, and growth opportunities.\",\n        max_loops=1,\n        model_name=\"gpt-4o\"\n    )\n]\n\n\nconsensus_agent = Agent(\n    agent_name=\"Consensus-Agent\",\n    agent_description=\"Consensus agent focused on analyzing investment advice\",\n    system_prompt=\"You are a consensus agent focused on analyzing investment advice and providing a final answer.\",\n    max_loops=1,\n    model_name=\"gpt-4o\"\n)\n\n# Create majority voting system\nmajority_voting = MajorityVoting(\n    name=\"Investment-Advisory-System\",\n    description=\"Multi-agent system for investment advice\",\n    agents=agents,\n    verbose=True,\n    consensus_agent=consensus_agent\n)\n\n# Run the analysis with majority voting\nresult = majority_voting.batch_run(\n    task=\"Create a table of super high growth opportunities for AI. I have $40k to invest in ETFs, index funds, and more. Please create a table in markdown.\",\n    correct_answer=\"\"  # Optional evaluation metric\n)\n\nprint(result)\n</code></pre>"},{"location":"swarms/structs/malt/","title":"MALT: Multi-Agent Learning Task Framework","text":""},{"location":"swarms/structs/malt/#overview","title":"Overview","text":"<p>MALT (Multi-Agent Learning Task) is a sophisticated orchestration framework that coordinates multiple specialized AI agents to tackle complex tasks through structured conversations. Inspired by the principles outlined in the MALT research paper, this implementation provides a reliable, extensible system for multi-agent collaboration.</p> <p>The framework is designed around a three-agent architecture:</p> <ol> <li> <p>Creator Agent: Generates initial content or solutions</p> </li> <li> <p>Verifier Agent: Critically evaluates the creator's output</p> </li> <li> <p>Refiner Agent: Improves the solution based on verifier feedback</p> </li> </ol> <p>This collaborative approach enables high-quality outputs for complex tasks by combining the strengths of multiple specialized agents, each focused on a different aspect of the problem-solving process.</p>"},{"location":"swarms/structs/malt/#how-it-works","title":"How It Works","text":"<p>The MALT framework follows a structured workflow:</p> <ol> <li>A task is submitted to the system</li> <li>The Creator Agent generates an initial solution</li> <li>Multiple instances of the Verifier Agent independently evaluate the solution</li> <li>Multiple instances of the Refiner Agent improve the solution based on verification feedback</li> <li>The final refined output is returned</li> </ol> <p>This process can be configured to run for multiple iterations, with each cycle potentially improving the quality of the output. The system maintains a conversation history, tracking interactions between agents throughout the workflow.</p>"},{"location":"swarms/structs/malt/#key-components","title":"Key Components","text":"<ul> <li>Agent: Represents an individual AI agent with specific capabilities and responsibilities</li> <li>Conversation: Manages the interaction history between agents</li> <li>MALT Orchestrator: Coordinates the workflow and manages agent interactions</li> <li>Concurrency Support: Enables parallel execution of multiple agent instances</li> </ul>"},{"location":"swarms/structs/malt/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>flowchart TD\n    User[User/Client] --&gt;|Submit Task| MALT[MALT Orchestrator]\n\n    subgraph MALT Framework\n        MALT --&gt;|Task| Creator[Creator Agent]\n        Creator --&gt;|Initial Solution| Conversation[Conversation Manager]\n        Conversation --&gt;|Solution| VerifierPool[Verifier Agents Pool]\n\n        subgraph VerifierPool\n            Verifier1[Verifier Agent 1]\n            Verifier2[Verifier Agent 2]\n            Verifier3[Verifier Agent 3]\n        end\n\n        VerifierPool --&gt;|Verification Feedback| Conversation\n        Conversation --&gt;|Solution + Feedback| RefinerPool[Refiner Agents Pool]\n\n        subgraph RefinerPool\n            Refiner1[Refiner Agent 1]\n            Refiner2[Refiner Agent 2]\n            Refiner3[Refiner Agent 3]\n        end\n\n        RefinerPool --&gt;|Refined Solutions| Conversation\n    end\n\n    Conversation --&gt;|Final Output| User</code></pre>"},{"location":"swarms/structs/malt/#execution-workflow","title":"Execution Workflow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant MALT\n    participant Creator\n    participant Verifiers\n    participant Refiners\n    participant Conversation\n\n    User-&gt;&gt;MALT: Submit task\n    MALT-&gt;&gt;Creator: Process task\n    Creator-&gt;&gt;Conversation: Add initial solution\n\n    par Verification Phase\n        Conversation-&gt;&gt;Verifiers: Send solution for verification\n        Verifiers-&gt;&gt;Conversation: Return verification feedback\n    end\n\n    par Refinement Phase\n        Conversation-&gt;&gt;Refiners: Send solution + feedback\n        Refiners-&gt;&gt;Conversation: Return refined solutions\n    end\n\n    MALT-&gt;&gt;Conversation: Request final output\n    Conversation-&gt;&gt;MALT: Return conversation history\n    MALT-&gt;&gt;User: Return final result</code></pre>"},{"location":"swarms/structs/malt/#api-reference","title":"API Reference","text":""},{"location":"swarms/structs/malt/#malt-class","title":"MALT Class","text":"<p>The core orchestrator that manages the multi-agent interaction process.</p>"},{"location":"swarms/structs/malt/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Default Description <code>main_agent</code> <code>Agent</code> <code>None</code> The primary agent (Creator) responsible for generating initial solutions <code>refiner_agent</code> <code>Agent</code> <code>None</code> The agent that refines solutions based on verification feedback <code>verifier_agent</code> <code>Agent</code> <code>None</code> The agent that verifies and evaluates solutions <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of iterations for the task execution <code>return_list</code> <code>bool</code> <code>False</code> Flag to return output as a list <code>return_dict</code> <code>bool</code> <code>False</code> Flag to return output as a dictionary <code>agents</code> <code>list[Agent]</code> <code>[]</code> Alternative list of agents to use in the task <code>preset_agents</code> <code>bool</code> <code>True</code> Use default preset agents for mathematical proofs"},{"location":"swarms/structs/malt/#methods","title":"Methods","text":"Method Parameters Return Type Description <code>reliability_check</code> None None Validates agent configuration and parameters <code>step</code> <code>task: str, img: str = None, *args, **kwargs</code> <code>str</code> or <code>list</code> or <code>dict</code> Executes a single iteration of the MALT workflow <code>run</code> <code>task: str, img: str = None, *args, **kwargs</code> <code>str</code> or <code>list</code> or <code>dict</code> Executes the complete MALT workflow for a task <code>run_batched</code> <code>tasks: List[str], *args, **kwargs</code> <code>List[str]</code> or <code>List[list]</code> or <code>List[dict]</code> Sequentially processes multiple tasks <code>run_concurrently</code> <code>tasks: List[str], *args, **kwargs</code> <code>concurrent.futures.Future</code> Processes multiple tasks in parallel using ThreadPoolExecutor <code>__call__</code> <code>task: str, *args, **kwargs</code> Same as <code>run</code> Allows the MALT instance to be called as a function <code>__str__</code> None <code>str</code> Returns the conversation history as a string <code>__repr__</code> None <code>str</code> Returns the conversation history as a string"},{"location":"swarms/structs/malt/#sample-implementations","title":"Sample Implementations","text":""},{"location":"swarms/structs/malt/#default-mathematical-proof-agents","title":"Default Mathematical Proof Agents","text":"<p>The MALT framework includes preset agents specialized for mathematical proof generation and refinement:</p> <ol> <li>Proof Creator Agent: Generates original mathematical theorems and proofs</li> <li>Proof Verifier Agent: Critically evaluates and identifies issues in mathematical proofs</li> <li>Proof Refiner Agent: Improves proofs based on verification feedback</li> </ol> <p>Each agent has a carefully designed system prompt that guides its behavior and specialization.</p>"},{"location":"swarms/structs/malt/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/malt/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.multi_agent_exec import MALT\n\n# Initialize with preset mathematical proof agents\nmalt = MALT(preset_agents=True)\n\n# Run a mathematical proof task\nresult = malt.run(\"Develop a theorem and proof related to prime numbers and their distribution.\")\n\nprint(result)\n</code></pre>"},{"location":"swarms/structs/malt/#custom-agents","title":"Custom Agents","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.multi_agent_exec import MALT\n\n# Define custom agents\ncreator = Agent(\n    agent_name=\"Physics-Creator\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    system_prompt=\"You are a theoretical physicist specializing in quantum mechanics...\"\n)\n\nverifier = Agent(\n    agent_name=\"Physics-Verifier\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    system_prompt=\"You are an experimental physicist who verifies theoretical claims...\"\n)\n\nrefiner = Agent(\n    agent_name=\"Physics-Communicator\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=1,\n    system_prompt=\"You excel at explaining complex physics concepts to diverse audiences...\"\n)\n\n# Initialize MALT with custom agents\nmalt = MALT(\n    main_agent=creator,\n    verifier_agent=verifier,\n    refiner_agent=refiner,\n    preset_agents=False,\n    max_loops=1\n)\n\n# Run a physics explanation task\nresult = malt.run(\"Explain the quantum entanglement phenomenon and its implications.\")\n</code></pre>"},{"location":"swarms/structs/malt/#concurrent-processing","title":"Concurrent Processing","text":"<pre><code>from swarms.structs.multi_agent_exec import MALT\n\n# Initialize MALT\nmalt = MALT()\n\n# Define multiple tasks\ntasks = [\n    \"Prove a theorem related to continuous functions on compact sets.\",\n    \"Develop a theorem about convergence in infinite-dimensional Hilbert spaces.\",\n    \"Create a theorem relating to measure theory and Lebesgue integration.\"\n]\n\n# Process tasks concurrently\nfutures = malt.run_concurrently(tasks)\n\n# Collect results as they complete\nfor future in futures:\n    result = future.result()\n    print(result)\n</code></pre>"},{"location":"swarms/structs/malt/#example-complex-mathematical-domain","title":"Example: Complex Mathematical Domain","text":"<p>Here's an example of how MALT can generate, verify, and refine a mathematical proof:</p>"},{"location":"swarms/structs/malt/#input","title":"Input","text":"<pre><code>malt = MALT(preset_agents=True)\ntask = \"Develop a theorem and rigorous proof related to the convergence properties of infinite series.\"\nresult = malt.run(task)\n</code></pre>"},{"location":"swarms/structs/malt/#output-flow","title":"Output Flow","text":"<ol> <li>Creator Agent generates a theorem and proof about conditions for absolute convergence</li> <li>Verifier Agents identify issues:</li> <li>Logical gap in lemma 2</li> <li>Missing justification for uniform convergence claim</li> <li>Imprecise definition of certain terms</li> <li>Refiner Agents produce improved versions addressing these concerns</li> <li>The final output contains the refined, rigorous mathematical proof</li> </ol>"},{"location":"swarms/structs/malt/#best-practices","title":"Best Practices","text":"<ol> <li>Task Specificity: Provide clear, detailed task descriptions for optimal results</li> <li>Agent Specialization: Design agent prompts to focus on specific aspects of the task</li> <li>Iteration Control: Adjust <code>max_loops</code> based on task complexity</li> <li>Concurrent Verification: Use multiple verifier instances for comprehensive evaluation</li> <li>Custom Agents: Create domain-specific agents for specialized tasks</li> </ol>"},{"location":"swarms/structs/malt/#potential-improvements","title":"Potential Improvements","text":"<ul> <li>Autonomously create specialized agents based on task requirements</li> <li>Implement feedback loops between agents for iterative improvement</li> <li>Add support for agent-specific memory and knowledge bases</li> <li>Expand concurrency capabilities for improved performance</li> <li>Implement learning mechanisms for agent improvement over time</li> </ul>"},{"location":"swarms/structs/malt/#references","title":"References","text":"<ul> <li>Original MALT paper: arXiv:2412.01928</li> <li>Built on the swarms framework for multi-agent systems</li> </ul>"},{"location":"swarms/structs/matrix_swarm/","title":"MatrixSwarm","text":"<p>The <code>MatrixSwarm</code> class provides a framework for managing and operating on matrices of AI agents, enabling matrix-like operations similar to linear algebra. This allows for complex agent interactions and parallel processing capabilities.</p>"},{"location":"swarms/structs/matrix_swarm/#overview","title":"Overview","text":"<p><code>MatrixSwarm</code> treats AI agents as elements in a matrix, allowing for operations like addition, multiplication, and transposition. This approach enables sophisticated agent orchestration and parallel processing patterns.</p>"},{"location":"swarms/structs/matrix_swarm/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms import Agent\nfrom swarms.matrix import MatrixSwarm\n\n# Create a 2x2 matrix of agents\nagents = [\n    [Agent(agent_name=\"Agent-0-0\"), Agent(agent_name=\"Agent-0-1\")],\n    [Agent(agent_name=\"Agent-1-0\"), Agent(agent_name=\"Agent-1-1\")]\n]\n\n# Initialize the matrix\nmatrix = MatrixSwarm(agents)\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#class-constructor","title":"Class Constructor","text":"<pre><code>def __init__(self, agents: List[List[Agent]])\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters","title":"Parameters","text":"<ul> <li><code>agents</code> (<code>List[List[Agent]]</code>): A 2D list of Agent instances representing the matrix.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the input is not a valid 2D list of Agent instances.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/matrix_swarm/#transpose","title":"transpose()","text":"<p>Transposes the matrix of agents by swapping rows and columns.</p> <pre><code>def transpose(self) -&gt; MatrixSwarm\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#returns","title":"Returns","text":"<ul> <li><code>MatrixSwarm</code>: A new MatrixSwarm instance with transposed dimensions.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#addother","title":"add(other)","text":"<p>Performs element-wise addition of two agent matrices.</p> <pre><code>def add(self, other: MatrixSwarm) -&gt; MatrixSwarm\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_1","title":"Parameters","text":"<ul> <li><code>other</code> (<code>MatrixSwarm</code>): Another MatrixSwarm instance to add.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#returns_1","title":"Returns","text":"<ul> <li><code>MatrixSwarm</code>: A new MatrixSwarm resulting from the addition.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#raises_1","title":"Raises","text":"<ul> <li><code>ValueError</code>: If matrix dimensions are incompatible.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#scalar_multiplyscalar","title":"scalar_multiply(scalar)","text":"<p>Scales the matrix by duplicating agents along rows.</p> <pre><code>def scalar_multiply(self, scalar: int) -&gt; MatrixSwarm\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_2","title":"Parameters","text":"<ul> <li><code>scalar</code> (<code>int</code>): The multiplication factor.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#returns_2","title":"Returns","text":"<ul> <li><code>MatrixSwarm</code>: A new MatrixSwarm with scaled dimensions.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#multiplyother-inputs","title":"multiply(other, inputs)","text":"<p>Performs matrix multiplication (dot product) between two agent matrices.</p> <pre><code>def multiply(self, other: MatrixSwarm, inputs: List[str]) -&gt; List[List[AgentOutput]]\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_3","title":"Parameters","text":"<ul> <li><code>other</code> (<code>MatrixSwarm</code>): The second MatrixSwarm for multiplication.</li> <li><code>inputs</code> (<code>List[str]</code>): Input queries for the agents.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#returns_3","title":"Returns","text":"<ul> <li><code>List[List[AgentOutput]]</code>: Matrix of operation results.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#raises_2","title":"Raises","text":"<ul> <li><code>ValueError</code>: If matrix dimensions are incompatible for multiplication.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#subtractother","title":"subtract(other)","text":"<p>Performs element-wise subtraction of two agent matrices.</p> <pre><code>def subtract(self, other: MatrixSwarm) -&gt; MatrixSwarm\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_4","title":"Parameters","text":"<ul> <li><code>other</code> (<code>MatrixSwarm</code>): Another MatrixSwarm to subtract.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#returns_4","title":"Returns","text":"<ul> <li><code>MatrixSwarm</code>: A new MatrixSwarm resulting from the subtraction.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#identitysize","title":"identity(size)","text":"<p>Creates an identity matrix of agents.</p> <pre><code>def identity(self, size: int) -&gt; MatrixSwarm\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_5","title":"Parameters","text":"<ul> <li><code>size</code> (<code>int</code>): Size of the identity matrix (NxN).</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#returns_5","title":"Returns","text":"<ul> <li><code>MatrixSwarm</code>: An identity MatrixSwarm.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#determinant","title":"determinant()","text":"<p>Computes the determinant of a square agent matrix.</p> <pre><code>def determinant(self) -&gt; Any\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#returns_6","title":"Returns","text":"<ul> <li><code>Any</code>: The determinant result.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#raises_3","title":"Raises","text":"<ul> <li><code>ValueError</code>: If the matrix is not square.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#save_to_filepath","title":"save_to_file(path)","text":"<p>Saves the matrix structure and metadata to a JSON file.</p> <pre><code>def save_to_file(self, path: str) -&gt; None\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#parameters_6","title":"Parameters","text":"<ul> <li><code>path</code> (<code>str</code>): File path for saving the matrix data.</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#extended-example","title":"Extended Example","text":"<p>Here's a comprehensive example demonstrating various MatrixSwarm operations:</p> <pre><code>from swarms import Agent\nfrom swarms.matrix import MatrixSwarm\n\n# Create agents with specific configurations\nagents = [\n    [\n        Agent(\n            agent_name=f\"Agent-{i}-{j}\",\n            system_prompt=\"Your system prompt here\",\n            model_name=\"gpt-4\",\n            max_loops=1,\n            verbose=True\n        ) for j in range(2)\n    ] for i in range(2)\n]\n\n# Initialize matrix\nmatrix = MatrixSwarm(agents)\n\n# Example operations\ntransposed = matrix.transpose()\nscaled = matrix.scalar_multiply(2)\n\n# Run operations with inputs\ninputs = [\"Query 1\", \"Query 2\"]\nresults = matrix.multiply(transposed, inputs)\n\n# Save results\nmatrix.save_to_file(\"matrix_results.json\")\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#output-schema","title":"Output Schema","text":"<p>The <code>AgentOutput</code> class defines the structure for operation results:</p> <pre><code>class AgentOutput(BaseModel):\n    agent_name: str\n    input_query: str\n    output_result: Any\n    metadata: dict\n</code></pre>"},{"location":"swarms/structs/matrix_swarm/#best-practices","title":"Best Practices","text":"<ol> <li>Initialization</li> <li>Ensure all agents in the matrix are properly configured before initialization</li> <li> <p>Validate matrix dimensions for your use case</p> </li> <li> <p>Operation Performance</p> </li> <li>Consider computational costs for large matrices</li> <li> <p>Use appropriate batch sizes for inputs</p> </li> <li> <p>Error Handling</p> </li> <li>Implement proper error handling for agent operations</li> <li> <p>Validate inputs before matrix operations</p> </li> <li> <p>Resource Management</p> </li> <li>Monitor agent resource usage in large matrices</li> <li>Implement proper cleanup procedures</li> </ol>"},{"location":"swarms/structs/matrix_swarm/#limitations","title":"Limitations","text":"<ul> <li>Matrix operations are constrained by the underlying agent capabilities</li> <li>Performance may vary based on agent configuration and complexity</li> <li>Resource usage scales with matrix dimensions</li> </ul>"},{"location":"swarms/structs/matrix_swarm/#see-also","title":"See Also","text":"<ul> <li>Swarms Documentation</li> <li>Agent Class Reference</li> </ul>"},{"location":"swarms/structs/moa/","title":"MixtureOfAgents Class Documentation","text":""},{"location":"swarms/structs/moa/#architecture-overview","title":"Architecture Overview","text":"<pre><code>graph TD\n    A[Input Task] --&gt; B[Initialize MixtureOfAgents]\n    B --&gt; C[Reliability Check]\n    C --&gt; D[Layer 1: Parallel Agent Execution]\n    D --&gt; E[Layer 2: Sequential Processing]\n    E --&gt; F[Layer 3: Parallel Agent Execution]\n    F --&gt; G[Final Aggregator Agent]\n    G --&gt; H[Output Response]\n\n    subgraph \"Agent Layer Details\"\n        I[Agent 1] --&gt; J[Agent Results]\n        K[Agent 2] --&gt; J\n        L[Agent N] --&gt; J\n    end\n\n    subgraph \"Processing Flow\"\n        M[Previous Context] --&gt; N[Current Task]\n        N --&gt; O[Agent Processing]\n        O --&gt; P[Aggregation]\n        P --&gt; M\n    end</code></pre>"},{"location":"swarms/structs/moa/#overview","title":"Overview","text":"<p>The <code>MixtureOfAgents</code> class represents a mixture of agents operating within a swarm. The workflow of the swarm follows a parallel \u2192 sequential \u2192 parallel \u2192 final output agent process. This implementation is inspired by concepts discussed in the paper: https://arxiv.org/pdf/2406.04692.</p> <p>The class is designed to manage a collection of agents, orchestrate their execution in layers, and handle the final aggregation of their outputs through a designated final agent. This architecture facilitates complex, multi-step processing where intermediate results are refined through successive layers of agent interactions.</p>"},{"location":"swarms/structs/moa/#class-definition","title":"Class Definition","text":""},{"location":"swarms/structs/moa/#mixtureofagents","title":"MixtureOfAgents","text":"<pre><code>class MixtureOfAgents(BaseSwarm):\n</code></pre>"},{"location":"swarms/structs/moa/#attributes","title":"Attributes","text":"Attribute Type Description Default <code>agents</code> <code>List[Agent]</code> The list of agents in the swarm. <code>None</code> <code>flow</code> <code>str</code> The flow of the swarm. <code>parallel -&gt; sequential -&gt; parallel -&gt; final output agent</code> <code>max_loops</code> <code>int</code> The maximum number of loops to run. <code>1</code> <code>verbose</code> <code>bool</code> Flag indicating whether to print verbose output. <code>True</code> <code>layers</code> <code>int</code> The number of layers in the swarm. <code>3</code> <code>rules</code> <code>str</code> The rules for the swarm. <code>None</code> <code>final_agent</code> <code>Agent</code> The agent to handle the final output processing. <code>None</code> <code>auto_save</code> <code>bool</code> Flag indicating whether to auto-save the metadata to a file. <code>False</code> <code>saved_file_name</code> <code>str</code> The name of the file where the metadata will be saved. <code>\"moe_swarm.json\"</code>"},{"location":"swarms/structs/moa/#methods","title":"Methods","text":""},{"location":"swarms/structs/moa/#__init__","title":"<code>__init__</code>","text":""},{"location":"swarms/structs/moa/#parameters","title":"Parameters","text":"Parameter Type Description Default <code>name</code> <code>str</code> The name of the swarm. <code>\"MixtureOfAgents\"</code> <code>description</code> <code>str</code> A brief description of the swarm. <code>\"A swarm of agents that run in parallel and sequentially.\"</code> <code>agents</code> <code>List[Agent]</code> The list of agents in the swarm. <code>None</code> <code>max_loops</code> <code>int</code> The maximum number of loops to run. <code>1</code> <code>verbose</code> <code>bool</code> Flag indicating whether to print verbose output. <code>True</code> <code>layers</code> <code>int</code> The number of layers in the swarm. <code>3</code> <code>rules</code> <code>str</code> The rules for the swarm. <code>None</code> <code>final_agent</code> <code>Agent</code> The agent to handle the final output processing. <code>None</code> <code>auto_save</code> <code>bool</code> Flag indicating whether to auto-save the metadata to a file. <code>False</code> <code>saved_file_name</code> <code>str</code> The name of the file where the metadata will be saved. <code>\"moe_swarm.json\"</code>"},{"location":"swarms/structs/moa/#agent_check","title":"<code>agent_check</code>","text":"<pre><code>def agent_check(self):\n</code></pre>"},{"location":"swarms/structs/moa/#description","title":"Description","text":"<p>Checks if the provided <code>agents</code> attribute is a list of <code>Agent</code> instances. Raises a <code>TypeError</code> if the validation fails.</p>"},{"location":"swarms/structs/moa/#example-usage","title":"Example Usage","text":"<pre><code>moe_swarm = MixtureOfAgents(agents=[agent1, agent2])\nmoe_swarm.agent_check()  # Validates the agents\n</code></pre>"},{"location":"swarms/structs/moa/#final_agent_check","title":"<code>final_agent_check</code>","text":"<pre><code>def final_agent_check(self):\n</code></pre>"},{"location":"swarms/structs/moa/#description_1","title":"Description","text":"<p>Checks if the provided <code>final_agent</code> attribute is an instance of <code>Agent</code>. Raises a <code>TypeError</code> if the validation fails.</p>"},{"location":"swarms/structs/moa/#example-usage_1","title":"Example Usage","text":"<pre><code>moe_swarm = MixtureOfAgents(final_agent=final_agent)\nmoe_swarm.final_agent_check()  # Validates the final agent\n</code></pre>"},{"location":"swarms/structs/moa/#swarm_initialization","title":"<code>swarm_initialization</code>","text":"<pre><code>def swarm_initialization(self):\n</code></pre>"},{"location":"swarms/structs/moa/#description_2","title":"Description","text":"<p>Initializes the swarm by logging the swarm name, description, and the number of agents.</p>"},{"location":"swarms/structs/moa/#example-usage_2","title":"Example Usage","text":"<pre><code>moe_swarm = MixtureOfAgents(agents=[agent1, agent2])\nmoe_swarm.swarm_initialization()  # Initializes the swarm\n</code></pre>"},{"location":"swarms/structs/moa/#run","title":"<code>run</code>","text":"<pre><code>def run(self, task: str = None, *args, **kwargs):\n</code></pre>"},{"location":"swarms/structs/moa/#parameters_1","title":"Parameters","text":"Parameter Type Description Default <code>task</code> <code>str</code> The task to be performed by the swarm. <code>None</code> <code>*args</code> <code>tuple</code> Additional arguments. <code>None</code> <code>**kwargs</code> <code>dict</code> Additional keyword arguments. <code>None</code>"},{"location":"swarms/structs/moa/#returns","title":"Returns","text":"Type Description <code>str</code> The conversation history as a string."},{"location":"swarms/structs/moa/#description_3","title":"Description","text":"<p>Runs the swarm with the given task, orchestrates the execution of agents through the specified layers, and returns the conversation history.</p>"},{"location":"swarms/structs/moa/#example-usage_3","title":"Example Usage","text":"<pre><code>moe_swarm = MixtureOfAgents(agents=[agent1, agent2], final_agent=final_agent)\nhistory = moe_swarm.run(task=\"Solve this problem.\")\nprint(history)\n</code></pre>"},{"location":"swarms/structs/moa/#reliability_check","title":"<code>reliability_check</code>","text":"<pre><code>def reliability_check(self) -&gt; None:\n</code></pre>"},{"location":"swarms/structs/moa/#description_4","title":"Description","text":"<p>Performs validation checks on the Mixture of Agents class to ensure all required components are properly configured. Raises ValueError if any checks fail.</p>"},{"location":"swarms/structs/moa/#validation-checks","title":"Validation Checks:","text":"<ul> <li>Verifies reference agents are provided</li> <li>Validates aggregator agent exists</li> <li>Checks aggregator system prompt is set</li> <li>Ensures layers count is valid (&gt; 0)</li> </ul>"},{"location":"swarms/structs/moa/#_get_final_system_prompt","title":"<code>_get_final_system_prompt</code>","text":"<pre><code>def _get_final_system_prompt(self, system_prompt: str, results: List[str]) -&gt; str:\n</code></pre>"},{"location":"swarms/structs/moa/#description_5","title":"Description","text":"<p>Internal method that constructs a system prompt for subsequent layers by incorporating previous responses.</p>"},{"location":"swarms/structs/moa/#parameters_2","title":"Parameters","text":"Parameter Type Description <code>system_prompt</code> <code>str</code> The initial system prompt <code>results</code> <code>List[str]</code> List of previous responses"},{"location":"swarms/structs/moa/#returns_1","title":"Returns","text":"Type Description <code>str</code> Combined system prompt with previous responses"},{"location":"swarms/structs/moa/#run_batched","title":"<code>run_batched</code>","text":"<pre><code>def run_batched(self, tasks: List[str]) -&gt; List[str]:\n</code></pre>"},{"location":"swarms/structs/moa/#description_6","title":"Description","text":"<p>Processes multiple tasks sequentially, returning a list of responses.</p>"},{"location":"swarms/structs/moa/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>tasks</code> <code>List[str]</code> List of tasks to process"},{"location":"swarms/structs/moa/#returns_2","title":"Returns","text":"Type Description <code>List[str]</code> List of responses for each task"},{"location":"swarms/structs/moa/#run_concurrently","title":"<code>run_concurrently</code>","text":"<pre><code>def run_concurrently(self, tasks: List[str]) -&gt; List[str]:\n</code></pre>"},{"location":"swarms/structs/moa/#description_7","title":"Description","text":"<p>Processes multiple tasks concurrently using a ThreadPoolExecutor, optimizing for parallel execution.</p>"},{"location":"swarms/structs/moa/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>tasks</code> <code>List[str]</code> List of tasks to process concurrently"},{"location":"swarms/structs/moa/#returns_3","title":"Returns","text":"Type Description <code>List[str]</code> List of responses for each task"},{"location":"swarms/structs/moa/#detailed-explanation","title":"Detailed Explanation","text":""},{"location":"swarms/structs/moa/#initialization","title":"Initialization","text":"<p>The <code>__init__</code> method initializes the swarm with the provided parameters, sets up the conversation rules, and invokes the initialization of the swarm. It also ensures the validity of the <code>agents</code> and <code>final_agent</code> attributes by calling the <code>agent_check</code> and <code>final_agent_check</code> methods respectively.</p>"},{"location":"swarms/structs/moa/#agent-validation","title":"Agent Validation","text":"<p>The <code>agent_check</code> method validates whether the <code>agents</code> attribute is a list of <code>Agent</code> instances, while the <code>final_agent_check</code> method validates whether the <code>final_agent</code> is an instance of <code>Agent</code>. These checks are crucial to ensure that the swarm operates correctly with the appropriate agent types.</p>"},{"location":"swarms/structs/moa/#swarm-initialization","title":"Swarm Initialization","text":"<p>The <code>swarm_initialization</code> method logs essential information about the swarm, including its name, description, and the number of agents. This provides a clear starting point for the swarm's operations and facilitates debugging and monitoring.</p>"},{"location":"swarms/structs/moa/#running-the-swarm","title":"Running the Swarm","text":"<p>The <code>run</code> method is the core of the <code>MixtureOfAgents</code> class. It orchestrates the execution of agents through multiple layers, collects their outputs, and processes the final output using the <code>final_agent</code>. The conversation history is maintained and updated throughout this process, allowing for a seamless flow of information and responses.</p> <p>During each layer, the method iterates over the agents, invokes their <code>run</code> method with the current conversation history, and logs the outputs. These outputs are then added to the conversation, and the history is updated for the next layer.</p> <p>After all layers are completed, the final output agent processes the entire conversation history, and the metadata is created and optionally saved to a file. This metadata includes details about the layers, agent runs, and final output, providing a comprehensive record of the swarm's execution.</p>"},{"location":"swarms/structs/moa/#additional-information-and-tips","title":"Additional Information and Tips","text":""},{"location":"swarms/structs/moa/#common-issues-and-solutions","title":"Common Issues and Solutions","text":"<ul> <li>Type Errors: Ensure that all agents in the <code>agents</code> list and the <code>final_agent</code> are instances of the <code>Agent</code> class. The <code>agent_check</code> and <code>final_agent_check</code> methods help validate this.</li> <li>Verbose Logging: Use the <code>verbose</code> flag to control the verbosity of the output. This can help with debugging or reduce clutter in the logs.</li> <li>Auto-Save Feature: Utilize the <code>auto_save</code> flag to automatically save the metadata to a file. This can be useful for keeping records of the swarm's operations without manual intervention.</li> </ul>"},{"location":"swarms/structs/moa/#references-and-resources","title":"References and Resources","text":"<p>For further reading and background information on the concepts used in the <code>MixtureOfAgents</code> class, refer to the paper: https://arxiv.org/pdf/2406.04692.</p>"},{"location":"swarms/structs/moa/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/moa/#example-1-basic-initialization-and-run","title":"Example 1: Basic Initialization and Run","text":"<pre><code>from swarms import MixtureOfAgents, Agent\n\nfrom swarm_models import OpenAIChat\n\n# Define agents\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the accountants\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n# Initialize accountant 1\naccountant1 = Agent(\n    agent_name=\"Accountant1\",\n    system_prompt=\"Prepares financial statements\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\n# Initialize accountant 2\naccountant2 = Agent(\n    agent_name=\"Accountant2\",\n    system_prompt=\"Audits financial records\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n\n# Initialize the MixtureOfAgents\nmoe_swarm = MixtureOfAgents(agents=[director, accountant1, accountant2], final_agent=director)\n\n# Run the swarm\nhistory = moe_swarm.run(task=\"Perform task X.\")\nprint(history)\n</code></pre>"},{"location":"swarms/structs/moa/#example-2-verbose-output-and-auto-save","title":"Example 2: Verbose Output and Auto-Save","text":"<pre><code>from swarms import MixtureOfAgents, Agent\n\nfrom swarm_models import OpenAIChat\n\n# Define Agents\n# Define agents\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the accountants\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n# Initialize accountant 1\naccountant1 = Agent(\n    agent_name=\"Accountant1\",\n    system_prompt=\"Prepares financial statements\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\n# Initialize accountant 2\naccountant2 = Agent(\n    agent_name=\"Accountant2\",\n    system_prompt=\"Audits financial records\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n# Initialize the MixtureOfAgents with verbose output and auto-save enabled\nmoe_swarm = MixtureOfAgents(\n    agents=[director, accountant1, accountant2],\n    final_agent=director,\n    verbose=True,\n    auto_save=True\n)\n\n# Run the swarm\nhistory = moe_swarm.run(task=\"Analyze data set Y.\")\nprint(history)\n</code></pre>"},{"location":"swarms/structs/moa/#example-3-custom-rules-and-multiple-layers","title":"Example 3: Custom Rules and Multiple Layers","text":"<pre><code>from swarms import MixtureOfAgents, Agent\n\nfrom swarm_models import OpenAIChat\n\n# Define agents\n# Initialize the director agent\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the accountants\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n# Initialize accountant 1\naccountant1 = Agent(\n    agent_name=\"Accountant1\",\n    system_prompt=\"Prepares financial statements\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\n# Initialize accountant 2\naccountant2 = Agent(\n    agent_name=\"Accountant2\",\n    system_prompt=\"Audits financial records\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n# Initialize the MixtureOfAgents with custom rules and multiple layers\nmoe_swarm = MixtureOfAgents(\n    agents=[director, accountant1, accountant2],\n    final_agent=director,\n    layers=5,\n    rules=\"Custom rules for the swarm\"\n)\n\n# Run the swarm\nhistory = moe_swarm.run(task=\"Optimize process Z.\")\nprint(history)\n</code></pre> <p>This comprehensive documentation provides a detailed understanding of the <code>MixtureOfAgents</code> class, its attributes, methods, and usage. The examples illustrate how to initialize and run the swarm, demonstrating its flexibility and capability to handle various tasks and configurations.</p>"},{"location":"swarms/structs/moa/#conclusion","title":"Conclusion","text":"<p>The <code>MixtureOfAgents</code> class is a powerful and flexible framework for managing and orchestrating a swarm of agents. By following a structured approach of parallel and sequential processing, it enables the implementation of complex multi-step workflows where intermediate results are refined through multiple layers of agent interactions. This architecture is particularly suitable for tasks that require iterative processing, collaboration among diverse agents, and sophisticated aggregation of outputs.</p>"},{"location":"swarms/structs/moa/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Flexible Initialization: The class allows for customizable initialization with various parameters, enabling users to tailor the swarm's configuration to their specific needs.</li> <li>Robust Agent Management: With built-in validation methods, the class ensures that all agents and the final agent are correctly instantiated, preventing runtime errors and facilitating smooth execution.</li> <li>Layered Processing: The layered approach to processing allows for intermediate results to be iteratively refined, enhancing the overall output quality.</li> <li>Verbose Logging and Auto-Save: These features aid in debugging, monitoring, and record-keeping, providing transparency and ease of management.</li> <li>Comprehensive Documentation: The detailed class and method documentation, along with numerous usage examples, provide a clear and thorough understanding of how to leverage the <code>MixtureOfAgents</code> class effectively.</li> </ol>"},{"location":"swarms/structs/moa/#practical-applications","title":"Practical Applications","text":"<p>The <code>MixtureOfAgents</code> class can be applied in various domains, including but not limited to:</p> <ul> <li>Natural Language Processing (NLP): Managing a swarm of NLP models to process, analyze, and synthesize text.</li> <li>Data Analysis: Coordinating multiple data analysis agents to process and interpret complex data sets.</li> <li>Optimization Problems: Running a swarm of optimization algorithms to solve complex problems in fields such as logistics, finance, and engineering.</li> <li>AI Research: Implementing experimental setups that require the collaboration of multiple AI models or agents to explore new methodologies and approaches.</li> </ul>"},{"location":"swarms/structs/moa/#future-extensions","title":"Future Extensions","text":"<p>The <code>MixtureOfAgents</code> framework provides a solid foundation for further extensions and customizations, including:</p> <ul> <li>Dynamic Layer Configuration: Allowing layers to be added or removed dynamically based on the task requirements or intermediate results.</li> <li>Advanced Agent Communication: Enhancing the communication protocols between agents to allow for more sophisticated information exchange.</li> <li>Integration with Other Frameworks: Seamlessly integrating with other machine learning or data processing frameworks to leverage their capabilities within the swarm architecture.</li> </ul> <p>In conclusion, the <code>MixtureOfAgents</code> class represents a versatile and efficient solution for orchestrating multi-agent systems, facilitating complex task execution through its structured and layered approach. By harnessing the power of parallel and sequential processing, it opens up new possibilities for tackling intricate problems across various domains.</p>"},{"location":"swarms/structs/moa/#additional-examples","title":"Additional Examples","text":""},{"location":"swarms/structs/moa/#example-4-batch-processing","title":"Example 4: Batch Processing","text":"<pre><code>from swarms import MixtureOfAgents, Agent\nfrom swarm_models import OpenAIChat\n\n# Initialize agents as in previous examples\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the accountants\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\naccountant1 = Agent(\n    agent_name=\"Accountant1\",\n    system_prompt=\"Prepares financial statements\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\naccountant2 = Agent(\n    agent_name=\"Accountant2\",\n    system_prompt=\"Audits financial records\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n# Initialize MixtureOfAgents\nmoe_swarm = MixtureOfAgents(\n    agents=[director, accountant1, accountant2],\n    final_agent=director\n)\n\n# Process multiple tasks in batch\ntasks = [\n    \"Analyze Q1 financial statements\",\n    \"Review tax compliance\",\n    \"Prepare budget forecast\"\n]\nresults = moe_swarm.run_batched(tasks)\nfor task, result in zip(tasks, results):\n    print(f\"Task: {task}\\nResult: {result}\\n\")\n</code></pre>"},{"location":"swarms/structs/moa/#example-5-concurrent-processing","title":"Example 5: Concurrent Processing","text":"<pre><code>from swarms import MixtureOfAgents, Agent\nfrom swarm_models import OpenAIChat\n\n# Initialize agents as before\n# ... agent initialization code ...\n\n# Initialize MixtureOfAgents\nmoe_swarm = MixtureOfAgents(\n    agents=[director, accountant1, accountant2],\n    final_agent=director\n)\n\n# Process multiple tasks concurrently\ntasks = [\n    \"Generate monthly report\",\n    \"Audit expense claims\",\n    \"Update financial projections\",\n    \"Review investment portfolio\"\n]\nresults = moe_swarm.run_concurrently(tasks)\nfor task, result in zip(tasks, results):\n    print(f\"Task: {task}\\nResult: {result}\\n\")\n</code></pre>"},{"location":"swarms/structs/moa/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/structs/moa/#context-preservation","title":"Context Preservation","text":"<p>The <code>MixtureOfAgents</code> class maintains context between iterations when running multiple loops. Each subsequent iteration receives the context from previous runs, allowing for more sophisticated and context-aware processing.</p>"},{"location":"swarms/structs/moa/#asynchronous-processing","title":"Asynchronous Processing","text":"<p>The class implements asynchronous processing internally using Python's <code>asyncio</code>, enabling efficient handling of concurrent operations and improved performance for complex workflows.</p>"},{"location":"swarms/structs/moa/#telemetry-and-logging","title":"Telemetry and Logging","text":"<p>Built-in telemetry and logging capabilities help track agent performance and maintain detailed execution records: - Automatic logging of agent outputs - Structured data capture using Pydantic models - JSON-formatted output options</p>"},{"location":"swarms/structs/model_router/","title":"ModelRouter Docs","text":"<p>The ModelRouter is an intelligent routing system that automatically selects and executes AI models based on task requirements. It leverages a function-calling architecture to analyze tasks and recommend the optimal model and provider combination for each specific use case.</p>"},{"location":"swarms/structs/model_router/#key-features","title":"Key Features","text":"<ul> <li>Dynamic model selection based on task complexity and requirements</li> <li>Multi-provider support (OpenAI, Anthropic, Google, etc.)</li> <li>Concurrent and asynchronous execution capabilities</li> <li>Batch processing with memory</li> <li>Automatic error handling and retries</li> <li>Provider-aware routing</li> <li>Cost optimization</li> </ul>"},{"location":"swarms/structs/model_router/#constructor-arguments","title":"Constructor Arguments","text":"Parameter Type Default Description system_prompt str model_router_system_prompt Custom prompt for guiding model selection behavior max_tokens int 4000 Maximum token limit for model outputs temperature float 0.5 Control parameter for response randomness (0.0-1.0) max_workers int/str 10 Maximum concurrent workers (\"auto\" for CPU count) api_key str None API key for model access max_loops int 1 Maximum number of refinement iterations *args Any None Additional positional arguments **kwargs Any None Additional keyword arguments"},{"location":"swarms/structs/model_router/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/model_router/#runtask-str-str","title":"run(task: str) -&gt; str","text":"<p>Executes a single task through the model router with memory and refinement capabilities.</p>"},{"location":"swarms/structs/model_router/#installation","title":"Installation","text":"<ol> <li>Install the latest version of swarms using pip:</li> </ol> <pre><code>pip3 install -U swarms\n</code></pre> <ol> <li>Setup your API Keys in your .env file with the following:</li> </ol> <pre><code>OPENAI_API_KEY=your_openai_api_key\nANTHROPIC_API_KEY=your_anthropic_api_key\nGOOGLE_API_KEY=your_google_api_key\n# Add more API keys as needed following litellm format\n</code></pre> <pre><code>from swarms import ModelRouter\n\nrouter = ModelRouter()\n\n# Simple text analysis\nresult = router.run(\"Analyze the sentiment and key themes in this customer feedback\")\n\n# Complex reasoning task\ncomplex_result = router.run(\"\"\"\nEvaluate the following business proposal:\n- Initial investment: $500,000\n- Projected ROI: 25% annually\n- Market size: $2B\n- Competition: 3 major players\nProvide detailed analysis and recommendations.\n\"\"\")\n</code></pre>"},{"location":"swarms/structs/model_router/#batch_runtasks-list-list","title":"batch_run(tasks: list) -&gt; list","text":"<p>Executes multiple tasks sequentially with result aggregation.</p> <pre><code># Multiple analysis tasks\ntasks = [\n    \"Analyze Q1 financial performance\",\n    \"Predict Q2 market trends\",\n    \"Evaluate competitor strategies\",\n    \"Generate growth recommendations\"\n]\n\nresults = router.batch_run(tasks)\n\n# Process results\nfor task, result in zip(tasks, results):\n    print(f\"Task: {task}\\nResult: {result}\\n\")\n</code></pre>"},{"location":"swarms/structs/model_router/#concurrent_runtasks-list-list","title":"concurrent_run(tasks: list) -&gt; list","text":"<p>Parallel execution of multiple tasks using thread pooling.</p> <pre><code>import asyncio\nfrom typing import List\n\n# Define multiple concurrent tasks\nanalysis_tasks = [\n    \"Perform technical analysis of AAPL stock\",\n    \"Analyze market sentiment from social media\",\n    \"Generate trading signals\",\n    \"Calculate risk metrics\"\n]\n\n# Execute tasks concurrently\nresults = router.concurrent_run(analysis_tasks)\n\n# Process results with error handling\nfor task, result in zip(analysis_tasks, results):\n    try:\n        processed_result = process_analysis(result)\n        save_to_database(processed_result)\n    except Exception as e:\n        log_error(f\"Error processing {task}: {str(e)}\")\n</code></pre>"},{"location":"swarms/structs/model_router/#async_runtask-str-asynciotask","title":"async_run(task: str) -&gt; asyncio.Task","text":"<p>Asynchronous task execution with coroutine support.</p> <pre><code>async def process_data_stream():\n    tasks = []\n    async for data in data_stream:\n        task = await router.async_run(f\"Process data: {data}\")\n        tasks.append(task)\n\n    results = await asyncio.gather(*tasks)\n    return results\n\n# Usage in async context\nasync def main():\n    router = ModelRouter()\n    results = await process_data_stream()\n</code></pre>"},{"location":"swarms/structs/model_router/#advanced-usage-examples","title":"Advanced Usage Examples","text":""},{"location":"swarms/structs/model_router/#financial-analysis-system","title":"Financial Analysis System","text":"<pre><code>from swarms import ModelRouter\nfrom typing import Dict, List\nimport pandas as pd\n\nclass FinancialAnalysisSystem:\n    def __init__(self):\n        self.router = ModelRouter(\n            temperature=0.3,  # Lower temperature for more deterministic outputs\n            max_tokens=8000,  # Higher token limit for detailed analysis\n            max_loops=2  # Allow for refinement iteration\n        )\n\n    def analyze_company_financials(self, financial_data: Dict) -&gt; Dict:\n        analysis_task = f\"\"\"\n        Perform comprehensive financial analysis:\n\n        Financial Metrics:\n        - Revenue: ${financial_data['revenue']}M\n        - EBITDA: ${financial_data['ebitda']}M\n        - Debt/Equity: {financial_data['debt_equity']}\n        - Working Capital: ${financial_data['working_capital']}M\n\n        Required Analysis:\n        1. Profitability assessment\n        2. Liquidity analysis\n        3. Growth projections\n        4. Risk evaluation\n        5. Investment recommendations\n\n        Provide detailed insights and actionable recommendations.\n        \"\"\"\n\n        result = self.router.run(analysis_task)\n        return self._parse_analysis_result(result)\n\n    def _parse_analysis_result(self, result: str) -&gt; Dict:\n        # Implementation of result parsing\n        pass\n\n# Usage\nanalyzer = FinancialAnalysisSystem()\ncompany_data = {\n    'revenue': 150,\n    'ebitda': 45,\n    'debt_equity': 0.8,\n    'working_capital': 25\n}\n\nanalysis = analyzer.analyze_company_financials(company_data)\n</code></pre>"},{"location":"swarms/structs/model_router/#healthcare-data-processing-pipeline","title":"Healthcare Data Processing Pipeline","text":"<pre><code>from swarms import ModelRouter\nimport pandas as pd\nfrom typing import List, Dict\n\nclass MedicalDataProcessor:\n    def __init__(self):\n        self.router = ModelRouter(\n            max_workers=\"auto\",  # Automatic worker scaling\n            temperature=0.2,     # Conservative temperature for medical analysis\n            system_prompt=\"\"\"You are a specialized medical data analyzer focused on:\n            1. Clinical terminology interpretation\n            2. Patient data analysis\n            3. Treatment recommendation review\n            4. Medical research synthesis\"\"\"\n        )\n\n    async def process_patient_records(self, records: List[Dict]) -&gt; List[Dict]:\n        analysis_tasks = []\n\n        for record in records:\n            task = f\"\"\"\n            Analyze patient record:\n            - Age: {record['age']}\n            - Symptoms: {', '.join(record['symptoms'])}\n            - Vital Signs: {record['vitals']}\n            - Medications: {', '.join(record['medications'])}\n            - Lab Results: {record['lab_results']}\n\n            Provide:\n            1. Symptom analysis\n            2. Medication interaction check\n            3. Lab results interpretation\n            4. Treatment recommendations\n            \"\"\"\n            analysis_tasks.append(task)\n\n        results = await asyncio.gather(*[\n            self.router.async_run(task) for task in analysis_tasks\n        ])\n\n        return [self._parse_medical_analysis(r) for r in results]\n\n    def _parse_medical_analysis(self, analysis: str) -&gt; Dict:\n        # Implementation of medical analysis parsing\n        pass\n\n# Usage\nasync def main():\n    processor = MedicalDataProcessor()\n    patient_records = [\n        {\n            'age': 45,\n            'symptoms': ['fever', 'cough', 'fatigue'],\n            'vitals': {'bp': '120/80', 'temp': '38.5C'},\n            'medications': ['lisinopril', 'metformin'],\n            'lab_results': 'WBC: 11,000, CRP: 2.5'\n        }\n        # More records...\n    ]\n\n    analyses = await processor.process_patient_records(patient_records)\n</code></pre>"},{"location":"swarms/structs/model_router/#natural-language-processing-pipeline","title":"Natural Language Processing Pipeline","text":"<pre><code>from swarms import ModelRouter\nfrom typing import List, Dict\nimport asyncio\n\nclass NLPPipeline:\n    def __init__(self):\n        self.router = ModelRouter(\n            temperature=0.4,\n            max_loops=2\n        )\n\n    def process_documents(self, documents: List[str]) -&gt; List[Dict]:\n        tasks = [self._create_nlp_task(doc) for doc in documents]\n        results = self.router.concurrent_run(tasks)\n        return [self._parse_nlp_result(r) for r in results]\n\n    def _create_nlp_task(self, document: str) -&gt; str:\n        return f\"\"\"\n        Perform comprehensive NLP analysis:\n\n        Text: {document}\n\n        Required Analysis:\n        1. Entity recognition\n        2. Sentiment analysis\n        3. Topic classification\n        4. Key phrase extraction\n        5. Intent detection\n\n        Provide structured analysis with confidence scores.\n        \"\"\"\n\n    def _parse_nlp_result(self, result: str) -&gt; Dict:\n        # Implementation of NLP result parsing\n        pass\n\n# Usage\npipeline = NLPPipeline()\ndocuments = [\n    \"We're extremely satisfied with the new product features!\",\n    \"The customer service response time needs improvement.\",\n    \"Looking to upgrade our subscription plan next month.\"\n]\n\nanalyses = pipeline.process_documents(documents)\n</code></pre>"},{"location":"swarms/structs/model_router/#available-models-and-use-cases","title":"Available Models and Use Cases","text":"Model Provider Optimal Use Cases Characteristics gpt-4-turbo OpenAI Complex reasoning, Code generation, Creative writing High accuracy, Latest knowledge cutoff claude-3-opus Anthropic Research analysis, Technical documentation, Long-form content Strong reasoning, Detailed outputs gemini-pro Google Multimodal tasks, Code generation, Technical analysis Fast inference, Strong coding abilities mistral-large Mistral General tasks, Content generation, Classification Open source, Good price/performance deepseek-reasoner DeepSeek Mathematical analysis, Logic problems, Scientific computing Specialized reasoning capabilities"},{"location":"swarms/structs/model_router/#provider-capabilities","title":"Provider Capabilities","text":"Provider Strengths Best For Integration Notes OpenAI Consistent performance, Strong reasoning Production systems, Complex tasks Requires API key setup Anthropic Safety features, Detailed analysis Research, Technical writing Claude-specific formatting Google Technical tasks, Multimodal support Code generation, Analysis Vertex AI integration available Groq High-speed inference Real-time applications Optimized for specific models DeepSeek Specialized reasoning Scientific computing Custom API integration Mistral Open source flexibility General applications Self-hosted options available"},{"location":"swarms/structs/model_router/#performance-optimization-tips","title":"Performance Optimization Tips","text":"<ol> <li>Token Management</li> <li>Set appropriate max_tokens based on task complexity</li> <li>Monitor token usage for cost optimization</li> <li> <p>Use streaming for long outputs</p> </li> <li> <p>Concurrency Settings</p> </li> <li>Adjust max_workers based on system resources</li> <li>Use \"auto\" workers for optimal CPU utilization</li> <li> <p>Monitor memory usage with large batch sizes</p> </li> <li> <p>Temperature Tuning</p> </li> <li>Lower (0.1-0.3) for factual/analytical tasks</li> <li>Higher (0.7-0.9) for creative tasks</li> <li> <p>Mid-range (0.4-0.6) for balanced outputs</p> </li> <li> <p>System Prompts</p> </li> <li>Customize for specific domains</li> <li>Include relevant context</li> <li>Define clear output formats</li> </ol>"},{"location":"swarms/structs/model_router/#dependencies","title":"Dependencies","text":"<ul> <li>asyncio: Asynchronous I/O support</li> <li>concurrent.futures: Thread pool execution</li> <li>pydantic: Data validation</li> <li>litellm: LLM interface standardization</li> </ul>"},{"location":"swarms/structs/multi_agent_collaboration_examples/","title":"Multi-Agent Examples","text":""},{"location":"swarms/structs/multi_agent_collaboration_examples/#sequentialworkflow","title":"<code>SequentialWorkflow</code>","text":"<p>Sequential Workflow enables you to sequentially execute tasks with <code>Agent</code> and then pass the output into the next agent and onwards until you have specified your max loops.</p> <pre><code>from swarms import Agent, SequentialWorkflow\n\nfrom swarm_models import Anthropic\n\n\n# Initialize the language model agent (e.g., GPT-3)\nllm = Anthropic()\n\n# Initialize agents for individual tasks\nagent1 = Agent(\n    agent_name=\"Blog generator\",\n    system_prompt=\"Generate a blog post like stephen king\",\n    llm=llm,\n    max_loops=1,\n    dashboard=False,\n    tools=[],\n)\nagent2 = Agent(\n    agent_name=\"summarizer\",\n    system_prompt=\"Sumamrize the blog post\",\n    llm=llm,\n    max_loops=1,\n    dashboard=False,\n    tools=[],\n)\n\n# Create the Sequential workflow\nworkflow = SequentialWorkflow(\n    agents=[agent1, agent2], max_loops=1, verbose=False\n)\n\n# Run the workflow\nworkflow.run(\n    \"Generate a blog post on how swarms of agents can help businesses grow.\"\n)\n</code></pre>"},{"location":"swarms/structs/multi_agent_collaboration_examples/#agentrearrange","title":"<code>AgentRearrange</code>","text":"<p>Inspired by Einops and einsum, this orchestration techniques enables you to map out the relationships between various agents. For example you specify linear and sequential relationships like <code>a -&gt; a1 -&gt; a2 -&gt; a3</code> or concurrent relationships where the first agent will send a message to 3 agents all at once: <code>a -&gt; a1, a2, a3</code>. You can customize your workflow to mix sequential and concurrent relationships. Docs Available:</p> <pre><code>from swarms import Agent, AgentRearrange\n\n\nfrom swarm_models import Anthropic\n\n# Initialize the director agent\n\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the workers\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n\n# Initialize worker 1\n\nworker1 = Agent(\n    agent_name=\"Worker1\",\n    system_prompt=\"Generates a transcript for a youtube video on what swarms are\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"worker1.json\",\n)\n\n\n# Initialize worker 2\nworker2 = Agent(\n    agent_name=\"Worker2\",\n    system_prompt=\"Summarizes the transcript generated by Worker1\",\n    llm=Anthropic(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"worker2.json\",\n)\n\n\n# Create a list of agents\nagents = [director, worker1, worker2]\n\n# Define the flow pattern\nflow = \"Director -&gt; Worker1 -&gt; Worker2\"\n\n# Using AgentRearrange class\nagent_system = AgentRearrange(agents=agents, flow=flow)\noutput = agent_system.run(\n    \"Create a format to express and communicate swarms of llms in a structured manner for youtube\"\n)\nprint(output)\n</code></pre>"},{"location":"swarms/structs/multi_agent_collaboration_examples/#hierarhicalswarm","title":"<code>HierarhicalSwarm</code>","text":"<p>Coming soon...</p>"},{"location":"swarms/structs/multi_agent_collaboration_examples/#graphswarm","title":"<code>GraphSwarm</code>","text":"<pre><code>from swarms.structs.agent import Agent              \nfrom swarms import Edge, GraphWorkflow, Node, NodeType  \n\n\n# Initialize two agents with GPT-4o-mini\nagent1 = Agent(\n    agent_name=\"agent1\",\n    system_prompt=\"You are an autonomous agent executing workflow tasks.\",\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    saved_state_path=\"agent1_state.json\",\n    model_name=\"gpt-4o-mini\",\n)  \n\nagent2 = Agent(\n    agent_name=\"agent2\",\n    system_prompt=\"You are an autonomous agent executing workflow tasks.\",\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    saved_state_path=\"agent2_state.json\",\n    model_name=\"gpt-4o-mini\",\n) \n\ndef sample_task():\n    print(\"Running sample task\")\n    return \"Task completed\"\n\n# Build the DAG\nwf = GraphWorkflow()\nwf.add_node(Node(id=\"agent1\", type=NodeType.AGENT, agent=agent1))\nwf.add_node(Node(id=\"agent2\", type=NodeType.AGENT, agent=agent2))\nwf.add_node(Node(id=\"task1\",  type=NodeType.TASK, callable=sample_task))  \n\n# Connect agents to the task\nwf.add_edge(Edge(source=\"agent1\", target=\"task1\"))\nwf.add_edge(Edge(source=\"agent2\", target=\"task1\"))  \n\nwf.set_entry_points([\"agent1\", \"agent2\"])\nwf.set_end_points([\"task1\"])  \n\n# Visualize and run\nprint(wf.visualize())  \nresults = wf.run()    \nprint(\"Execution results:\", results)\n</code></pre>"},{"location":"swarms/structs/multi_agent_collaboration_examples/#mixtureofagents","title":"<code>MixtureOfAgents</code>","text":"<p>This is an implementation from the paper: \"Mixture-of-Agents Enhances Large Language Model Capabilities\" by together.ai, it achieves SOTA on AlpacaEval 2.0, MT-Bench and FLASK, surpassing GPT-4 Omni. Great for tasks that need to be parallelized and then sequentially fed into another loop</p> <pre><code>from swarms import Agent, OpenAIChat, MixtureOfAgents\n\n# Initialize the director agent\ndirector = Agent(\n    agent_name=\"Director\",\n    system_prompt=\"Directs the tasks for the accountants\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"director.json\",\n)\n\n# Initialize accountant 1\naccountant1 = Agent(\n    agent_name=\"Accountant1\",\n    system_prompt=\"Prepares financial statements\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant1.json\",\n)\n\n# Initialize accountant 2\naccountant2 = Agent(\n    agent_name=\"Accountant2\",\n    system_prompt=\"Audits financial records\",\n    llm=OpenAIChat(),\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"accountant2.json\",\n)\n\n# Create a list of agents\nagents = [director, accountant1, accountant2]\n\n\n# Swarm\nswarm = MixtureOfAgents(\n    name=\"Mixture of Accountants\",\n    agents=agents,\n    layers=3,\n    final_agent=director,\n)\n\n\n# Run the swarm\nout = swarm.run(\"Prepare financial statements and audit financial records\")\nprint(out)\n</code></pre>"},{"location":"swarms/structs/multi_agent_orchestration/","title":"Multi-Agent Orchestration:","text":"<p>Swarms was designed to faciliate the communication between many different and specialized agents from a vast array of other frameworks such as langchain, autogen, crew, and more.</p> <p>In traditional swarm theory, there are many types of swarms usually for very specialized use-cases and problem sets. Such as Hiearchical and sequential are great for accounting and sales, because there is usually a boss coordinator agent that distributes a workload to other specialized agents.</p> Name Description Code Link Use Cases Hierarchical Swarms A system where agents are organized in a hierarchy, with higher-level agents coordinating lower-level agents to achieve complex tasks. Code Link Manufacturing process optimization, multi-level sales management, healthcare resource coordination Agent Rearrange A setup where agents rearrange themselves dynamically based on the task requirements and environmental conditions. Code Link Adaptive manufacturing lines, dynamic sales territory realignment, flexible healthcare staffing Concurrent Workflows Agents perform different tasks simultaneously, coordinating to complete a larger goal. Code Link Concurrent production lines, parallel sales operations, simultaneous patient care processes Sequential Coordination Agents perform tasks in a specific sequence, where the completion of one task triggers the start of the next. Code Link Step-by-step assembly lines, sequential sales processes, stepwise patient treatment workflows Parallel Processing Agents work on different parts of a task simultaneously to speed up the overall process. Code Link Parallel data processing in manufacturing, simultaneous sales analytics, concurrent medical tests"},{"location":"swarms/structs/multi_agent_router/","title":"MultiAgentRouter Documentation","text":"<p>The MultiAgentRouter is a sophisticated task routing system that efficiently delegates tasks to specialized AI agents. It uses a \"boss\" agent to analyze incoming tasks and route them to the most appropriate specialized agent based on their capabilities and expertise.</p>"},{"location":"swarms/structs/multi_agent_router/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Installation</li> <li>Key Components</li> <li>Arguments</li> <li>Methods</li> <li>Usage Examples</li> <li>Healthcare</li> <li>Finance</li> <li>Legal</li> <li>Research</li> </ul>"},{"location":"swarms/structs/multi_agent_router/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/structs/multi_agent_router/#key-components","title":"Key Components","text":""},{"location":"swarms/structs/multi_agent_router/#arguments-table","title":"Arguments Table","text":"Argument Type Default Description name str \"swarm-router\" Name identifier for the router instance description str \"Routes tasks...\" Description of the router's purpose agents List[Agent] [] List of available specialized agents model str \"gpt-4o-mini\" Base language model for the boss agent temperature float 0.1 Temperature parameter for model outputs shared_memory_system callable None Optional shared memory system output_type Literal[\"json\", \"string\"] \"json\" Format of agent outputs execute_task bool True Whether to execute routed tasks"},{"location":"swarms/structs/multi_agent_router/#methods-table","title":"Methods Table","text":"Method Arguments Returns Description route_task task: str dict Routes a single task to appropriate agent batch_run tasks: List[str] List[dict] Sequentially routes multiple tasks concurrent_batch_run tasks: List[str] List[dict] Concurrently routes multiple tasks query_ragent task: str str Queries the research agent find_agent_in_list agent_name: str Optional[Agent] Finds agent by name"},{"location":"swarms/structs/multi_agent_router/#production-examples","title":"Production Examples","text":""},{"location":"swarms/structs/multi_agent_router/#healthcare-example","title":"Healthcare Example","text":"<pre><code>from swarms import Agent, MultiAgentRouter\n\n# Define specialized healthcare agents\nagents = [\n    Agent(\n        agent_name=\"DiagnosisAgent\",\n        description=\"Specializes in preliminary symptom analysis and diagnostic suggestions\",\n        system_prompt=\"\"\"You are a medical diagnostic assistant. Analyze symptoms and provide \n        evidence-based diagnostic suggestions, always noting this is for informational purposes \n        only and recommending professional medical consultation.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"TreatmentPlanningAgent\",\n        description=\"Assists in creating treatment plans and medical documentation\",\n        system_prompt=\"\"\"You are a treatment planning assistant. Help create structured \n        treatment plans based on confirmed diagnoses, following medical best practices \n        and guidelines.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"MedicalResearchAgent\",\n        description=\"Analyzes medical research papers and clinical studies\",\n        system_prompt=\"\"\"You are a medical research analyst. Analyze and summarize medical \n        research papers, clinical trials, and scientific studies, providing evidence-based \n        insights.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    )\n]\n\n# Initialize router\nhealthcare_router = MultiAgentRouter(\n    name=\"Healthcare-Router\",\n    description=\"Routes medical and healthcare-related tasks to specialized agents\",\n    agents=agents,\n    model=\"gpt-4o\",\n    temperature=0.1\n)\n\n# Example usage\ntry:\n    # Process medical case\n    case_analysis = healthcare_router.route_task(\n        \"\"\"Patient presents with: \n        - Persistent dry cough for 3 weeks\n        - Mild fever (38.1\u00b0C)\n        - Fatigue\n        Analyze symptoms and suggest potential diagnoses for healthcare provider review.\"\"\"\n    )\n\n    # Research treatment options\n    treatment_research = healthcare_router.route_task(\n        \"\"\"Find recent clinical studies on treatment efficacy for community-acquired \n        pneumonia in adult patients, focusing on outpatient care.\"\"\"\n    )\n\n    # Process multiple cases concurrently\n    cases = [\n        \"Case 1: Patient symptoms...\",\n        \"Case 2: Patient symptoms...\",\n        \"Case 3: Patient symptoms...\"\n    ]\n    concurrent_results = healthcare_router.concurrent_batch_run(cases)\n\nexcept Exception as e:\n    logger.error(f\"Error in healthcare processing: {str(e)}\")\n</code></pre>"},{"location":"swarms/structs/multi_agent_router/#finance-example","title":"Finance Example","text":"<pre><code># Define specialized finance agents\nfinance_agents = [\n    Agent(\n        agent_name=\"MarketAnalysisAgent\",\n        description=\"Analyzes market trends and provides trading insights\",\n        system_prompt=\"\"\"You are a financial market analyst. Analyze market data, trends, \n        and indicators to provide evidence-based market insights and trading suggestions.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"RiskAssessmentAgent\",\n        description=\"Evaluates financial risks and compliance requirements\",\n        system_prompt=\"\"\"You are a risk assessment specialist. Analyze financial data \n        and operations for potential risks, ensuring regulatory compliance and suggesting \n        risk mitigation strategies.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"InvestmentAgent\",\n        description=\"Provides investment strategies and portfolio management\",\n        system_prompt=\"\"\"You are an investment strategy specialist. Develop and analyze \n        investment strategies, portfolio allocations, and provide long-term financial \n        planning guidance.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    )\n]\n\n# Initialize finance router\nfinance_router = MultiAgentRouter(\n    name=\"Finance-Router\",\n    description=\"Routes financial analysis and investment tasks\",\n    agents=finance_agents\n)\n\n# Example tasks\ntasks = [\n    \"\"\"Analyze current market conditions for technology sector, focusing on:\n    - AI/ML companies\n    - Semiconductor manufacturers\n    - Cloud service providers\n    Provide risk assessment and investment opportunities.\"\"\",\n\n    \"\"\"Develop a diversified portfolio strategy for a conservative investor with:\n    - Investment horizon: 10 years\n    - Risk tolerance: Low to medium\n    - Initial investment: $500,000\n    - Monthly contribution: $5,000\"\"\",\n\n    \"\"\"Conduct risk assessment for a fintech startup's crypto trading platform:\n    - Regulatory compliance requirements\n    - Security measures\n    - Operational risks\n    - Market risks\"\"\"\n]\n\n# Process tasks concurrently\nresults = finance_router.concurrent_batch_run(tasks)\n</code></pre>"},{"location":"swarms/structs/multi_agent_router/#legal-example","title":"Legal Example","text":"<pre><code># Define specialized legal agents\nlegal_agents = [\n    Agent(\n        agent_name=\"ContractAnalysisAgent\",\n        description=\"Analyzes legal contracts and documents\",\n        system_prompt=\"\"\"You are a legal document analyst. Review contracts and legal \n        documents for key terms, potential issues, and compliance requirements.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"ComplianceAgent\",\n        description=\"Ensures regulatory compliance and updates\",\n        system_prompt=\"\"\"You are a legal compliance specialist. Monitor and analyze \n        regulatory requirements, ensuring compliance and suggesting necessary updates \n        to policies and procedures.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    ),\n    Agent(\n        agent_name=\"LegalResearchAgent\",\n        description=\"Conducts legal research and case analysis\",\n        system_prompt=\"\"\"You are a legal researcher. Research relevant cases, statutes, \n        and regulations, providing comprehensive legal analysis and citations.\"\"\",\n        model_name=\"openai/gpt-4o\"\n    )\n]\n\n# Initialize legal router\nlegal_router = MultiAgentRouter(\n    name=\"Legal-Router\",\n    description=\"Routes legal analysis and compliance tasks\",\n    agents=legal_agents\n)\n\n# Example usage for legal department\ncontract_analysis = legal_router.route_task(\n    \"\"\"Review the following software licensing agreement:\n    [contract text]\n\n    Analyze for:\n    1. Key terms and conditions\n    2. Potential risks and liabilities\n    3. Compliance with current regulations\n    4. Suggested modifications\"\"\"\n)\n</code></pre>"},{"location":"swarms/structs/multi_agent_router/#error-handling-and-best-practices","title":"Error Handling and Best Practices","text":"<ol> <li> <p>Always use try-except blocks for task routing: <pre><code>try:\n    result = router.route_task(task)\nexcept Exception as e:\n    logger.error(f\"Task routing failed: {str(e)}\")\n</code></pre></p> </li> <li> <p>Monitor agent performance: <pre><code>if result[\"execution\"][\"execution_time\"] &gt; 5.0:\n    logger.warning(f\"Long execution time for task: {result['task']['original']}\")\n</code></pre></p> </li> <li> <p>Implement rate limiting for concurrent tasks: <pre><code>from concurrent.futures import ThreadPoolExecutor\nwith ThreadPoolExecutor(max_workers=5) as executor:\n    results = router.concurrent_batch_run(tasks)\n</code></pre></p> </li> <li> <p>Regular agent validation: <pre><code>for agent in router.agents.values():\n    if not agent.validate():\n        logger.error(f\"Agent validation failed: {agent.name}\")\n</code></pre></p> </li> </ol>"},{"location":"swarms/structs/multi_agent_router/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Task Batching</p> </li> <li> <p>Group similar tasks together</p> </li> <li> <p>Use concurrent_batch_run for independent tasks</p> </li> <li> <p>Monitor memory usage with large batches</p> </li> <li> <p>Model Selection</p> </li> <li> <p>Choose appropriate models based on task complexity</p> </li> <li> <p>Balance speed vs. accuracy requirements</p> </li> <li> <p>Consider cost implications</p> </li> <li> <p>Response Caching</p> </li> <li> <p>Implement caching for frequently requested analyses</p> </li> <li> <p>Use shared memory system for repeated queries</p> </li> <li> <p>Regular cache invalidation for time-sensitive data</p> </li> </ol>"},{"location":"swarms/structs/multi_agent_router/#security-considerations","title":"Security Considerations","text":"<ol> <li> <p>Data Privacy</p> </li> <li> <p>Implement data encryption</p> </li> <li> <p>Handle sensitive information appropriately</p> </li> <li> <p>Regular security audits</p> </li> <li> <p>Access Control</p> </li> <li> <p>Implement role-based access</p> </li> <li> <p>Audit logging</p> </li> <li> <p>Regular permission reviews</p> </li> </ol>"},{"location":"swarms/structs/multi_agent_router/#monitoring-and-logging","title":"Monitoring and Logging","text":"<ol> <li> <p>Performance Metrics</p> </li> <li> <p>Response times</p> </li> <li> <p>Success rates</p> </li> <li> <p>Error rates</p> </li> <li> <p>Resource utilization</p> </li> <li> <p>Logging</p> </li> <li> <p>Use structured logging</p> </li> <li> <p>Implement log rotation</p> </li> <li> <p>Regular log analysis</p> </li> <li> <p>Alerts</p> </li> <li> <p>Set up alerting for critical errors</p> </li> <li> <p>Monitor resource usage</p> </li> <li> <p>Track API rate limits</p> </li> </ol>"},{"location":"swarms/structs/multi_swarm_orchestration/","title":"Hierarchical Agent Orchestration Architectures","text":"<p>Hierarchical agent orchestration involves organizing multiple agents in structured layers to efficiently handle complex tasks. There are several key architectures available, each with distinct characteristics and use cases.</p> <p>Here are the Hierarchical swarms we support:</p> Architecture Strengths Weaknesses HHCS - Clear task routing- Specialized swarm handling- Parallel processing capability- Good for complex multi-domain tasks - More complex setup- Overhead in routing- Requires careful swarm design Auto Agent Builder - Dynamic agent creation- Flexible scaling- Self-organizing- Good for evolving tasks - Higher resource usage- Potential creation overhead- May create redundant agents SwarmRouter - Multiple workflow types- Simple configuration- Flexible deployment- Good for varied task types - Less specialized than HHCS- Limited inter-swarm communication- May require manual type selection"},{"location":"swarms/structs/multi_swarm_orchestration/#core-architectures","title":"Core Architectures","text":""},{"location":"swarms/structs/multi_swarm_orchestration/#1-hybrid-hierarchical-cluster-swarm-hhcs","title":"1. Hybrid Hierarchical-Cluster Swarm (HHCS)","text":"<p>Hybrid Hierarchical-Cluster Swarm (HHCS) is architecture that uses a Router Agent to analyze and distribute tasks to other swarms.</p> <ul> <li> <p>Tasks are routed to specialized swarms based on their requirements</p> </li> <li> <p>Enables parallel processing through multiple specialized swarms</p> </li> <li> <p>Ideal for complex, multi-domain tasks and enterprise-scale operations</p> </li> <li> <p>Provides clear task routing but requires more complex setup</p> </li> </ul> <pre><code>flowchart TD\n    Start([Task Input]) --&gt; RouterAgent[Router Agent]\n    RouterAgent --&gt; Analysis{Task Analysis}\n\n    Analysis --&gt;|Analyze Requirements| Selection[Swarm Selection]\n    Selection --&gt;|Select Best Swarm| Route[Route Task]\n\n    Route --&gt; Swarm1[Specialized Swarm 1]\n    Route --&gt; Swarm2[Specialized Swarm 2]\n    Route --&gt; SwarmN[Specialized Swarm N]\n\n    Swarm1 --&gt;|Process| Result1[Output 1]\n    Swarm2 --&gt;|Process| Result2[Output 2]\n    SwarmN --&gt;|Process| ResultN[Output N]\n\n    Result1 --&gt; Final[Final Output]\n    Result2 --&gt; Final\n    ResultN --&gt; Final</code></pre>"},{"location":"swarms/structs/multi_swarm_orchestration/#2-auto-agent-builder","title":"2. Auto Agent Builder","text":"<p>Auto Agent Builder is a dynamic agent architecture that creates specialized agents on-demand.</p> <ul> <li> <p>Analyzes tasks and automatically builds appropriate agents for the job</p> </li> <li> <p>Maintains an agent pool that feeds into task orchestration</p> </li> <li> <p>Best suited for evolving requirements and dynamic workloads</p> </li> <li> <p>Self-organizing but may have higher resource usage</p> </li> </ul> <pre><code>flowchart TD\n    Task[Task Input] --&gt; Builder[Agent Builder]\n    Builder --&gt; Analysis{Task Analysis}\n\n    Analysis --&gt; Create[Create Specialized Agents]\n    Create --&gt; Pool[Agent Pool]\n\n    Pool --&gt; Agent1[Specialized Agent 1]\n    Pool --&gt; Agent2[Specialized Agent 2]\n    Pool --&gt; AgentN[Specialized Agent N]\n\n    Agent1 --&gt; Orchestration[Task Orchestration]\n    Agent2 --&gt; Orchestration\n    AgentN --&gt; Orchestration\n\n    Orchestration --&gt; Result[Final Result]</code></pre>"},{"location":"swarms/structs/multi_swarm_orchestration/#3-swarmrouter","title":"3. SwarmRouter","text":"<p>SwarmRouter is a flexible system supporting multiple swarm architectures through a simple interface:</p> <ul> <li> <p>Sequential workflows</p> </li> <li> <p>Concurrent workflows</p> </li> <li> <p>Hierarchical swarms</p> </li> <li> <p>Group chat interactions</p> </li> <li> <p>Simpler to configure and deploy compared to other architectures</p> </li> <li> <p>Best for general-purpose tasks and smaller scale operations</p> </li> <li> <p>Recommended for 5-20 agents.</p> </li> </ul> <pre><code>flowchart TD\n    Input[Task Input] --&gt; Router[Swarm Router]\n    Router --&gt; TypeSelect{Swarm Type Selection}\n\n    TypeSelect --&gt;|Sequential| Seq[Sequential Workflow]\n    TypeSelect --&gt;|Concurrent| Con[Concurrent Workflow]\n    TypeSelect --&gt;|Hierarchical| Hier[Hierarchical Swarm]\n    TypeSelect --&gt;|Group| Group[Group Chat]\n\n    Seq --&gt; Output[Task Output]\n    Con --&gt; Output\n    Hier --&gt; Output\n    Group --&gt; Output</code></pre>"},{"location":"swarms/structs/multi_swarm_orchestration/#use-case-recommendations","title":"Use Case Recommendations","text":""},{"location":"swarms/structs/multi_swarm_orchestration/#hhcs-best-for","title":"HHCS: Best for:","text":"<ul> <li> <p>Enterprise-scale operations</p> </li> <li> <p>Multi-domain problems</p> </li> <li> <p>Complex task routing</p> </li> <li> <p>Parallel processing needs</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#auto-agent-builder-best-for","title":"Auto Agent Builder: Best for:","text":"<ul> <li> <p>Dynamic workloads</p> </li> <li> <p>Evolving requirements</p> </li> <li> <p>Research and development</p> </li> <li> <p>Exploratory tasks</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#swarmrouter-best-for","title":"SwarmRouter: Best for:","text":"<ul> <li> <p>General purpose tasks</p> </li> <li> <p>Quick deployment</p> </li> <li> <p>Mixed workflow types</p> </li> <li> <p>Smaller scale operations</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#documentation-links","title":"Documentation Links","text":""},{"location":"swarms/structs/multi_swarm_orchestration/#hhcs-documentation","title":"HHCS Documentation:","text":"<ul> <li> <p>Hybrid Hierarchical-Cluster Swarm Documentation</p> </li> <li> <p>Covers detailed implementation, constructor arguments, and full examples</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#auto-agent-builder-documentation","title":"Auto Agent Builder Documentation:","text":"<ul> <li> <p>Agent Builder Documentation</p> </li> <li> <p>Includes enterprise use cases, best practices, and integration patterns</p> </li> <li> <p>SwarmRouter Documentation:</p> </li> <li> <p>SwarmRouter Documentation</p> </li> <li> <p>Provides comprehensive API reference, advanced usage, and use cases</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#best-practices-for-selection","title":"Best Practices for Selection","text":""},{"location":"swarms/structs/multi_swarm_orchestration/#evaluate-task-complexity","title":"Evaluate Task Complexity","text":"<ul> <li> <p>Simple tasks \u2192 SwarmRouter</p> </li> <li> <p>Complex, multi-domain tasks \u2192 HHCS</p> </li> <li> <p>Dynamic, evolving tasks \u2192 Auto Agent Builder</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#consider-scale","title":"Consider Scale","text":"<ul> <li> <p>Small scale \u2192 SwarmRouter</p> </li> <li> <p>Large scale \u2192 HHCS</p> </li> <li> <p>Variable scale \u2192 Auto Agent Builder</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#resource-availability","title":"Resource Availability","text":"<ul> <li> <p>Limited resources \u2192 SwarmRouter</p> </li> <li> <p>Abundant resources \u2192 HHCS or Auto Agent Builder</p> </li> <li> <p>Dynamic resources \u2192 Auto Agent Builder</p> </li> </ul>"},{"location":"swarms/structs/multi_swarm_orchestration/#development-time","title":"Development Time","text":"<ul> <li> <p>Quick deployment \u2192 SwarmRouter</p> </li> <li> <p>Complex system \u2192 HHCS</p> </li> <li> <p>Experimental system \u2192 Auto Agent Builder</p> </li> </ul> <p>This documentation provides a high-level overview of the main hierarchical agent orchestration architectures available in the system. Each architecture has its own strengths and ideal use cases, and the choice between them should be based on specific project requirements, scale, and complexity.</p>"},{"location":"swarms/structs/multi_threaded_workflow/","title":"MultiThreadedWorkflow Documentation","text":"<p>The <code>MultiThreadedWorkflow</code> class represents a multi-threaded workflow designed to execute tasks concurrently using a thread pool. This class is highly useful in scenarios where tasks need to be executed in parallel to improve performance and efficiency. The workflow ensures that tasks are managed in a priority-based queue, and it includes mechanisms for retrying failed tasks and optionally saving task results automatically.</p>"},{"location":"swarms/structs/multi_threaded_workflow/#class-definition","title":"Class Definition","text":""},{"location":"swarms/structs/multi_threaded_workflow/#multithreadedworkflow","title":"<code>MultiThreadedWorkflow</code>","text":""},{"location":"swarms/structs/multi_threaded_workflow/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>max_workers</code> <code>int</code> <code>5</code> The maximum number of worker threads in the thread pool. <code>autosave</code> <code>bool</code> <code>True</code> Flag indicating whether to automatically save task results. <code>tasks</code> <code>List[PriorityTask]</code> <code>None</code> List of priority tasks to be executed. <code>retry_attempts</code> <code>int</code> <code>3</code> The maximum number of retry attempts for failed tasks. <code>*args</code> <code>tuple</code> Variable length argument list. <code>**kwargs</code> <code>dict</code> Arbitrary keyword arguments."},{"location":"swarms/structs/multi_threaded_workflow/#attributes","title":"Attributes","text":"Attribute Type Description <code>max_workers</code> <code>int</code> The maximum number of worker threads in the thread pool. <code>autosave</code> <code>bool</code> Flag indicating whether to automatically save task results. <code>retry_attempts</code> <code>int</code> The maximum number of retry attempts for failed tasks. <code>tasks_queue</code> <code>PriorityQueue</code> The queue that holds the priority tasks. <code>lock</code> <code>Lock</code> The lock used for thread synchronization."},{"location":"swarms/structs/multi_threaded_workflow/#methods","title":"Methods","text":""},{"location":"swarms/structs/multi_threaded_workflow/#run","title":"<code>run</code>","text":""},{"location":"swarms/structs/multi_threaded_workflow/#description","title":"Description","text":"<p>The <code>run</code> method executes the tasks stored in the priority queue using a thread pool. It handles task completion, retries failed tasks up to a specified number of attempts, and optionally saves the results of tasks if the autosave flag is set.</p>"},{"location":"swarms/structs/multi_threaded_workflow/#usage-example","title":"Usage Example","text":"<pre><code>from swarms import MultiThreadedWorkflow, PriorityTask, Task\n\n# Define some tasks\ntasks = [PriorityTask(task=Task()), PriorityTask(task=Task())]\n\n# Create a MultiThreadedWorkflow instance\nworkflow = MultiThreadedWorkflow(max_workers=3, autosave=True, tasks=tasks, retry_attempts=2)\n\n# Run the workflow\nresults = workflow.run()\nprint(results)\n</code></pre>"},{"location":"swarms/structs/multi_threaded_workflow/#_autosave_task_result","title":"<code>_autosave_task_result</code>","text":""},{"location":"swarms/structs/multi_threaded_workflow/#description_1","title":"Description","text":"<p>The <code>_autosave_task_result</code> method is responsible for saving the results of a task. It uses a thread lock to ensure that the autosave operation is thread-safe.</p>"},{"location":"swarms/structs/multi_threaded_workflow/#usage-example_1","title":"Usage Example","text":"<p>This method is intended for internal use and is typically called by the <code>run</code> method. However, here is an example of how it might be used directly:</p> <pre><code># Create a task and result\ntask = Task()\nresult = task.run()\n\n# Autosave the result\nworkflow = MultiThreadedWorkflow()\nworkflow._autosave_task_result(task, result)\n</code></pre>"},{"location":"swarms/structs/multi_threaded_workflow/#detailed-functionality-and-usage","title":"Detailed Functionality and Usage","text":""},{"location":"swarms/structs/multi_threaded_workflow/#initialization","title":"Initialization","text":"<p>When an instance of <code>MultiThreadedWorkflow</code> is created, it initializes the following:</p> <ul> <li>max_workers: Sets the maximum number of threads that can run concurrently.</li> <li>autosave: Determines if the task results should be saved automatically.</li> <li>tasks: Accepts a list of tasks that need to be executed. If no tasks are provided, an empty list is used.</li> <li>retry_attempts: Sets the maximum number of retry attempts for failed tasks.</li> <li>tasks_queue: A priority queue to manage tasks based on their priority.</li> <li>lock: A threading lock to ensure thread-safe operations.</li> </ul>"},{"location":"swarms/structs/multi_threaded_workflow/#running-tasks","title":"Running Tasks","text":"<p>The <code>run</code> method performs the following steps:</p> <ol> <li>Initialize Results and Executor: Creates a list to store results and a <code>ThreadPoolExecutor</code> to manage the threads.</li> <li>Submit Tasks: Iterates over the tasks in the queue, submitting them to the executor for execution and storing the future objects.</li> <li>Monitor Completion: Uses the <code>wait</code> function to monitor the completion of tasks. Once a task is completed, it retrieves the result or catches exceptions.</li> <li>Retry Mechanism: If a task fails, it checks the number of attempts made and retries the task if the limit is not reached.</li> <li>Autosave: If the <code>autosave</code> flag is set, the <code>_autosave_task_result</code> method is called to save the task results.</li> </ol>"},{"location":"swarms/structs/multi_threaded_workflow/#autosave-task-result","title":"Autosave Task Result","text":"<p>The <code>_autosave_task_result</code> method handles the saving of task results. It uses a threading lock to ensure that the save operation is not interrupted by other threads.</p>"},{"location":"swarms/structs/multi_threaded_workflow/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Thread Safety: The use of threading locks ensures that the operations are thread-safe, preventing race conditions.</li> <li>Logging: The class uses the logging module to log information about task completion, retries, and failures.</li> <li>Error Handling: The retry mechanism helps in handling transient errors by attempting to re-execute failed tasks.</li> </ul>"},{"location":"swarms/structs/multi_threaded_workflow/#references-and-resources","title":"References and Resources","text":"<p>For more information on threading and concurrent execution in Python, refer to the following resources:</p> <ul> <li>Python Threading Documentation</li> <li>Python Concurrent Futures Documentation</li> </ul>"},{"location":"swarms/structs/overview/","title":"Multi-Agent Architectures Overview","text":"<p>This page provides a comprehensive overview of all available multi-agent architectures in Swarms, their use cases, and functionality.</p>"},{"location":"swarms/structs/overview/#architecture-comparison","title":"Architecture Comparison","text":"Core ArchitecturesWorkflow ArchitecturesHierarchical Architectures Architecture Use Case Key Functionality Documentation MajorityVoting Decision making through consensus Combines multiple agent opinions and selects the most common answer Docs AgentRearrange Optimizing agent order Dynamically reorders agents based on task requirements Docs RoundRobin Equal task distribution Cycles through agents in a fixed order Docs Mixture of Agents Complex problem solving Combines diverse expert agents for comprehensive analysis Docs GroupChat Collaborative discussions Simulates group discussions with multiple agents Docs AgentRegistry Agent management Central registry for managing and accessing agents Docs SpreadSheetSwarm Data processing Collaborative data processing and analysis Docs ForestSwarm Hierarchical decision making Tree-like structure for complex decision processes Docs SwarmRouter Task routing Routes tasks to appropriate agents based on requirements Docs TaskQueueSwarm Task management Manages and prioritizes tasks in a queue Docs SwarmRearrange Dynamic swarm optimization Optimizes swarm configurations for specific tasks Docs MultiAgentRouter Advanced task routing Routes tasks to specialized agents based on capabilities Docs MatrixSwarm Parallel processing Matrix-based organization for parallel task execution Docs ModelRouter Model selection Routes tasks to appropriate AI models Docs MALT Multi-agent learning Enables agents to learn from each other Docs Deep Research Swarm Research automation Conducts comprehensive research across multiple domains Docs Swarm Matcher Agent matching Matches tasks with appropriate agent combinations Docs Architecture Use Case Key Functionality Documentation ConcurrentWorkflow Parallel task execution Executes multiple tasks simultaneously Docs SequentialWorkflow Step-by-step processing Executes tasks in a specific sequence Docs GraphWorkflow Complex task dependencies Manages tasks with complex dependencies Docs Architecture Use Case Key Functionality Documentation HierarchicalSwarm Hierarchical task orchestration Director agent coordinates specialized worker agents Docs Auto Agent Builder Automated agent creation Automatically creates and configures agents Docs Hybrid Hierarchical-Cluster Swarm Complex organization Combines hierarchical and cluster-based organization Docs Auto Swarm Builder Automated swarm creation Automatically creates and configures swarms Docs"},{"location":"swarms/structs/overview/#communication-structure","title":"Communication Structure","text":"<p>Communication Protocols</p> <p>The Conversation documentation details the communication protocols and structures used between agents in these architectures.</p>"},{"location":"swarms/structs/overview/#choosing-the-right-architecture","title":"Choosing the Right Architecture","text":"<p>When selecting a multi-agent architecture, consider the following factors:</p> <p>Task Complexity</p> <p>Simple tasks may only need basic architectures like RoundRobin, while complex tasks might require Hierarchical or Graph-based approaches.</p> <p>Parallelization Needs</p> <p>If tasks can be executed in parallel, consider ConcurrentWorkflow or MatrixSwarm.</p> <p>Decision Making Requirements</p> <p>For consensus-based decisions, MajorityVoting is ideal.</p> <p>Resource Optimization</p> <p>If you need to optimize agent usage, consider SwarmRouter or TaskQueueSwarm.</p> <p>Learning Requirements</p> <p>If agents need to learn from each other, MALT is the appropriate choice.</p> <p>Dynamic Adaptation</p> <p>For tasks requiring dynamic adaptation, consider SwarmRearrange or Auto Swarm Builder.</p> <p>For more detailed information about each architecture, please refer to their respective documentation pages.</p>"},{"location":"swarms/structs/round_robin_swarm/","title":"RoundRobin: Round-Robin Task Execution in a Swarm","text":""},{"location":"swarms/structs/round_robin_swarm/#introduction","title":"Introduction","text":"<p>The <code>RoundRobinSwarm</code> class is designed to manage and execute tasks among multiple agents in a round-robin fashion. This approach ensures that each agent in a swarm receives an equal opportunity to execute tasks, which promotes fairness and efficiency in distributed systems. It is particularly useful in environments where collaborative, sequential task execution is needed among various agents.</p>"},{"location":"swarms/structs/round_robin_swarm/#conceptual-overview","title":"Conceptual Overview","text":""},{"location":"swarms/structs/round_robin_swarm/#what-is-round-robin","title":"What is Round-Robin?","text":"<p>Round-robin is a scheduling technique commonly used in computing for managing processes in shared systems. It involves assigning a fixed time slot to each process and cycling through all processes in a circular order without prioritization. In the context of swarms of agents, this method ensures equitable distribution of tasks and resource usage among all agents.</p>"},{"location":"swarms/structs/round_robin_swarm/#application-in-swarms","title":"Application in Swarms","text":"<p>In swarms, <code>RoundRobinSwarm</code> utilizes the round-robin scheduling to manage tasks among agents like software components, autonomous robots, or virtual entities. This strategy is beneficial where tasks are interdependent or require sequential processing.</p>"},{"location":"swarms/structs/round_robin_swarm/#class-attributes","title":"Class Attributes","text":"<ul> <li><code>agents (List[Agent])</code>: List of agents participating in the swarm.</li> <li><code>verbose (bool)</code>: Enables or disables detailed logging of swarm operations.</li> <li><code>max_loops (int)</code>: Limits the number of times the swarm cycles through all agents.</li> <li><code>index (int)</code>: Maintains the current position in the agent list to ensure round-robin execution.</li> </ul>"},{"location":"swarms/structs/round_robin_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/round_robin_swarm/#__init__","title":"<code>__init__</code>","text":"<p>Initializes the swarm with the provided list of agents, verbosity setting, and operational parameters.</p> <p>Parameters: - <code>agents</code>: Optional list of agents in the swarm. - <code>verbose</code>: Boolean flag for detailed logging. - <code>max_loops</code>: Maximum number of execution cycles. - <code>callback</code>: Optional function called after each loop.</p>"},{"location":"swarms/structs/round_robin_swarm/#run","title":"<code>run</code>","text":"<p>Executes a specified task across all agents in a round-robin manner, cycling through each agent repeatedly for the number of specified loops.</p> <p>Conceptual Behavior: - Distribute the task sequentially among all agents starting from the current index. - Each agent processes the task and potentially modifies it or produces new output. - After an agent completes its part of the task, the index moves to the next agent. - This cycle continues until the specified maximum number of loops is completed. - Optionally, a callback function can be invoked after each loop to handle intermediate results or perform additional actions.</p>"},{"location":"swarms/structs/round_robin_swarm/#examples","title":"Examples","text":""},{"location":"swarms/structs/round_robin_swarm/#example-1-load-balancing-among-servers","title":"Example 1: Load Balancing Among Servers","text":"<p>In this example, <code>RoundRobinSwarm</code> is used to distribute network requests evenly among a group of servers. This is common in scenarios where load balancing is crucial for maintaining system responsiveness and scalability.</p> <pre><code>from swarms import Agent, RoundRobinSwarm\nfrom swarm_models import OpenAIChat\n\n\n# Initialize the LLM\nllm = OpenAIChat()\n\n# Define sales agents\nsales_agent1 = Agent(\n    agent_name=\"Sales Agent 1 - Automation Specialist\",\n    system_prompt=\"You're Sales Agent 1, your purpose is to generate sales for a company by focusing on the benefits of automating accounting processes!\",\n    agent_description=\"Generate sales by focusing on the benefits of automation!\",\n    llm=llm,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    context_length=1000,\n)\n\nsales_agent2 = Agent(\n    agent_name=\"Sales Agent 2 - Cost Saving Specialist\",\n    system_prompt=\"You're Sales Agent 2, your purpose is to generate sales for a company by emphasizing the cost savings of using swarms of agents!\",\n    agent_description=\"Generate sales by emphasizing cost savings!\",\n    llm=llm,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    context_length=1000,\n)\n\nsales_agent3 = Agent(\n    agent_name=\"Sales Agent 3 - Efficiency Specialist\",\n    system_prompt=\"You're Sales Agent 3, your purpose is to generate sales for a company by highlighting the efficiency and accuracy of our swarms of agents in accounting processes!\",\n    agent_description=\"Generate sales by highlighting efficiency and accuracy!\",\n    llm=llm,\n    max_loops=1,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    context_length=1000,\n)\n\n# Initialize the swarm with sales agents\nsales_swarm = RoundRobinSwarm(agents=[sales_agent1, sales_agent2, sales_agent3], verbose=True)\n\n# Define a sales task\ntask = \"Generate a sales email for an accountant firm executive to sell swarms of agents to automate their accounting processes.\"\n\n# Distribute sales tasks to different agents\nfor _ in range(5):  # Repeat the task 5 times\n    results = sales_swarm.run(task)\n    print(\"Sales generated:\", results)\n</code></pre>"},{"location":"swarms/structs/round_robin_swarm/#conclusion","title":"Conclusion","text":"<p>The RoundRobinSwarm class provides a robust and flexible framework for managing tasks among multiple agents in a fair and efficient manner. This class is especially useful in environments where tasks need to be distributed evenly among a group of agents, ensuring that all tasks are handled timely and effectively. Through the round-robin algorithm, each agent in the swarm is guaranteed an equal opportunity to contribute to the overall task, promoting efficiency and collaboration.</p>"},{"location":"swarms/structs/sequential_workflow/","title":"SequentialWorkflow Documentation","text":"<p>Overview: A Sequential Swarm architecture processes tasks in a linear sequence. Each agent completes its task before passing the result to the next agent in the chain. This architecture ensures orderly processing and is useful when tasks have dependencies. Learn more here in the docs:</p> <p>Use-Cases:</p> <ul> <li> <p>Workflows where each step depends on the previous one, such as assembly lines or sequential data processing.</p> </li> <li> <p>Scenarios requiring strict order of operations.</p> </li> </ul> <pre><code>graph TD\n    A[First Agent] --&gt; B[Second Agent]\n    B --&gt; C[Third Agent]\n    C --&gt; D[Fourth Agent]</code></pre>"},{"location":"swarms/structs/sequential_workflow/#attributes","title":"Attributes","text":"Attribute Type Description <code>agents</code> <code>List[Agent]</code> The list of agents in the workflow. <code>flow</code> <code>str</code> A string representing the order of agents. <code>agent_rearrange</code> <code>AgentRearrange</code> Manages the dynamic execution of agents."},{"location":"swarms/structs/sequential_workflow/#methods","title":"Methods","text":""},{"location":"swarms/structs/sequential_workflow/#__init__self-agents-listagent-none-max_loops-int-1-args-kwargs","title":"<code>__init__(self, agents: List[Agent] = None, max_loops: int = 1, *args, **kwargs)</code>","text":"<p>The constructor initializes the <code>SequentialWorkflow</code> object.</p> <ul> <li>Parameters:</li> <li><code>agents</code> (<code>List[Agent]</code>, optional): The list of agents in the workflow. Defaults to <code>None</code>.</li> <li><code>max_loops</code> (<code>int</code>, optional): The maximum number of loops to execute the workflow. Defaults to <code>1</code>.</li> <li><code>*args</code>: Variable length argument list.</li> <li><code>**kwargs</code>: Arbitrary keyword arguments.</li> </ul>"},{"location":"swarms/structs/sequential_workflow/#runself-task-str-str","title":"<code>run(self, task: str) -&gt; str</code>","text":"<p>Runs the specified task through the agents in the dynamically constructed flow.</p> <ul> <li>Parameters:</li> <li> <p><code>task</code> (<code>str</code>): The task for the agents to execute.</p> </li> <li> <p>Returns:</p> </li> <li><code>str</code>: The final result after processing through all agents.</li> </ul>"},{"location":"swarms/structs/sequential_workflow/#usage-example","title":"Usage Example:","text":"<pre><code>from swarms import Agent, SequentialWorkflow\n\n# Initialize agents for individual tasks\nagent1 = Agent(\n  agent_name=\"ICD-10 Code Analyzer\",\n  system_prompt=\"Analyze medical data and provide relevant ICD-10 codes.\",\n  model_name=\"gpt-4o\",\n  max_loops=1,\n)\nagent2 = Agent(\n  agent_name=\"ICD-10 Code Summarizer\",\n  system_prompt=\"Summarize the findings and suggest ICD-10 codes.\",\n  model_name=\"gpt-4o\",\n  max_loops=1,\n)\n\n# Create the Sequential workflow\nworkflow = SequentialWorkflow(\n  agents=[agent1, agent2], max_loops=1, verbose=False\n)\n\n# Run the workflow\nworkflow.run(\n  \"Analyze the medical report and provide the appropriate ICD-10 codes.\"\n)\n</code></pre> <p>This example initializes a <code>SequentialWorkflow</code> with three agents and executes a task, printing the final result.</p>"},{"location":"swarms/structs/sequential_workflow/#notes","title":"Notes:","text":"<ul> <li>Logs the task execution process and handles any exceptions that occur during the task execution.</li> </ul>"},{"location":"swarms/structs/sequential_workflow/#logging-and-error-handling","title":"Logging and Error Handling","text":"<p>The <code>run</code> method includes logging to track the execution flow and captures errors to provide detailed information in case of failures. This is crucial for debugging and ensuring smooth operation of the workflow.</p>"},{"location":"swarms/structs/sequential_workflow/#additional-tips","title":"Additional Tips","text":"<ul> <li> <p>Ensure that the agents provided to the <code>SequentialWorkflow</code> are properly initialized and configured to handle the tasks they will receive.</p> </li> <li> <p>The <code>max_loops</code> parameter can be used to control how many times the workflow should be executed, which is useful for iterative processes.</p> </li> <li> <p>Utilize the logging information to monitor and debug the task execution process.</p> </li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/","title":"SpreadSheetSwarm Documentation","text":""},{"location":"swarms/structs/spreadsheet_swarm/#class-definition","title":"Class Definition","text":"<pre><code>class SpreadSheetSwarm:\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#full-path","title":"Full Path","text":"<pre><code>from swarms.structs.spreadsheet_swarm import SpreadSheetSwarm\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#attributes","title":"Attributes","text":"<p>The <code>SpreadSheetSwarm</code> class contains several attributes that define its behavior and configuration. These attributes are initialized in the constructor (<code>__init__</code> method) and are used throughout the class to manage the swarm's operations.</p> Attribute Type Description <code>name</code> <code>str</code> The name of the swarm. <code>description</code> <code>str</code> A description of the swarm's purpose. <code>agents</code> <code>Union[Agent, List[Agent]]</code> The agents participating in the swarm. Can be a single agent or a list of agents. <code>autosave_on</code> <code>bool</code> Flag indicating whether autosave is enabled. <code>save_file_path</code> <code>str</code> The file path where the swarm data will be saved. <code>task_queue</code> <code>queue.Queue</code> The queue that stores tasks to be processed by the agents. <code>lock</code> <code>threading.Lock</code> A lock used for thread synchronization to prevent race conditions. <code>metadata</code> <code>SwarmRunMetadata</code> Metadata for the swarm run, including start time, end time, tasks completed, and outputs. <code>run_all_agents</code> <code>bool</code> Flag indicating whether to run all agents or just one. <code>max_loops</code> <code>int</code> The number of times to repeat the task. <code>workspace_dir</code> <code>str</code> The directory where the workspace is located, retrieved from environment variables."},{"location":"swarms/structs/spreadsheet_swarm/#parameters","title":"Parameters","text":"<ul> <li><code>name</code> (<code>str</code>, optional): The name of the swarm. Default is <code>\"Spreadsheet-Swarm\"</code>.</li> <li><code>description</code> (<code>str</code>, optional): A brief description of the swarm. Default is <code>\"A swarm that processes tasks from a queue using multiple agents on different threads.\"</code>.</li> <li><code>agents</code> (<code>Union[Agent, List[Agent]]</code>, optional): The agents participating in the swarm. Default is an empty list.</li> <li><code>autosave_on</code> (<code>bool</code>, optional): A flag to indicate if autosave is enabled. Default is <code>True</code>.</li> <li><code>save_file_path</code> (<code>str</code>, optional): The file path where swarm data will be saved. Default is <code>\"spreedsheet_swarm.csv\"</code>.</li> <li><code>run_all_agents</code> (<code>bool</code>, optional): Flag to determine if all agents should run. Default is <code>True</code>.</li> <li><code>max_loops</code> (<code>int</code>, optional): The number of times to repeat the task. Default is <code>1</code>.</li> <li><code>workspace_dir</code> (<code>str</code>, optional): The directory where the workspace is located. Default is retrieved from environment variable <code>WORKSPACE_DIR</code>.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#constructor-__init__","title":"Constructor (<code>__init__</code>)","text":"<p>The constructor initializes the <code>SpreadSheetSwarm</code> with the provided parameters. It sets up the task queue, locks for thread synchronization, and initializes the metadata.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/spreadsheet_swarm/#reliability_check","title":"<code>reliability_check</code>","text":"<pre><code>def reliability_check(self):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description","title":"Description","text":"<p>The <code>reliability_check</code> method performs a series of checks to ensure that the swarm is properly configured before it begins processing tasks. It verifies that there are agents available and that a valid file path is provided for saving the swarm's data. If any of these checks fail, an exception is raised.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#raises","title":"Raises","text":"<ul> <li><code>ValueError</code>: Raised if no agents are provided or if no save file path is specified.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#example","title":"Example","text":"<pre><code>swarm = SpreadSheetSwarm(agents=[agent1, agent2])\nswarm.reliability_check()\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#run","title":"<code>run</code>","text":"<pre><code>def run(self, task: str, *args, **kwargs):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description_1","title":"Description","text":"<p>The <code>run</code> method starts the task processing using the swarm. Depending on the configuration, it can either run all agents or a specific subset of them. The method tracks the start and end times of the task, executes the task multiple times if specified, and logs the results.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#parameters_1","title":"Parameters","text":"<ul> <li><code>task</code> (<code>str</code>): The task to be executed by the swarm.</li> <li><code>*args</code>: Additional positional arguments to pass to the agents.</li> <li><code>**kwargs</code>: Additional keyword arguments to pass to the agents.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#example_1","title":"Example","text":"<pre><code>swarm = SpreadSheetSwarm(agents=[agent1, agent2])\nswarm.run(\"Process Data\")\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#export_to_json","title":"<code>export_to_json</code>","text":"<pre><code>def export_to_json(self):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description_2","title":"Description","text":"<p>The <code>export_to_json</code> method generates a JSON representation of the swarm's metadata. This can be useful for exporting the results to an external system or for logging purposes.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#returns","title":"Returns","text":"<ul> <li><code>str</code>: The JSON representation of the swarm's metadata.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#example_2","title":"Example","text":"<pre><code>json_data = swarm.export_to_json()\nprint(json_data)\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#data_to_json_file","title":"<code>data_to_json_file</code>","text":"<pre><code>def data_to_json_file(self):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description_3","title":"Description","text":"<p>The <code>data_to_json_file</code> method saves the swarm's metadata as a JSON file in the specified workspace directory. The file name is generated using the swarm's name and run ID.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#example_3","title":"Example","text":"<pre><code>swarm.data_to_json_file()\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#_track_output","title":"<code>_track_output</code>","text":"<pre><code>def _track_output(self, agent: Agent, task: str, result: str):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description_4","title":"Description","text":"<p>The <code>_track_output</code> method is used internally to record the results of tasks executed by the agents. It updates the metadata with the completed tasks and their results.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#parameters_2","title":"Parameters","text":"<ul> <li><code>agent</code> (<code>Agent</code>): The agent that executed the task.</li> <li><code>task</code> (<code>str</code>): The task that was executed.</li> <li><code>result</code> (<code>str</code>): The result of the task execution.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#example_4","title":"Example","text":"<pre><code>swarm._track_output(agent1, \"Process Data\", \"Success\")\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#_save_to_csv","title":"<code>_save_to_csv</code>","text":"<pre><code>def _save_to_csv(self):\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#description_5","title":"Description","text":"<p>The <code>_save_to_csv</code> method saves the swarm's metadata to a CSV file. It logs each task and its result before writing them to the file. The file is saved in the location specified by <code>save_file_path</code>.</p>"},{"location":"swarms/structs/spreadsheet_swarm/#example_5","title":"Example","text":"<pre><code>swarm._save_to_csv()\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/spreadsheet_swarm/#example-1-basic-swarm-initialization","title":"Example 1: Basic Swarm Initialization","text":"<pre><code>import os\n\nfrom swarms import Agent\nfrom swarm_models import OpenAIChat\nfrom swarms.prompts.finance_agent_sys_prompt import (\n    FINANCIAL_AGENT_SYS_PROMPT,\n)\nfrom swarms.structs.spreadsheet_swarm import SpreadSheetSwarm\n\n# Example usage:\napi_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_key=api_key, model_name=\"gpt-4o-mini\", temperature=0.1\n)\n\n\n# Initialize your agents (assuming the Agent class and model are already defined)\nagents = [\n    Agent(\n        agent_name=f\"Financial-Analysis-Agent-spreesheet-swarm:{i}\",\n        system_prompt=FINANCIAL_AGENT_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"finance_agent.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    )\n    for i in range(10)\n]\n\n# Create a Swarm with the list of agents\nswarm = SpreadSheetSwarm(\n    name=\"Finance-Spreadsheet-Swarm\",\n    description=\"A swarm that processes tasks from a queue using multiple agents on different threads.\",\n    agents=agents,\n    autosave_on=True,\n    save_file_path=\"financial_spreed_sheet_swarm_demo.csv\",\n    run_all_agents=False,\n    max_loops=1,\n)\n\n# Run the swarm\nswarm.run(\n    task=\"Analyze the states with the least taxes for LLCs. Provide an overview of all tax rates and add them with a comprehensive analysis\"\n)\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#example-2-qr-code-generator","title":"Example 2: QR Code Generator","text":"<pre><code>import os\nfrom swarms import Agent\nfrom swarm_models import OpenAIChat\nfrom swarms.structs.spreadsheet_swarm import SpreadSheetSwarm\n\n# Define custom system prompts for QR code generation\nQR_CODE_AGENT_1_SYS_PROMPT = \"\"\"\nYou are a Python coding expert. Your task is to write a Python script to generate a QR code for the link: https://lu.ma/jjc1b2bo. The code should save the QR code as an image file.\n\"\"\"\n\nQR_CODE_AGENT_2_SYS_PROMPT = \"\"\"\nYou are a Python coding expert. Your task is to write a Python script to generate a QR code for the link: https://github.com/The-Swarm-Corporation/Cookbook. The code should save the QR code as an image file.\n\"\"\"\n\n# Example usage:\napi_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_key=api_key, model_name=\"gpt-4o-mini\", temperature=0.1\n)\n\n# Initialize your agents for QR code generation\nagents = [\n    Agent(\n        agent_name=\"QR-Code-Generator-Agent-Luma\",\n        system_prompt=QR_CODE_AGENT_1_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"qr_code_agent_luma.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n    Agent(\n        agent_name=\"QR-Code-Generator-Agent-Cookbook\",\n        system_prompt=QR_CODE_AGENT_2_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"qr_code_agent_cookbook.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n]\n\n# Create a Swarm with the list of agents\nswarm = SpreadSheetSwarm(\n    name=\"QR-Code-Generation-Swarm\",\n    description=\"A swarm that generates Python scripts to create QR codes for specific links.\",\n    agents=agents,\n    autosave_on=True,\n    save_file_path=\"qr_code_generation_results.csv\",\n    run_all_agents=False,\n    max_loops=1,\n)\n\n# Run the swarm\nswarm.run(\n    task=\"Generate Python scripts to create QR codes for the provided links and save them as image files.\"\n)\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#example-3-social-media-marketing","title":"Example 3: Social Media Marketing","text":"<pre><code>import os\nfrom swarms import Agent\nfrom swarm_models import OpenAIChat\nfrom swarms.structs.spreadsheet_swarm import SpreadSheetSwarm\n\n# Define custom system prompts for each social media platform\nTWITTER_AGENT_SYS_PROMPT = \"\"\"\nYou are a Twitter marketing expert. Your task is to create engaging, concise tweets and analyze trends to maximize engagement. Consider hashtags, timing, and content relevance.\n\"\"\"\n\nINSTAGRAM_AGENT_SYS_PROMPT = \"\"\"\nYou are an Instagram marketing expert. Your task is to create visually appealing and engaging content, including captions and hashtags, tailored to a specific audience.\n\"\"\"\n\nFACEBOOK_AGENT_SYS_PROMPT = \"\"\"\nYou are a Facebook marketing expert. Your task is to craft posts that are optimized for engagement and reach on Facebook, including using images, links, and targeted messaging.\n\"\"\"\n\nEMAIL_AGENT_SYS_PROMPT = \"\"\"\nYou are an Email marketing expert. Your task is to write compelling email campaigns that drive conversions, focusing on subject lines, personalization, and call-to-action strategies.\n\"\"\"\n\n# Example usage:\napi_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_key=api_key, model_name=\"gpt-4o-mini\", temperature=0.1\n)\n\n# Initialize your agents for different social media platforms\nagents = [\n    Agent(\n        agent_name=\"Twitter-Marketing-Agent\",\n        system_prompt=TWITTER_AGENT_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"twitter_agent.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n    Agent(\n        agent_name=\"Instagram-Marketing-Agent\",\n        system_prompt=INSTAGRAM_AGENT_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"instagram_agent.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n    Agent(\n        agent_name=\"Facebook-Marketing-Agent\",\n        system_prompt=FACEBOOK_AGENT_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"facebook_agent.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n    Agent(\n        agent_name=\"Email-Marketing-Agent\",\n        system_prompt=EMAIL_AGENT_SYS_PROMPT,\n        llm=model,\n        max_loops=1,\n        dynamic_temperature_enabled=True,\n        saved_state_path=\"email_agent.json\",\n        user_name=\"swarms_corp\",\n        retry_attempts=1,\n    ),\n]\n\n# Create a Swarm with the list of agents\nswarm = SpreadSheetSwarm(\n    name=\"Social-Media-Marketing-Swarm\",\n    description=\"A swarm that processes social media marketing tasks using multiple agents on different threads.\",\n    agents=agents,\n    autosave_on=True,\n    save_file_path=\"social_media_marketing_spreadsheet.csv\",\n    run_all_agents=False,\n    max_loops=2,\n)\n\n# Run the swarm\nswarm.run(\n    task=\"Create posts to promote hack nights in miami beach for developers, engineers, and tech enthusiasts. Include relevant hashtags, images, and engaging captions.\"\n)\n</code></pre>"},{"location":"swarms/structs/spreadsheet_swarm/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li> <p>Thread Synchronization: When working with multiple agents in a concurrent environment, it's crucial to ensure that access to shared resources is properly synchronized using locks to avoid race conditions.</p> </li> <li> <p>Autosave Feature: If you enable the <code>autosave_on</code> flag, ensure that the file path provided is correct and writable. This feature is handy for long-running tasks where you want to periodically save the state.</p> </li> <li> <p>Error Handling</p> </li> </ul> Implementing proper error handling within your agents can prevent the swarm from crashing during execution. Consider catching exceptions in the <code>run</code> method and logging errors appropriately. <ul> <li>Custom Agents: You can extend the <code>Agent</code> class to create custom agents that perform specific tasks tailored to your application's needs.</li> </ul>"},{"location":"swarms/structs/spreadsheet_swarm/#references-and-resources","title":"References and Resources","text":"<ul> <li>Python's <code>queue</code> module</li> <li>Python's <code>threading</code> module</li> <li>CSV File Handling in Python</li> <li>JSON Handling in Python</li> </ul>"},{"location":"swarms/structs/swarm_matcher/","title":"SwarmMatcher","text":"<p>SwarmMatcher is a tool for automatically matching tasks to the most appropriate swarm type based on their semantic similarity.</p>"},{"location":"swarms/structs/swarm_matcher/#overview","title":"Overview","text":"<p>The SwarmMatcher utilizes transformer-based embeddings to determine the best swarm architecture for a given task. By analyzing the semantic meaning of task descriptions and comparing them to known swarm types, it can intelligently select the optimal swarm configuration for any task.</p>"},{"location":"swarms/structs/swarm_matcher/#workflow","title":"Workflow","text":"<pre><code>flowchart TD\n    A[Task Description] --&gt; B[Generate Task Embedding]\n    C[Swarm Type Descriptions] --&gt; D[Generate Swarm Type Embeddings]\n    B --&gt; E[Calculate Similarity Scores]\n    D --&gt; E\n    E --&gt; F[Select Best Matching Swarm Type]\n    F --&gt; G[Return Selected Swarm Type]\n\n    subgraph Initialization\n        H[Define Swarm Types] --&gt; I[Load Transformer Model]\n        I --&gt; J[Pre-compute Swarm Type Embeddings]\n    end\n\n    subgraph Matching Process\n        A --&gt; B --&gt; E --&gt; F --&gt; G\n    end</code></pre>"},{"location":"swarms/structs/swarm_matcher/#installation","title":"Installation","text":"<p>SwarmMatcher is included in the Swarms package. To use it, simply import it from the library:</p> <pre><code>from swarms.structs.swarm_matcher import SwarmMatcher, SwarmMatcherConfig, SwarmType\n</code></pre>"},{"location":"swarms/structs/swarm_matcher/#basic-usage","title":"Basic Usage","text":"<pre><code>from swarms.structs.swarm_matcher import swarm_matcher\n\n# Use the simplified function to match a task to a swarm type\nswarm_type = swarm_matcher(\"Analyze this dataset and create visualizations\")\nprint(f\"Selected swarm type: {swarm_type}\")\n</code></pre>"},{"location":"swarms/structs/swarm_matcher/#advanced-usage","title":"Advanced Usage","text":"<p>For more control over the matching process, you can create and configure your own SwarmMatcher instance:</p> <pre><code>from swarms.structs.swarm_matcher import SwarmMatcher, SwarmMatcherConfig, SwarmType, initialize_swarm_types\n\n# Create a configuration\nconfig = SwarmMatcherConfig(\n    model_name=\"sentence-transformers/all-MiniLM-L6-v2\",\n    embedding_dim=512\n)\n\n# Initialize the matcher\nmatcher = SwarmMatcher(config)\n\n# Add default swarm types\ninitialize_swarm_types(matcher)\n\n# Add a custom swarm type\ncustom_swarm = SwarmType(\n    name=\"CustomSwarm\",\n    description=\"A specialized swarm for handling specific domain tasks with expert knowledge.\"\n)\nmatcher.add_swarm_type(custom_swarm)\n\n# Find the best match for a task\nbest_match, score = matcher.find_best_match(\"Process natural language and extract key insights\")\nprint(f\"Best match: {best_match}, Score: {score}\")\n\n# Auto-select a swarm type\nselected_swarm = matcher.auto_select_swarm(\"Create data visualizations from this CSV file\")\nprint(f\"Selected swarm: {selected_swarm}\")\n</code></pre>"},{"location":"swarms/structs/swarm_matcher/#available-swarm-types","title":"Available Swarm Types","text":"<p>SwarmMatcher comes with several pre-defined swarm types:</p> Swarm Type Description AgentRearrange Optimize agent order and rearrange flow for multi-step tasks, ensuring efficient task allocation and minimizing bottlenecks. MixtureOfAgents Combine diverse expert agents for comprehensive analysis, fostering a collaborative approach to problem-solving and leveraging individual strengths. SpreadSheetSwarm Collaborative data processing and analysis in a spreadsheet-like environment, facilitating real-time data sharing and visualization. SequentialWorkflow Execute tasks in a step-by-step, sequential process workflow, ensuring a logical and methodical approach to task execution. ConcurrentWorkflow Process multiple tasks or data sources concurrently in parallel, maximizing productivity and reducing processing time."},{"location":"swarms/structs/swarm_matcher/#api-reference","title":"API Reference","text":""},{"location":"swarms/structs/swarm_matcher/#swarmtype","title":"SwarmType","text":"<p>A class representing a type of swarm with its name and description.</p> Parameter Type Description name str The name of the swarm type description str A detailed description of the swarm type's capabilities and ideal use cases embedding Optional[List[float]] The generated embedding vector for this swarm type (auto-populated)"},{"location":"swarms/structs/swarm_matcher/#swarmmatcherconfig","title":"SwarmMatcherConfig","text":"<p>Configuration settings for the SwarmMatcher.</p> Parameter Type Default Description model_name str \"sentence-transformers/all-MiniLM-L6-v2\" The transformer model to use for embeddings embedding_dim int 512 The dimension of the embedding vectors"},{"location":"swarms/structs/swarm_matcher/#swarmmatcher_1","title":"SwarmMatcher","text":"<p>The main class for matching tasks to swarm types.</p>"},{"location":"swarms/structs/swarm_matcher/#methods","title":"Methods","text":""},{"location":"swarms/structs/swarm_matcher/#__init__config-swarmmatcherconfig","title":"<code>__init__(config: SwarmMatcherConfig)</code>","text":"<p>Initializes the SwarmMatcher with a configuration.</p>"},{"location":"swarms/structs/swarm_matcher/#get_embeddingtext-str-npndarray","title":"<code>get_embedding(text: str) -&gt; np.ndarray</code>","text":"<p>Generates an embedding vector for a given text using the configured model.</p> Parameter Type Description text str The text to embed Returns np.ndarray The embedding vector"},{"location":"swarms/structs/swarm_matcher/#add_swarm_typeswarm_type-swarmtype","title":"<code>add_swarm_type(swarm_type: SwarmType)</code>","text":"<p>Adds a swarm type to the matcher, generating an embedding for its description.</p> Parameter Type Description swarm_type SwarmType The swarm type to add"},{"location":"swarms/structs/swarm_matcher/#find_best_matchtask-str-tuplestr-float","title":"<code>find_best_match(task: str) -&gt; Tuple[str, float]</code>","text":"<p>Finds the best matching swarm type for a given task.</p> Parameter Type Description task str The task description Returns Tuple[str, float] The name of the best matching swarm type and the similarity score"},{"location":"swarms/structs/swarm_matcher/#auto_select_swarmtask-str-str","title":"<code>auto_select_swarm(task: str) -&gt; str</code>","text":"<p>Automatically selects the best swarm type for a given task.</p> Parameter Type Description task str The task description Returns str The name of the selected swarm type"},{"location":"swarms/structs/swarm_matcher/#run_multipletasks-liststr-liststr","title":"<code>run_multiple(tasks: List[str]) -&gt; List[str]</code>","text":"<p>Matches multiple tasks to swarm types in batch.</p> Parameter Type Description tasks List[str] A list of task descriptions Returns List[str] A list of selected swarm type names"},{"location":"swarms/structs/swarm_matcher/#save_swarm_typesfilename-str","title":"<code>save_swarm_types(filename: str)</code>","text":"<p>Saves the registered swarm types to a JSON file.</p> Parameter Type Description filename str Path where the swarm types will be saved"},{"location":"swarms/structs/swarm_matcher/#load_swarm_typesfilename-str","title":"<code>load_swarm_types(filename: str)</code>","text":"<p>Loads swarm types from a JSON file.</p> Parameter Type Description filename str Path to the JSON file containing swarm types"},{"location":"swarms/structs/swarm_matcher/#examples","title":"Examples","text":""},{"location":"swarms/structs/swarm_matcher/#simple-matching","title":"Simple Matching","text":"<pre><code>from swarms.structs.swarm_matcher import swarm_matcher\n\n# Match tasks to swarm types\ntasks = [\n    \"Analyze this dataset and create visualizations\",\n    \"Coordinate multiple agents to tackle different aspects of a problem\",\n    \"Process these 10 PDF files in sequence\",\n    \"Handle these data processing tasks in parallel\"\n]\n\nfor task in tasks:\n    swarm_type = swarm_matcher(task)\n    print(f\"Task: {task}\")\n    print(f\"Selected swarm: {swarm_type}\\n\")\n</code></pre>"},{"location":"swarms/structs/swarm_matcher/#custom-swarm-types","title":"Custom Swarm Types","text":"<pre><code>from swarms.structs.swarm_matcher import SwarmMatcher, SwarmMatcherConfig, SwarmType\n\n# Create configuration and matcher\nconfig = SwarmMatcherConfig()\nmatcher = SwarmMatcher(config)\n\n# Define custom swarm types\nswarm_types = [\n    SwarmType(\n        name=\"DataAnalysisSwarm\",\n        description=\"Specialized in processing and analyzing large datasets, performing statistical analysis, and extracting insights from complex data.\"\n    ),\n    SwarmType(\n        name=\"CreativeWritingSwarm\",\n        description=\"Optimized for creative content generation, storytelling, and producing engaging written material with consistent style and tone.\"\n    ),\n    SwarmType(\n        name=\"ResearchSwarm\",\n        description=\"Focused on deep research tasks, synthesizing information from multiple sources, and producing comprehensive reports on complex topics.\"\n    )\n]\n\n# Add swarm types\nfor swarm_type in swarm_types:\n    matcher.add_swarm_type(swarm_type)\n\n# Save the swarm types for future use\nmatcher.save_swarm_types(\"custom_swarm_types.json\")\n\n# Use the matcher\ntask = \"Research quantum computing advances in the last 5 years\"\nbest_match = matcher.auto_select_swarm(task)\nprint(f\"Selected swarm type: {best_match}\")\n</code></pre>"},{"location":"swarms/structs/swarm_matcher/#how-it-works","title":"How It Works","text":"<p>SwarmMatcher uses a transformer-based model to generate embeddings (vector representations) of both the task descriptions and the swarm type descriptions. It then calculates the similarity between these embeddings to determine which swarm type is most semantically similar to the given task.</p> <pre><code>sequenceDiagram\n    participant User\n    participant SwarmMatcher\n    participant TransformerModel\n\n    User-&gt;&gt;SwarmMatcher: task = \"Analyze this dataset\"\n    Note over SwarmMatcher: Initialization already complete\n\n    SwarmMatcher-&gt;&gt;TransformerModel: get_embedding(task)\n    TransformerModel--&gt;&gt;SwarmMatcher: task_embedding\n\n    loop For each swarm type\n        SwarmMatcher-&gt;&gt;SwarmMatcher: Calculate similarity score\n        Note over SwarmMatcher: score = dot_product(task_embedding, swarm_type.embedding)\n    end\n\n    SwarmMatcher-&gt;&gt;SwarmMatcher: Find best score\n    SwarmMatcher--&gt;&gt;User: \"SpreadSheetSwarm\"</code></pre> <p>The matching process follows these steps:</p> <ol> <li>The task description is converted to an embedding vector</li> <li>Each swarm type's description is converted to an embedding vector</li> <li>The similarity between the task embedding and each swarm type embedding is calculated</li> <li>The swarm type with the highest similarity score is selected</li> </ol> <p>This approach ensures that the matcher can understand the semantic meaning of tasks, not just keyword matching, resulting in more accurate swarm type selection.</p>"},{"location":"swarms/structs/swarm_network/","title":"SwarmNetwork [WIP]","text":"<p>The <code>SwarmNetwork</code> class is a powerful tool for managing a pool of agents, orchestrating task distribution, and scaling resources based on workload. It is designed to handle tasks efficiently by dynamically adjusting the number of agents according to the current demand. This class also provides an optional API for interacting with the agent pool, making it accessible for integration with other systems.</p>"},{"location":"swarms/structs/swarm_network/#key-features","title":"Key Features","text":"<ul> <li>Agent Pool Management: Dynamically manage a pool of agents.</li> <li>Task Queue Management: Handle tasks through a queue system.</li> <li>Agent Health Monitoring: Monitor the health of agents.</li> <li>Agent Pool Scaling: Scale the agent pool up or down based on workload.</li> <li>API: Interact with the agent pool and task queue through a simple API.</li> <li>Agent Deployment Options: Run agents on threads, processes, containers, machines, or clusters.</li> </ul>"},{"location":"swarms/structs/swarm_network/#parameters","title":"Parameters","text":"Parameter Type Default Value Description name str None The name of the swarm network. description str None A description of the swarm network. agents List[Agent] None A list of agents in the pool. idle_threshold float 0.2 The idle threshold for the agents. busy_threshold float 0.7 The busy threshold for the agents. api_enabled Optional[bool] False A flag to enable/disable the API. logging_enabled Optional[bool] False A flag to enable/disable logging. api_on Optional[bool] False A flag to enable/disable the FastAPI instance. host str \"0.0.0.0\" The host address for the FastAPI instance. port int 8000 The port number for the FastAPI instance. swarm_callable Optional[callable] None A callable to be executed by the swarm network. *args tuple Additional positional arguments. **kwargs dict Additional keyword arguments."},{"location":"swarms/structs/swarm_network/#attributes","title":"Attributes","text":"Attribute Type Description task_queue queue.Queue A queue for storing tasks. idle_threshold float The idle threshold for the agents. busy_threshold float The busy threshold for the agents. agents List[Agent] A list of agents in the pool. api_enabled bool A flag to enable/disable the API. logging_enabled bool A flag to enable/disable logging. host str The host address for the FastAPI instance. port int The port number for the FastAPI instance. swarm_callable Optional[callable] A callable to be executed by the swarm network. agent_dict dict A dictionary of agents for easy access. lock threading.Lock A lock for synchronizing access to shared resources."},{"location":"swarms/structs/swarm_network/#methods","title":"Methods","text":""},{"location":"swarms/structs/swarm_network/#description","title":"Description","text":"<p>Initializes a new instance of the <code>SwarmNetwork</code> class.</p>"},{"location":"swarms/structs/swarm_network/#parameters_1","title":"Parameters","text":"<ul> <li><code>name</code> (str): The name of the swarm network.</li> <li><code>description</code> (str): A description of the swarm network.</li> <li><code>agents</code> (List[Agent]): A list of agents in the pool.</li> <li><code>idle_threshold</code> (float): The idle threshold for the agents.</li> <li><code>busy_threshold</code> (float): The busy threshold for the agents.</li> <li><code>api_enabled</code> (Optional[bool]): A flag to enable/disable the API.</li> <li><code>logging_enabled</code> (Optional[bool]): A flag to enable/disable logging.</li> <li><code>api_on</code> (Optional[bool]): A flag to enable/disable the FastAPI instance.</li> <li><code>host</code> (str): The host address for the FastAPI instance.</li> <li><code>port</code> (int): The port number for the FastAPI instance.</li> <li><code>swarm_callable</code> (Optional[callable]): A callable to be executed by the swarm network.</li> <li><code>*args</code>: Additional positional arguments.</li> <li><code>**kwargs</code>: Additional keyword arguments.</li> </ul>"},{"location":"swarms/structs/swarm_network/#add_task","title":"<code>add_task</code>","text":"<pre><code>def add_task(self, task)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_1","title":"Description","text":"<p>Adds a task to the task queue.</p>"},{"location":"swarms/structs/swarm_network/#parameters_2","title":"Parameters","text":"<ul> <li><code>task</code> (type): The task to be added to the queue.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\nagent = Agent()\nswarm = SwarmNetwork(agents=[agent])\nswarm.add_task(\"task\")\n</code></pre>"},{"location":"swarms/structs/swarm_network/#async_add_task","title":"<code>async_add_task</code>","text":"<pre><code>async def async_add_task(self, task)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_2","title":"Description","text":"<p>Adds a task to the task queue asynchronously.</p>"},{"location":"swarms/structs/swarm_network/#parameters_3","title":"Parameters","text":"<ul> <li><code>task</code> (type): The task to be added to the queue.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_1","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\nagent = Agent()\nswarm = SwarmNetwork(agents=[agent])\nawait swarm.async_add_task(\"task\")\n</code></pre>"},{"location":"swarms/structs/swarm_network/#run_single_agent","title":"<code>run_single_agent</code>","text":"<pre><code>def run_single_agent(self, agent_id, task: Optional[str], *args, **kwargs)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_3","title":"Description","text":"<p>Runs a task on a specific agent by ID.</p>"},{"location":"swarms/structs/swarm_network/#parameters_4","title":"Parameters","text":"<ul> <li><code>agent_id</code> (type): The ID of the agent.</li> <li><code>task</code> (str, optional): The task to be executed by the agent.</li> <li><code>*args</code>: Additional positional arguments.</li> <li><code>**kwargs</code>: Additional keyword arguments.</li> </ul>"},{"location":"swarms/structs/swarm_network/#returns","title":"Returns","text":"<ul> <li><code>_type_</code>: The output of the agent running the task.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_2","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nresult = swarm.run_single_agent(agent.id, \"task\")\n</code></pre>"},{"location":"swarms/structs/swarm_network/#run_many_agents","title":"<code>run_many_agents</code>","text":"<pre><code>def run_many_agents(self, task: Optional[str] = None, *args, **kwargs) -&gt; List\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_4","title":"Description","text":"<p>Runs a task on all agents in the pool.</p>"},{"location":"swarms/structs/swarm_network/#parameters_5","title":"Parameters","text":"<ul> <li><code>task</code> (str, optional): The task to be executed by the agents.</li> <li><code>*args</code>: Additional positional arguments.</li> <li><code>**kwargs</code>: Additional keyword arguments.</li> </ul>"},{"location":"swarms/structs/swarm_network/#returns_1","title":"Returns","text":"<ul> <li><code>List</code>: The output of all agents running the task.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_3","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\n\nswarm = SwarmNetwork(agents=[agent1, agent2])\nresults = swarm.run_many_agents(\"task\")\n</code></pre>"},{"location":"swarms/structs/swarm_network/#list_agents","title":"<code>list_agents</code>","text":"<pre><code>def list_agents(self)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_5","title":"Description","text":"<p>Lists all agents in the pool.</p>"},{"location":"swarms/structs/swarm_network/#example_4","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nswarm.list_agents()\n</code></pre>"},{"location":"swarms/structs/swarm_network/#get_agent","title":"<code>get_agent</code>","text":"<pre><code>def get_agent(self, agent_id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_6","title":"Description","text":"<p>Gets an agent by ID.</p>"},{"location":"swarms/structs/swarm_network/#parameters_6","title":"Parameters","text":"<ul> <li><code>agent_id</code> (type): The ID of the agent to retrieve.</li> </ul>"},{"location":"swarms/structs/swarm_network/#returns_2","title":"Returns","text":"<ul> <li><code>_type_</code>: The agent with the specified ID.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_5","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nretrieved_agent = swarm.get_agent(agent.id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#add_agent","title":"<code>add_agent</code>","text":"<pre><code>def add_agent(self, agent: Agent)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_7","title":"Description","text":"<p>Adds an agent to the agent pool.</p>"},{"location":"swarms/structs/swarm_network/#parameters_7","title":"Parameters","text":"<ul> <li><code>agent</code> (type): The agent to be added to the pool.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_6","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[])\nswarm.add_agent(agent)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#remove_agent","title":"<code>remove_agent</code>","text":"<pre><code>def remove_agent(self, agent_id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_8","title":"Description","text":"<p>Removes an agent from the agent pool.</p>"},{"location":"swarms/structs/swarm_network/#parameters_8","title":"Parameters","text":"<ul> <li><code>agent_id</code> (type): The ID of the agent to be removed.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_7","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nswarm.remove_agent(agent.id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#_1","title":"`","text":"<p>async_remove_agent`</p> <pre><code>async def async_remove_agent(self, agent_id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_9","title":"Description","text":"<p>Removes an agent from the agent pool asynchronously.</p>"},{"location":"swarms/structs/swarm_network/#parameters_9","title":"Parameters","text":"<ul> <li><code>agent_id</code> (type): The ID of the agent to be removed.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_8","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nawait swarm.async_remove_agent(agent.id)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#scale_up","title":"<code>scale_up</code>","text":"<pre><code>def scale_up(self, num_agents: int = 1)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_10","title":"Description","text":"<p>Scales up the agent pool by adding new agents.</p>"},{"location":"swarms/structs/swarm_network/#parameters_10","title":"Parameters","text":"<ul> <li><code>num_agents</code> (int, optional): The number of agents to add. Defaults to 1.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_9","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\nswarm = SwarmNetwork(agents=[agent])\nswarm.scale_up(2)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#scale_down","title":"<code>scale_down</code>","text":"<pre><code>def scale_down(self, num_agents: int = 1)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#description_11","title":"Description","text":"<p>Scales down the agent pool by removing agents.</p>"},{"location":"swarms/structs/swarm_network/#parameters_11","title":"Parameters","text":"<ul> <li><code>num_agents</code> (int, optional): The number of agents to remove. Defaults to 1.</li> </ul>"},{"location":"swarms/structs/swarm_network/#example_10","title":"Example","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.swarm_net import SwarmNetwork\n\n# Initialize the agent\nagent2 = Agent(\n    agent_name=\"ROTH-IRA-AGENT\",\n    system_prompt=ESTATE_PLANNING_AGENT_SYS_PROMPT,\n    llm=model,\n    max_loops=\"auto\",\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    interactive=True,\n    # interactive=True, # Set to False to disable interactive mode\n    saved_state_path=\"finance_agent.json\",\n    # tools=[Add your functions here# ],\n    # stopping_token=\"Stop!\",\n    # interactive=True,\n    # docs_folder=\"docs\", # Enter your folder name\n    # pdf_path=\"docs/finance_agent.pdf\",\n    # sop=\"Calculate the profit for a company.\",\n    # sop_list=[\"Calculate the profit for a company.\"],\n    user_name=\"swarms_corp\",\n    # # docs=\n    # # docs_folder=\"docs\",\n    retry_attempts=3,\n    # context_length=1000,\n    # tool_schema = dict\n    context_length=200000,\n    # agent_ops_on=True,\n    # long_term_memory=ChromaDB(docs_folder=\"artifacts\"),\n)\n\n\nswarm = SwarmNetwork(agents=[agent])\nswarm.scale_down(1)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#run","title":"<code>run</code>","text":""},{"location":"swarms/structs/swarm_network/#description_12","title":"Description","text":"<p>Runs the swarm network, starting the FastAPI application.</p>"},{"location":"swarms/structs/swarm_network/#example_11","title":"Example","text":"<pre><code>import os\n\nfrom dotenv import load_dotenv\n\n# Import the OpenAIChat model and the Agent struct\nfrom swarms import Agent, OpenAIChat, SwarmNetwork\n\n# Load the environment variables\nload_dotenv()\n\n# Get the API key from the environment\napi_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Initialize the language model\nllm = OpenAIChat(\n    temperature=0.5,\n    openai_api_key=api_key,\n)\n\n## Initialize the workflow\nagent = Agent(llm=llm, max_loops=1, agent_name=\"Social Media Manager\")\nagent2 = Agent(llm=llm, max_loops=1, agent_name=\" Product Manager\")\nagent3 = Agent(llm=llm, max_loops=1, agent_name=\"SEO Manager\")\n\n\n# Load the swarmnet with the agents\nswarmnet = SwarmNetwork(\n    agents=[agent, agent2, agent3],\n)\n\n# List the agents in the swarm network\nout = swarmnet.list_agents()\nprint(out)\n\n# Run the workflow on a task\nout = swarmnet.run_single_agent(\n    agent2.id, \"Generate a 10,000 word blog on health and wellness.\"\n)\nprint(out)\n\n\n# Run all the agents in the swarm network on a task\nout = swarmnet.run_many_agents(\"Generate a 10,000 word blog on health and wellness.\")\nprint(out)\n</code></pre>"},{"location":"swarms/structs/swarm_network/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Error Handling: Make use of try-except blocks to handle potential errors when adding tasks, running tasks, and managing agents.</li> <li>Logging: Enable logging to track the activity and status of the swarm network.</li> <li>API: The provided API allows for easy interaction with the swarm network and can be extended as needed.</li> <li>Asynchronous Operations: Utilize the asynchronous methods for non-blocking operations, especially in a production environment.</li> <li>Scaling: Adjust the scaling thresholds (<code>idle_threshold</code> and <code>busy_threshold</code>) based on the specific needs and workload patterns.</li> </ul>"},{"location":"swarms/structs/swarm_network/#references-and-resources","title":"References and Resources","text":"<ul> <li>Python Queue Documentation</li> <li>Threading in Python</li> <li>FastAPI Documentation</li> <li>Tenacity Documentation</li> </ul> <p>By following this documentation, users can effectively manage and utilize the <code>SwarmNetwork</code> class to handle dynamic workloads and maintain an efficient pool of agents.</p>"},{"location":"swarms/structs/swarm_rearrange/","title":"SwarmRearrange Documentation","text":"<p>SwarmRearrange is a class for orchestrating multiple swarms in a sequential or parallel flow pattern. It provides thread-safe operations for managing swarm execution, history tracking, and flow validation.</p>"},{"location":"swarms/structs/swarm_rearrange/#constructor-arguments","title":"Constructor Arguments","text":"Parameter Type Default Description id str UUID Unique identifier for the swarm arrangement name str \"SwarmRearrange\" Name of the swarm arrangement description str \"A swarm of swarms...\" Description of the arrangement swarms List[Any] [] List of swarm objects to be managed flow str None Flow pattern for swarm execution max_loops int 1 Maximum number of execution loops verbose bool True Enable detailed logging human_in_the_loop bool False Enable human intervention custom_human_in_the_loop Callable None Custom function for human interaction return_json bool False Return results in JSON format"},{"location":"swarms/structs/swarm_rearrange/#methods","title":"Methods","text":""},{"location":"swarms/structs/swarm_rearrange/#add_swarmswarm-any","title":"add_swarm(swarm: Any)","text":"<p>Adds a single swarm to the arrangement.</p>"},{"location":"swarms/structs/swarm_rearrange/#remove_swarmswarm_name-str","title":"remove_swarm(swarm_name: str)","text":"<p>Removes a swarm by name from the arrangement.</p>"},{"location":"swarms/structs/swarm_rearrange/#add_swarmsswarms-listany","title":"add_swarms(swarms: List[Any])","text":"<p>Adds multiple swarms to the arrangement.</p>"},{"location":"swarms/structs/swarm_rearrange/#validate_flow","title":"validate_flow()","text":"<p>Validates the flow pattern syntax and swarm names.</p>"},{"location":"swarms/structs/swarm_rearrange/#runtask-str-none-img-str-none-custom_tasks-dictstr-str-none","title":"run(task: str = None, img: str = None, custom_tasks: Dict[str, str] = None)","text":"<p>Executes the swarm arrangement according to the flow pattern.</p>"},{"location":"swarms/structs/swarm_rearrange/#flow-pattern-syntax","title":"Flow Pattern Syntax","text":"<p>The flow pattern uses arrow notation (<code>-&gt;</code>) to define execution order:</p> <ul> <li>Sequential: <code>\"SwarmA -&gt; SwarmB -&gt; SwarmC\"</code></li> <li>Parallel: <code>\"SwarmA, SwarmB -&gt; SwarmC\"</code></li> <li>Human intervention: Use <code>\"H\"</code> in the flow</li> </ul>"},{"location":"swarms/structs/swarm_rearrange/#examples","title":"Examples","text":""},{"location":"swarms/structs/swarm_rearrange/#basic-sequential-flow","title":"Basic Sequential Flow","text":"<pre><code>from swarms.structs.swarm_arange import SwarmRearrange\nimport os\nfrom swarms import Agent, AgentRearrange\nfrom swarm_models import OpenAIChat\n\n# model = Anthropic(anthropic_api_key=os.getenv(\"ANTHROPIC_API_KEY\"))\ncompany = \"TGSC\"\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\n\n# Initialize the Managing Director agent\nmanaging_director = Agent(\n    agent_name=\"Managing-Director\",\n    system_prompt=f\"\"\"\n    As the Managing Director at Blackstone, your role is to oversee the entire investment analysis process for potential acquisitions. \n    Your responsibilities include:\n    1. Setting the overall strategy and direction for the analysis\n    2. Coordinating the efforts of the various team members and ensuring a comprehensive evaluation\n    3. Reviewing the findings and recommendations from each team member\n    4. Making the final decision on whether to proceed with the acquisition\n\n    For the current potential acquisition of {company}, direct the tasks for the team to thoroughly analyze all aspects of the company, including its financials, industry position, technology, market potential, and regulatory compliance. Provide guidance and feedback as needed to ensure a rigorous and unbiased assessment.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"managing-director.json\",\n)\n\n# Initialize the Vice President of Finance\nvp_finance = Agent(\n    agent_name=\"VP-Finance\",\n    system_prompt=f\"\"\"\n    As the Vice President of Finance at Blackstone, your role is to lead the financial analysis of potential acquisitions. \n    For the current potential acquisition of {company}, your tasks include:\n    1. Conducting a thorough review of {company}' financial statements, including income statements, balance sheets, and cash flow statements\n    2. Analyzing key financial metrics such as revenue growth, profitability margins, liquidity ratios, and debt levels\n    3. Assessing the company's historical financial performance and projecting future performance based on assumptions and market conditions\n    4. Identifying any financial risks or red flags that could impact the acquisition decision\n    5. Providing a detailed report on your findings and recommendations to the Managing Director\n\n    Be sure to consider factors such as the sustainability of {company}' business model, the strength of its customer base, and its ability to generate consistent cash flows. Your analysis should be data-driven, objective, and aligned with Blackstone's investment criteria.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"vp-finance.json\",\n)\n\n# Initialize the Industry Analyst\nindustry_analyst = Agent(\n    agent_name=\"Industry-Analyst\",\n    system_prompt=f\"\"\"\n    As the Industry Analyst at Blackstone, your role is to provide in-depth research and analysis on the industries and markets relevant to potential acquisitions.\n    For the current potential acquisition of {company}, your tasks include:\n    1. Conducting a comprehensive analysis of the industrial robotics and automation solutions industry, including market size, growth rates, key trends, and future prospects\n    2. Identifying the major players in the industry and assessing their market share, competitive strengths and weaknesses, and strategic positioning \n    3. Evaluating {company}' competitive position within the industry, including its market share, differentiation, and competitive advantages\n    4. Analyzing the key drivers and restraints for the industry, such as technological advancements, labor costs, regulatory changes, and economic conditions\n    5. Identifying potential risks and opportunities for {company} based on the industry analysis, such as disruptive technologies, emerging markets, or shifts in customer preferences  \n\n    Your analysis should provide a clear and objective assessment of the attractiveness and future potential of the industrial robotics industry, as well as {company}' positioning within it. Consider both short-term and long-term factors, and provide evidence-based insights to inform the investment decision.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"industry-analyst.json\",\n)\n\n# Initialize the Technology Expert\ntech_expert = Agent(\n    agent_name=\"Tech-Expert\",\n    system_prompt=f\"\"\"\n    As the Technology Expert at Blackstone, your role is to assess the technological capabilities, competitive advantages, and potential risks of companies being considered for acquisition.\n    For the current potential acquisition of {company}, your tasks include:\n    1. Conducting a deep dive into {company}' proprietary technologies, including its robotics platforms, automation software, and AI capabilities \n    2. Assessing the uniqueness, scalability, and defensibility of {company}' technology stack and intellectual property\n    3. Comparing {company}' technologies to those of its competitors and identifying any key differentiators or technology gaps\n    4. Evaluating {company}' research and development capabilities, including its innovation pipeline, engineering talent, and R&amp;D investments\n    5. Identifying any potential technology risks or disruptive threats that could impact {company}' long-term competitiveness, such as emerging technologies or expiring patents\n\n    Your analysis should provide a comprehensive assessment of {company}' technological strengths and weaknesses, as well as the sustainability of its competitive advantages. Consider both the current state of its technology and its future potential in light of industry trends and advancements.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"tech-expert.json\",\n)\n\n# Initialize the Market Researcher\nmarket_researcher = Agent(\n    agent_name=\"Market-Researcher\",\n    system_prompt=f\"\"\"\n    As the Market Researcher at Blackstone, your role is to analyze the target company's customer base, market share, and growth potential to assess the commercial viability and attractiveness of the potential acquisition.\n    For the current potential acquisition of {company}, your tasks include:\n    1. Analyzing {company}' current customer base, including customer segmentation, concentration risk, and retention rates\n    2. Assessing {company}' market share within its target markets and identifying key factors driving its market position\n    3. Conducting a detailed market sizing and segmentation analysis for the industrial robotics and automation markets, including identifying high-growth segments and emerging opportunities\n    4. Evaluating the demand drivers and sales cycles for {company}' products and services, and identifying any potential risks or limitations to adoption\n    5. Developing financial projections and estimates for {company}' revenue growth potential based on the market analysis and assumptions around market share and penetration\n\n    Your analysis should provide a data-driven assessment of the market opportunity for {company} and the feasibility of achieving our investment return targets. Consider both bottom-up and top-down market perspectives, and identify any key sensitivities or assumptions in your projections.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"market-researcher.json\",\n)\n\n# Initialize the Regulatory Specialist\nregulatory_specialist = Agent(\n    agent_name=\"Regulatory-Specialist\",\n    system_prompt=f\"\"\"\n    As the Regulatory Specialist at Blackstone, your role is to identify and assess any regulatory risks, compliance requirements, and potential legal liabilities associated with potential acquisitions.\n    For the current potential acquisition of {company}, your tasks include:  \n    1. Identifying all relevant regulatory bodies and laws that govern the operations of {company}, including industry-specific regulations, labor laws, and environmental regulations\n    2. Reviewing {company}' current compliance policies, procedures, and track record to identify any potential gaps or areas of non-compliance\n    3. Assessing the potential impact of any pending or proposed changes to relevant regulations that could affect {company}' business or create additional compliance burdens\n    4. Evaluating the potential legal liabilities and risks associated with {company}' products, services, and operations, including product liability, intellectual property, and customer contracts\n    5. Providing recommendations on any regulatory or legal due diligence steps that should be taken as part of the acquisition process, as well as any post-acquisition integration considerations\n\n    Your analysis should provide a comprehensive assessment of the regulatory and legal landscape surrounding {company}, and identify any material risks or potential deal-breakers. Consider both the current state and future outlook, and provide practical recommendations to mitigate identified risks.\n    \"\"\",\n    llm=model,\n    max_loops=1,\n    dashboard=False,\n    streaming_on=True,\n    verbose=True,\n    stopping_token=\"&lt;DONE&gt;\",\n    state_save_file_type=\"json\",\n    saved_state_path=\"regulatory-specialist.json\",\n)\n\n# Create a list of agents\nagents = [\n    managing_director,\n    vp_finance,\n    industry_analyst,\n    tech_expert,\n    market_researcher,\n    regulatory_specialist,\n]\n\n# Define multiple flow patterns\nflows = [\n    \"Industry-Analyst -&gt; Tech-Expert -&gt; Market-Researcher -&gt; Regulatory-Specialist -&gt; Managing-Director -&gt; VP-Finance\",\n    \"Managing-Director -&gt; VP-Finance -&gt; Industry-Analyst -&gt; Tech-Expert -&gt; Market-Researcher -&gt; Regulatory-Specialist\",\n    \"Tech-Expert -&gt; Market-Researcher -&gt; Regulatory-Specialist -&gt; Industry-Analyst -&gt; Managing-Director -&gt; VP-Finance\",\n]\n\n# Create instances of AgentRearrange for each flow pattern\nblackstone_acquisition_analysis = AgentRearrange(\n    name=\"Blackstone-Acquisition-Analysis\",\n    description=\"A system for analyzing potential acquisitions\",\n    agents=agents,\n    flow=flows[0],\n)\n\nblackstone_investment_strategy = AgentRearrange(\n    name=\"Blackstone-Investment-Strategy\",\n    description=\"A system for evaluating investment opportunities\",\n    agents=agents,\n    flow=flows[1],\n)\n\nblackstone_market_analysis = AgentRearrange(\n    name=\"Blackstone-Market-Analysis\",\n    description=\"A system for analyzing market trends and opportunities\",\n    agents=agents,\n    flow=flows[2],\n)\n\nswarm_arrange = SwarmRearrange(\n    swarms=[\n        blackstone_acquisition_analysis,\n        blackstone_investment_strategy,\n        blackstone_market_analysis,\n    ],\n    flow=f\"{blackstone_acquisition_analysis.name} -&gt; {blackstone_investment_strategy.name} -&gt; {blackstone_market_analysis.name}\",\n)\n\nprint(\n    swarm_arrange.run(\n        \"Analyze swarms, 150k revenue with 45m+ agents build, with 1.4m downloads since march 2024\"\n    )\n)\n</code></pre>"},{"location":"swarms/structs/swarm_rearrange/#human-in-the-loop","title":"Human-in-the-Loop","text":"<pre><code>def custom_human_input(task):\n    return input(f\"Review {task} and provide feedback: \")\n\n# Create arrangement with human intervention\narrangement = SwarmRearrange(\n    name=\"HumanAugmented\",\n    swarms=[swarm1, swarm2],\n    flow=\"SwarmA -&gt; H -&gt; SwarmB\",\n    human_in_the_loop=True,\n    custom_human_in_the_loop=custom_human_input\n)\n\n# Execute with human intervention\nresult = arrangement.run(\"Initial task\")\n</code></pre>"},{"location":"swarms/structs/swarm_rearrange/#complex-multi-stage-pipeline","title":"Complex Multi-Stage Pipeline","text":"<pre><code># Define multiple flow patterns\nflows = [\n    \"Collector -&gt; Processor -&gt; Analyzer\",\n    \"Analyzer -&gt; ML -&gt; Validator\",\n    \"Validator -&gt; Reporter\"\n]\n\n# Create arrangements for each flow\npipelines = [\n    SwarmRearrange(name=f\"Pipeline{i}\", swarms=swarms, flow=flow)\n    for i, flow in enumerate(flows)\n]\n\n# Create master arrangement\nmaster = SwarmRearrange(\n    name=\"MasterPipeline\",\n    swarms=pipelines,\n    flow=\"Pipeline0 -&gt; Pipeline1 -&gt; Pipeline2\"\n)\n\n# Execute complete pipeline\nresult = master.run(\"Start analysis\")\n</code></pre>"},{"location":"swarms/structs/swarm_rearrange/#best-practices","title":"Best Practices","text":"<ol> <li>Flow Validation: Always validate flows before execution</li> <li>Error Handling: Implement try-catch blocks around run() calls</li> <li>History Tracking: Use track_history() for monitoring swarm execution</li> <li>Resource Management: Set appropriate max_loops to prevent infinite execution</li> <li>Logging: Enable verbose mode during development for detailed logging</li> </ol>"},{"location":"swarms/structs/swarm_rearrange/#error-handling","title":"Error Handling","text":"<p>The class implements comprehensive error handling:</p> <pre><code>try:\n    arrangement = SwarmRearrange(swarms=swarms, flow=flow)\n    result = arrangement.run(task)\nexcept ValueError as e:\n    logger.error(f\"Flow validation error: {e}\")\nexcept Exception as e:\n    logger.error(f\"Execution error: {e}\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/","title":"SwarmRouter Documentation","text":"<p>The <code>SwarmRouter</code> class is a flexible routing system designed to manage different types of swarms for task execution. It provides a unified interface to interact with various swarm types, including:</p> Swarm Type Description <code>AgentRearrange</code> Optimizes agent arrangement for task execution <code>MixtureOfAgents</code> Combines multiple agent types for diverse tasks <code>SpreadSheetSwarm</code> Uses spreadsheet-like operations for task management <code>SequentialWorkflow</code> Executes tasks sequentially <code>ConcurrentWorkflow</code> Executes tasks in parallel <code>GroupChat</code> Facilitates communication among agents in a group chat format <code>MultiAgentRouter</code> Routes tasks between multiple agents <code>AutoSwarmBuilder</code> Automatically builds swarm structure <code>HiearchicalSwarm</code> Hierarchical organization of agents <code>MajorityVoting</code> Uses majority voting for decision making <code>MALT</code> Multi-Agent Language Tasks <code>DeepResearchSwarm</code> Specialized for deep research tasks <code>CouncilAsAJudge</code> Council-based judgment system <code>InteractiveGroupChat</code> Interactive group chat with user participation <code>auto</code> Automatically selects best swarm type via embedding search"},{"location":"swarms/structs/swarm_router/#classes","title":"Classes","text":""},{"location":"swarms/structs/swarm_router/#document","title":"Document","text":"<p>A Pydantic model for representing document data.</p> Attribute Type Description <code>file_path</code> str Path to the document file. <code>data</code> str Content of the document."},{"location":"swarms/structs/swarm_router/#swarmlog","title":"SwarmLog","text":"<p>A Pydantic model for capturing log entries.</p> Attribute Type Description <code>id</code> str Unique identifier for the log entry. <code>timestamp</code> datetime Time of log creation. <code>level</code> str Log level (e.g., \"info\", \"error\"). <code>message</code> str Log message content. <code>swarm_type</code> SwarmType Type of swarm associated with the log. <code>task</code> str Task being performed (optional). <code>metadata</code> Dict[str, Any] Additional metadata (optional). <code>documents</code> List[Document] List of documents associated with the log."},{"location":"swarms/structs/swarm_router/#swarmrouterconfig","title":"SwarmRouterConfig","text":"<p>Configuration model for SwarmRouter.</p> Attribute Type Description <code>name</code> str Name identifier for the SwarmRouter instance <code>description</code> str Description of the SwarmRouter's purpose <code>swarm_type</code> SwarmType Type of swarm to use <code>rearrange_flow</code> Optional[str] Flow configuration string <code>rules</code> Optional[str] Rules to inject into every agent <code>multi_agent_collab_prompt</code> bool Whether to enable multi-agent collaboration prompts <code>task</code> str The task to be executed by the swarm"},{"location":"swarms/structs/swarm_router/#swarmrouter","title":"SwarmRouter","text":"<p>Main class for routing tasks to different swarm types.</p> Attribute Type Description <code>name</code> str Name of the SwarmRouter instance <code>description</code> str Description of the SwarmRouter's purpose <code>max_loops</code> int Maximum number of loops to perform <code>agents</code> List[Union[Agent, Callable]] List of Agent objects or callable functions <code>swarm_type</code> SwarmType Type of swarm to be used <code>autosave</code> bool Flag to enable/disable autosave <code>rearrange_flow</code> str The flow for the AgentRearrange swarm type <code>return_json</code> bool Flag to enable/disable returning the result in JSON format <code>auto_generate_prompts</code> bool Flag to enable/disable auto generation of prompts <code>shared_memory_system</code> Any Shared memory system for agents <code>rules</code> str Rules to inject into every agent <code>documents</code> List[str] List of document file paths <code>output_type</code> OutputType Output format type (e.g., \"string\", \"dict\", \"list\", \"json\", \"yaml\", \"xml\") <code>no_cluster_ops</code> bool Flag to disable cluster operations <code>speaker_fn</code> callable Speaker function for GroupChat swarm type <code>load_agents_from_csv</code> bool Flag to enable/disable loading agents from CSV <code>csv_file_path</code> str Path to the CSV file for loading agents <code>return_entire_history</code> bool Flag to enable/disable returning the entire conversation history <code>multi_agent_collab_prompt</code> bool Whether to enable multi-agent collaboration prompts"},{"location":"swarms/structs/swarm_router/#methods","title":"Methods:","text":"Method Parameters Description <code>__init__</code> <code>name: str = \"swarm-router\", description: str = \"Routes your task to the desired swarm\", max_loops: int = 1, agents: List[Union[Agent, Callable]] = [], swarm_type: SwarmType = \"SequentialWorkflow\", autosave: bool = False, rearrange_flow: str = None, return_json: bool = False, auto_generate_prompts: bool = False, shared_memory_system: Any = None, rules: str = None, documents: List[str] = [], output_type: OutputType = \"dict\", no_cluster_ops: bool = False, speaker_fn: callable = None, load_agents_from_csv: bool = False, csv_file_path: str = None, return_entire_history: bool = True, multi_agent_collab_prompt: bool = True</code> Initialize the SwarmRouter <code>setup</code> None Set up the SwarmRouter by activating APE and handling shared memory and rules <code>activate_shared_memory</code> None Activate shared memory with all agents <code>handle_rules</code> None Inject rules to every agent <code>activate_ape</code> None Activate automatic prompt engineering for agents that support it <code>reliability_check</code> None Perform reliability checks on the SwarmRouter configuration <code>_create_swarm</code> <code>task: str = None, *args, **kwargs</code> Create and return the specified swarm type <code>update_system_prompt_for_agent_in_swarm</code> None Update system prompts for all agents with collaboration prompts <code>_log</code> <code>level: str, message: str, task: str = \"\", metadata: Dict[str, Any] = None</code> Create a log entry <code>_run</code> <code>task: str, img: Optional[str] = None, model_response: Optional[str] = None, *args, **kwargs</code> Run the specified task on the selected swarm type <code>run</code> <code>task: str, img: Optional[str] = None, model_response: Optional[str] = None, *args, **kwargs</code> Execute a task on the selected swarm type <code>__call__</code> <code>task: str, *args, **kwargs</code> Make the SwarmRouter instance callable <code>batch_run</code> <code>tasks: List[str], *args, **kwargs</code> Execute multiple tasks in sequence <code>async_run</code> <code>task: str, *args, **kwargs</code> Execute a task asynchronously <code>get_logs</code> None Retrieve all logged entries <code>concurrent_run</code> <code>task: str, *args, **kwargs</code> Execute a task using concurrent execution <code>concurrent_batch_run</code> <code>tasks: List[str], *args, **kwargs</code> Execute multiple tasks concurrently"},{"location":"swarms/structs/swarm_router/#installation","title":"Installation","text":"<p>To use the SwarmRouter, first install the required dependencies:</p> <pre><code>pip install swarms swarm_models\n</code></pre>"},{"location":"swarms/structs/swarm_router/#basic-usage","title":"Basic Usage","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, SwarmRouter, SwarmType\nfrom swarm_models import OpenAIChat\n\nload_dotenv()\n\n# Get the OpenAI API key from the environment variable\napi_key = os.getenv(\"GROQ_API_KEY\")\n\n# Model\nmodel = OpenAIChat(\n    openai_api_base=\"https://api.groq.com/openai/v1\",\n    openai_api_key=api_key,\n    model_name=\"llama-3.1-70b-versatile\",\n    temperature=0.1,\n)\n\n# Define specialized system prompts for each agent\nDATA_EXTRACTOR_PROMPT = \"\"\"You are a highly specialized private equity agent focused on data extraction from various documents. Your expertise includes:\n1. Extracting key financial metrics (revenue, EBITDA, growth rates, etc.) from financial statements and reports\n2. Identifying and extracting important contract terms from legal documents\n3. Pulling out relevant market data from industry reports and analyses\n4. Extracting operational KPIs from management presentations and internal reports\n5. Identifying and extracting key personnel information from organizational charts and bios\nProvide accurate, structured data extracted from various document types to support investment analysis.\"\"\"\n\nSUMMARIZER_PROMPT = \"\"\"You are an expert private equity agent specializing in summarizing complex documents. Your core competencies include:\n1. Distilling lengthy financial reports into concise executive summaries\n2. Summarizing legal documents, highlighting key terms and potential risks\n3. Condensing industry reports to capture essential market trends and competitive dynamics\n4. Summarizing management presentations to highlight key strategic initiatives and projections\n5. Creating brief overviews of technical documents, emphasizing critical points for non-technical stakeholders\nDeliver clear, concise summaries that capture the essence of various documents while highlighting information crucial for investment decisions.\"\"\"\n\n# Initialize specialized agents\ndata_extractor_agent = Agent(\n    agent_name=\"Data-Extractor\",\n    system_prompt=DATA_EXTRACTOR_PROMPT,\n    llm=model,\n    max_loops=1,\n    autosave=True,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"data_extractor_agent.json\",\n    user_name=\"pe_firm\",\n    retry_attempts=1,\n    context_length=200000,\n    output_type=\"string\",\n)\n\nsummarizer_agent = Agent(\n    agent_name=\"Document-Summarizer\",\n    system_prompt=SUMMARIZER_PROMPT,\n    llm=model,\n    max_loops=1,\n    autosave=True,\n    verbose=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"summarizer_agent.json\",\n    user_name=\"pe_firm\",\n    retry_attempts=1,\n    context_length=200000,\n    output_type=\"string\",\n)\n\n# Initialize the SwarmRouter\nrouter = SwarmRouter(\n    name=\"pe-document-analysis-swarm\",\n    description=\"Analyze documents for private equity due diligence and investment decision-making\",\n    max_loops=1,\n    agents=[data_extractor_agent, summarizer_agent],\n    swarm_type=\"ConcurrentWorkflow\",\n    autosave=True,\n    return_json=True,\n)\n\n# Example usage\nif __name__ == \"__main__\":\n    # Run a comprehensive private equity document analysis task\n    result = router.run(\n        \"Where is the best place to find template term sheets for series A startups? Provide links and references\"\n    )\n    print(result)\n\n    # Retrieve and print logs\n    for log in router.get_logs():\n        print(f\"{log.timestamp} - {log.level}: {log.message}\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/structs/swarm_router/#changing-swarm-types","title":"Changing Swarm Types","text":"<p>You can create multiple SwarmRouter instances with different swarm types:</p> <pre><code>sequential_router = SwarmRouter(\n    name=\"SequentialRouter\",\n    agents=[agent1, agent2],\n    swarm_type=\"SequentialWorkflow\"\n)\n\nconcurrent_router = SwarmRouter(\n    name=\"ConcurrentRouter\",\n    agents=[agent1, agent2],\n    swarm_type=\"ConcurrentWorkflow\"\n)\n</code></pre>"},{"location":"swarms/structs/swarm_router/#automatic-swarm-type-selection","title":"Automatic Swarm Type Selection","text":"<p>You can let the SwarmRouter automatically select the best swarm type for a given task:</p> <pre><code>auto_router = SwarmRouter(\n    name=\"AutoRouter\",\n    agents=[agent1, agent2],\n    swarm_type=\"auto\"\n)\n\nresult = auto_router.run(\"Analyze and summarize the quarterly financial report\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#loading-agents-from-csv","title":"Loading Agents from CSV","text":"<p>To load agents from a CSV file:</p> <pre><code>csv_router = SwarmRouter(\n    name=\"CSVAgentRouter\",\n    load_agents_from_csv=True,\n    csv_file_path=\"agents.csv\",\n    swarm_type=\"SequentialWorkflow\"\n)\n\nresult = csv_router.run(\"Process the client data\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#using-shared-memory-system","title":"Using Shared Memory System","text":"<p>To enable shared memory across agents:</p> <pre><code>from swarms.memory import SemanticMemory\n\nmemory_system = SemanticMemory()\n\nmemory_router = SwarmRouter(\n    name=\"MemoryRouter\",\n    agents=[agent1, agent2],\n    shared_memory_system=memory_system,\n    swarm_type=\"SequentialWorkflow\"\n)\n\nresult = memory_router.run(\"Analyze historical data and make predictions\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#injecting-rules-to-all-agents","title":"Injecting Rules to All Agents","text":"<p>To inject common rules into all agents:</p> <pre><code>rules = \"\"\"\n1. Always provide sources for your information\n2. Check your calculations twice\n3. Explain your reasoning clearly\n4. Highlight uncertainties and assumptions\n\"\"\"\n\nrules_router = SwarmRouter(\n    name=\"RulesRouter\",\n    agents=[agent1, agent2],\n    rules=rules,\n    swarm_type=\"SequentialWorkflow\"\n)\n\nresult = rules_router.run(\"Analyze the investment opportunity\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#use-cases","title":"Use Cases","text":""},{"location":"swarms/structs/swarm_router/#agentrearrange","title":"AgentRearrange","text":"<p>Use Case: Optimizing agent order for complex multi-step tasks.</p> <pre><code>rearrange_router = SwarmRouter(\n    name=\"TaskOptimizer\",\n    description=\"Optimize agent order for multi-step tasks\",\n    max_loops=3,\n    agents=[data_extractor, analyzer, summarizer],\n    swarm_type=\"AgentRearrange\",\n    rearrange_flow=f\"{data_extractor.name} -&gt; {analyzer.name} -&gt; {summarizer.name}\"\n)\n\nresult = rearrange_router.run(\"Analyze and summarize the quarterly financial report\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#mixtureofagents","title":"MixtureOfAgents","text":"<p>Use Case: Combining diverse expert agents for comprehensive analysis.</p> <pre><code>mixture_router = SwarmRouter(\n    name=\"ExpertPanel\",\n    description=\"Combine insights from various expert agents\",\n    max_loops=1,\n    agents=[financial_expert, market_analyst, tech_specialist, aggregator],\n    swarm_type=\"MixtureOfAgents\"\n)\n\nresult = mixture_router.run(\"Evaluate the potential acquisition of TechStartup Inc.\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#spreadsheetswarm","title":"SpreadSheetSwarm","text":"<p>Use Case: Collaborative data processing and analysis.</p> <pre><code>spreadsheet_router = SwarmRouter(\n    name=\"DataProcessor\",\n    description=\"Collaborative data processing and analysis\",\n    max_loops=1,\n    agents=[data_cleaner, statistical_analyzer, visualizer],\n    swarm_type=\"SpreadSheetSwarm\"\n)\n\nresult = spreadsheet_router.run(\"Process and visualize customer churn data\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#sequentialworkflow","title":"SequentialWorkflow","text":"<p>Use Case: Step-by-step document analysis and report generation.</p> <pre><code>sequential_router = SwarmRouter(\n    name=\"ReportGenerator\",\n    description=\"Generate comprehensive reports sequentially\",\n    max_loops=1,\n    agents=[data_extractor, analyzer, writer, reviewer],\n    swarm_type=\"SequentialWorkflow\",\n    return_entire_history=True\n)\n\nresult = sequential_router.run(\"Create a due diligence report for Project Alpha\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#concurrentworkflow","title":"ConcurrentWorkflow","text":"<p>Use Case: Parallel processing of multiple data sources.</p> <pre><code>concurrent_router = SwarmRouter(\n    name=\"MultiSourceAnalyzer\",\n    description=\"Analyze multiple data sources concurrently\",\n    max_loops=1,\n    agents=[financial_analyst, market_researcher, competitor_analyst],\n    swarm_type=\"ConcurrentWorkflow\",\n    output_type=\"string\"\n)\n\nresult = concurrent_router.run(\"Conduct a comprehensive market analysis for Product X\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#groupchat","title":"GroupChat","text":"<p>Use Case: Simulating a group discussion with multiple agents.</p> <pre><code>group_chat_router = SwarmRouter(\n    name=\"GroupChat\",\n    description=\"Simulate a group discussion with multiple agents\",\n    max_loops=10,\n    agents=[financial_analyst, market_researcher, competitor_analyst],\n    swarm_type=\"GroupChat\",\n    speaker_fn=custom_speaker_function\n)\n\nresult = group_chat_router.run(\"Discuss the pros and cons of expanding into the Asian market\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#multiagentrouter","title":"MultiAgentRouter","text":"<p>Use Case: Routing tasks to the most appropriate agent.</p> <pre><code>multi_agent_router = SwarmRouter(\n    name=\"MultiAgentRouter\",\n    description=\"Route tasks to specialized agents\",\n    max_loops=1,\n    agents=[financial_analyst, market_researcher, competitor_analyst],\n    swarm_type=\"MultiAgentRouter\",\n    shared_memory_system=memory_system\n)\n\nresult = multi_agent_router.run(\"Analyze the competitive landscape for our new product\")\n</code></pre> <p>See MultiAgentRouter Minimal Example for a lightweight demonstration.</p>"},{"location":"swarms/structs/swarm_router/#hierarchicalswarm","title":"HierarchicalSwarm","text":"<p>Use Case: Creating a hierarchical structure of agents with a director.</p> <pre><code>hierarchical_router = SwarmRouter(\n    name=\"HierarchicalSwarm\",\n    description=\"Hierarchical organization of agents with a director\",\n    max_loops=3,\n    agents=[director, analyst1, analyst2, researcher],\n    swarm_type=\"HiearchicalSwarm\",\n    return_all_history=True\n)\n\nresult = hierarchical_router.run(\"Develop a comprehensive market entry strategy\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#majorityvoting","title":"MajorityVoting","text":"<p>Use Case: Using consensus among multiple agents for decision-making.</p> <pre><code>voting_router = SwarmRouter(\n    name=\"MajorityVoting\",\n    description=\"Make decisions using consensus among agents\",\n    max_loops=1,\n    agents=[analyst1, analyst2, analyst3, consensus_agent],\n    swarm_type=\"MajorityVoting\"\n)\n\nresult = voting_router.run(\"Should we invest in Company X based on the available data?\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#auto-select-experimental","title":"Auto Select (Experimental)","text":"<p>Autonomously selects the right swarm by conducting vector search on your input task or name or description or all 3.</p> <pre><code>auto_router = SwarmRouter(\n    name=\"MultiSourceAnalyzer\",\n    description=\"Analyze multiple data sources concurrently\",\n    max_loops=1,\n    agents=[financial_analyst, market_researcher, competitor_analyst],\n    swarm_type=\"auto\" # Set this to 'auto' for it to auto select your swarm. It's match words like concurrently multiple -&gt; \"ConcurrentWorkflow\"\n)\n\nresult = auto_router.run(\"Conduct a comprehensive market analysis for Product X\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#interactivegroupchat","title":"InteractiveGroupChat","text":"<p>Use Case: Interactive group discussions with user participation.</p> <pre><code>interactive_chat_router = SwarmRouter(\n    name=\"InteractiveGroupChat\",\n    description=\"Interactive group chat with user participation\",\n    max_loops=10,\n    agents=[financial_analyst, market_researcher, competitor_analyst],\n    swarm_type=\"InteractiveGroupChat\",\n    output_type=\"string\"\n)\n\nresult = interactive_chat_router.run(\"Discuss the market trends and provide interactive analysis\")\n</code></pre> <p>The InteractiveGroupChat allows for dynamic interaction between agents and users, enabling real-time participation in group discussions and decision-making processes. This is particularly useful for scenarios requiring human input or validation during the conversation flow.</p>"},{"location":"swarms/structs/swarm_router/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms/structs/swarm_router/#processing-documents","title":"Processing Documents","text":"<p>To process documents with the SwarmRouter:</p> <pre><code>document_router = SwarmRouter(\n    name=\"DocumentProcessor\",\n    agents=[document_analyzer, summarizer],\n    documents=[\"report.pdf\", \"contract.docx\", \"data.csv\"],\n    swarm_type=\"SequentialWorkflow\"\n)\n\nresult = document_router.run(\"Extract key information from the provided documents\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#batch-processing","title":"Batch Processing","text":"<p>To process multiple tasks in a batch:</p> <pre><code>tasks = [\"Analyze Q1 report\", \"Summarize competitor landscape\", \"Evaluate market trends\"]\nresults = router.batch_run(tasks)\n</code></pre>"},{"location":"swarms/structs/swarm_router/#asynchronous-execution","title":"Asynchronous Execution","text":"<p>For asynchronous task execution:</p> <pre><code>result = await router.async_run(\"Generate financial projections\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#concurrent-execution","title":"Concurrent Execution","text":"<p>To run a single task concurrently:</p> <pre><code>result = router.concurrent_run(\"Analyze multiple data streams\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#concurrent-batch-processing","title":"Concurrent Batch Processing","text":"<p>To process multiple tasks concurrently:</p> <pre><code>tasks = [\"Task 1\", \"Task 2\", \"Task 3\"]\nresults = router.concurrent_batch_run(tasks)\n</code></pre>"},{"location":"swarms/structs/swarm_router/#using-the-swarmrouter-as-a-callable","title":"Using the SwarmRouter as a Callable","text":"<p>You can use the SwarmRouter instance directly as a callable:</p> <pre><code>router = SwarmRouter(\n    name=\"CallableRouter\",\n    agents=[agent1, agent2],\n    swarm_type=\"SequentialWorkflow\"\n)\n\nresult = router(\"Analyze the market data\")  # Equivalent to router.run(\"Analyze the market data\")\n</code></pre>"},{"location":"swarms/structs/swarm_router/#using-the-swarm_router-function","title":"Using the swarm_router Function","text":"<p>For quick one-off tasks, you can use the swarm_router function:</p> <pre><code>from swarms import swarm_router\n\nresult = swarm_router(\n    name=\"QuickRouter\",\n    agents=[agent1, agent2],\n    swarm_type=\"ConcurrentWorkflow\",\n    task=\"Analyze the quarterly report\"\n)\n</code></pre>"},{"location":"swarms/structs/task/","title":"Task Class Documentation","text":"<p>The <code>Task</code> class is a pivotal component designed for managing tasks in a sequential workflow. This class allows for the execution of tasks using various agents, which can be callable objects or specific instances of the <code>Agent</code> class. It supports the scheduling of tasks, handling their dependencies, and setting conditions and actions that govern their execution.</p> <p>Key features of the <code>Task</code> class include: - Executing tasks with specified agents and handling their results. - Scheduling tasks to run at specified times. - Setting triggers, actions, and conditions for tasks. - Managing task dependencies and priorities. - Providing a history of task executions for tracking purposes.</p>"},{"location":"swarms/structs/task/#class-definition","title":"Class Definition","text":"<p>The <code>Task</code> class is defined as follows:</p>"},{"location":"swarms/structs/task/#attributes","title":"Attributes","text":"Attribute Type Description <code>agent</code> <code>Union[Callable, Agent]</code> The agent or callable object to run the task. <code>description</code> <code>str</code> Description of the task. <code>result</code> <code>Any</code> Result of the task. <code>history</code> <code>List[Any]</code> History of the task. <code>schedule_time</code> <code>datetime</code> Time to schedule the task. <code>scheduler</code> <code>sched.scheduler</code> Scheduler to schedule the task. <code>trigger</code> <code>Callable</code> Trigger to run the task. <code>action</code> <code>Callable</code> Action to run the task. <code>condition</code> <code>Callable</code> Condition to run the task. <code>priority</code> <code>int</code> Priority of the task. <code>dependencies</code> <code>List[Task]</code> List of tasks that need to be completed before this task can be executed. <code>args</code> <code>List[Any]</code> Arguments to pass to the agent or callable object. <code>kwargs</code> <code>Dict[str, Any]</code> Keyword arguments to pass to the agent or callable object."},{"location":"swarms/structs/task/#methods","title":"Methods","text":""},{"location":"swarms/structs/task/#executeself-args-kwargs","title":"<code>execute(self, *args, **kwargs)</code>","text":"<p>Executes the task by calling the agent or model with the specified arguments and keyword arguments. If a condition is set, the task will only execute if the condition returns <code>True</code>.</p>"},{"location":"swarms/structs/task/#parameters","title":"Parameters","text":"<ul> <li><code>args</code>: Arguments to pass to the agent or callable object.</li> <li><code>kwargs</code>: Keyword arguments to pass to the agent or callable object.</li> </ul>"},{"location":"swarms/structs/task/#examples","title":"Examples","text":"<pre><code>&gt;&gt;&gt; from swarms.structs import Task, Agent\n&gt;&gt;&gt; from swarm_models import OpenAIChat\n&gt;&gt;&gt; agent = Agent(llm=OpenAIChat(openai_api_key=\"\"), max_loops=1, dashboard=False)\n&gt;&gt;&gt; task = Task(description=\"What's the weather in Miami?\", agent=agent)\n&gt;&gt;&gt; task.run()\n&gt;&gt;&gt; task.result\n</code></pre>"},{"location":"swarms/structs/task/#handle_scheduled_taskself","title":"<code>handle_scheduled_task(self)</code>","text":"<p>Handles the execution of a scheduled task. If the schedule time is not set or has already passed, the task is executed immediately. Otherwise, the task is scheduled to be executed at the specified schedule time.</p>"},{"location":"swarms/structs/task/#examples_1","title":"Examples","text":"<pre><code>&gt;&gt;&gt; task.schedule_time = datetime.now() + timedelta(seconds=10)\n&gt;&gt;&gt; task.handle_scheduled_task()\n</code></pre>"},{"location":"swarms/structs/task/#set_triggerself-trigger-callable","title":"<code>set_trigger(self, trigger: Callable)</code>","text":"<p>Sets the trigger for the task.</p>"},{"location":"swarms/structs/task/#parameters_1","title":"Parameters","text":"<ul> <li><code>trigger</code> (<code>Callable</code>): The trigger to set.</li> </ul>"},{"location":"swarms/structs/task/#examples_2","title":"Examples","text":"<pre><code>&gt;&gt;&gt; def my_trigger():\n&gt;&gt;&gt;     print(\"Trigger executed\")\n&gt;&gt;&gt; task.set_trigger(my_trigger)\n</code></pre>"},{"location":"swarms/structs/task/#set_actionself-action-callable","title":"<code>set_action(self, action: Callable)</code>","text":"<p>Sets the action for the task.</p>"},{"location":"swarms/structs/task/#parameters_2","title":"Parameters","text":"<ul> <li><code>action</code> (<code>Callable</code>): The action to set.</li> </ul>"},{"location":"swarms/structs/task/#examples_3","title":"Examples","text":"<pre><code>&gt;&gt;&gt; def my_action():\n&gt;&gt;&gt;     print(\"Action executed\")\n&gt;&gt;&gt; task.set_action(my_action)\n</code></pre>"},{"location":"swarms/structs/task/#set_conditionself-condition-callable","title":"<code>set_condition(self, condition: Callable)</code>","text":"<p>Sets the condition for the task.</p>"},{"location":"swarms/structs/task/#parameters_3","title":"Parameters","text":"<ul> <li><code>condition</code> (<code>Callable</code>): The condition to set.</li> </ul>"},{"location":"swarms/structs/task/#examples_4","title":"Examples","text":"<pre><code>&gt;&gt;&gt; def my_condition():\n&gt;&gt;&gt;     print(\"Condition checked\")\n&gt;&gt;&gt;     return True\n&gt;&gt;&gt; task.set_condition(my_condition)\n</code></pre>"},{"location":"swarms/structs/task/#is_completedself","title":"<code>is_completed(self)</code>","text":"<p>Checks whether the task has been completed.</p>"},{"location":"swarms/structs/task/#returns","title":"Returns","text":"<ul> <li><code>bool</code>: <code>True</code> if the task has been completed, <code>False</code> otherwise.</li> </ul>"},{"location":"swarms/structs/task/#examples_5","title":"Examples","text":"<pre><code>&gt;&gt;&gt; task.is_completed()\n</code></pre>"},{"location":"swarms/structs/task/#add_dependencyself-task","title":"<code>add_dependency(self, task)</code>","text":"<p>Adds a task to the list of dependencies.</p>"},{"location":"swarms/structs/task/#parameters_4","title":"Parameters","text":"<ul> <li><code>task</code> (<code>Task</code>): The task to add as a dependency.</li> </ul>"},{"location":"swarms/structs/task/#examples_6","title":"Examples","text":"<pre><code>&gt;&gt;&gt; dependent_task = Task(description=\"Dependent Task\")\n&gt;&gt;&gt; task.add_dependency(dependent_task)\n</code></pre>"},{"location":"swarms/structs/task/#set_priorityself-priority-int","title":"<code>set_priority(self, priority: int)</code>","text":"<p>Sets the priority of the task.</p>"},{"location":"swarms/structs/task/#parameters_5","title":"Parameters","text":"<ul> <li><code>priority</code> (<code>int</code>): The priority to set.</li> </ul>"},{"location":"swarms/structs/task/#examples_7","title":"Examples","text":"<pre><code>&gt;&gt;&gt; task.set_priority(5)\n</code></pre>"},{"location":"swarms/structs/task/#check_dependency_completionself","title":"<code>check_dependency_completion(self)</code>","text":"<p>Checks whether all the dependencies have been completed.</p>"},{"location":"swarms/structs/task/#returns_1","title":"Returns","text":"<ul> <li><code>bool</code>: <code>True</code> if all the dependencies have been completed, <code>False</code> otherwise.</li> </ul>"},{"location":"swarms/structs/task/#examples_8","title":"Examples","text":"<pre><code>&gt;&gt;&gt; task.check_dependency_completion()\n</code></pre>"},{"location":"swarms/structs/task/#contextself-task-task-none-context-listtask-none-args-kwargs","title":"<code>context(self, task: \"Task\" = None, context: List[\"Task\"] = None, *args, **kwargs)</code>","text":"<p>Sets the context for the task. For a sequential workflow, it sequentially adds the context of the previous task in the list.</p>"},{"location":"swarms/structs/task/#parameters_6","title":"Parameters","text":"<ul> <li><code>task</code> (<code>Task</code>, optional): The task whose context is to be set.</li> <li><code>context</code> (<code>List[Task]</code>, optional): The list of tasks to set the context.</li> </ul>"},{"location":"swarms/structs/task/#examples_9","title":"Examples","text":"<pre><code>&gt;&gt;&gt; task1 = Task(description=\"Task 1\")\n&gt;&gt;&gt; task2 = Task(description=\"Task 2\")\n&gt;&gt;&gt; task2.context(context=[task1])\n</code></pre>"},{"location":"swarms/structs/task/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/structs/task/#basic-usage","title":"Basic Usage","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, OpenAIChat, Task\n\n# Load the environment variables\nload_dotenv()\n\n# Define a function to be used as the action\ndef my_action():\n    print(\"Action executed\")\n\n# Define a function to be used as the condition\ndef my_condition():\n    print(\"Condition checked\")\n    return True\n\n# Create an agent\nagent = Agent(\n    llm=OpenAIChat(openai_api_key=os.environ[\"OPENAI_API_KEY\"]),\n    max_loops=1,\n    dashboard=False,\n)\n\n# Create a task\ntask = Task(\n    description=\"Generate a report on the top 3 biggest expenses for small businesses and how businesses can save 20%\",\n    agent=agent,\n)\n\n# Set the action and condition\ntask.set_action(my_action)\ntask.set_condition(my_condition)\n\n# Execute the task\nprint(\"Executing task...\")\ntask.run()\n\n# Check if the task is completed\nif task.is_completed():\n    print(\"Task completed\")\nelse:\n    print(\"Task not completed\")\n\n# Output the result of the task\nprint(f\"Task result: {task.result}\")\n</code></pre>"},{"location":"swarms/structs/task/#scheduled-task-execution","title":"Scheduled Task Execution","text":"<pre><code>from datetime import datetime, timedelta\nimport os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, OpenAIChat, Task\n\n# Load the environment variables\nload_dotenv()\n\n# Create an agent\nagent = Agent(\n    llm=OpenAIChat(openai_api_key=os.environ[\"OPENAI_API_KEY\"]),\n    max_loops=1,\n    dashboard=False,\n)\n\n# Create a task\ntask = Task(\n    description=\"Scheduled task example\",\n    agent=agent,\n    schedule_time=datetime.now() + timedelta(seconds=10)\n)\n\n# Handle scheduled task\ntask.handle_scheduled_task()\n</code></pre>"},{"location":"swarms/structs/task/#task-with-dependencies","title":"Task with Dependencies","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, OpenAIChat, Task\n\n# Load the environment variables\nload_dotenv()\n\n# Create agents\nagent1 = Agent(\n    llm=OpenAIChat(openai_api_key=os.environ[\"OPENAI_API_KEY\"]),\n    max_loops=1,\n    dashboard=False,\n)\nagent2 = Agent(\n    llm=OpenAIChat(openai_api_key=os.environ[\"OPENAI_API_KEY\"]),\n    max_loops=1,\n    dashboard=False,\n)\n\n# Create tasks\ntask1 = Task(description=\"First task\", agent=agent1)\ntask2 = Task(description=\"Second task\", agent=agent2)\n\n# Add dependency\ntask2.add_dependency(task1)\n\n# Execute tasks\nprint(\"Executing first task...\")\ntask1.run()\n\nprint(\"Executing second task...\")\ntask2.run()\n\n# Check if tasks are completed\nprint(f\"Task 1 completed: {task1.is_completed()}\")\nprint(f\"Task 2 completed: {task2.is_completed()}\")\n</code></pre>"},{"location":"swarms/structs/task/#task-context","title":"Task Context","text":"<pre><code>import os\nfrom dotenv import load_dotenv\nfrom swarms import Agent, OpenAIChat, Task\n\n# Load the environment variables\nload_dotenv()\n\n# Create an agent\nagent = Agent(\n    llm=OpenAIChat(openai_api_key=os.environ[\"OPENAI_API_KEY\"]),\n    max_loops\n\n=1,\n    dashboard=False,\n)\n\n# Create tasks\ntask1 = Task(description=\"First task\", agent=agent)\ntask2 = Task(description=\"Second task\", agent=agent)\n\n# Set context for the second task\ntask2.context(context=[task1])\n\n# Execute tasks\nprint(\"Executing first task...\")\ntask1.run()\n\nprint(\"Executing second task...\")\ntask2.run()\n\n# Output the context of the second task\nprint(f\"Task 2 context: {task2.history}\")\n</code></pre>"},{"location":"swarms/structs/taskqueue_swarm/","title":"TaskQueueSwarm Documentation","text":"<p>The <code>TaskQueueSwarm</code> class is designed to manage and execute tasks using multiple agents concurrently. This class allows for the orchestration of multiple agents processing tasks from a shared queue, facilitating complex workflows where tasks can be distributed and processed in parallel by different agents.</p>"},{"location":"swarms/structs/taskqueue_swarm/#attributes","title":"Attributes","text":"Attribute Type Description <code>agents</code> <code>List[Agent]</code> The list of agents in the swarm. <code>task_queue</code> <code>queue.Queue</code> A queue to store tasks for processing. <code>lock</code> <code>threading.Lock</code> A lock for thread synchronization. <code>autosave_on</code> <code>bool</code> Whether to automatically save the swarm metadata. <code>save_file_path</code> <code>str</code> The file path for saving swarm metadata. <code>workspace_dir</code> <code>str</code> The directory path of the workspace. <code>return_metadata_on</code> <code>bool</code> Whether to return the swarm metadata after running. <code>max_loops</code> <code>int</code> The maximum number of loops to run the swarm. <code>metadata</code> <code>SwarmRunMetadata</code> Metadata about the swarm run."},{"location":"swarms/structs/taskqueue_swarm/#methods","title":"Methods","text":""},{"location":"swarms/structs/taskqueue_swarm/#__init__self-agents-listagent-name-str-task-queue-swarm-description-str-a-swarm-that-processes-tasks-from-a-queue-using-multiple-agents-on-different-threads-autosave_on-bool-true-save_file_path-str-swarm_run_metadatajson-workspace_dir-str-osgetenvworkspace_dir-return_metadata_on-bool-false-max_loops-int-1-args-kwargs","title":"<code>__init__(self, agents: List[Agent], name: str = \"Task-Queue-Swarm\", description: str = \"A swarm that processes tasks from a queue using multiple agents on different threads.\", autosave_on: bool = True, save_file_path: str = \"swarm_run_metadata.json\", workspace_dir: str = os.getenv(\"WORKSPACE_DIR\"), return_metadata_on: bool = False, max_loops: int = 1, *args, **kwargs)</code>","text":"<p>The constructor initializes the <code>TaskQueueSwarm</code> object.</p> <ul> <li>Parameters:</li> <li><code>agents</code> (<code>List[Agent]</code>): The list of agents in the swarm.</li> <li><code>name</code> (<code>str</code>, optional): The name of the swarm. Defaults to \"Task-Queue-Swarm\".</li> <li><code>description</code> (<code>str</code>, optional): The description of the swarm. Defaults to \"A swarm that processes tasks from a queue using multiple agents on different threads.\".</li> <li><code>autosave_on</code> (<code>bool</code>, optional): Whether to automatically save the swarm metadata. Defaults to True.</li> <li><code>save_file_path</code> (<code>str</code>, optional): The file path to save the swarm metadata. Defaults to \"swarm_run_metadata.json\".</li> <li><code>workspace_dir</code> (<code>str</code>, optional): The directory path of the workspace. Defaults to os.getenv(\"WORKSPACE_DIR\").</li> <li><code>return_metadata_on</code> (<code>bool</code>, optional): Whether to return the swarm metadata after running. Defaults to False.</li> <li><code>max_loops</code> (<code>int</code>, optional): The maximum number of loops to run the swarm. Defaults to 1.</li> <li><code>*args</code>: Variable length argument list.</li> <li><code>**kwargs</code>: Arbitrary keyword arguments.</li> </ul>"},{"location":"swarms/structs/taskqueue_swarm/#add_taskself-task-str","title":"<code>add_task(self, task: str)</code>","text":"<p>Adds a task to the queue.</p> <ul> <li>Parameters:</li> <li><code>task</code> (<code>str</code>): The task to be added to the queue.</li> </ul>"},{"location":"swarms/structs/taskqueue_swarm/#runself","title":"<code>run(self)</code>","text":"<p>Runs the swarm by having agents pick up tasks from the queue.</p> <ul> <li>Returns:</li> <li> <p><code>str</code>: JSON string of the swarm run metadata if <code>return_metadata_on</code> is True.</p> </li> <li> <p>Usage Example: <pre><code>from swarms import Agent, TaskQueueSwarm\nfrom swarms_models import OpenAIChat\n\n# Initialize the language model\nllm = OpenAIChat()\n\n# Initialize agents\nagent1 = Agent(agent_name=\"Agent1\", llm=llm)\nagent2 = Agent(agent_name=\"Agent2\", llm=llm)\n\n# Create the TaskQueueSwarm\nswarm = TaskQueueSwarm(agents=[agent1, agent2], max_loops=5)\n\n# Add tasks to the swarm\nswarm.add_task(\"Analyze the latest market trends\")\nswarm.add_task(\"Generate a summary report\")\n\n# Run the swarm\nresult = swarm.run()\nprint(result)  # Prints the swarm run metadata\n</code></pre></p> </li> </ul> <p>This example initializes a <code>TaskQueueSwarm</code> with two agents, adds tasks to the queue, and runs the swarm.</p>"},{"location":"swarms/structs/taskqueue_swarm/#save_json_to_fileself","title":"<code>save_json_to_file(self)</code>","text":"<p>Saves the swarm run metadata to a JSON file.</p>"},{"location":"swarms/structs/taskqueue_swarm/#export_metadataself","title":"<code>export_metadata(self)</code>","text":"<p>Exports the swarm run metadata as a JSON string.</p> <ul> <li>Returns:</li> <li><code>str</code>: JSON string of the swarm run metadata.</li> </ul>"},{"location":"swarms/structs/taskqueue_swarm/#additional-notes","title":"Additional Notes","text":"<ul> <li>The <code>TaskQueueSwarm</code> uses threading to process tasks concurrently, which can significantly improve performance for I/O-bound tasks.</li> <li>The <code>reliability_checks</code> method ensures that the swarm is properly configured before running.</li> <li>The swarm automatically handles task distribution among agents and provides detailed metadata about the run.</li> <li>Error handling and logging are implemented to track the execution flow and capture any issues during task processing.</li> </ul>"},{"location":"swarms/structs/various_execution_methods/","title":"Concurrent Agents API Reference","text":"<p>This documentation covers the API for running multiple agents concurrently using various execution strategies. The implementation uses <code>asyncio</code> with <code>uvloop</code> for enhanced performance and <code>ThreadPoolExecutor</code> for handling CPU-bound operations.</p>"},{"location":"swarms/structs/various_execution_methods/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Core Functions</li> <li>Advanced Functions</li> <li>Utility Functions</li> <li>Resource Monitoring</li> <li>Usage Examples</li> </ul>"},{"location":"swarms/structs/various_execution_methods/#core-functions","title":"Core Functions","text":""},{"location":"swarms/structs/various_execution_methods/#run_agents_concurrently","title":"run_agents_concurrently()","text":"<p>Primary function for running multiple agents concurrently with optimized performance using both uvloop and ThreadPoolExecutor.</p>"},{"location":"swarms/structs/various_execution_methods/#arguments","title":"Arguments","text":"Parameter Type Required Default Description agents List[AgentType] Yes - List of Agent instances to run concurrently task str Yes - Task string to execute batch_size int No CPU count Number of agents to run in parallel in each batch max_workers int No CPU count * 2 Maximum number of threads in the executor"},{"location":"swarms/structs/various_execution_methods/#returns","title":"Returns","text":"<p><code>List[Any]</code>: List of outputs from each agent</p>"},{"location":"swarms/structs/various_execution_methods/#flow-diagram","title":"Flow Diagram","text":"<pre><code>graph TD\n    A[Start] --&gt; B[Initialize ThreadPoolExecutor]\n    B --&gt; C[Split Agents into Batches]\n    C --&gt; D[Process Batch]\n    D --&gt; E{More Batches?}\n    E --&gt;|Yes| D\n    E --&gt;|No| F[Combine Results]\n    F --&gt; G[Return Results]\n\n    subgraph \"Batch Processing\"\n    D --&gt; H[Run Agents Async]\n    H --&gt; I[Wait for Completion]\n    I --&gt; J[Collect Batch Results]\n    end</code></pre>"},{"location":"swarms/structs/various_execution_methods/#run_agents_sequentially","title":"run_agents_sequentially()","text":"<p>Runs multiple agents sequentially for baseline comparison or simple use cases.</p>"},{"location":"swarms/structs/various_execution_methods/#arguments_1","title":"Arguments","text":"Parameter Type Required Default Description agents List[AgentType] Yes - List of Agent instances to run task str Yes - Task string to execute"},{"location":"swarms/structs/various_execution_methods/#returns_1","title":"Returns","text":"<p><code>List[Any]</code>: List of outputs from each agent</p>"},{"location":"swarms/structs/various_execution_methods/#advanced-functions","title":"Advanced Functions","text":""},{"location":"swarms/structs/various_execution_methods/#run_agents_with_different_tasks","title":"run_agents_with_different_tasks()","text":"<p>Runs multiple agents with different tasks concurrently.</p>"},{"location":"swarms/structs/various_execution_methods/#arguments_2","title":"Arguments","text":"Parameter Type Required Default Description agent_task_pairs List[tuple[AgentType, str]] Yes - List of (agent, task) tuples batch_size int No CPU count Number of agents to run in parallel max_workers int No CPU count * 2 Maximum number of threads"},{"location":"swarms/structs/various_execution_methods/#run_agents_with_timeout","title":"run_agents_with_timeout()","text":"<p>Runs multiple agents concurrently with timeout limits.</p>"},{"location":"swarms/structs/various_execution_methods/#arguments_3","title":"Arguments","text":"Parameter Type Required Default Description agents List[AgentType] Yes - List of Agent instances task str Yes - Task string to execute timeout float Yes - Timeout in seconds for each agent batch_size int No CPU count Number of agents to run in parallel max_workers int No CPU count * 2 Maximum number of threads"},{"location":"swarms/structs/various_execution_methods/#usage-examples","title":"Usage Examples","text":"<pre><code>from swarms.structs.agent import Agent\nfrom swarms.structs.multi_agent_exec import (\n    run_agents_concurrently,\n    run_agents_with_timeout,\n    run_agents_with_different_tasks\n)\n\n# Initialize agents using only the built-in model_name parameter\nagents = [\n    Agent(\n        agent_name=f\"Analysis-Agent-{i}\",\n        system_prompt=\"You are a financial analysis expert\",\n        model_name=\"gpt-4o-mini\",\n        max_loops=1\n    )\n    for i in range(5)\n]\n\n# Basic concurrent execution\ntask = \"Analyze the impact of rising interest rates on tech stocks\"\noutputs = run_agents_concurrently(agents, task)\n\n# Running with timeout\noutputs_with_timeout = run_agents_with_timeout(\n    agents=agents,\n    task=task,\n    timeout=30.0,\n    batch_size=2\n)\n\n# Running different tasks\ntask_pairs = [\n    (agents[0], \"Analyze tech stocks\"),\n    (agents[1], \"Analyze energy stocks\"),\n    (agents[2], \"Analyze retail stocks\")\n]\ndifferent_outputs = run_agents_with_different_tasks(task_pairs)\n</code></pre>"},{"location":"swarms/structs/various_execution_methods/#resource-monitoring","title":"Resource Monitoring","text":""},{"location":"swarms/structs/various_execution_methods/#resourcemetrics","title":"ResourceMetrics","text":"<p>A dataclass for system resource metrics.</p>"},{"location":"swarms/structs/various_execution_methods/#properties","title":"Properties","text":"Property Type Description cpu_percent float Current CPU usage percentage memory_percent float Current memory usage percentage active_threads int Number of active threads"},{"location":"swarms/structs/various_execution_methods/#run_agents_with_resource_monitoring","title":"run_agents_with_resource_monitoring()","text":"<p>Runs agents with system resource monitoring and adaptive batch sizing.</p>"},{"location":"swarms/structs/various_execution_methods/#arguments_4","title":"Arguments","text":"Parameter Type Required Default Description agents List[AgentType] Yes - List of Agent instances task str Yes - Task string to execute cpu_threshold float No 90.0 Max CPU usage percentage memory_threshold float No 90.0 Max memory usage percentage check_interval float No 1.0 Resource check interval in seconds"},{"location":"swarms/structs/various_execution_methods/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>All functions are decorated with <code>@profile_func</code> for performance monitoring</li> <li>Default batch sizes and worker counts are optimized based on CPU cores</li> <li>Resource monitoring helps prevent system overload</li> <li>Using <code>uvloop</code> provides better performance than standard <code>asyncio</code></li> </ul>"},{"location":"swarms/structs/various_execution_methods/#error-handling","title":"Error Handling","text":"<ul> <li>Functions handle asyncio event loop creation/retrieval</li> <li>Timeout mechanism prevents infinite waiting</li> <li>Resource monitoring allows for adaptive performance adjustment</li> </ul>"},{"location":"swarms/structs/yaml_model/","title":"YamlModel: A Pydantic Model for YAML Data","text":"<p>The <code>YamlModel</code> class, derived from <code>BaseModel</code> in Pydantic, offers a convenient way to work with YAML data in your Python applications. It provides methods for serialization (converting to YAML), deserialization (creating an instance from YAML), and schema generation. This documentation will delve into the functionalities of <code>YamlModel</code> and guide you through its usage with illustrative examples.</p>"},{"location":"swarms/structs/yaml_model/#purpose-and-functionality","title":"Purpose and Functionality","text":"<p>The primary purpose of <code>YamlModel</code> is to streamline the interaction between your Python code and YAML data. It accomplishes this by:</p> <ul> <li>Serialization: Transforming a <code>YamlModel</code> instance into a YAML string representation using the <code>to_yaml()</code> method.</li> <li>Deserialization: Constructing a <code>YamlModel</code> instance from a provided YAML string using the <code>from_yaml()</code> class method.</li> <li>JSON to YAML Conversion: Facilitating the conversion of JSON data to YAML format through the <code>json_to_yaml()</code> static method.</li> <li>Saving to YAML File: Enabling the storage of <code>YamlModel</code> instances as YAML files using the <code>save_to_yaml()</code> method.</li> <li>(Future Implementation) Schema Generation: The <code>create_yaml_schema()</code> class method (not yet implemented but included for future reference) will generate a YAML schema that reflects the structure of the <code>YamlModel</code> class and its fields.</li> </ul>"},{"location":"swarms/structs/yaml_model/#class-definition-and-arguments","title":"Class Definition and Arguments","text":"<p>The <code>YamlModel</code> class inherits from Pydantic's <code>BaseModel</code> class. You can define your custom YAML models by creating subclasses of <code>YamlModel</code> and specifying your data fields within the class definition. Here's the breakdown of the <code>YamlModel</code> class and its methods:</p> <pre><code>class YamlModel(BaseModel):\n    \"\"\"\n    A Pydantic model class for working with YAML data.\n    \"\"\"\n\n    def to_yaml(self):\n        \"\"\"\n        Serialize the Pydantic model instance to a YAML string.\n        \"\"\"\n        return yaml.safe_dump(self.dict(), sort_keys=False)\n\n    @classmethod\n    def from_yaml(cls, yaml_str: str):\n        \"\"\"\n        Create an instance of the class from a YAML string.\n\n        Args:\n            yaml_str (str): The YAML string to parse.\n\n        Returns:\n            cls: An instance of the class with attributes populated from the YAML data.\n                 Returns None if there was an error loading the YAML data.\n        \"\"\"\n        # ...\n\n    @staticmethod\n    def json_to_yaml(json_str: str):\n        \"\"\"\n        Convert a JSON string to a YAML string.\n        \"\"\"\n        # ...\n\n    def save_to_yaml(self, filename: str):\n        \"\"\"\n        Save the Pydantic model instance as a YAML file.\n        \"\"\"\n        # ...\n\n    # TODO: Implement a method to create a YAML schema from the model fields\n    # @classmethod\n    # def create_yaml_schema(cls):\n    #     # ...\n    \"\"\"\n</code></pre> <p>Arguments:</p> <ul> <li><code>self</code> (implicit): Refers to the current instance of the <code>YamlModel</code> class.</li> <li><code>yaml_str</code> (str): The YAML string used for deserialization in the <code>from_yaml()</code> method.</li> <li><code>json_str</code> (str): The JSON string used for conversion to YAML in the <code>json_to_yaml()</code> method.</li> <li><code>filename</code> (str): The filename (including path) for saving the YAML model instance in the <code>save_to_yaml()</code> method.</li> </ul>"},{"location":"swarms/structs/yaml_model/#detailed-method-descriptions","title":"Detailed Method Descriptions","text":"<p>1. to_yaml()</p> <p>This method transforms an instance of the <code>YamlModel</code> class into a YAML string representation. It utilizes the <code>yaml.safe_dump()</code> function from the <code>PyYAML</code> library to ensure secure YAML data generation. The <code>sort_keys=False</code> argument guarantees that the order of keys in the resulting YAML string remains consistent with the order of fields defined in your <code>YamlModel</code> subclass.</p> <p>Example:</p> <pre><code>class User(YamlModel):\n    name: str\n    age: int\n    is_active: bool\n\nuser = User(name=\"Bob\", age=30, is_active=True)\nyaml_string = user.to_yaml()\nprint(yaml_string)\n</code></pre> <p>This code will output a YAML string representation of the <code>user</code> object, resembling:</p> <pre><code>name: Bob\nage: 30\nis_active: true\n</code></pre>"},{"location":"swarms/structs/yaml_model/#detailed-method-descriptions_1","title":"Detailed Method Descriptions","text":"<p>2. from_yaml(cls, yaml_str) (Class Method)</p> <p>The <code>from_yaml()</code> class method is responsible for constructing a <code>YamlModel</code> instance from a provided YAML string. </p> <ul> <li> <p>Arguments:</p> <ul> <li><code>cls</code> (class): The class representing the desired YAML model (the subclass of <code>YamlModel</code> that matches the structure of the YAML data).</li> <li><code>yaml_str</code> (str): The YAML string containing the data to be parsed and used for creating the model instance.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>cls</code> (instance): An instance of the specified class (<code>cls</code>) populated with the data extracted from the YAML string. If an error occurs during parsing, it returns <code>None</code>.</li> </ul> </li> <li> <p>Error Handling:</p> </li> </ul> <p>The <code>from_yaml()</code> method employs <code>yaml.safe_load()</code> for secure YAML parsing. It incorporates a <code>try-except</code> block to handle potential <code>ValueError</code> exceptions that might arise during the parsing process. If an error is encountered, it logs the error message and returns <code>None</code>.</p> <p>Example:</p> <pre><code>class User(YamlModel):\n    name: str\n    age: int\n    is_active: bool\n\nyaml_string = \"\"\"\nname: Alice\nage: 25\nis_active: false\n\"\"\"\n\nuser = User.from_yaml(yaml_string)\nprint(user.name)  # Output: Alice\n</code></pre> <p>3. json_to_yaml(json_str) (Static Method)</p> <p>This static method in the <code>YamlModel</code> class serves the purpose of converting a JSON string into a YAML string representation.</p> <ul> <li> <p>Arguments:</p> <ul> <li><code>json_str</code> (str): The JSON string that needs to be converted to YAML format.</li> </ul> </li> <li> <p>Returns:</p> <ul> <li><code>str</code>: The converted YAML string representation of the provided JSON data.</li> </ul> </li> <li> <p>Functionality:</p> </li> </ul> <p>The <code>json_to_yaml()</code> method leverages the <code>json.loads()</code> function to parse the JSON string into a Python dictionary. Subsequently, it utilizes <code>yaml.dump()</code> to generate the corresponding YAML string representation from the parsed dictionary.</p> <p>Example:</p> <pre><code>json_string = '{\"name\": \"Charlie\", \"age\": 42, \"is_active\": true}'\nyaml_string = YamlModel.json_to_yaml(json_string)\nprint(yaml_string)\n</code></pre> <p>This code snippet will convert the JSON data to a YAML string, likely resembling:</p> <pre><code>name: Charlie\nage: 42\nis_active: true\n</code></pre> <p>4. save_to_yaml(self, filename)</p> <p>The <code>save_to_yaml()</code> method facilitates the storage of a <code>YamlModel</code> instance as a YAML file.</p> <ul> <li> <p>Arguments:</p> <ul> <li><code>self</code> (implicit): Refers to the current instance of the <code>YamlModel</code> class that you intend to save.</li> <li><code>filename</code> (str): The desired filename (including path) for the YAML file.</li> </ul> </li> <li> <p>Functionality:</p> </li> </ul> <p>The <code>save_to_yaml()</code> method employs the previously explained <code>to_yaml()</code> method to generate a YAML string representation of the <code>self</code> instance. It then opens the specified file in write mode (<code>\"w\"</code>) and writes the YAML string content to the file.</p> <p>Example:</p> <pre><code>class Employee(YamlModel):\n    name: str\n    department: str\n    salary: float\n\nemployee = Employee(name=\"David\", department=\"Engineering\", salary=95000.00)\nemployee.save_to_yaml(\"employee.yaml\")\n</code></pre> <p>This code will create a YAML file named \"employee.yaml\" containing the serialized representation of the <code>employee</code> object.</p>"},{"location":"swarms/structs/yaml_model/#more-usage-examples","title":"More Usage Examples ++","text":"<pre><code>class User(YamlModel):\n    name: str\n    age: int\n    is_active: bool\n\n# Create an instance of the User model\nuser = User(name=\"Alice\", age=30, is_active=True)\n\n# Serialize the User instance to YAML and print it\nyaml_string = user.to_yaml()\nprint(yaml_string)\n</code></pre> <p>This code snippet demonstrates the creation of a <code>User</code> instance and its subsequent serialization to a YAML string using the <code>to_yaml()</code> method. The printed output will likely resemble:</p> <pre><code>name: Alice\nage: 30\nis_active: true\n</code></pre>"},{"location":"swarms/structs/yaml_model/#converting-json-to-yaml","title":"Converting JSON to YAML","text":"<pre><code># Convert JSON string to YAML and print\njson_string = '{\"name\": \"Bob\", \"age\": 25, \"is_active\": false}'\nyaml_string = YamlModel.json_to_yaml(json_string)\nprint(yaml_string)\n</code></pre> <p>This example showcases the conversion of a JSON string containing user data into a YAML string representation using the <code>json_to_yaml()</code> static method. The resulting YAML string might look like:</p> <pre><code>name: Bob\nage: 25\nis_active: false\n</code></pre>"},{"location":"swarms/structs/yaml_model/#saving-user-instance-to-yaml-file","title":"Saving User Instance to YAML File","text":"<pre><code># Save the User instance to a YAML file\nuser.save_to_yaml(\"user.yaml\")\n</code></pre> <p>This code demonstrates the utilization of the <code>save_to_yaml()</code> method to store the <code>user</code> instance as a YAML file named \"user.yaml\". The contents of the file will mirror the serialized YAML string representation of the user object.</p>"},{"location":"swarms/structs/yaml_model/#additional-considerations","title":"Additional Considerations","text":"<ul> <li>Ensure you have the <code>PyYAML</code> library installed (<code>pip install pyyaml</code>) to leverage the YAML parsing and serialization functionalities within <code>YamlModel</code>.</li> <li>Remember that the <code>create_yaml_schema()</code> method is not yet implemented but serves as a placeholder for future enhancements.</li> <li>For complex data structures within your YAML models, consider leveraging Pydantic's data validation and nested model capabilities for robust data management.</li> </ul>"},{"location":"swarms/structs/yaml_model/#conclusion","title":"Conclusion","text":"<p>The <code>YamlModel</code> class in Pydantic offers a streamlined approach to working with YAML data in your Python projects. By employing the provided methods (<code>to_yaml()</code>, <code>from_yaml()</code>, <code>json_to_yaml()</code>, and <code>save_to_yaml()</code>), you can efficiently convert between Python objects and YAML representations, facilitating data persistence and exchange. This comprehensive documentation empowers you to effectively utilize <code>YamlModel</code> for your YAML data processing requirements.</p>"},{"location":"swarms/structs/board_of_directors/","title":"Board of Directors - Multi-Agent Architecture","text":"<p>The Board of Directors is a sophisticated multi-agent architecture that implements collective decision-making through democratic processes, voting mechanisms, and role-based leadership. This architecture provides an alternative to single-director patterns by enabling collaborative intelligence through structured governance.</p>"},{"location":"swarms/structs/board_of_directors/#overview","title":"\ud83c\udfdb\ufe0f Overview","text":"<p>The Board of Directors architecture follows a democratic workflow pattern:</p> <ol> <li>Task Reception: User provides a task to the swarm</li> <li>Board Meeting: Board of Directors convenes to discuss and create a plan</li> <li>Voting &amp; Consensus: Board members vote and reach consensus on task distribution</li> <li>Order Distribution: Board distributes orders to specialized worker agents</li> <li>Execution: Individual agents execute their assigned tasks</li> <li>Feedback Loop: Board evaluates results and issues new orders if needed (up to <code>max_loops</code>)</li> <li>Context Preservation: All conversation history and context is maintained throughout the process</li> </ol>"},{"location":"swarms/structs/board_of_directors/#architecture-components","title":"\ud83c\udfd7\ufe0f Architecture Components","text":""},{"location":"swarms/structs/board_of_directors/#core-components","title":"Core Components","text":"Component Description Purpose BoardOfDirectorsSwarm Main orchestration class Manages the entire board workflow and agent coordination Board Member Roles Role definitions and hierarchy Defines responsibilities and voting weights for each board member Decision Making Process Voting and consensus mechanisms Implements democratic decision-making with weighted voting Workflow Management Process orchestration Manages the complete lifecycle from task reception to final delivery"},{"location":"swarms/structs/board_of_directors/#architecture-diagram","title":"Architecture Diagram","text":"<pre><code>graph TD\n    A[User Task] --&gt; B[Board of Directors]\n    B --&gt; C[Board Meeting &amp; Discussion]\n    C --&gt; D[Voting &amp; Consensus]\n    D --&gt; E[Create Plan &amp; Orders]\n    E --&gt; F[Distribute to Agents]\n    F --&gt; G[Agent 1]\n    F --&gt; H[Agent 2]\n    F --&gt; I[Agent N]\n    G --&gt; J[Execute Task]\n    H --&gt; J\n    I --&gt; J\n    J --&gt; K[Report Results]\n    K --&gt; L[Board Evaluation]\n    L --&gt; M{More Loops?}\n    M --&gt;|Yes| C\n    M --&gt;|No| N[Final Output]</code></pre>"},{"location":"swarms/structs/board_of_directors/#key-features","title":"\ud83c\udfaf Key Features","text":""},{"location":"swarms/structs/board_of_directors/#democratic-decision-making","title":"Democratic Decision Making","text":"<ul> <li>Collective Intelligence: Multiple perspectives through board member collaboration</li> <li>Weighted Voting: Different voting weights based on roles and expertise</li> <li>Consensus Building: Support for both majority voting and consensus approaches</li> <li>Conflict Resolution: Structured processes for handling disagreements</li> </ul>"},{"location":"swarms/structs/board_of_directors/#role-based-leadership","title":"Role-Based Leadership","text":"<ul> <li>Hierarchical Structure: Clear roles with defined responsibilities</li> <li>Specialized Expertise: Each board member brings unique domain knowledge</li> <li>Authority Distribution: Balanced power distribution across roles</li> <li>Accountability: Clear lines of responsibility and decision ownership</li> </ul>"},{"location":"swarms/structs/board_of_directors/#operational-excellence","title":"Operational Excellence","text":"<ul> <li>Iterative Refinement: Multiple feedback loops for improved results</li> <li>Context Preservation: Full conversation history maintained</li> <li>Flexible Output Formats: Support for various output types (dict, str, list)</li> <li>Comprehensive Logging: Detailed logging for debugging and monitoring</li> </ul>"},{"location":"swarms/structs/board_of_directors/#board-member-roles","title":"\ud83d\udc65 Board Member Roles","text":"<p>The Board of Directors supports various roles with different responsibilities and voting weights:</p> Role Description Voting Weight Responsibilities <code>CHAIRMAN</code> Primary leader responsible for board meetings and final decisions 1.5 Leading meetings, facilitating consensus, making final decisions <code>VICE_CHAIRMAN</code> Secondary leader who supports the chairman 1.2 Supporting chairman, coordinating operations <code>SECRETARY</code> Responsible for documentation and meeting minutes 1.0 Documenting meetings, maintaining records <code>TREASURER</code> Manages financial aspects and resource allocation 1.0 Financial oversight, resource management <code>EXECUTIVE_DIRECTOR</code> Executive-level board member with operational authority 1.5 Strategic planning, operational oversight <code>MEMBER</code> General board member with specific expertise 1.0 Contributing expertise, participating in decisions"},{"location":"swarms/structs/board_of_directors/#quick-start","title":"\ud83d\ude80 Quick Start","text":""},{"location":"swarms/structs/board_of_directors/#basic-setup","title":"Basic Setup","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.board_of_directors_swarm import (\n    BoardOfDirectorsSwarm,\n    BoardMember,\n    BoardMemberRole\n)\nfrom swarms.config.board_config import enable_board_feature\n\n# Enable the Board of Directors feature\nenable_board_feature()\n\n# Create board members with specific roles\nchairman = Agent(\n    agent_name=\"Chairman\",\n    agent_description=\"Chairman of the Board responsible for leading meetings\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Chairman of the Board...\"\n)\n\nvice_chairman = Agent(\n    agent_name=\"Vice-Chairman\",\n    agent_description=\"Vice Chairman who supports the Chairman\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Vice Chairman...\"\n)\n\n# Create BoardMember objects with roles and expertise\nboard_members = [\n    BoardMember(chairman, BoardMemberRole.CHAIRMAN, 1.5, [\"leadership\", \"strategy\"]),\n    BoardMember(vice_chairman, BoardMemberRole.VICE_CHAIRMAN, 1.2, [\"operations\", \"coordination\"]),\n]\n\n# Create worker agents\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research and analysis\",\n    model_name=\"gpt-4o\",\n)\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis and valuation\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the Board of Directors swarm\nboard_swarm = BoardOfDirectorsSwarm(\n    name=\"Executive_Board_Swarm\",\n    description=\"Executive board with specialized roles for strategic decision-making\",\n    board_members=board_members,\n    agents=[research_agent, financial_agent],\n    max_loops=2,\n    verbose=True,\n    decision_threshold=0.6,\n    enable_voting=True,\n    enable_consensus=True,\n)\n\n# Execute a complex task with democratic decision-making\nresult = board_swarm.run(task=\"Analyze the market potential for Tesla (TSLA) stock\")\nprint(result)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/#use-cases","title":"\ud83d\udccb Use Cases","text":""},{"location":"swarms/structs/board_of_directors/#corporate-governance","title":"Corporate Governance","text":"<ul> <li>Strategic Planning: Long-term business strategy development</li> <li>Risk Management: Comprehensive risk assessment and mitigation</li> <li>Resource Allocation: Optimal distribution of company resources</li> <li>Performance Oversight: Monitoring and evaluating organizational performance</li> </ul>"},{"location":"swarms/structs/board_of_directors/#financial-analysis","title":"Financial Analysis","text":"<ul> <li>Portfolio Management: Investment portfolio optimization and rebalancing</li> <li>Market Analysis: Comprehensive market research and trend analysis</li> <li>Risk Assessment: Financial risk evaluation and management</li> <li>Compliance Monitoring: Regulatory compliance and audit preparation</li> </ul>"},{"location":"swarms/structs/board_of_directors/#research-development","title":"Research &amp; Development","text":"<ul> <li>Technology Assessment: Evaluation of emerging technologies</li> <li>Product Development: Strategic product planning and development</li> <li>Innovation Management: Managing innovation pipelines and initiatives</li> <li>Quality Assurance: Ensuring high standards across development processes</li> </ul>"},{"location":"swarms/structs/board_of_directors/#project-management","title":"Project Management","text":"<ul> <li>Complex Project Planning: Multi-faceted project strategy development</li> <li>Resource Optimization: Efficient allocation of project resources</li> <li>Stakeholder Management: Coordinating diverse stakeholder interests</li> <li>Risk Mitigation: Identifying and addressing project risks</li> </ul>"},{"location":"swarms/structs/board_of_directors/#configuration","title":"\u2699\ufe0f Configuration","text":""},{"location":"swarms/structs/board_of_directors/#decision-thresholds","title":"Decision Thresholds","text":"<ul> <li>Default Threshold: 60% consensus required for decisions</li> <li>Configurable: Adjustable based on organizational needs</li> <li>Role-Based: Different thresholds for different types of decisions</li> <li>Fallback Mechanisms: Chairman can make final decisions when consensus fails</li> </ul>"},{"location":"swarms/structs/board_of_directors/#voting-mechanisms","title":"Voting Mechanisms","text":"<ul> <li>Weighted Voting: Different voting weights based on roles</li> <li>Consensus Building: Support for both majority and consensus approaches</li> <li>Conflict Resolution: Structured processes for handling disagreements</li> <li>Transparency: Clear visibility into decision-making processes</li> </ul>"},{"location":"swarms/structs/board_of_directors/#operational-settings","title":"Operational Settings","text":"<ul> <li>Meeting Duration: Configurable board meeting time limits</li> <li>Participation Requirements: Minimum participation rates for valid decisions</li> <li>Feedback Loops: Multiple iterations for complex problem-solving</li> <li>Documentation: Comprehensive record-keeping of all decisions</li> </ul>"},{"location":"swarms/structs/board_of_directors/#advanced-features","title":"\ud83d\udd27 Advanced Features","text":""},{"location":"swarms/structs/board_of_directors/#custom-board-templates","title":"Custom Board Templates","text":"<p>Pre-configured board templates for common use cases:</p> <pre><code>from swarms.config.board_config import get_default_board_template\n\n# Get a financial analysis board template\nfinancial_board = get_default_board_template(\"financial_analysis\")\n\n# Get a strategic planning board template\nstrategic_board = get_default_board_template(\"strategic_planning\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/#dynamic-role-assignment","title":"Dynamic Role Assignment","text":"<p>Automatically assign roles based on task requirements:</p> <pre><code># Board members are automatically assigned roles based on expertise\nboard_swarm = BoardOfDirectorsSwarm(\n    board_members=board_members,\n    auto_assign_roles=True,\n    role_mapping={\n        \"financial_analysis\": [\"Treasurer\", \"Financial_Member\"],\n        \"strategic_planning\": [\"Chairman\", \"Executive_Director\"]\n    }\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/#consensus-optimization","title":"Consensus Optimization","text":"<p>Advanced consensus-building mechanisms:</p> <pre><code># Enable advanced consensus features\nboard_swarm = BoardOfDirectorsSwarm(\n    enable_consensus=True,\n    consensus_timeout=300,  # 5 minutes\n    min_participation_rate=0.5,  # 50% minimum participation\n    auto_fallback_to_chairman=True\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/#performance-monitoring","title":"\ud83d\udcca Performance Monitoring","text":""},{"location":"swarms/structs/board_of_directors/#decision-metrics","title":"Decision Metrics","text":"<ul> <li>Consensus Rate: Percentage of decisions reached by consensus</li> <li>Voting Participation: Board member participation rates</li> <li>Decision Quality: Assessment of decision outcomes</li> <li>Execution Efficiency: Time from decision to implementation</li> </ul>"},{"location":"swarms/structs/board_of_directors/#operational-metrics","title":"Operational Metrics","text":"<ul> <li>Meeting Duration: Average board meeting length</li> <li>Agent Utilization: How effectively worker agents are utilized</li> <li>Feedback Loop Efficiency: Speed of iterative improvements</li> <li>Resource Optimization: Efficient use of computational resources</li> </ul>"},{"location":"swarms/structs/board_of_directors/#troubleshooting","title":"\ud83d\udee0\ufe0f Troubleshooting","text":""},{"location":"swarms/structs/board_of_directors/#common-issues","title":"Common Issues","text":"<ol> <li>Consensus Failures: Lower decision threshold or increase timeout</li> <li>Role Conflicts: Ensure clear role definitions and responsibilities</li> <li>Agent Coordination: Verify agent communication and task distribution</li> <li>Performance Issues: Monitor resource usage and optimize configurations</li> </ol>"},{"location":"swarms/structs/board_of_directors/#best-practices","title":"Best Practices","text":"<ol> <li>Role Clarity: Define clear responsibilities for each board member</li> <li>Expertise Alignment: Match board member expertise to task requirements</li> <li>Consensus Building: Allow adequate time for discussion and consensus</li> <li>Documentation: Maintain comprehensive records of all decisions</li> <li>Continuous Improvement: Learn from each execution cycle</li> </ol>"},{"location":"swarms/structs/board_of_directors/#documentation-sections","title":"\ud83d\udcda Documentation Sections","text":"<ul> <li>BoardOfDirectorsSwarm: Complete API reference and implementation details</li> <li>Board Member Roles: Detailed role definitions and responsibilities</li> <li>Decision Making Process: Voting mechanisms and consensus building</li> <li>Workflow Management: Complete process orchestration guide</li> </ul>"},{"location":"swarms/structs/board_of_directors/#success-criteria","title":"\ud83c\udfaf Success Criteria","text":"<p>A successful Board of Directors implementation should demonstrate:</p> <ul> <li>\u2705 Democratic Decision Making: All board members contribute to decisions</li> <li>\u2705 Consensus Achievement: Decisions reached through collaborative processes</li> <li>\u2705 Role Effectiveness: Each board member fulfills their responsibilities</li> <li>\u2705 Agent Coordination: Worker agents execute tasks efficiently</li> <li>\u2705 Quality Output: High-quality results through collective intelligence</li> <li>\u2705 Process Transparency: Clear visibility into decision-making processes</li> </ul> <p>The Board of Directors architecture represents a sophisticated approach to multi-agent collaboration, enabling organizations to leverage collective intelligence through structured governance and democratic decision-making processes. </p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/","title":"Board of Directors Decision Making","text":"<p>The Board of Directors implements sophisticated decision-making processes that combine voting mechanisms, consensus building, and hierarchical authority to ensure effective and fair decision-making.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-making-framework","title":"Decision-Making Framework","text":"<pre><code>graph TD\n    A[Task/Issue Presented] --&gt; B[Initial Assessment]\n    B --&gt; C[Expertise Assignment]\n    C --&gt; D[Individual Analysis]\n    D --&gt; E[Group Discussion]\n    E --&gt; F[Proposal Development]\n    F --&gt; G[Voting Process]\n    G --&gt; H{Consensus Reached?}\n    H --&gt;|Yes| I[Decision Approved]\n    H --&gt;|No| J[Reconciliation Process]\n    J --&gt; K[Proposal Refinement]\n    K --&gt; G\n    I --&gt; L[Implementation Planning]\n    L --&gt; M[Execution]\n\n    style A fill:#e3f2fd\n    style I fill:#c8e6c9\n    style H fill:#fff3e0</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#voting-mechanisms","title":"Voting Mechanisms","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#weighted-voting-system","title":"Weighted Voting System","text":"<pre><code>graph LR\n    subgraph \"Voting Weights\"\n        A[Chairman: 1.5]\n        B[Executive Director: 1.5]\n        C[Vice Chairman: 1.2]\n        D[Secretary: 1.0]\n        E[Treasurer: 1.0]\n        F[Member: 1.0]\n    end\n\n    subgraph \"Voting Process\"\n        G[Individual Votes]\n        H[Weight Calculation]\n        I[Threshold Check]\n        J[Decision Outcome]\n    end\n\n    A --&gt; G\n    B --&gt; G\n    C --&gt; G\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H\n    H --&gt; I\n    I --&gt; J</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#voting-power-distribution","title":"Voting Power Distribution","text":"<pre><code>pie title Total Voting Power Distribution\n    \"Chairman\" : 1.5\n    \"Executive Director\" : 1.5\n    \"Vice Chairman\" : 1.2\n    \"Secretary\" : 1.0\n    \"Treasurer\" : 1.0\n    \"Member\" : 1.0</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-thresholds","title":"Decision Thresholds","text":"<pre><code>graph TD\n    A[Vote Calculation] --&gt; B{Threshold Check}\n    B --&gt;|Below 60%| C[Rejection]\n    B --&gt;|60-75%| D[Conditional Approval]\n    B --&gt;|Above 75%| E[Strong Approval]\n    B --&gt;|100%| F[Unanimous Approval]\n\n    C --&gt; G[Reconciliation Required]\n    D --&gt; H[Implementation with Conditions]\n    E --&gt; I[Full Implementation]\n    F --&gt; J[Immediate Implementation]\n\n    style C fill:#ffcdd2\n    style D fill:#fff9c4\n    style E fill:#c8e6c9\n    style F fill:#4caf50</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#consensus-building-process","title":"Consensus Building Process","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#consensus-development-flow","title":"Consensus Development Flow","text":"<pre><code>flowchart TD\n    A[Initial Proposal] --&gt; B[Individual Review]\n    B --&gt; C[Expert Analysis]\n    C --&gt; D[Stakeholder Input]\n    D --&gt; E[Proposal Refinement]\n    E --&gt; F[Group Discussion]\n    F --&gt; G[Alternative Proposals]\n    G --&gt; H[Compromise Development]\n    H --&gt; I[Consensus Check]\n    I --&gt;|No Consensus| J[Mediation Process]\n    J --&gt; K[Proposal Modification]\n    K --&gt; I\n    I --&gt;|Consensus| L[Final Decision]\n\n    style A fill:#e3f2fd\n    style L fill:#c8e6c9\n    style I fill:#fff3e0</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#consensus-strategies","title":"Consensus Strategies","text":"<pre><code>graph TD\n    A[Consensus Building] --&gt; B[Compromise Solutions]\n    A --&gt; C[Expert Mediation]\n    A --&gt; D[Alternative Approaches]\n    A --&gt; E[Time Extension]\n    A --&gt; F[Stakeholder Consultation]\n\n    B --&gt; G[Win-Win Solutions]\n    B --&gt; H[Partial Agreement]\n    B --&gt; I[Phased Implementation]\n\n    C --&gt; J[Neutral Mediator]\n    C --&gt; K[Expert Opinion]\n    C --&gt; L[Third-Party Assessment]\n\n    D --&gt; M[Multiple Options]\n    D --&gt; N[Pilot Programs]\n    D --&gt; O[Experimental Approaches]\n\n    E --&gt; P[Additional Analysis]\n    E --&gt; Q[Stakeholder Engagement]\n    E --&gt; R[Market Research]\n\n    F --&gt; S[External Input]\n    F --&gt; T[Industry Consultation]\n    F --&gt; U[Expert Panels]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-types-and-processes","title":"Decision Types and Processes","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#strategic-decisions","title":"Strategic Decisions","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant ExecDir\n    participant Board\n    participant Stakeholders\n\n    Chairman-&gt;&gt;ExecDir: Request Strategic Analysis\n    ExecDir-&gt;&gt;Board: Present Strategic Options\n    Board-&gt;&gt;Stakeholders: Consult Stakeholders\n    Stakeholders-&gt;&gt;Board: Provide Input\n    Board-&gt;&gt;ExecDir: Refine Strategic Plan\n    ExecDir-&gt;&gt;Chairman: Present Final Recommendations\n    Chairman-&gt;&gt;Board: Call for Strategic Vote\n    Board-&gt;&gt;Chairman: Cast Weighted Votes\n    Chairman-&gt;&gt;Board: Announce Strategic Decision</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#operational-decisions","title":"Operational Decisions","text":"<pre><code>flowchart TD\n    A[Operational Issue] --&gt; B[Vice Chairman Assessment]\n    B --&gt; C[Resource Analysis]\n    C --&gt; D[Implementation Planning]\n    D --&gt; E[Board Review]\n    E --&gt; F[Operational Vote]\n    F --&gt; G{Approval?}\n    G --&gt;|Yes| H[Implementation]\n    G --&gt;|No| I[Plan Revision]\n    I --&gt; E\n    H --&gt; J[Monitoring]\n    J --&gt; K[Performance Review]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#financial-decisions","title":"Financial Decisions","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant Treasurer\n    participant Board\n    participant Financial\n\n    Chairman-&gt;&gt;Treasurer: Financial Request\n    Treasurer-&gt;&gt;Financial: Conduct Analysis\n    Financial-&gt;&gt;Treasurer: Financial Assessment\n    Treasurer-&gt;&gt;Board: Present Financial Options\n    Board-&gt;&gt;Treasurer: Request Clarification\n    Treasurer-&gt;&gt;Board: Provide Additional Data\n    Board-&gt;&gt;Chairman: Financial Recommendations\n    Chairman-&gt;&gt;Board: Financial Decision Vote\n    Board-&gt;&gt;Chairman: Cast Financial Votes\n    Chairman-&gt;&gt;Treasurer: Approve Financial Plan</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#conflict-resolution","title":"Conflict Resolution","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#dispute-resolution-process","title":"Dispute Resolution Process","text":"<pre><code>graph TD\n    A[Conflict Identified] --&gt; B[Initial Assessment]\n    B --&gt; C[Stakeholder Identification]\n    C --&gt; D[Root Cause Analysis]\n    D --&gt; E[Mediation Attempt]\n    E --&gt; F{Resolution?}\n    F --&gt;|Yes| G[Agreement Reached]\n    F --&gt;|No| H[Escalation Process]\n    H --&gt; I[Chairman Intervention]\n    I --&gt; J[Expert Consultation]\n    J --&gt; K[Final Resolution]\n    G --&gt; L[Implementation]\n    K --&gt; L\n\n    style A fill:#ffcdd2\n    style G fill:#c8e6c9\n    style K fill:#c8e6c9</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#mediation-strategies","title":"Mediation Strategies","text":"<pre><code>graph LR\n    subgraph \"Mediation Approaches\"\n        A[Facilitated Discussion]\n        B[Expert Opinion]\n        C[Third-Party Mediation]\n        D[Stakeholder Consultation]\n    end\n\n    subgraph \"Resolution Methods\"\n        E[Compromise Solutions]\n        F[Alternative Approaches]\n        G[Phased Implementation]\n        H[Pilot Programs]\n    end\n\n    A --&gt; E\n    B --&gt; F\n    C --&gt; G\n    D --&gt; H</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-quality-assurance","title":"Decision Quality Assurance","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#quality-control-framework","title":"Quality Control Framework","text":"<pre><code>graph TD\n    A[Decision Made] --&gt; B[Quality Assessment]\n    B --&gt; C[Compliance Check]\n    C --&gt; D[Risk Evaluation]\n    D --&gt; E[Stakeholder Impact]\n    E --&gt; F[Implementation Feasibility]\n    F --&gt; G[Final Approval]\n\n    subgraph \"Quality Criteria\"\n        H[Strategic Alignment]\n        I[Financial Viability]\n        J[Operational Feasibility]\n        K[Risk Acceptability]\n        L[Stakeholder Support]\n    end\n\n    B --&gt; H\n    C --&gt; I\n    D --&gt; J\n    E --&gt; K\n    F --&gt; L</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-review-process","title":"Decision Review Process","text":"<pre><code>flowchart TD\n    A[Decision Implementation] --&gt; B[Progress Monitoring]\n    B --&gt; C[Performance Assessment]\n    C --&gt; D[Outcome Evaluation]\n    D --&gt; E{Success Criteria Met?}\n    E --&gt;|Yes| F[Success Confirmed]\n    E --&gt;|No| G[Root Cause Analysis]\n    G --&gt; H[Corrective Actions]\n    H --&gt; I[Plan Adjustment]\n    I --&gt; B\n\n    F --&gt; J[Lessons Learned]\n    J --&gt; K[Process Improvement]\n    K --&gt; L[Knowledge Documentation]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-communication","title":"Decision Communication","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#communication-flow","title":"Communication Flow","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant Secretary\n    participant Board\n    participant Agents\n    participant Stakeholders\n\n    Chairman-&gt;&gt;Secretary: Record Decision\n    Secretary-&gt;&gt;Board: Distribute Decision Summary\n    Board-&gt;&gt;Agents: Communicate Implementation Plan\n    Agents-&gt;&gt;Board: Confirm Understanding\n    Board-&gt;&gt;Stakeholders: Announce Decision\n    Stakeholders-&gt;&gt;Board: Provide Feedback\n    Board-&gt;&gt;Chairman: Report Stakeholder Response\n    Chairman-&gt;&gt;Secretary: Update Documentation</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-documentation","title":"Decision Documentation","text":"<pre><code>graph TD\n    A[Decision Made] --&gt; B[Documentation Creation]\n    B --&gt; C[Rationale Recording]\n    C --&gt; D[Implementation Plan]\n    D --&gt; E[Timeline Definition]\n    E --&gt; F[Resource Allocation]\n    F --&gt; G[Success Metrics]\n    G --&gt; H[Review Schedule]\n\n    subgraph \"Documentation Elements\"\n        I[Decision Summary]\n        J[Voting Results]\n        K[Implementation Steps]\n        L[Risk Mitigation]\n        M[Success Criteria]\n    end\n\n    B --&gt; I\n    C --&gt; J\n    D --&gt; K\n    E --&gt; L\n    F --&gt; M</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#performance-metrics","title":"Performance Metrics","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-quality-metrics","title":"Decision Quality Metrics","text":"<pre><code>graph LR\n    subgraph \"Efficiency Metrics\"\n        A[Decision Speed]\n        B[Consensus Time]\n        C[Implementation Time]\n    end\n\n    subgraph \"Quality Metrics\"\n        D[Decision Accuracy]\n        E[Stakeholder Satisfaction]\n        F[Outcome Success Rate]\n    end\n\n    subgraph \"Process Metrics\"\n        G[Participation Rate]\n        H[Conflict Resolution Time]\n        I[Documentation Quality]\n    end\n\n    A --&gt; D\n    B --&gt; E\n    C --&gt; F\n\n    G --&gt; A\n    H --&gt; B\n    I --&gt; C</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-impact-assessment","title":"Decision Impact Assessment","text":"<pre><code>flowchart TD\n    A[Decision Implemented] --&gt; B[Short-term Impact]\n    B --&gt; C[Medium-term Results]\n    C --&gt; D[Long-term Outcomes]\n    D --&gt; E[Stakeholder Feedback]\n    E --&gt; F[Performance Analysis]\n    F --&gt; G[Lessons Learned]\n    G --&gt; H[Process Improvement]\n\n    subgraph \"Impact Areas\"\n        I[Financial Performance]\n        J[Operational Efficiency]\n        K[Stakeholder Satisfaction]\n        L[Strategic Alignment]\n    end\n\n    B --&gt; I\n    C --&gt; J\n    D --&gt; K\n    E --&gt; L</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#best-practices","title":"Best Practices","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-making-excellence","title":"Decision-Making Excellence","text":"<ol> <li>Clear Criteria: Establish clear decision criteria and success metrics</li> <li>Inclusive Process: Ensure all relevant stakeholders are consulted</li> <li>Transparent Communication: Maintain transparency throughout the process</li> <li>Quality Assurance: Implement quality checks at each decision stage</li> <li>Continuous Learning: Learn from past decisions to improve future ones</li> <li>Risk Management: Consider risks and mitigation strategies</li> <li>Implementation Planning: Plan for successful implementation</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Rushing Decisions: Allow adequate time for thorough analysis</li> <li>Ignoring Stakeholders: Consider all relevant stakeholder perspectives</li> <li>Poor Documentation: Maintain comprehensive decision records</li> <li>Inadequate Communication: Ensure clear communication of decisions</li> <li>Lack of Follow-up: Monitor implementation and outcomes</li> <li>Groupthink: Encourage diverse perspectives and constructive dissent</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_decision_making/#decision-making-tools","title":"Decision-Making Tools","text":"<ul> <li>Decision Matrices: Use structured frameworks for complex decisions</li> <li>Risk Assessment: Conduct thorough risk analysis</li> <li>Stakeholder Mapping: Identify and engage all relevant stakeholders</li> <li>Scenario Planning: Consider multiple possible outcomes</li> <li>Cost-Benefit Analysis: Evaluate financial implications</li> <li>Impact Assessment: Consider broader implications and consequences</li> </ul> <p>For more information on implementing effective decision-making processes, see the Board of Directors Configuration Guide and Workflow Documentation. </p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/","title":"Board of Directors Example","text":"<p>This example demonstrates how to use the Board of Directors swarm feature for democratic decision-making and collective intelligence in multi-agent systems.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#overview","title":"Overview","text":"<p>The Board of Directors Swarm provides a sophisticated alternative to single-director architectures by implementing collective decision-making through voting, consensus, and role-based leadership. This example shows how to create and configure a board for strategic decision-making scenarios.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#basic-setup","title":"Basic Setup","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#1-import-required-modules","title":"1. Import Required Modules","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.board_of_directors_swarm import (\n    BoardOfDirectorsSwarm,\n    BoardMember,\n    BoardMemberRole\n)\nfrom swarms.config.board_config import (\n    enable_board_feature,\n    set_decision_threshold,\n    get_default_board_template\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#2-enable-board-feature","title":"2. Enable Board Feature","text":"<pre><code># Enable the Board of Directors feature globally\nenable_board_feature()\n\n# Set global decision threshold\nset_decision_threshold(0.7)  # 70% majority required\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#3-create-board-members","title":"3. Create Board Members","text":"<pre><code># Create Chairman\nchairman = Agent(\n    agent_name=\"Chairman\",\n    agent_description=\"Chairman of the Board responsible for leading meetings and making final decisions\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"\"\"You are the Chairman of the Board. Your responsibilities include:\n1. Leading board meetings and discussions\n2. Facilitating consensus among board members\n3. Making final decisions when consensus cannot be reached\n4. Ensuring all board members have an opportunity to contribute\n5. Maintaining focus on the organization's goals and objectives\n\nYou should be diplomatic, fair, and decisive in your leadership.\"\"\"\n)\n\n# Create Vice Chairman\nvice_chairman = Agent(\n    agent_name=\"Vice-Chairman\",\n    agent_description=\"Vice Chairman who supports the Chairman and coordinates operations\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"\"\"You are the Vice Chairman of the Board. Your responsibilities include:\n1. Supporting the Chairman in leading board meetings\n2. Coordinating operational activities and implementation\n3. Ensuring effective communication between board members\n4. Managing day-to-day board operations\n5. Stepping in when the Chairman is unavailable\n\nYou should be collaborative, organized, and supportive of the Chairman's leadership.\"\"\"\n)\n\n# Create Secretary\nsecretary = Agent(\n    agent_name=\"Secretary\",\n    agent_description=\"Secretary responsible for documentation and record keeping\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"\"\"You are the Secretary of the Board. Your responsibilities include:\n1. Documenting all board meetings and decisions\n2. Maintaining accurate records and meeting minutes\n3. Ensuring proper communication and notifications\n4. Managing board documentation and archives\n5. Supporting compliance and governance requirements\n\nYou should be detail-oriented, organized, and thorough in your documentation.\"\"\"\n)\n\n# Create Treasurer\ntreasurer = Agent(\n    agent_name=\"Treasurer\",\n    agent_description=\"Treasurer responsible for financial oversight and resource management\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"\"\"You are the Treasurer of the Board. Your responsibilities include:\n1. Overseeing financial planning and budgeting\n2. Monitoring resource allocation and utilization\n3. Ensuring financial compliance and accountability\n4. Providing financial insights for decision-making\n5. Managing financial risk and controls\n\nYou should be financially astute, analytical, and focused on value creation.\"\"\"\n)\n\n# Create Executive Director\nexecutive_director = Agent(\n    agent_name=\"Executive-Director\",\n    agent_description=\"Executive Director responsible for strategic planning and operational oversight\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"\"\"You are the Executive Director of the Board. Your responsibilities include:\n1. Developing and implementing strategic plans\n2. Overseeing operational performance and efficiency\n3. Leading innovation and continuous improvement\n4. Managing stakeholder relationships\n5. Ensuring organizational effectiveness\n\nYou should be strategic, results-oriented, and focused on organizational success.\"\"\"\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#4-create-boardmember-objects","title":"4. Create BoardMember Objects","text":"<pre><code># Create BoardMember objects with roles, voting weights, and expertise areas\nboard_members = [\n    BoardMember(\n        agent=chairman,\n        role=BoardMemberRole.CHAIRMAN,\n        voting_weight=1.5,\n        expertise_areas=[\"leadership\", \"strategy\", \"governance\", \"decision_making\"]\n    ),\n    BoardMember(\n        agent=vice_chairman,\n        role=BoardMemberRole.VICE_CHAIRMAN,\n        voting_weight=1.2,\n        expertise_areas=[\"operations\", \"coordination\", \"communication\", \"implementation\"]\n    ),\n    BoardMember(\n        agent=secretary,\n        role=BoardMemberRole.SECRETARY,\n        voting_weight=1.0,\n        expertise_areas=[\"documentation\", \"compliance\", \"record_keeping\", \"communication\"]\n    ),\n    BoardMember(\n        agent=treasurer,\n        role=BoardMemberRole.TREASURER,\n        voting_weight=1.0,\n        expertise_areas=[\"finance\", \"budgeting\", \"risk_management\", \"resource_allocation\"]\n    ),\n    BoardMember(\n        agent=executive_director,\n        role=BoardMemberRole.EXECUTIVE_DIRECTOR,\n        voting_weight=1.5,\n        expertise_areas=[\"strategy\", \"operations\", \"innovation\", \"performance_management\"]\n    )\n]\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#5-create-specialized-worker-agents","title":"5. Create Specialized Worker Agents","text":"<pre><code># Create specialized worker agents for different types of analysis\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research, data analysis, and trend identification\",\n    model_name=\"gpt-4o\",\n    system_prompt=\"\"\"You are a Research Specialist. Your responsibilities include:\n1. Conducting comprehensive market research and analysis\n2. Identifying trends, opportunities, and risks\n3. Gathering and analyzing relevant data\n4. Providing evidence-based insights and recommendations\n5. Supporting strategic decision-making with research findings\n\nYou should be thorough, analytical, and objective in your research.\"\"\"\n)\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis, valuation, and investment assessment\",\n    model_name=\"gpt-4o\",\n    system_prompt=\"\"\"You are a Financial Analyst. Your responsibilities include:\n1. Conducting financial analysis and valuation\n2. Assessing investment opportunities and risks\n3. Analyzing financial performance and metrics\n4. Providing financial insights and recommendations\n5. Supporting financial decision-making\n\nYou should be financially astute, analytical, and focused on value creation.\"\"\"\n)\n\ntechnical_agent = Agent(\n    agent_name=\"Technical-Specialist\",\n    agent_description=\"Expert in technical analysis, feasibility assessment, and implementation planning\",\n    model_name=\"gpt-4o\",\n    system_prompt=\"\"\"You are a Technical Specialist. Your responsibilities include:\n1. Conducting technical feasibility analysis\n2. Assessing implementation requirements and challenges\n3. Providing technical insights and recommendations\n4. Supporting technical decision-making\n5. Planning and coordinating technical implementations\n\nYou should be technically proficient, practical, and solution-oriented.\"\"\"\n)\n\nstrategy_agent = Agent(\n    agent_name=\"Strategy-Specialist\",\n    agent_description=\"Expert in strategic planning, competitive analysis, and business development\",\n    model_name=\"gpt-4o\",\n    system_prompt=\"\"\"You are a Strategy Specialist. Your responsibilities include:\n1. Developing strategic plans and initiatives\n2. Conducting competitive analysis and market positioning\n3. Identifying strategic opportunities and threats\n4. Providing strategic insights and recommendations\n5. Supporting strategic decision-making\n\nYou should be strategic, forward-thinking, and focused on long-term success.\"\"\"\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#6-initialize-the-board-of-directors-swarm","title":"6. Initialize the Board of Directors Swarm","text":"<pre><code># Initialize the Board of Directors swarm with comprehensive configuration\nboard_swarm = BoardOfDirectorsSwarm(\n    name=\"Executive_Board_Swarm\",\n    description=\"Executive board with specialized roles for strategic decision-making and collective intelligence\",\n    board_members=board_members,\n    agents=[research_agent, financial_agent, technical_agent, strategy_agent],\n    max_loops=3,  # Allow multiple iterations for complex analysis\n    verbose=True,  # Enable detailed logging\n    decision_threshold=0.7,  # 70% consensus required\n    enable_voting=True,  # Enable voting mechanisms\n    enable_consensus=True,  # Enable consensus building\n    max_workers=4,  # Maximum parallel workers\n    output_type=\"dict\"  # Return results as dictionary\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#custom-board-templates","title":"Custom Board Templates","text":"<p>You can use pre-configured board templates for common use cases:</p> <pre><code># Get a financial analysis board template\nfinancial_board_template = get_default_board_template(\"financial_analysis\")\n\n# Get a strategic planning board template\nstrategic_board_template = get_default_board_template(\"strategic_planning\")\n\n# Get a technology assessment board template\ntech_board_template = get_default_board_template(\"technology_assessment\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#dynamic-role-assignment","title":"Dynamic Role Assignment","text":"<p>Automatically assign roles based on task requirements:</p> <pre><code># Board members are automatically assigned roles based on expertise\nboard_swarm = BoardOfDirectorsSwarm(\n    board_members=board_members,\n    agents=agents,\n    auto_assign_roles=True,\n    role_mapping={\n        \"financial_analysis\": [\"Treasurer\", \"Financial_Member\"],\n        \"strategic_planning\": [\"Chairman\", \"Executive_Director\"],\n        \"technical_assessment\": [\"Technical_Member\", \"Executive_Director\"],\n        \"research_analysis\": [\"Research_Member\", \"Secretary\"]\n    }\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#consensus-optimization","title":"Consensus Optimization","text":"<p>Configure advanced consensus-building mechanisms:</p> <pre><code># Enable advanced consensus features\nboard_swarm = BoardOfDirectorsSwarm(\n    board_members=board_members,\n    agents=agents,\n    enable_consensus=True,\n    consensus_timeout=300,  # 5 minutes timeout\n    min_participation_rate=0.8,  # 80% minimum participation\n    auto_fallback_to_chairman=True,  # Chairman can make final decisions\n    consensus_rounds=3  # Maximum consensus building rounds\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#example-use-cases","title":"Example Use Cases","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#1-strategic-investment-analysis","title":"1. Strategic Investment Analysis","text":"<pre><code># Execute a complex strategic investment analysis\ninvestment_task = \"\"\"\nAnalyze the strategic investment opportunity for a $50M Series B funding round in a \nfintech startup. Consider market conditions, competitive landscape, financial projections, \ntechnical feasibility, and strategic fit. Provide comprehensive recommendations including:\n1. Investment recommendation (proceed/hold/decline)\n2. Valuation analysis and suggested terms\n3. Risk assessment and mitigation strategies\n4. Strategic value and synergies\n5. Implementation timeline and milestones\n\"\"\"\n\nresult = board_swarm.run(task=investment_task)\nprint(\"Investment Analysis Results:\")\nprint(json.dumps(result, indent=2))\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#2-technology-strategy-development","title":"2. Technology Strategy Development","text":"<pre><code># Develop a comprehensive technology strategy\ntech_strategy_task = \"\"\"\nDevelop a comprehensive technology strategy for a mid-size manufacturing company \nlooking to digitize operations and implement Industry 4.0 technologies. Consider:\n1. Current technology assessment and gaps\n2. Technology roadmap and implementation plan\n3. Investment requirements and ROI analysis\n4. Risk assessment and mitigation strategies\n5. Change management and training requirements\n6. Competitive positioning and market advantages\n\"\"\"\n\nresult = board_swarm.run(task=tech_strategy_task)\nprint(\"Technology Strategy Results:\")\nprint(json.dumps(result, indent=2))\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#3-market-entry-strategy","title":"3. Market Entry Strategy","text":"<pre><code># Develop a market entry strategy for a new product\nmarket_entry_task = \"\"\"\nDevelop a comprehensive market entry strategy for a new AI-powered productivity \nsoftware targeting the enterprise market. Consider:\n1. Market analysis and opportunity assessment\n2. Competitive landscape and positioning\n3. Go-to-market strategy and channels\n4. Pricing strategy and revenue model\n5. Resource requirements and investment needs\n6. Risk assessment and mitigation strategies\n7. Success metrics and KPIs\n\"\"\"\n\nresult = board_swarm.run(task=market_entry_task)\nprint(\"Market Entry Strategy Results:\")\nprint(json.dumps(result, indent=2))\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#monitoring-and-analysis","title":"Monitoring and Analysis","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#board-performance-metrics","title":"Board Performance Metrics","text":"<pre><code># Get board performance metrics\nboard_summary = board_swarm.get_board_summary()\nprint(\"Board Summary:\")\nprint(f\"Board Name: {board_summary['board_name']}\")\nprint(f\"Total Board Members: {board_summary['total_members']}\")\nprint(f\"Total Worker Agents: {board_summary['total_agents']}\")\nprint(f\"Decision Threshold: {board_summary['decision_threshold']}\")\nprint(f\"Max Loops: {board_summary['max_loops']}\")\n\n# Display board member details\nprint(\"\\nBoard Members:\")\nfor member in board_summary['members']:\n    print(f\"- {member['name']} (Role: {member['role']}, Weight: {member['voting_weight']})\")\n    print(f\"  Expertise: {', '.join(member['expertise_areas'])}\")\n\n# Display worker agent details\nprint(\"\\nWorker Agents:\")\nfor agent in board_summary['agents']:\n    print(f\"- {agent['name']}: {agent['description']}\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#decision-analysis","title":"Decision Analysis","text":"<pre><code># Analyze decision-making patterns\nif hasattr(result, 'get') and callable(result.get):\n    conversation_history = result.get('conversation_history', [])\n\n    print(f\"\\nDecision Analysis:\")\n    print(f\"Total Messages: {len(conversation_history)}\")\n\n    # Count board member contributions\n    board_contributions = {}\n    for msg in conversation_history:\n        if 'Board' in msg.get('role', ''):\n            member_name = msg.get('agent_name', 'Unknown')\n            board_contributions[member_name] = board_contributions.get(member_name, 0) + 1\n\n    print(f\"Board Member Contributions:\")\n    for member, count in board_contributions.items():\n        print(f\"- {member}: {count} contributions\")\n\n    # Count agent executions\n    agent_executions = {}\n    for msg in conversation_history:\n        if any(agent.agent_name in msg.get('role', '') for agent in [research_agent, financial_agent, technical_agent, strategy_agent]):\n            agent_name = msg.get('agent_name', 'Unknown')\n            agent_executions[agent_name] = agent_executions.get(agent_name, 0) + 1\n\n    print(f\"\\nAgent Executions:\")\n    for agent, count in agent_executions.items():\n        print(f\"- {agent}: {count} executions\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#best-practices","title":"Best Practices","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#1-role-definition","title":"1. Role Definition","text":"<ul> <li>Clearly define responsibilities for each board member</li> <li>Ensure expertise areas align with organizational needs</li> <li>Balance voting weights based on role importance</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#2-task-formulation","title":"2. Task Formulation","text":"<ul> <li>Provide clear, specific task descriptions</li> <li>Include relevant context and constraints</li> <li>Specify expected outputs and deliverables</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#3-consensus-building","title":"3. Consensus Building","text":"<ul> <li>Allow adequate time for discussion and consensus</li> <li>Encourage diverse perspectives and viewpoints</li> <li>Use structured decision-making processes</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#4-performance-monitoring","title":"4. Performance Monitoring","text":"<ul> <li>Track decision quality and outcomes</li> <li>Monitor board member participation</li> <li>Analyze agent utilization and effectiveness</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#5-continuous-improvement","title":"5. Continuous Improvement","text":"<ul> <li>Learn from each execution cycle</li> <li>Refine board composition and roles</li> <li>Optimize decision thresholds and processes</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#common-issues","title":"Common Issues","text":"<ol> <li>Consensus Failures: Lower decision threshold or increase timeout</li> <li>Role Conflicts: Ensure clear role definitions and responsibilities</li> <li>Agent Coordination: Verify agent communication and task distribution</li> <li>Performance Issues: Monitor resource usage and optimize configurations</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#debug-commands","title":"Debug Commands","text":"<pre><code># Enable detailed logging\nimport logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Check board configuration\nprint(board_swarm.get_board_summary())\n\n# Test individual components\nfor member in board_members:\n    print(f\"Testing {member.agent.agent_name}...\")\n    response = member.agent.run(\"Test message\")\n    print(f\"Response: {response[:100]}...\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_example/#conclusion","title":"Conclusion","text":"<p>This example demonstrates the comprehensive capabilities of the Board of Directors Swarm for democratic decision-making and collective intelligence. The feature provides a sophisticated alternative to single-director architectures, enabling more robust and well-considered decisions through voting, consensus, and role-based leadership.</p> <p>For more information, see the Board of Directors Documentation and Configuration Guide. </p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/","title":"Board of Directors Roles","text":"<p>The Board of Directors system implements a hierarchical structure with clearly defined roles, responsibilities, and voting weights. Each role is designed to contribute specific expertise and authority to the decision-making process.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#role-hierarchy","title":"Role Hierarchy","text":"<pre><code>graph TD\n    A[Chairman&lt;br/&gt;Voting Weight: 1.5&lt;br/&gt;Final Authority] --&gt; B[Vice Chairman&lt;br/&gt;Voting Weight: 1.2&lt;br/&gt;Operational Support]\n    A --&gt; C[Executive Director&lt;br/&gt;Voting Weight: 1.5&lt;br/&gt;Strategic Planning]\n    A --&gt; D[Secretary&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Documentation]\n    A --&gt; E[Treasurer&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Financial Oversight]\n    A --&gt; F[Member&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Expertise Contribution]\n\n    B --&gt; G[Operational Coordination]\n    C --&gt; H[Strategic Initiatives]\n    D --&gt; I[Record Keeping]\n    E --&gt; J[Resource Management]\n    F --&gt; K[Specialized Input]\n\n    style A fill:#ffeb3b\n    style B fill:#2196f3\n    style C fill:#4caf50\n    style D fill:#ff9800\n    style E fill:#9c27b0\n    style F fill:#607d8b</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#chairman-role","title":"Chairman Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#primary-responsibilities","title":"Primary Responsibilities","text":"<pre><code>graph TD\n    A[Chairman] --&gt; B[Meeting Leadership]\n    A --&gt; C[Final Decision Authority]\n    A --&gt; D[Consensus Facilitation]\n    A --&gt; E[Strategic Direction]\n    A --&gt; F[Stakeholder Communication]\n\n    B --&gt; G[Agenda Setting]\n    B --&gt; H[Discussion Management]\n    B --&gt; I[Time Management]\n\n    C --&gt; J[Approval Authority]\n    C --&gt; K[Override Capability]\n    C --&gt; L[Final Sign-off]\n\n    D --&gt; M[Conflict Resolution]\n    D --&gt; N[Mediation]\n    D --&gt; O[Compromise Facilitation]\n\n    E --&gt; P[Vision Setting]\n    E --&gt; Q[Goal Definition]\n    E --&gt; R[Priority Establishment]\n\n    F --&gt; S[External Relations]\n    F --&gt; T[Stakeholder Updates]\n    F --&gt; U[Public Communication]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#chairmans-decision-flow","title":"Chairman's Decision Flow","text":"<pre><code>flowchart TD\n    A[Task Received] --&gt; B[Assess Complexity]\n    B --&gt; C[Determine Board Composition]\n    C --&gt; D[Set Meeting Agenda]\n    D --&gt; E[Lead Discussion]\n    E --&gt; F[Facilitate Consensus]\n    F --&gt; G{Consensus Reached?}\n    G --&gt;|Yes| H[Approve Decision]\n    G --&gt;|No| I[Exercise Authority]\n    I --&gt; J[Make Final Decision]\n    H --&gt; K[Oversee Execution]\n    J --&gt; K\n    K --&gt; L[Monitor Progress]\n    L --&gt; M[Review Results]\n    M --&gt; N[Final Approval]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#key-competencies","title":"Key Competencies","text":"<ul> <li>Leadership: Ability to guide and inspire board members</li> <li>Decision Making: Strong analytical and judgment skills</li> <li>Communication: Excellent verbal and written communication</li> <li>Conflict Resolution: Skills in mediating disagreements</li> <li>Strategic Thinking: Long-term vision and planning ability</li> <li>Stakeholder Management: Relationship building and management</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#vice-chairman-role","title":"Vice Chairman Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#supporting-responsibilities","title":"Supporting Responsibilities","text":"<pre><code>graph TD\n    A[Vice Chairman] --&gt; B[Operational Support]\n    A --&gt; C[Chairman Backup]\n    A --&gt; D[Coordination]\n    A --&gt; E[Implementation Oversight]\n    A --&gt; F[Team Management]\n\n    B --&gt; G[Process Optimization]\n    B --&gt; H[Efficiency Improvement]\n    B --&gt; I[Resource Coordination]\n\n    C --&gt; J[Acting Chairman]\n    C --&gt; K[Decision Support]\n    C --&gt; L[Authority Delegation]\n\n    D --&gt; M[Cross-functional Coordination]\n    D --&gt; N[Communication Management]\n    D --&gt; O[Timeline Management]\n\n    E --&gt; P[Execution Monitoring]\n    E --&gt; Q[Quality Assurance]\n    E --&gt; R[Performance Tracking]\n\n    F --&gt; S[Team Development]\n    F --&gt; T[Motivation]\n    F --&gt; U[Conflict Prevention]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#vice-chairmans-operational-flow","title":"Vice Chairman's Operational Flow","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant ViceChair\n    participant Board\n    participant Agents\n\n    Chairman-&gt;&gt;ViceChair: Delegate Operational Tasks\n    ViceChair-&gt;&gt;Board: Coordinate Member Activities\n    ViceChair-&gt;&gt;Agents: Oversee Agent Performance\n    Agents-&gt;&gt;ViceChair: Report Progress\n    ViceChair-&gt;&gt;Chairman: Provide Status Updates\n    Chairman-&gt;&gt;ViceChair: Request Specific Actions\n    ViceChair-&gt;&gt;Board: Implement Chairman's Directives\n    ViceChair-&gt;&gt;Agents: Adjust Execution Plans</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#executive-director-role","title":"Executive Director Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#strategic-responsibilities","title":"Strategic Responsibilities","text":"<pre><code>graph TD\n    A[Executive Director] --&gt; B[Strategic Planning]\n    A --&gt; C[Operational Oversight]\n    A --&gt; D[Performance Management]\n    A --&gt; E[Innovation Leadership]\n    A --&gt; F[Risk Management]\n\n    B --&gt; G[Long-term Vision]\n    B --&gt; H[Goal Setting]\n    B --&gt; I[Strategy Development]\n\n    C --&gt; J[Process Optimization]\n    C --&gt; K[Quality Management]\n    C --&gt; L[Efficiency Improvement]\n\n    D --&gt; M[KPI Definition]\n    D --&gt; N[Performance Monitoring]\n    D --&gt; O[Improvement Initiatives]\n\n    E --&gt; P[Technology Adoption]\n    E --&gt; Q[Process Innovation]\n    E --&gt; R[Best Practices]\n\n    F --&gt; S[Risk Assessment]\n    F --&gt; T[Mitigation Planning]\n    F --&gt; U[Contingency Preparation]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#strategic-decision-framework","title":"Strategic Decision Framework","text":"<pre><code>flowchart TD\n    A[Strategic Analysis] --&gt; B[Market Assessment]\n    B --&gt; C[Competitive Analysis]\n    C --&gt; D[Internal Capability Review]\n    D --&gt; E[Opportunity Identification]\n    E --&gt; F[Risk Evaluation]\n    F --&gt; G[Strategic Options]\n    G --&gt; H[Recommendation Development]\n    H --&gt; I[Board Presentation]\n    I --&gt; J[Implementation Planning]\n    J --&gt; K[Execution Oversight]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#secretary-role","title":"Secretary Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#documentation-responsibilities","title":"Documentation Responsibilities","text":"<pre><code>graph TD\n    A[Secretary] --&gt; B[Meeting Documentation]\n    A --&gt; C[Record Keeping]\n    A --&gt; D[Communication Management]\n    A --&gt; E[Compliance Monitoring]\n    A --&gt; F[Information Management]\n\n    B --&gt; G[Agenda Preparation]\n    B --&gt; H[Minutes Recording]\n    B --&gt; I[Action Item Tracking]\n\n    C --&gt; J[Document Storage]\n    C --&gt; K[Version Control]\n    C --&gt; L[Access Management]\n\n    D --&gt; M[Internal Communications]\n    D --&gt; N[External Correspondence]\n    D --&gt; O[Notification Systems]\n\n    E --&gt; P[Policy Compliance]\n    E --&gt; Q[Regulatory Requirements]\n    E --&gt; R[Audit Preparation]\n\n    F --&gt; S[Information Architecture]\n    F --&gt; T[Knowledge Management]\n    F --&gt; U[Data Governance]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#documentation-workflow","title":"Documentation Workflow","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant Secretary\n    participant Board\n    participant System\n\n    Chairman-&gt;&gt;Secretary: Request Meeting Setup\n    Secretary-&gt;&gt;System: Prepare Meeting Materials\n    Secretary-&gt;&gt;Board: Distribute Agenda\n    Board-&gt;&gt;Secretary: Submit Pre-meeting Materials\n    Secretary-&gt;&gt;Chairman: Compile Meeting Package\n    Chairman-&gt;&gt;Board: Conduct Meeting\n    Secretary-&gt;&gt;System: Record Meeting Minutes\n    Secretary-&gt;&gt;Board: Distribute Minutes\n    Board-&gt;&gt;Secretary: Confirm Action Items\n    Secretary-&gt;&gt;System: Update Tracking System</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#treasurer-role","title":"Treasurer Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#financial-responsibilities","title":"Financial Responsibilities","text":"<pre><code>graph TD\n    A[Treasurer] --&gt; B[Financial Oversight]\n    A --&gt; C[Resource Allocation]\n    A --&gt; D[Budget Management]\n    A --&gt; E[Financial Reporting]\n    A --&gt; F[Risk Assessment]\n\n    B --&gt; G[Financial Planning]\n    B --&gt; H[Cost Control]\n    B --&gt; I[Investment Decisions]\n\n    C --&gt; J[Resource Optimization]\n    C --&gt; K[Capacity Planning]\n    C --&gt; L[Efficiency Analysis]\n\n    D --&gt; M[Budget Development]\n    D --&gt; N[Expense Monitoring]\n    D --&gt; O[Variance Analysis]\n\n    E --&gt; P[Financial Statements]\n    E --&gt; Q[Performance Metrics]\n    E --&gt; R[Stakeholder Reports]\n\n    F --&gt; S[Financial Risk]\n    F --&gt; T[Market Risk]\n    F --&gt; U[Operational Risk]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#financial-decision-process","title":"Financial Decision Process","text":"<pre><code>flowchart TD\n    A[Financial Request] --&gt; B[Resource Assessment]\n    B --&gt; C[Budget Analysis]\n    C --&gt; D[Cost-Benefit Analysis]\n    D --&gt; E[Risk Evaluation]\n    E --&gt; F[Alternative Analysis]\n    F --&gt; G[Recommendation]\n    G --&gt; H[Board Presentation]\n    H --&gt; I[Approval Decision]\n    I --&gt; J[Implementation]\n    J --&gt; K[Monitoring]\n    K --&gt; L[Performance Review]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#member-role","title":"Member Role","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#general-responsibilities","title":"General Responsibilities","text":"<pre><code>graph TD\n    A[Member] --&gt; B[Expertise Contribution]\n    A --&gt; C[Participation]\n    A --&gt; D[Specialized Input]\n    A --&gt; E[Committee Work]\n    A --&gt; F[Stakeholder Representation]\n\n    B --&gt; G[Domain Knowledge]\n    B --&gt; H[Technical Expertise]\n    B --&gt; I[Industry Experience]\n\n    C --&gt; J[Active Engagement]\n    C --&gt; K[Voting Participation]\n    C --&gt; L[Discussion Contribution]\n\n    D --&gt; M[Specialized Analysis]\n    D --&gt; N[Expert Opinions]\n    D --&gt; O[Technical Recommendations]\n\n    E --&gt; P[Committee Leadership]\n    E --&gt; Q[Task Force Participation]\n    E --&gt; R[Working Group Support]\n\n    F --&gt; S[Stakeholder Advocacy]\n    F --&gt; T[Interest Representation]\n    F --&gt; U[Community Engagement]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#member-contribution-framework","title":"Member Contribution Framework","text":"<pre><code>graph LR\n    subgraph \"Expertise Areas\"\n        A[Technical Expertise]\n        B[Industry Knowledge]\n        C[Operational Experience]\n        D[Strategic Insight]\n    end\n\n    subgraph \"Contribution Types\"\n        E[Analysis &amp; Research]\n        F[Recommendations]\n        G[Risk Assessment]\n        H[Implementation Support]\n    end\n\n    subgraph \"Participation Levels\"\n        I[Active Voting]\n        J[Discussion Leadership]\n        K[Committee Work]\n        L[Mentoring]\n    end\n\n    A --&gt; E\n    B --&gt; F\n    C --&gt; G\n    D --&gt; H\n\n    E --&gt; I\n    F --&gt; J\n    G --&gt; K\n    H --&gt; L</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#role-interactions","title":"Role Interactions","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#collaborative-decision-making","title":"Collaborative Decision Making","text":"<pre><code>sequenceDiagram\n    participant Chairman\n    participant ViceChair\n    participant ExecDir\n    participant Secretary\n    participant Treasurer\n    participant Member\n\n    Chairman-&gt;&gt;ViceChair: Delegate Operational Tasks\n    Chairman-&gt;&gt;ExecDir: Request Strategic Analysis\n    Chairman-&gt;&gt;Secretary: Schedule Meeting\n    Chairman-&gt;&gt;Treasurer: Request Financial Assessment\n    Chairman-&gt;&gt;Member: Request Expert Input\n\n    ViceChair-&gt;&gt;ExecDir: Coordinate Implementation\n    ExecDir-&gt;&gt;Treasurer: Resource Requirements\n    Treasurer-&gt;&gt;Secretary: Financial Documentation\n    Secretary-&gt;&gt;Member: Meeting Materials\n    Member-&gt;&gt;Chairman: Expert Recommendations\n\n    Chairman-&gt;&gt;ViceChair: Final Decision\n    ViceChair-&gt;&gt;ExecDir: Implementation Plan\n    ExecDir-&gt;&gt;Treasurer: Resource Allocation\n    Treasurer-&gt;&gt;Secretary: Financial Records\n    Secretary-&gt;&gt;Member: Action Items</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#voting-power-distribution","title":"Voting Power Distribution","text":"<pre><code>pie title Voting Weight Distribution\n    \"Chairman\" : 1.5\n    \"Executive Director\" : 1.5\n    \"Vice Chairman\" : 1.2\n    \"Secretary\" : 1.0\n    \"Treasurer\" : 1.0\n    \"Member\" : 1.0</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#best-practices-for-role-management","title":"Best Practices for Role Management","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#role-clarity","title":"Role Clarity","text":"<ol> <li>Clear Definition: Each role should have clearly defined responsibilities</li> <li>Authority Limits: Establish clear boundaries of authority for each role</li> <li>Communication Protocols: Define how roles interact and communicate</li> <li>Succession Planning: Plan for role transitions and backups</li> <li>Performance Metrics: Establish KPIs for each role</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#collaboration-guidelines","title":"Collaboration Guidelines","text":"<ol> <li>Respect Hierarchy: Understand and respect the decision-making hierarchy</li> <li>Active Participation: All members should actively contribute to discussions</li> <li>Constructive Feedback: Provide feedback that improves outcomes</li> <li>Conflict Resolution: Address disagreements professionally and constructively</li> <li>Continuous Learning: Stay updated on best practices and industry trends</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_roles/#performance-optimization","title":"Performance Optimization","text":"<ol> <li>Regular Reviews: Conduct periodic reviews of role effectiveness</li> <li>Skill Development: Invest in training and development for each role</li> <li>Process Improvement: Continuously improve board processes and procedures</li> <li>Technology Adoption: Leverage technology to enhance role effectiveness</li> <li>Knowledge Sharing: Promote knowledge sharing between roles</li> </ol> <p>For more information on implementing specific roles, see the Board of Directors Configuration Guide and Workflow Documentation. </p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/","title":"<code>BoardOfDirectorsSwarm</code>","text":"<p>The <code>BoardOfDirectorsSwarm</code> is a sophisticated multi-agent orchestration system that implements a collective decision-making approach as an alternative to the single Director pattern. It consists of a board of directors that convenes to discuss, vote, and reach consensus on task distribution and execution strategies.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#overview","title":"Overview","text":"<p>The Board of Directors Swarm follows a democratic workflow pattern:</p> <ol> <li>Task Reception: User provides a task to the swarm</li> <li>Board Meeting: Board of Directors convenes to discuss and create a plan</li> <li>Voting &amp; Consensus: Board members vote and reach consensus on task distribution</li> <li>Order Distribution: Board distributes orders to specialized worker agents</li> <li>Execution: Individual agents execute their assigned tasks</li> <li>Feedback Loop: Board evaluates results and issues new orders if needed (up to <code>max_loops</code>)</li> <li>Context Preservation: All conversation history and context is maintained throughout the process</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#architecture","title":"Architecture","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#high-level-workflow","title":"High-Level Workflow","text":"<pre><code>graph TD\n    A[User Task] --&gt; B[Board of Directors]\n    B --&gt; C[Board Meeting &amp; Discussion]\n    C --&gt; D[Voting &amp; Consensus]\n    D --&gt; E[Create Plan &amp; Orders]\n    E --&gt; F[Distribute to Agents]\n    F --&gt; G[Agent 1]\n    F --&gt; H[Agent 2]\n    F --&gt; I[Agent N]\n    G --&gt; J[Execute Task]\n    H --&gt; J\n    I --&gt; J\n    J --&gt; K[Report Results]\n    K --&gt; L[Board Evaluation]\n    L --&gt; M{More Loops?}\n    M --&gt;|Yes| C\n    M --&gt;|No| N[Final Output]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#detailed-decision-making-process","title":"Detailed Decision-Making Process","text":"<pre><code>flowchart TD\n    A[Task Received] --&gt; B[Board Convenes]\n    B --&gt; C[Chairman Opens Meeting]\n    C --&gt; D[Task Analysis Phase]\n    D --&gt; E[Expertise Assignment]\n    E --&gt; F[Individual Member Analysis]\n    F --&gt; G[Discussion &amp; Debate]\n    G --&gt; H[Proposal Generation]\n    H --&gt; I[Voting Process]\n    I --&gt; J{Consensus Reached?}\n    J --&gt;|No| K[Reconciliation Phase]\n    K --&gt; G\n    J --&gt;|Yes| L[Plan Finalization]\n    L --&gt; M[Order Creation]\n    M --&gt; N[Agent Assignment]\n    N --&gt; O[Execution Phase]\n    O --&gt; P[Result Collection]\n    P --&gt; Q[Board Review]\n    Q --&gt; R{Approval?}\n    R --&gt;|No| S[Refinement Loop]\n    S --&gt; G\n    R --&gt;|Yes| T[Final Delivery]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#board-member-interaction-flow","title":"Board Member Interaction Flow","text":"<pre><code>sequenceDiagram\n    participant User\n    participant Chairman\n    participant ViceChair\n    participant Secretary\n    participant Treasurer\n    participant ExecDir\n    participant Agents\n\n    User-&gt;&gt;Chairman: Submit Task\n    Chairman-&gt;&gt;ViceChair: Notify Board Meeting\n    Chairman-&gt;&gt;Secretary: Request Meeting Setup\n    Chairman-&gt;&gt;Treasurer: Resource Assessment\n    Chairman-&gt;&gt;ExecDir: Strategic Planning\n\n    Note over Chairman,ExecDir: Board Discussion Phase\n\n    Chairman-&gt;&gt;ViceChair: Lead Discussion\n    ViceChair-&gt;&gt;Secretary: Document Decisions\n    Secretary-&gt;&gt;Treasurer: Budget Considerations\n    Treasurer-&gt;&gt;ExecDir: Resource Allocation\n    ExecDir-&gt;&gt;Chairman: Strategic Recommendations\n\n    Note over Chairman,ExecDir: Voting &amp; Consensus\n\n    Chairman-&gt;&gt;ViceChair: Call for Vote\n    ViceChair-&gt;&gt;Secretary: Record Votes\n    Secretary-&gt;&gt;Treasurer: Financial Approval\n    Treasurer-&gt;&gt;ExecDir: Resource Approval\n    ExecDir-&gt;&gt;Chairman: Final Decision\n\n    Note over Chairman,Agents: Execution Phase\n\n    Chairman-&gt;&gt;Agents: Distribute Orders\n    Agents-&gt;&gt;Chairman: Execute Tasks\n    Agents-&gt;&gt;ViceChair: Progress Reports\n    Agents-&gt;&gt;Secretary: Documentation\n    Agents-&gt;&gt;Treasurer: Resource Usage\n    Agents-&gt;&gt;ExecDir: Strategic Updates\n\n    Note over Chairman,ExecDir: Review &amp; Feedback\n\n    Chairman-&gt;&gt;User: Deliver Results</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#agent-execution-and-feedback-loop","title":"Agent Execution and Feedback Loop","text":"<pre><code>graph LR\n    subgraph \"Board of Directors\"\n        A[Chairman]\n        B[Vice Chairman]\n        C[Secretary]\n        D[Treasurer]\n        E[Executive Director]\n    end\n\n    subgraph \"Worker Agents\"\n        F[Research Agent]\n        G[Analysis Agent]\n        H[Technical Agent]\n        I[Financial Agent]\n        J[Strategy Agent]\n    end\n\n    subgraph \"Execution Flow\"\n        K[Task Distribution]\n        L[Parallel Execution]\n        M[Result Aggregation]\n        N[Quality Assessment]\n        O[Feedback Loop]\n    end\n\n    A --&gt; K\n    B --&gt; K\n    C --&gt; K\n    D --&gt; K\n    E --&gt; K\n\n    K --&gt; L\n    L --&gt; F\n    L --&gt; G\n    L --&gt; H\n    L --&gt; I\n    L --&gt; J\n\n    F --&gt; M\n    G --&gt; M\n    H --&gt; M\n    I --&gt; M\n    J --&gt; M\n\n    M --&gt; N\n    N --&gt; O\n    O --&gt; K</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#key-features","title":"Key Features","text":"<ul> <li>Collective Decision Making: Board members collaborate through voting and consensus</li> <li>Role-Based Leadership: Different board member roles with specific responsibilities</li> <li>Voting Mechanisms: Configurable voting weights and decision thresholds</li> <li>Consensus Building: Support for both majority voting and consensus approaches</li> <li>Specialized Agents: Each agent has specific expertise and responsibilities</li> <li>Iterative Refinement: Multiple feedback loops for improved results</li> <li>Context Preservation: Full conversation history maintained</li> <li>Flexible Output Formats: Support for various output types (dict, str, list)</li> <li>Comprehensive Logging: Detailed logging for debugging and monitoring</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#board-member-roles","title":"Board Member Roles","text":"<p>The Board of Directors supports various roles with different responsibilities and voting weights:</p> Role Description Voting Weight Responsibilities <code>CHAIRMAN</code> Primary leader responsible for board meetings and final decisions 1.5 Leading meetings, facilitating consensus, making final decisions <code>VICE_CHAIRMAN</code> Secondary leader who supports the chairman 1.2 Supporting chairman, coordinating operations <code>SECRETARY</code> Responsible for documentation and meeting minutes 1.0 Documenting meetings, maintaining records <code>TREASURER</code> Manages financial aspects and resource allocation 1.0 Financial oversight, resource management <code>EXECUTIVE_DIRECTOR</code> Executive-level board member with operational authority 1.5 Strategic planning, operational oversight <code>MEMBER</code> General board member with specific expertise 1.0 Contributing expertise, participating in decisions"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#role-hierarchy-and-decision-flow","title":"Role Hierarchy and Decision Flow","text":"<pre><code>graph TD\n    subgraph \"Board Hierarchy\"\n        A[Chairman&lt;br/&gt;Voting Weight: 1.5&lt;br/&gt;Final Decision Authority]\n        B[Vice Chairman&lt;br/&gt;Voting Weight: 1.2&lt;br/&gt;Operational Support]\n        C[Executive Director&lt;br/&gt;Voting Weight: 1.5&lt;br/&gt;Strategic Planning]\n        D[Secretary&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Documentation]\n        E[Treasurer&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Financial Oversight]\n        F[Member&lt;br/&gt;Voting Weight: 1.0&lt;br/&gt;Expertise Contribution]\n    end\n\n    subgraph \"Decision Process\"\n        G[Task Analysis]\n        H[Expertise Assignment]\n        I[Individual Analysis]\n        J[Discussion &amp; Debate]\n        K[Voting]\n        L[Consensus Check]\n        M[Final Decision]\n    end\n\n    A --&gt; G\n    B --&gt; G\n    C --&gt; G\n    D --&gt; G\n    E --&gt; G\n    F --&gt; G\n\n    G --&gt; H\n    H --&gt; I\n    I --&gt; J\n    J --&gt; K\n    K --&gt; L\n    L --&gt; M\n\n    A -.-&gt;|Final Authority| M</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#boardofdirectorsswarm-constructor","title":"<code>BoardOfDirectorsSwarm</code> Constructor","text":"Parameter Type Default Description <code>name</code> <code>str</code> <code>\"BoardOfDirectorsSwarm\"</code> The name of the swarm instance <code>description</code> <code>str</code> <code>\"Distributed task swarm with collective decision-making\"</code> Brief description of the swarm's functionality <code>board_members</code> <code>Optional[List[BoardMember]]</code> <code>None</code> List of board members with their roles and expertise <code>agents</code> <code>List[Union[Agent, Callable, Any]]</code> <code>None</code> List of worker agents in the swarm <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of feedback loops between board and agents <code>output_type</code> <code>OutputType</code> <code>\"dict-all-except-first\"</code> Format for output (dict, str, list) <code>board_model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Model name for board member agents <code>verbose</code> <code>bool</code> <code>False</code> Enable detailed logging <code>add_collaboration_prompt</code> <code>bool</code> <code>True</code> Add collaboration prompts to agents <code>board_feedback_on</code> <code>bool</code> <code>True</code> Enable board feedback on agent outputs <code>decision_threshold</code> <code>float</code> <code>0.6</code> Threshold for majority decisions (0.0-1.0) <code>enable_voting</code> <code>bool</code> <code>True</code> Enable voting mechanisms for board decisions <code>enable_consensus</code> <code>bool</code> <code>True</code> Enable consensus-building mechanisms <code>max_workers</code> <code>Optional[int]</code> <code>None</code> Maximum number of workers for parallel execution"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#core-methods","title":"Core Methods","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#run_board_meetingtask-imgnone","title":"<code>run_board_meeting(task, img=None)</code>","text":"<p>Conducts a board meeting to discuss and decide on the given task. This method orchestrates the complete board meeting process, including discussion, decision-making, and task distribution planning.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>task</code> <code>str</code> Required The task to be discussed and planned by the board <code>img</code> <code>str</code> <code>None</code> Optional image to be used with the task"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#returns","title":"Returns","text":"Type Description <code>BoardSpec</code> The board's plan and orders"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example","title":"Example","text":"<pre><code>from swarms import Agent\nfrom swarms.structs.board_of_directors_swarm import (\n    BoardOfDirectorsSwarm,\n    BoardMember,\n    BoardMemberRole\n)\n\n# Create board members\nchairman = Agent(\n    agent_name=\"Chairman\",\n    agent_description=\"Chairman of the Board responsible for leading meetings\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Chairman of the Board...\"\n)\n\nvice_chairman = Agent(\n    agent_name=\"Vice-Chairman\",\n    agent_description=\"Vice Chairman who supports the Chairman\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Vice Chairman...\"\n)\n\n# Create BoardMember objects\nboard_members = [\n    BoardMember(chairman, BoardMemberRole.CHAIRMAN, 1.5, [\"leadership\", \"strategy\"]),\n    BoardMember(vice_chairman, BoardMemberRole.VICE_CHAIRMAN, 1.2, [\"operations\", \"coordination\"]),\n]\n\n# Create worker agents\nresearch_agent = Agent(\n    agent_name=\"Research-Specialist\",\n    agent_description=\"Expert in market research and analysis\",\n    model_name=\"gpt-4o\",\n)\n\nfinancial_agent = Agent(\n    agent_name=\"Financial-Analyst\",\n    agent_description=\"Specialist in financial analysis and valuation\",\n    model_name=\"gpt-4o\",\n)\n\n# Initialize the Board of Directors swarm\nboard_swarm = BoardOfDirectorsSwarm(\n    name=\"Executive_Board_Swarm\",\n    description=\"Executive board with specialized roles for strategic decision-making\",\n    board_members=board_members,\n    agents=[research_agent, financial_agent],\n    max_loops=2,\n    verbose=True,\n    decision_threshold=0.6,\n    enable_voting=True,\n    enable_consensus=True,\n)\n\n# Run a board meeting\nboard_spec = board_swarm.run_board_meeting(\n    task=\"Analyze the market potential for Tesla (TSLA) stock\"\n)\nprint(f\"Board Plan: {board_spec.plan}\")\nprint(f\"Number of Orders: {len(board_spec.orders)}\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#steptask-imgnone-args-kwargs","title":"<code>step(task, img=None, *args, **kwargs)</code>","text":"<p>Executes a single step of the Board of Directors swarm. This method runs one complete cycle of board meeting and task execution, including board discussion, task distribution, and optional feedback.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>task</code> <code>str</code> Required The task to be executed <code>img</code> <code>str</code> <code>None</code> Optional image input <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#returns_1","title":"Returns","text":"Type Description <code>Any</code> The result of the step execution"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_1","title":"Example","text":"<pre><code># Execute a single step\nresult = board_swarm.step(\n    task=\"Analyze the market potential for Tesla (TSLA) stock\"\n)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#runtask-imgnone-args-kwargs","title":"<code>run(task, img=None, *args, **kwargs)</code>","text":"<p>Executes the Board of Directors swarm for a specified number of feedback loops, processing the task through multiple iterations for refinement and improvement.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>task</code> <code>str</code> Required The initial task to be processed by the swarm <code>img</code> <code>str</code> <code>None</code> Optional image input for the agents <code>*args</code> <code>Any</code> - Additional positional arguments <code>**kwargs</code> <code>Any</code> - Additional keyword arguments"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#returns_2","title":"Returns","text":"Type Description <code>Any</code> The formatted conversation history as output based on <code>output_type</code>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_2","title":"Example","text":"<pre><code># Run the complete swarm with multiple loops\nresult = board_swarm.run(\n    task=\"Analyze the market potential for Tesla (TSLA) stock\"\n)\nprint(result)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#board-management-methods","title":"Board Management Methods","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#add_board_memberboard_member","title":"<code>add_board_member(board_member)</code>","text":"<p>Adds a new member to the Board of Directors.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters_3","title":"Parameters","text":"Parameter Type Description <code>board_member</code> <code>BoardMember</code> The board member to add"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_3","title":"Example","text":"<pre><code># Create a new board member\ntreasurer = Agent(\n    agent_name=\"Treasurer\",\n    agent_description=\"Board Treasurer responsible for financial oversight\",\n    model_name=\"gpt-4o-mini\",\n    system_prompt=\"You are the Treasurer...\"\n)\n\ntreasurer_member = BoardMember(\n    treasurer, \n    BoardMemberRole.TREASURER, \n    1.0, \n    [\"finance\", \"budgeting\"]\n)\n\n# Add to the board\nboard_swarm.add_board_member(treasurer_member)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#remove_board_memberagent_name","title":"<code>remove_board_member(agent_name)</code>","text":"<p>Removes a board member by agent name.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters_4","title":"Parameters","text":"Parameter Type Description <code>agent_name</code> <code>str</code> The name of the agent to remove from the board"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_4","title":"Example","text":"<pre><code># Remove a board member\nboard_swarm.remove_board_member(\"Treasurer\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#get_board_memberagent_name","title":"<code>get_board_member(agent_name)</code>","text":"<p>Gets a board member by agent name.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#parameters_5","title":"Parameters","text":"Parameter Type Description <code>agent_name</code> <code>str</code> The name of the agent"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#returns_3","title":"Returns","text":"Type Description <code>Optional[BoardMember]</code> The board member if found, None otherwise"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_5","title":"Example","text":"<pre><code># Get a specific board member\nchairman_member = board_swarm.get_board_member(\"Chairman\")\nif chairman_member:\n    print(f\"Chairman voting weight: {chairman_member.voting_weight}\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#get_board_summary","title":"<code>get_board_summary()</code>","text":"<p>Gets a comprehensive summary of the Board of Directors.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#returns_4","title":"Returns","text":"Type Description <code>Dict[str, Any]</code> Summary of the board structure and members"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#example_6","title":"Example","text":"<pre><code># Get board summary\nsummary = board_swarm.get_board_summary()\nprint(f\"Board Name: {summary['board_name']}\")\nprint(f\"Total Members: {summary['total_members']}\")\nprint(f\"Total Agents: {summary['total_agents']}\")\nprint(f\"Decision Threshold: {summary['decision_threshold']}\")\n\nfor member in summary['members']:\n    print(f\"- {member['name']} ({member['role']}): Weight {member['voting_weight']}\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#configuration-management","title":"Configuration Management","text":"<p>The Board of Directors feature can be configured through the <code>BoardConfig</code> class:</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#enabling-the-feature","title":"Enabling the Feature","text":"<pre><code>from swarms.config.board_config import enable_board_feature, is_board_feature_enabled\n\n# Check if feature is enabled\nif not is_board_feature_enabled():\n    # Enable the feature\n    enable_board_feature()\n    print(\"Board of Directors feature enabled\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#configuration-options","title":"Configuration Options","text":"<pre><code>from swarms.config.board_config import (\n    set_board_size,\n    set_decision_threshold,\n    set_board_model,\n    enable_verbose_logging\n)\n\n# Configure board settings\nset_board_size(5)  # Set default board size to 5 members\nset_decision_threshold(0.7)  # Set decision threshold to 70%\nset_board_model(\"gpt-4o\")  # Set default model for board members\nenable_verbose_logging()  # Enable verbose logging\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#advanced-usage-examples","title":"Advanced Usage Examples","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#custom-board-template","title":"Custom Board Template","text":"<pre><code>from swarms.config.board_config import get_default_board_template\n\n# Get a predefined board template\nexecutive_template = get_default_board_template(\"executive\")\nprint(\"Executive template roles:\", executive_template[\"roles\"])\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#complex-task-orchestration","title":"Complex Task Orchestration","text":"<pre><code># Create a comprehensive board for financial analysis\nfinancial_board = BoardOfDirectorsSwarm(\n    name=\"Financial_Analysis_Board\",\n    description=\"Specialized board for financial analysis and investment decisions\",\n    board_members=create_financial_board_members(),\n    agents=create_financial_agents(),\n    max_loops=3,\n    verbose=True,\n    decision_threshold=0.75,  # Higher threshold for financial decisions\n    enable_voting=True,\n    enable_consensus=True,\n)\n\n# Execute complex financial analysis\nresult = financial_board.run(\n    task=\"Conduct comprehensive analysis of Apple Inc. (AAPL) including market position, financial health, and investment recommendation\"\n)\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#board-feedback-and-iteration","title":"Board Feedback and Iteration","text":"<pre><code># Enable board feedback for iterative improvement\nboard_swarm = BoardOfDirectorsSwarm(\n    board_feedback_on=True,  # Enable board feedback\n    max_loops=3,  # Allow multiple iterations\n    verbose=True,\n)\n\n# The board will provide feedback after each iteration\nresult = board_swarm.run(task=\"Your complex task here\")\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#best-practices","title":"Best Practices","text":"<ol> <li>Role Assignment: Assign appropriate roles based on expertise areas</li> <li>Voting Weights: Use voting weights to reflect member authority and expertise</li> <li>Decision Threshold: Set appropriate thresholds based on task complexity</li> <li>Board Size: Keep board size manageable (3-7 members recommended)</li> <li>Feedback Loops: Use multiple loops for complex tasks requiring refinement</li> <li>Logging: Enable verbose logging for debugging and monitoring</li> <li>Consensus Building: Use consensus mechanisms for critical decisions</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#error-handling","title":"Error Handling","text":"<p>The Board of Directors swarm includes comprehensive error handling:</p> <pre><code>try:\n    result = board_swarm.run(task=\"Your task\")\nexcept Exception as e:\n    print(f\"Board execution failed: {e}\")\n    # Handle error appropriately\n</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Parallel Execution: The swarm supports parallel task execution with configurable worker limits</li> <li>Memory Management: Conversation history is preserved but can be managed for long-running processes</li> <li>Model Selection: Choose appropriate models for board members based on task complexity</li> <li>Caching: Consider caching for repeated board decisions</li> </ul>"},{"location":"swarms/structs/board_of_directors/board_of_directors_swarm/#integration-with-other-swarms","title":"Integration with Other Swarms","text":"<p>The Board of Directors swarm can be integrated with other swarm architectures:</p> <pre><code># Use Board of Directors as a component in larger workflows\nfrom swarms.structs.sequential_workflow import SequentialWorkflow\n\n# Create a workflow that includes board decision-making\nworkflow = SequentialWorkflow([\n    board_swarm,  # Board makes decisions\n    other_swarm,  # Other swarm executes based on board decisions\n])\n</code></pre> <p>For more information on multi-agent architectures and advanced usage patterns, see the Multi-Agent Collaboration Guide. </p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/","title":"Board of Directors Workflow","text":"<p>The Board of Directors workflow is a sophisticated multi-stage process that ensures comprehensive task analysis, collaborative decision-making, and effective execution through specialized agents.</p>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#workflow-overview","title":"Workflow Overview","text":"<pre><code>graph TD\n    A[Task Input] --&gt; B[Initial Assessment]\n    B --&gt; C[Board Assembly]\n    C --&gt; D[Meeting Phase]\n    D --&gt; E[Decision Phase]\n    E --&gt; F[Execution Phase]\n    F --&gt; G[Review Phase]\n    G --&gt; H{Approval?}\n    H --&gt;|No| I[Refinement]\n    I --&gt; D\n    H --&gt;|Yes| J[Final Delivery]\n\n    style A fill:#e1f5fe\n    style J fill:#c8e6c9\n    style H fill:#fff3e0</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-1-initial-assessment","title":"Phase 1: Initial Assessment","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#task-analysis-and-board-preparation","title":"Task Analysis and Board Preparation","text":"<pre><code>flowchart LR\n    A[Task Received] --&gt; B[Complexity Assessment]\n    B --&gt; C[Resource Requirements]\n    C --&gt; D[Expertise Mapping]\n    D --&gt; E[Board Member Selection]\n    E --&gt; F[Meeting Scheduling]\n\n    subgraph \"Assessment Criteria\"\n        G[Task Complexity]\n        H[Time Constraints]\n        I[Resource Availability]\n        J[Expertise Requirements]\n    end\n\n    B --&gt; G\n    B --&gt; H\n    C --&gt; I\n    D --&gt; J</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#board-member-activation","title":"Board Member Activation","text":"<pre><code>sequenceDiagram\n    participant System\n    participant Chairman\n    participant Members\n    participant Agents\n\n    System-&gt;&gt;Chairman: Notify New Task\n    Chairman-&gt;&gt;System: Assess Task Requirements\n    System-&gt;&gt;Members: Activate Relevant Members\n    Members-&gt;&gt;Chairman: Confirm Availability\n    Chairman-&gt;&gt;Agents: Prepare Agent Pool\n    Agents-&gt;&gt;Chairman: Confirm Readiness\n    Chairman-&gt;&gt;System: Board Ready for Meeting</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-2-board-meeting","title":"Phase 2: Board Meeting","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#meeting-structure","title":"Meeting Structure","text":"<pre><code>graph TD\n    A[Meeting Opens] --&gt; B[Agenda Review]\n    B --&gt; C[Task Presentation]\n    C --&gt; D[Expertise Assignment]\n    D --&gt; E[Individual Analysis]\n    E --&gt; F[Group Discussion]\n    F --&gt; G[Proposal Development]\n    G --&gt; H[Voting Process]\n    H --&gt; I[Consensus Building]\n    I --&gt; J[Plan Finalization]\n\n    subgraph \"Meeting Components\"\n        K[Time Management]\n        L[Documentation]\n        M[Conflict Resolution]\n        N[Decision Recording]\n    end\n\n    A --&gt; K\n    F --&gt; L\n    I --&gt; M\n    J --&gt; N</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#discussion-and-debate-process","title":"Discussion and Debate Process","text":"<pre><code>flowchart TD\n    A[Topic Introduction] --&gt; B[Expert Analysis]\n    B --&gt; C[Cross-Examination]\n    C --&gt; D[Alternative Proposals]\n    D --&gt; E[Pros/Cons Analysis]\n    E --&gt; F[Risk Assessment]\n    F --&gt; G[Resource Evaluation]\n    G --&gt; H[Consensus Check]\n    H --&gt;|No Consensus| I[Mediation]\n    I --&gt; B\n    H --&gt;|Consensus| J[Proposal Finalization]\n\n    style A fill:#e3f2fd\n    style J fill:#e8f5e8</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-3-decision-making","title":"Phase 3: Decision Making","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#voting-mechanism","title":"Voting Mechanism","text":"<pre><code>graph LR\n    subgraph \"Voting Process\"\n        A[Proposal Presentation]\n        B[Individual Voting]\n        C[Weight Calculation]\n        D[Threshold Check]\n        E[Decision Outcome]\n    end\n\n    subgraph \"Voting Weights\"\n        F[Chairman: 1.5]\n        G[Vice Chairman: 1.2]\n        H[Executive Director: 1.5]\n        I[Secretary: 1.0]\n        J[Treasurer: 1.0]\n        K[Member: 1.0]\n    end\n\n    A --&gt; B\n    B --&gt; C\n    C --&gt; D\n    D --&gt; E\n\n    F --&gt; C\n    G --&gt; C\n    H --&gt; C\n    I --&gt; C\n    J --&gt; C\n    K --&gt; C</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#consensus-building","title":"Consensus Building","text":"<pre><code>flowchart TD\n    A[Initial Vote] --&gt; B{Consensus Reached?}\n    B --&gt;|Yes| C[Decision Approved]\n    B --&gt;|No| D[Identify Disagreements]\n    D --&gt; E[Reconciliation Discussion]\n    E --&gt; F[Proposal Modification]\n    F --&gt; G[Re-vote]\n    G --&gt; B\n\n    subgraph \"Consensus Strategies\"\n        H[Compromise Solutions]\n        I[Expert Mediation]\n        J[Alternative Approaches]\n        K[Time Extension]\n    end\n\n    D --&gt; H\n    D --&gt; I\n    D --&gt; J\n    D --&gt; K</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-4-execution-planning","title":"Phase 4: Execution Planning","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#task-distribution-strategy","title":"Task Distribution Strategy","text":"<pre><code>graph TD\n    A[Approved Plan] --&gt; B[Task Breakdown]\n    B --&gt; C[Agent Assignment]\n    C --&gt; D[Resource Allocation]\n    D --&gt; E[Timeline Creation]\n    E --&gt; F[Quality Standards]\n    F --&gt; G[Execution Orders]\n\n    subgraph \"Assignment Criteria\"\n        H[Agent Expertise]\n        I[Current Workload]\n        J[Resource Requirements]\n        K[Time Constraints]\n    end\n\n    C --&gt; H\n    C --&gt; I\n    D --&gt; J\n    E --&gt; K</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#order-creation-and-distribution","title":"Order Creation and Distribution","text":"<pre><code>sequenceDiagram\n    participant Board\n    participant Chairman\n    participant Secretary\n    participant Agents\n\n    Board-&gt;&gt;Chairman: Approve Execution Plan\n    Chairman-&gt;&gt;Secretary: Create Formal Orders\n    Secretary-&gt;&gt;Chairman: Document Orders\n    Chairman-&gt;&gt;Agents: Distribute Orders\n    Agents-&gt;&gt;Chairman: Acknowledge Orders\n    Agents-&gt;&gt;Secretary: Confirm Understanding\n    Secretary-&gt;&gt;Board: Order Distribution Complete</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-5-execution-and-monitoring","title":"Phase 5: Execution and Monitoring","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#parallel-execution-flow","title":"Parallel Execution Flow","text":"<pre><code>graph LR\n    subgraph \"Agent Execution\"\n        A[Agent 1]\n        B[Agent 2]\n        C[Agent 3]\n        D[Agent N]\n    end\n\n    subgraph \"Monitoring\"\n        E[Progress Tracking]\n        F[Quality Control]\n        G[Resource Monitoring]\n        H[Issue Detection]\n    end\n\n    subgraph \"Communication\"\n        I[Status Reports]\n        J[Issue Escalation]\n        K[Resource Requests]\n        L[Completion Notifications]\n    end\n\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    D --&gt; E\n\n    E --&gt; F\n    F --&gt; G\n    G --&gt; H\n\n    H --&gt; I\n    H --&gt; J\n    H --&gt; K\n    H --&gt; L</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#real-time-monitoring","title":"Real-time Monitoring","text":"<pre><code>flowchart TD\n    A[Execution Start] --&gt; B[Progress Monitoring]\n    B --&gt; C[Quality Assessment]\n    C --&gt; D[Resource Tracking]\n    D --&gt; E{Issues Detected?}\n    E --&gt;|Yes| F[Issue Resolution]\n    F --&gt; G[Plan Adjustment]\n    G --&gt; B\n    E --&gt;|No| H[Continue Execution]\n    H --&gt; I{All Tasks Complete?}\n    I --&gt;|No| B\n    I --&gt;|Yes| J[Result Aggregation]</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#phase-6-review-and-feedback","title":"Phase 6: Review and Feedback","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#result-evaluation","title":"Result Evaluation","text":"<pre><code>graph TD\n    A[Results Collected] --&gt; B[Quality Assessment]\n    B --&gt; C[Compliance Check]\n    C --&gt; D[Performance Analysis]\n    D --&gt; E[Stakeholder Review]\n    E --&gt; F[Approval Decision]\n\n    subgraph \"Evaluation Criteria\"\n        G[Quality Standards]\n        H[Timeline Adherence]\n        I[Resource Efficiency]\n        J[Stakeholder Satisfaction]\n    end\n\n    B --&gt; G\n    C --&gt; H\n    D --&gt; I\n    E --&gt; J</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#feedback-loop-process","title":"Feedback Loop Process","text":"<pre><code>flowchart TD\n    A[Review Results] --&gt; B{Meet Standards?}\n    B --&gt;|Yes| C[Approve Results]\n    B --&gt;|No| D[Identify Issues]\n    D --&gt; E[Root Cause Analysis]\n    E --&gt; F[Plan Refinement]\n    F --&gt; G[Re-execution]\n    G --&gt; A\n\n    subgraph \"Feedback Types\"\n        H[Quality Issues]\n        I[Timeline Delays]\n        J[Resource Overruns]\n        K[Scope Changes]\n    end\n\n    D --&gt; H\n    D --&gt; I\n    D --&gt; J\n    D --&gt; K</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#quality-assurance","title":"Quality Assurance","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#multi-level-quality-control","title":"Multi-Level Quality Control","text":"<pre><code>graph TD\n    A[Agent Self-Check] --&gt; B[Peer Review]\n    B --&gt; C[Board Review]\n    C --&gt; D[Stakeholder Validation]\n    D --&gt; E[Final Approval]\n\n    subgraph \"Quality Gates\"\n        F[Completeness Check]\n        G[Accuracy Verification]\n        H[Compliance Validation]\n        I[Performance Metrics]\n    end\n\n    A --&gt; F\n    B --&gt; G\n    C --&gt; H\n    D --&gt; I</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#performance-metrics","title":"Performance Metrics","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#key-performance-indicators","title":"Key Performance Indicators","text":"<pre><code>graph LR\n    subgraph \"Efficiency Metrics\"\n        A[Execution Time]\n        B[Resource Utilization]\n        C[Cost Effectiveness]\n    end\n\n    subgraph \"Quality Metrics\"\n        D[Accuracy Rate]\n        E[Compliance Score]\n        F[Stakeholder Satisfaction]\n    end\n\n    subgraph \"Process Metrics\"\n        G[Decision Speed]\n        H[Consensus Time]\n        I[Iteration Count]\n    end\n\n    A --&gt; D\n    B --&gt; E\n    C --&gt; F\n\n    G --&gt; A\n    H --&gt; B\n    I --&gt; C</code></pre>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#best-practices","title":"Best Practices","text":""},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#workflow-optimization","title":"Workflow Optimization","text":"<ol> <li>Clear Role Definition: Ensure each board member understands their responsibilities</li> <li>Efficient Communication: Use structured communication channels for updates</li> <li>Proactive Monitoring: Implement real-time monitoring to catch issues early</li> <li>Flexible Planning: Allow for plan adjustments based on execution feedback</li> <li>Quality Focus: Maintain high standards throughout the execution process</li> <li>Documentation: Keep comprehensive records of decisions and actions</li> <li>Continuous Improvement: Learn from each execution cycle</li> </ol>"},{"location":"swarms/structs/board_of_directors/board_of_directors_workflow/#common-pitfalls-to-avoid","title":"Common Pitfalls to Avoid","text":"<ul> <li>Rushing Decisions: Allow adequate time for thorough analysis</li> <li>Ignoring Feedback: Always consider agent feedback and concerns</li> <li>Poor Communication: Ensure clear communication between board and agents</li> <li>Inflexible Plans: Be prepared to adjust plans based on new information</li> <li>Inadequate Monitoring: Monitor progress regularly to catch issues early</li> </ul> <p>For more information on implementing the Board of Directors workflow, see the Board of Directors Configuration Guide and Advanced Examples. </p>"},{"location":"swarms/tools/base_tool/","title":"BaseTool Class Documentation","text":""},{"location":"swarms/tools/base_tool/#overview","title":"Overview","text":"<p>The <code>BaseTool</code> class is a comprehensive tool management system for function calling, schema conversion, and execution. It provides a unified interface for converting Python functions to OpenAI function calling schemas, managing Pydantic models, executing tools with proper error handling, and supporting multiple AI provider formats (OpenAI, Anthropic, etc.).</p> <p>Key Features:</p> <ul> <li> <p>Convert Python functions to OpenAI function calling schemas</p> </li> <li> <p>Manage Pydantic models and their schemas  </p> </li> <li> <p>Execute tools with proper error handling and validation</p> </li> <li> <p>Support for parallel and sequential function execution</p> </li> <li> <p>Schema validation for multiple AI providers</p> </li> <li> <p>Automatic tool execution from API responses</p> </li> <li> <p>Caching for improved performance</p> </li> </ul>"},{"location":"swarms/tools/base_tool/#initialization-parameters","title":"Initialization Parameters","text":"Parameter Type Default Description <code>verbose</code> <code>Optional[bool]</code> <code>None</code> Enable detailed logging output <code>base_models</code> <code>Optional[List[type[BaseModel]]]</code> <code>None</code> List of Pydantic models to manage <code>autocheck</code> <code>Optional[bool]</code> <code>None</code> Enable automatic validation checks <code>auto_execute_tool</code> <code>Optional[bool]</code> <code>None</code> Enable automatic tool execution <code>tools</code> <code>Optional[List[Callable[..., Any]]]</code> <code>None</code> List of callable functions to manage <code>tool_system_prompt</code> <code>Optional[str]</code> <code>None</code> System prompt for tool operations <code>function_map</code> <code>Optional[Dict[str, Callable]]</code> <code>None</code> Mapping of function names to callables <code>list_of_dicts</code> <code>Optional[List[Dict[str, Any]]]</code> <code>None</code> List of dictionary representations"},{"location":"swarms/tools/base_tool/#methods-overview","title":"Methods Overview","text":"Method Description <code>func_to_dict</code> Convert a callable function to OpenAI function calling schema <code>load_params_from_func_for_pybasemodel</code> Load function parameters for Pydantic BaseModel integration <code>base_model_to_dict</code> Convert Pydantic BaseModel to OpenAI schema dictionary <code>multi_base_models_to_dict</code> Convert multiple Pydantic BaseModels to OpenAI schema <code>dict_to_openai_schema_str</code> Convert dictionary to OpenAI schema string <code>multi_dict_to_openai_schema_str</code> Convert multiple dictionaries to OpenAI schema string <code>get_docs_from_callable</code> Extract documentation from callable items <code>execute_tool</code> Execute a tool based on response string <code>detect_tool_input_type</code> Detect the type of tool input <code>dynamic_run</code> Execute dynamic run with automatic type detection <code>execute_tool_by_name</code> Search for and execute tool by name <code>execute_tool_from_text</code> Execute tool from JSON-formatted string <code>check_str_for_functions_valid</code> Check if output is valid JSON with matching function <code>convert_funcs_into_tools</code> Convert all functions in tools list to OpenAI format <code>convert_tool_into_openai_schema</code> Convert tools into OpenAI function calling schema <code>check_func_if_have_docs</code> Check if function has proper documentation <code>check_func_if_have_type_hints</code> Check if function has proper type hints <code>find_function_name</code> Find function by name in tools list <code>function_to_dict</code> Convert function to dictionary representation <code>multiple_functions_to_dict</code> Convert multiple functions to dictionary representations <code>execute_function_with_dict</code> Execute function using dictionary of parameters <code>execute_multiple_functions_with_dict</code> Execute multiple functions with parameter dictionaries <code>validate_function_schema</code> Validate function schema for different AI providers <code>get_schema_provider_format</code> Get detected provider format of schema <code>convert_schema_between_providers</code> Convert schema between provider formats <code>execute_function_calls_from_api_response</code> Execute function calls from API responses <code>detect_api_response_format</code> Detect the format of API response"},{"location":"swarms/tools/base_tool/#detailed-method-documentation","title":"Detailed Method Documentation","text":""},{"location":"swarms/tools/base_tool/#func_to_dict","title":"<code>func_to_dict</code>","text":"<p>Description: Convert a callable function to OpenAI function calling schema dictionary.</p> <p>Arguments: - <code>function</code> (Callable[..., Any], optional): The function to convert</p> <p>Returns: <code>Dict[str, Any]</code> - OpenAI function calling schema dictionary</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef add_numbers(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers together.\"\"\"\n    return a + b\n\n# Create BaseTool instance\ntool = BaseTool(verbose=True)\n\n# Convert function to OpenAI schema\nschema = tool.func_to_dict(add_numbers)\nprint(schema)\n# Output: {'type': 'function', 'function': {'name': 'add_numbers', 'description': 'Add two numbers together.', 'parameters': {...}}}\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#load_params_from_func_for_pybasemodel","title":"<code>load_params_from_func_for_pybasemodel</code>","text":"<p>Description: Load and process function parameters for Pydantic BaseModel integration.</p> <p>Arguments:</p> <ul> <li> <p><code>func</code> (Callable[..., Any]): The function to process</p> </li> <li> <p><code>*args</code>: Additional positional arguments</p> </li> <li> <p><code>**kwargs</code>: Additional keyword arguments</p> </li> </ul> <p>Returns: <code>Callable[..., Any]</code> - Processed function with loaded parameters</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef calculate_area(length: float, width: float) -&gt; float:\n    \"\"\"Calculate area of a rectangle.\"\"\"\n    return length * width\n\ntool = BaseTool()\nprocessed_func = tool.load_params_from_func_for_pybasemodel(calculate_area)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#base_model_to_dict","title":"<code>base_model_to_dict</code>","text":"<p>Description: Convert a Pydantic BaseModel to OpenAI function calling schema dictionary.</p> <p>Arguments:</p> <ul> <li> <p><code>pydantic_type</code> (type[BaseModel]): The Pydantic model class to convert</p> </li> <li> <p><code>*args</code>: Additional positional arguments</p> </li> <li> <p><code>**kwargs</code>: Additional keyword arguments</p> </li> </ul> <p>Returns: <code>dict[str, Any]</code> - OpenAI function calling schema dictionary</p> <p>Example: <pre><code>from pydantic import BaseModel\nfrom swarms.tools.base_tool import BaseTool\n\nclass UserInfo(BaseModel):\n    name: str\n    age: int\n    email: str\n\ntool = BaseTool()\nschema = tool.base_model_to_dict(UserInfo)\nprint(schema)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#multi_base_models_to_dict","title":"<code>multi_base_models_to_dict</code>","text":"<p>Description: Convert multiple Pydantic BaseModels to OpenAI function calling schema.</p> <p>Arguments: - <code>base_models</code> (List[BaseModel]): List of Pydantic models to convert</p> <p>Returns: <code>dict[str, Any]</code> - Combined OpenAI function calling schema</p> <p>Example: <pre><code>from pydantic import BaseModel\nfrom swarms.tools.base_tool import BaseTool\n\nclass User(BaseModel):\n    name: str\n    age: int\n\nclass Product(BaseModel):\n    name: str\n    price: float\n\ntool = BaseTool()\nschemas = tool.multi_base_models_to_dict([User, Product])\nprint(schemas)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#dict_to_openai_schema_str","title":"<code>dict_to_openai_schema_str</code>","text":"<p>Description: Convert a dictionary to OpenAI function calling schema string.</p> <p>Arguments:</p> <ul> <li><code>dict</code> (dict[str, Any]): Dictionary to convert</li> </ul> <p>Returns: <code>str</code> - OpenAI schema string representation</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\nmy_dict = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"get_weather\",\n        \"description\": \"Get weather information\",\n        \"parameters\": {\"type\": \"object\", \"properties\": {\"city\": {\"type\": \"string\"}}}\n    }\n}\n\ntool = BaseTool()\nschema_str = tool.dict_to_openai_schema_str(my_dict)\nprint(schema_str)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#multi_dict_to_openai_schema_str","title":"<code>multi_dict_to_openai_schema_str</code>","text":"<p>Description: Convert multiple dictionaries to OpenAI function calling schema string.</p> <p>Arguments:</p> <ul> <li><code>dicts</code> (list[dict[str, Any]]): List of dictionaries to convert</li> </ul> <p>Returns: <code>str</code> - Combined OpenAI schema string representation</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndict1 = {\"type\": \"function\", \"function\": {\"name\": \"func1\", \"description\": \"Function 1\"}}\ndict2 = {\"type\": \"function\", \"function\": {\"name\": \"func2\", \"description\": \"Function 2\"}}\n\ntool = BaseTool()\nschema_str = tool.multi_dict_to_openai_schema_str([dict1, dict2])\nprint(schema_str)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#get_docs_from_callable","title":"<code>get_docs_from_callable</code>","text":"<p>Description: Extract documentation from a callable item.</p> <p>Arguments:</p> <ul> <li><code>item</code>: The callable item to extract documentation from</li> </ul> <p>Returns: Processed documentation</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef example_function():\n    \"\"\"This is an example function with documentation.\"\"\"\n    pass\n\ntool = BaseTool()\ndocs = tool.get_docs_from_callable(example_function)\nprint(docs)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_tool","title":"<code>execute_tool</code>","text":"<p>Description: Execute a tool based on a response string.</p> <p>Arguments: - <code>response</code> (str): JSON response string containing tool execution details</p> <ul> <li> <p><code>*args</code>: Additional positional arguments</p> </li> <li> <p><code>**kwargs</code>: Additional keyword arguments</p> </li> </ul> <p>Returns: <code>Callable</code> - Result of the tool execution</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef greet(name: str) -&gt; str:\n    \"\"\"Greet a person by name.\"\"\"\n    return f\"Hello, {name}!\"\n\ntool = BaseTool(tools=[greet])\nresponse = '{\"name\": \"greet\", \"parameters\": {\"name\": \"Alice\"}}'\nresult = tool.execute_tool(response)\nprint(result)  # Output: \"Hello, Alice!\"\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#detect_tool_input_type","title":"<code>detect_tool_input_type</code>","text":"<p>Description: Detect the type of tool input for appropriate processing.</p> <p>Arguments:</p> <ul> <li><code>input</code> (ToolType): The input to analyze</li> </ul> <p>Returns: <code>str</code> - Type of the input (\"Pydantic\", \"Dictionary\", \"Function\", or \"Unknown\")</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\nfrom pydantic import BaseModel\n\nclass MyModel(BaseModel):\n    value: int\n\ndef my_function():\n    pass\n\ntool = BaseTool()\nprint(tool.detect_tool_input_type(MyModel))  # \"Pydantic\"\nprint(tool.detect_tool_input_type(my_function))  # \"Function\"\nprint(tool.detect_tool_input_type({\"key\": \"value\"}))  # \"Dictionary\"\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#dynamic_run","title":"<code>dynamic_run</code>","text":"<p>Description: Execute a dynamic run based on the input type with automatic type detection.</p> <p>Arguments: - <code>input</code> (Any): The input to be processed (Pydantic model, dict, or function)</p> <p>Returns: <code>str</code> - The result of the dynamic run (schema string or execution result)</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef multiply(x: int, y: int) -&gt; int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return x * y\n\ntool = BaseTool(auto_execute_tool=False)\nresult = tool.dynamic_run(multiply)\nprint(result)  # Returns OpenAI schema string\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_tool_by_name","title":"<code>execute_tool_by_name</code>","text":"<p>Description: Search for a tool by name and execute it with the provided response.</p> <p>Arguments: - <code>tool_name</code> (str): The name of the tool to execute</p> <ul> <li><code>response</code> (str): JSON response string containing execution parameters</li> </ul> <p>Returns: <code>Any</code> - The result of executing the tool</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef calculate_sum(a: int, b: int) -&gt; int:\n    \"\"\"Calculate sum of two numbers.\"\"\"\n    return a + b\n\ntool = BaseTool(function_map={\"calculate_sum\": calculate_sum})\nresult = tool.execute_tool_by_name(\"calculate_sum\", '{\"a\": 5, \"b\": 3}')\nprint(result)  # Output: 8\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_tool_from_text","title":"<code>execute_tool_from_text</code>","text":"<p>Description: Convert a JSON-formatted string into a tool dictionary and execute the tool.</p> <p>Arguments: - <code>text</code> (str): A JSON-formatted string representing a tool call with 'name' and 'parameters' keys</p> <p>Returns: <code>Any</code> - The result of executing the tool</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef divide(x: float, y: float) -&gt; float:\n    \"\"\"Divide x by y.\"\"\"\n    return x / y\n\ntool = BaseTool(function_map={\"divide\": divide})\ntext = '{\"name\": \"divide\", \"parameters\": {\"x\": 10, \"y\": 2}}'\nresult = tool.execute_tool_from_text(text)\nprint(result)  # Output: 5.0\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#check_str_for_functions_valid","title":"<code>check_str_for_functions_valid</code>","text":"<p>Description: Check if the output is a valid JSON string with a function name that matches the function map.</p> <p>Arguments: - <code>output</code> (str): The output string to validate</p> <p>Returns: <code>bool</code> - True if the output is valid and the function name matches, False otherwise</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef test_func():\n    pass\n\ntool = BaseTool(function_map={\"test_func\": test_func})\nvalid_output = '{\"type\": \"function\", \"function\": {\"name\": \"test_func\"}}'\nis_valid = tool.check_str_for_functions_valid(valid_output)\nprint(is_valid)  # Output: True\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#convert_funcs_into_tools","title":"<code>convert_funcs_into_tools</code>","text":"<p>Description: Convert all functions in the tools list into OpenAI function calling format.</p> <p>Arguments: None</p> <p>Returns: None (modifies internal state)</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef func1(x: int) -&gt; int:\n    \"\"\"Function 1.\"\"\"\n    return x * 2\n\ndef func2(y: str) -&gt; str:\n    \"\"\"Function 2.\"\"\"\n    return y.upper()\n\ntool = BaseTool(tools=[func1, func2])\ntool.convert_funcs_into_tools()\nprint(tool.function_map)  # {'func1': &lt;function func1&gt;, 'func2': &lt;function func2&gt;}\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#convert_tool_into_openai_schema","title":"<code>convert_tool_into_openai_schema</code>","text":"<p>Description: Convert tools into OpenAI function calling schema format.</p> <p>Arguments: None</p> <p>Returns: <code>dict[str, Any]</code> - Combined OpenAI function calling schema</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef subtract(a: int, b: int) -&gt; int:\n    \"\"\"Subtract b from a.\"\"\"\n    return a - b\n\ntool = BaseTool(tools=[add, subtract])\nschema = tool.convert_tool_into_openai_schema()\nprint(schema)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#check_func_if_have_docs","title":"<code>check_func_if_have_docs</code>","text":"<p>Description: Check if a function has proper documentation.</p> <p>Arguments:</p> <ul> <li><code>func</code> (callable): The function to check</li> </ul> <p>Returns: <code>bool</code> - True if function has documentation</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef documented_func():\n    \"\"\"This function has documentation.\"\"\"\n    pass\n\ndef undocumented_func():\n    pass\n\ntool = BaseTool()\nprint(tool.check_func_if_have_docs(documented_func))  # True\n# tool.check_func_if_have_docs(undocumented_func)  # Raises ToolDocumentationError\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#check_func_if_have_type_hints","title":"<code>check_func_if_have_type_hints</code>","text":"<p>Description: Check if a function has proper type hints.</p> <p>Arguments:</p> <ul> <li><code>func</code> (callable): The function to check</li> </ul> <p>Returns: <code>bool</code> - True if function has type hints</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef typed_func(x: int) -&gt; str:\n    \"\"\"A typed function.\"\"\"\n    return str(x)\n\ndef untyped_func(x):\n    \"\"\"An untyped function.\"\"\"\n    return str(x)\n\ntool = BaseTool()\nprint(tool.check_func_if_have_type_hints(typed_func))  # True\n# tool.check_func_if_have_type_hints(untyped_func)  # Raises ToolTypeHintError\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#find_function_name","title":"<code>find_function_name</code>","text":"<p>Description: Find a function by name in the tools list.</p> <p>Arguments: - <code>func_name</code> (str): The name of the function to find</p> <p>Returns: <code>Optional[callable]</code> - The function if found, None otherwise</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef my_function():\n    \"\"\"My function.\"\"\"\n    pass\n\ntool = BaseTool(tools=[my_function])\nfound_func = tool.find_function_name(\"my_function\")\nprint(found_func)  # &lt;function my_function at ...&gt;\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#function_to_dict","title":"<code>function_to_dict</code>","text":"<p>Description: Convert a function to dictionary representation.</p> <p>Arguments: - <code>func</code> (callable): The function to convert</p> <p>Returns: <code>dict</code> - Dictionary representation of the function</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef example_func(param: str) -&gt; str:\n    \"\"\"Example function.\"\"\"\n    return param\n\ntool = BaseTool()\nfunc_dict = tool.function_to_dict(example_func)\nprint(func_dict)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#multiple_functions_to_dict","title":"<code>multiple_functions_to_dict</code>","text":"<p>Description: Convert multiple functions to dictionary representations.</p> <p>Arguments:</p> <ul> <li><code>funcs</code> (list[callable]): List of functions to convert</li> </ul> <p>Returns: <code>list[dict]</code> - List of dictionary representations</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef func1(x: int) -&gt; int:\n    \"\"\"Function 1.\"\"\"\n    return x\n\ndef func2(y: str) -&gt; str:\n    \"\"\"Function 2.\"\"\"\n    return y\n\ntool = BaseTool()\nfunc_dicts = tool.multiple_functions_to_dict([func1, func2])\nprint(func_dicts)\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_function_with_dict","title":"<code>execute_function_with_dict</code>","text":"<p>Description: Execute a function using a dictionary of parameters.</p> <p>Arguments:</p> <ul> <li> <p><code>func_dict</code> (dict): Dictionary containing function parameters</p> </li> <li> <p><code>func_name</code> (Optional[str]): Name of function to execute (if not in dict)</p> </li> </ul> <p>Returns: <code>Any</code> - Result of function execution</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef power(base: int, exponent: int) -&gt; int:\n    \"\"\"Calculate base to the power of exponent.\"\"\"\n    return base ** exponent\n\ntool = BaseTool(tools=[power])\nresult = tool.execute_function_with_dict({\"base\": 2, \"exponent\": 3}, \"power\")\nprint(result)  # Output: 8\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_multiple_functions_with_dict","title":"<code>execute_multiple_functions_with_dict</code>","text":"<p>Description: Execute multiple functions using dictionaries of parameters.</p> <p>Arguments:</p> <ul> <li> <p><code>func_dicts</code> (list[dict]): List of dictionaries containing function parameters</p> </li> <li> <p><code>func_names</code> (Optional[list[str]]): Optional list of function names</p> </li> </ul> <p>Returns: <code>list[Any]</code> - List of results from function executions</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers.\"\"\"\n    return a + b\n\ndef multiply(a: int, b: int) -&gt; int:\n    \"\"\"Multiply two numbers.\"\"\"\n    return a * b\n\ntool = BaseTool(tools=[add, multiply])\nresults = tool.execute_multiple_functions_with_dict(\n    [{\"a\": 1, \"b\": 2}, {\"a\": 3, \"b\": 4}], \n    [\"add\", \"multiply\"]\n)\nprint(results)  # [3, 12]\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#validate_function_schema","title":"<code>validate_function_schema</code>","text":"<p>Description: Validate the schema of a function for different AI providers.</p> <p>Arguments:</p> <ul> <li> <p><code>schema</code> (Optional[Union[List[Dict[str, Any]], Dict[str, Any]]]): Function schema(s) to validate</p> </li> <li> <p><code>provider</code> (str): Target provider format (\"openai\", \"anthropic\", \"generic\", \"auto\")</p> </li> </ul> <p>Returns: <code>bool</code> - True if schema(s) are valid, False otherwise</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\nopenai_schema = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"add_numbers\",\n        \"description\": \"Add two numbers\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"a\": {\"type\": \"integer\"},\n                \"b\": {\"type\": \"integer\"}\n            },\n            \"required\": [\"a\", \"b\"]\n        }\n    }\n}\n\ntool = BaseTool()\nis_valid = tool.validate_function_schema(openai_schema, \"openai\")\nprint(is_valid)  # True\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#get_schema_provider_format","title":"<code>get_schema_provider_format</code>","text":"<p>Description: Get the detected provider format of a schema.</p> <p>Arguments:</p> <ul> <li><code>schema</code> (Dict[str, Any]): Function schema dictionary</li> </ul> <p>Returns: <code>str</code> - Provider format (\"openai\", \"anthropic\", \"generic\", \"unknown\")</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\nopenai_schema = {\n    \"type\": \"function\",\n    \"function\": {\"name\": \"test\", \"description\": \"Test function\"}\n}\n\ntool = BaseTool()\nprovider = tool.get_schema_provider_format(openai_schema)\nprint(provider)  # \"openai\"\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#convert_schema_between_providers","title":"<code>convert_schema_between_providers</code>","text":"<p>Description: Convert a function schema between different provider formats.</p> <p>Arguments:</p> <ul> <li> <p><code>schema</code> (Dict[str, Any]): Source function schema</p> </li> <li> <p><code>target_provider</code> (str): Target provider format (\"openai\", \"anthropic\", \"generic\")</p> </li> </ul> <p>Returns: <code>Dict[str, Any]</code> - Converted schema</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\nopenai_schema = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"test_func\",\n        \"description\": \"Test function\",\n        \"parameters\": {\"type\": \"object\", \"properties\": {}}\n    }\n}\n\ntool = BaseTool()\nanthropic_schema = tool.convert_schema_between_providers(openai_schema, \"anthropic\")\nprint(anthropic_schema)\n# Output: {\"name\": \"test_func\", \"description\": \"Test function\", \"input_schema\": {...}}\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#execute_function_calls_from_api_response","title":"<code>execute_function_calls_from_api_response</code>","text":"<p>Description: Automatically detect and execute function calls from OpenAI or Anthropic API responses.</p> <p>Arguments:</p> <ul> <li> <p><code>api_response</code> (Union[Dict[str, Any], str, List[Any]]): The API response containing function calls</p> </li> <li> <p><code>sequential</code> (bool): If True, execute functions sequentially. If False, execute in parallel</p> </li> <li> <p><code>max_workers</code> (int): Maximum number of worker threads for parallel execution</p> </li> <li> <p><code>return_as_string</code> (bool): If True, return results as formatted strings</p> </li> </ul> <p>Returns: <code>Union[List[Any], List[str]]</code> - List of results from executed functions</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\ndef get_weather(city: str) -&gt; str:\n    \"\"\"Get weather for a city.\"\"\"\n    return f\"Weather in {city}: Sunny, 25\u00b0C\"\n\n# Simulated OpenAI API response\nopenai_response = {\n    \"choices\": [{\n        \"message\": {\n            \"tool_calls\": [{\n                \"type\": \"function\",\n                \"function\": {\n                    \"name\": \"get_weather\",\n                    \"arguments\": '{\"city\": \"New York\"}'\n                },\n                \"id\": \"call_123\"\n            }]\n        }\n    }]\n}\n\ntool = BaseTool(tools=[get_weather])\nresults = tool.execute_function_calls_from_api_response(openai_response)\nprint(results)  # [\"Function 'get_weather' result:\\nWeather in New York: Sunny, 25\u00b0C\"]\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#detect_api_response_format","title":"<code>detect_api_response_format</code>","text":"<p>Description: Detect the format of an API response.</p> <p>Arguments:</p> <ul> <li><code>response</code> (Union[Dict[str, Any], str, BaseModel]): API response to analyze</li> </ul> <p>Returns: <code>str</code> - Detected format (\"openai\", \"anthropic\", \"generic\", \"unknown\")</p> <p>Example: <pre><code>from swarms.tools.base_tool import BaseTool\n\nopenai_response = {\n    \"choices\": [{\"message\": {\"tool_calls\": []}}]\n}\n\nanthropic_response = {\n    \"content\": [{\"type\": \"tool_use\", \"name\": \"test\", \"input\": {}}]\n}\n\ntool = BaseTool()\nprint(tool.detect_api_response_format(openai_response))  # \"openai\"\nprint(tool.detect_api_response_format(anthropic_response))  # \"anthropic\"\n</code></pre></p>"},{"location":"swarms/tools/base_tool/#exception-classes","title":"Exception Classes","text":"<p>The BaseTool class defines several custom exception classes for better error handling:</p> <ul> <li> <p><code>BaseToolError</code>: Base exception class for all BaseTool related errors</p> </li> <li> <p><code>ToolValidationError</code>: Raised when tool validation fails</p> </li> <li> <p><code>ToolExecutionError</code>: Raised when tool execution fails</p> </li> <li> <p><code>ToolNotFoundError</code>: Raised when a requested tool is not found</p> </li> <li> <p><code>FunctionSchemaError</code>: Raised when function schema conversion fails</p> </li> <li> <p><code>ToolDocumentationError</code>: Raised when tool documentation is missing or invalid</p> </li> <li> <p><code>ToolTypeHintError</code>: Raised when tool type hints are missing or invalid</p> </li> </ul>"},{"location":"swarms/tools/base_tool/#usage-tips","title":"Usage Tips","text":"<ol> <li>Always provide documentation and type hints for your functions when using BaseTool</li> <li>Use verbose=True during development for detailed logging</li> <li>Set up function_map for efficient tool execution by name</li> <li>Validate schemas before using them with different AI providers</li> <li>Use parallel execution for better performance when executing multiple functions</li> <li>Handle exceptions appropriately using the custom exception classes </li> </ol>"},{"location":"swarms/tools/build_tool/","title":"Swarms Tool Documentation","text":"<p>A tool is a Python function designed to perform specific tasks with clear type annotations and comprehensive docstrings. Below are examples of financial tools to help you get started.</p>"},{"location":"swarms/tools/build_tool/#rules","title":"Rules","text":"<p>To create a tool in the Swarms environment, follow these rules:</p> <ol> <li>Function Definition: </li> <li>The tool must be defined as a Python function.</li> <li> <p>The function should perform a specific task and be named appropriately.</p> </li> <li> <p>Type Annotations: </p> </li> <li>All arguments and the return value must have type annotations.</li> <li> <p>Both input and output types must be strings (<code>str</code>).</p> </li> <li> <p>Docstrings: </p> </li> <li> <p>Each function must include a comprehensive docstring that adheres to PEP 257 standards. The docstring should explain:</p> <ul> <li>The purpose of the function.</li> <li>Arguments: names, types, and descriptions.</li> <li>Return value: type and description.</li> <li>Potential exceptions that the function may raise.</li> </ul> </li> <li> <p>Input and Output Types:</p> </li> <li>The function's input must be a string.</li> <li>The function's output must be a string.</li> </ol>"},{"location":"swarms/tools/build_tool/#example-financial-tools","title":"Example Financial Tools","text":""},{"location":"swarms/tools/build_tool/#example-1-fetch-stock-price-from-yahoo-finance","title":"Example 1: Fetch Stock Price from Yahoo Finance","text":"<pre><code>import yfinance as yf\n\ndef get_stock_price(symbol: str) -&gt; str:\n    \"\"\"\n    Fetches the current stock price from Yahoo Finance.\n\n    Args:\n        symbol (str): The stock symbol (e.g., \"AAPL\", \"TSLA\", \"NVDA\").\n\n    Returns:\n        str: A formatted string containing the current stock price and basic information.\n\n    Raises:\n        ValueError: If the stock symbol is invalid or data cannot be retrieved.\n        Exception: If there is an error with the API request.\n    \"\"\"\n    try:\n        # Remove any whitespace and convert to uppercase\n        symbol = symbol.strip().upper()\n\n        if not symbol:\n            raise ValueError(\"Stock symbol cannot be empty.\")\n\n        # Fetch stock data\n        stock = yf.Ticker(symbol)\n        info = stock.info\n\n        if not info or 'regularMarketPrice' not in info:\n            raise ValueError(f\"Unable to fetch data for symbol: {symbol}\")\n\n        current_price = info.get('regularMarketPrice', 'N/A')\n        previous_close = info.get('regularMarketPreviousClose', 'N/A')\n        market_cap = info.get('marketCap', 'N/A')\n        company_name = info.get('longName', symbol)\n\n        # Format market cap for readability\n        if isinstance(market_cap, (int, float)) and market_cap &gt; 0:\n            if market_cap &gt;= 1e12:\n                market_cap_str = f\"${market_cap/1e12:.2f}T\"\n            elif market_cap &gt;= 1e9:\n                market_cap_str = f\"${market_cap/1e9:.2f}B\"\n            elif market_cap &gt;= 1e6:\n                market_cap_str = f\"${market_cap/1e6:.2f}M\"\n            else:\n                market_cap_str = f\"${market_cap:,.0f}\"\n        else:\n            market_cap_str = \"N/A\"\n\n        # Calculate price change\n        if isinstance(current_price, (int, float)) and isinstance(previous_close, (int, float)):\n            price_change = current_price - previous_close\n            price_change_percent = (price_change / previous_close) * 100\n            change_str = f\"{price_change:+.2f} ({price_change_percent:+.2f}%)\"\n        else:\n            change_str = \"N/A\"\n\n        result = f\"\"\"\nStock: {company_name} ({symbol})\nCurrent Price: ${current_price}\nPrevious Close: ${previous_close}\nChange: {change_str}\nMarket Cap: {market_cap_str}\n        \"\"\".strip()\n\n        return result\n\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error fetching stock data: {e}\")\n        raise\n</code></pre>"},{"location":"swarms/tools/build_tool/#example-2-fetch-cryptocurrency-price-from-coingecko","title":"Example 2: Fetch Cryptocurrency Price from CoinGecko","text":"<pre><code>import requests\n\ndef get_crypto_price(coin_id: str) -&gt; str:\n    \"\"\"\n    Fetches the current cryptocurrency price from CoinGecko API.\n\n    Args:\n        coin_id (str): The cryptocurrency ID (e.g., \"bitcoin\", \"ethereum\", \"cardano\").\n\n    Returns:\n        str: A formatted string containing the current crypto price and market data.\n\n    Raises:\n        ValueError: If the coin ID is invalid or data cannot be retrieved.\n        requests.exceptions.RequestException: If there is an error with the API request.\n    \"\"\"\n    try:\n        # Remove any whitespace and convert to lowercase\n        coin_id = coin_id.strip().lower()\n\n        if not coin_id:\n            raise ValueError(\"Coin ID cannot be empty.\")\n\n        url = f\"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id,\n            \"vs_currencies\": \"usd\",\n            \"include_market_cap\": \"true\",\n            \"include_24hr_vol\": \"true\",\n            \"include_24hr_change\": \"true\",\n            \"include_last_updated_at\": \"true\"\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n\n        if coin_id not in data:\n            raise ValueError(f\"Coin ID '{coin_id}' not found. Please check the spelling.\")\n\n        coin_data = data[coin_id]\n\n        if not coin_data:\n            raise ValueError(f\"No data available for coin ID: {coin_id}\")\n\n        usd_price = coin_data.get('usd', 'N/A')\n        market_cap = coin_data.get('usd_market_cap', 'N/A')\n        volume_24h = coin_data.get('usd_24h_vol', 'N/A')\n        change_24h = coin_data.get('usd_24h_change', 'N/A')\n        last_updated = coin_data.get('last_updated_at', 'N/A')\n\n        # Format large numbers for readability\n        def format_number(value):\n            if isinstance(value, (int, float)) and value &gt; 0:\n                if value &gt;= 1e12:\n                    return f\"${value/1e12:.2f}T\"\n                elif value &gt;= 1e9:\n                    return f\"${value/1e9:.2f}B\"\n                elif value &gt;= 1e6:\n                    return f\"${value/1e6:.2f}M\"\n                elif value &gt;= 1e3:\n                    return f\"${value/1e3:.2f}K\"\n                else:\n                    return f\"${value:,.2f}\"\n            return \"N/A\"\n\n        # Format the result\n        result = f\"\"\"\nCryptocurrency: {coin_id.title()}\nCurrent Price: ${usd_price:,.8f}\" if isinstance(usd_price, (int, float)) else f\"Current Price: {usd_price}\nMarket Cap: {format_number(market_cap)}\n24h Volume: {format_number(volume_24h)}\n24h Change: {change_24h:+.2f}%\" if isinstance(change_24h, (int, float)) else f\"24h Change: {change_24h}\nLast Updated: {last_updated}\n        \"\"\".strip()\n\n        return result\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Request Error: {e}\")\n        raise\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error fetching crypto data: {e}\")\n        raise\n</code></pre>"},{"location":"swarms/tools/build_tool/#example-3-calculate-portfolio-performance","title":"Example 3: Calculate Portfolio Performance","text":"<pre><code>def calculate_portfolio_performance(initial_investment_str: str, current_value_str: str, time_period_str: str) -&gt; str:\n    \"\"\"\n    Calculates portfolio performance metrics including return percentage and annualized return.\n\n    Args:\n        initial_investment_str (str): The initial investment amount as a string.\n        current_value_str (str): The current portfolio value as a string.\n        time_period_str (str): The time period in years as a string.\n\n    Returns:\n        str: A formatted string containing portfolio performance metrics.\n\n    Raises:\n        ValueError: If any of the inputs cannot be converted to the appropriate type or are negative.\n    \"\"\"\n    try:\n        initial_investment = float(initial_investment_str)\n        current_value = float(current_value_str)\n        time_period = float(time_period_str)\n\n        if initial_investment &lt;= 0 or current_value &lt; 0 or time_period &lt;= 0:\n            raise ValueError(\"Initial investment and time period must be positive, current value must be non-negative.\")\n\n        # Calculate total return\n        total_return = current_value - initial_investment\n        total_return_percentage = (total_return / initial_investment) * 100\n\n        # Calculate annualized return\n        if time_period &gt; 0:\n            annualized_return = ((current_value / initial_investment) ** (1 / time_period) - 1) * 100\n        else:\n            annualized_return = 0\n\n        # Determine performance status\n        if total_return &gt; 0:\n            status = \"Profitable\"\n        elif total_return &lt; 0:\n            status = \"Loss\"\n        else:\n            status = \"Break-even\"\n\n        result = f\"\"\"\nPortfolio Performance Analysis:\nInitial Investment: ${initial_investment:,.2f}\nCurrent Value: ${current_value:,.2f}\nTime Period: {time_period:.1f} years\n\nTotal Return: ${total_return:+,.2f} ({total_return_percentage:+.2f}%)\nAnnualized Return: {annualized_return:+.2f}%\nStatus: {status}\n        \"\"\".strip()\n\n        return result\n\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error calculating portfolio performance: {e}\")\n        raise\n</code></pre>"},{"location":"swarms/tools/build_tool/#example-4-calculate-compound-interest","title":"Example 4: Calculate Compound Interest","text":"<pre><code>def calculate_compound_interest(principal_str: str, rate_str: str, time_str: str, compounding_frequency_str: str) -&gt; str:\n    \"\"\"\n    Calculates compound interest for investment planning.\n\n    Args:\n        principal_str (str): The initial investment amount as a string.\n        rate_str (str): The annual interest rate (as decimal) as a string.\n        time_str (str): The investment time period in years as a string.\n        compounding_frequency_str (str): The number of times interest is compounded per year as a string.\n\n    Returns:\n        str: A formatted string containing the compound interest calculation results.\n\n    Raises:\n        ValueError: If any of the inputs cannot be converted to the appropriate type or are negative.\n    \"\"\"\n    try:\n        principal = float(principal_str)\n        rate = float(rate_str)\n        time = float(time_str)\n        n = int(compounding_frequency_str)\n\n        if principal &lt;= 0 or rate &lt; 0 or time &lt;= 0 or n &lt;= 0:\n            raise ValueError(\"Principal, time, and compounding frequency must be positive. Rate must be non-negative.\")\n\n        # Calculate compound interest\n        amount = principal * (1 + rate / n) ** (n * time)\n        interest_earned = amount - principal\n\n        # Calculate effective annual rate\n        effective_rate = ((1 + rate / n) ** n - 1) * 100\n\n        result = f\"\"\"\nCompound Interest Calculation:\nPrincipal: ${principal:,.2f}\nAnnual Rate: {rate*100:.2f}%\nTime Period: {time:.1f} years\nCompounding Frequency: {n} times per year\n\nFinal Amount: ${amount:,.2f}\nInterest Earned: ${interest_earned:,.2f}\nEffective Annual Rate: {effective_rate:.2f}%\n        \"\"\".strip()\n\n        return result\n\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error calculating compound interest: {e}\")\n        raise\n</code></pre>"},{"location":"swarms/tools/build_tool/#integrating-tools-into-an-agent","title":"Integrating Tools into an Agent","text":"<p>To integrate tools into an agent, simply pass callable functions with proper type annotations and documentation into the agent class.</p> <pre><code>from swarms import Agent\n\n# Initialize the financial analysis agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=(\n        \"You are a professional financial analyst agent. Use the provided tools to \"\n        \"analyze stocks, cryptocurrencies, and investment performance. Provide \"\n        \"clear, accurate financial insights and recommendations. Always format \"\n        \"responses in markdown for better readability.\"\n    ),\n    model_name=\"gpt-4o\",\n    max_loops=3,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"financial_agent.json\",\n    tools=[get_stock_price, get_crypto_price, calculate_portfolio_performance],\n    user_name=\"financial_analyst\",\n    retry_attempts=3,\n    context_length=200000,\n)\n\n# Run the agent\nresponse = agent(\"Analyze the current price of Apple stock and Bitcoin, then calculate the performance of a $10,000 investment in each over the past 2 years.\")\nprint(response)\n</code></pre>"},{"location":"swarms/tools/build_tool/#complete-financial-analysis-example","title":"Complete Financial Analysis Example","text":"<pre><code>import yfinance as yf\nimport requests\nfrom swarms import Agent\n\ndef get_stock_price(symbol: str) -&gt; str:\n    \"\"\"\n    Fetches the current stock price from Yahoo Finance.\n\n    Args:\n        symbol (str): The stock symbol (e.g., \"AAPL\", \"TSLA\", \"NVDA\").\n\n    Returns:\n        str: A formatted string containing the current stock price and basic information.\n\n    Raises:\n        ValueError: If the stock symbol is invalid or data cannot be retrieved.\n        Exception: If there is an error with the API request.\n    \"\"\"\n    try:\n        symbol = symbol.strip().upper()\n\n        if not symbol:\n            raise ValueError(\"Stock symbol cannot be empty.\")\n\n        stock = yf.Ticker(symbol)\n        info = stock.info\n\n        if not info or 'regularMarketPrice' not in info:\n            raise ValueError(f\"Unable to fetch data for symbol: {symbol}\")\n\n        current_price = info.get('regularMarketPrice', 'N/A')\n        previous_close = info.get('regularMarketPreviousClose', 'N/A')\n        market_cap = info.get('marketCap', 'N/A')\n        company_name = info.get('longName', symbol)\n\n        if isinstance(market_cap, (int, float)) and market_cap &gt; 0:\n            if market_cap &gt;= 1e12:\n                market_cap_str = f\"${market_cap/1e12:.2f}T\"\n            elif market_cap &gt;= 1e9:\n                market_cap_str = f\"${market_cap/1e9:.2f}B\"\n            elif market_cap &gt;= 1e6:\n                market_cap_str = f\"${market_cap/1e6:.2f}M\"\n            else:\n                market_cap_str = f\"${market_cap:,.0f}\"\n        else:\n            market_cap_str = \"N/A\"\n\n        if isinstance(current_price, (int, float)) and isinstance(previous_close, (int, float)):\n            price_change = current_price - previous_close\n            price_change_percent = (price_change / previous_close) * 100\n            change_str = f\"{price_change:+.2f} ({price_change_percent:+.2f}%)\"\n        else:\n            change_str = \"N/A\"\n\n        result = f\"\"\"\nStock: {company_name} ({symbol})\nCurrent Price: ${current_price}\nPrevious Close: ${previous_close}\nChange: {change_str}\nMarket Cap: {market_cap_str}\n        \"\"\".strip()\n\n        return result\n\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error fetching stock data: {e}\")\n        raise\n\ndef get_crypto_price(coin_id: str) -&gt; str:\n    \"\"\"\n    Fetches the current cryptocurrency price from CoinGecko API.\n\n    Args:\n        coin_id (str): The cryptocurrency ID (e.g., \"bitcoin\", \"ethereum\", \"cardano\").\n\n    Returns:\n        str: A formatted string containing the current crypto price and market data.\n\n    Raises:\n        ValueError: If the coin ID is invalid or data cannot be retrieved.\n        requests.exceptions.RequestException: If there is an error with the API request.\n    \"\"\"\n    try:\n        coin_id = coin_id.strip().lower()\n\n        if not coin_id:\n            raise ValueError(\"Coin ID cannot be empty.\")\n\n        url = f\"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id,\n            \"vs_currencies\": \"usd\",\n            \"include_market_cap\": \"true\",\n            \"include_24hr_vol\": \"true\",\n            \"include_24hr_change\": \"true\",\n            \"include_last_updated_at\": \"true\"\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n        data = response.json()\n\n        if coin_id not in data:\n            raise ValueError(f\"Coin ID '{coin_id}' not found. Please check the spelling.\")\n\n        coin_data = data[coin_id]\n\n        if not coin_data:\n            raise ValueError(f\"No data available for coin ID: {coin_id}\")\n\n        usd_price = coin_data.get('usd', 'N/A')\n        market_cap = coin_data.get('usd_market_cap', 'N/A')\n        volume_24h = coin_data.get('usd_24h_vol', 'N/A')\n        change_24h = coin_data.get('usd_24h_change', 'N/A')\n        last_updated = coin_data.get('last_updated_at', 'N/A')\n\n        def format_number(value):\n            if isinstance(value, (int, float)) and value &gt; 0:\n                if value &gt;= 1e12:\n                    return f\"${value/1e12:.2f}T\"\n                elif value &gt;= 1e9:\n                    return f\"${value/1e9:.2f}B\"\n                elif value &gt;= 1e6:\n                    return f\"${value/1e6:.2f}M\"\n                elif value &gt;= 1e3:\n                    return f\"${value/1e3:.2f}K\"\n                else:\n                    return f\"${value:,.2f}\"\n            return \"N/A\"\n\n        result = f\"\"\"\nCryptocurrency: {coin_id.title()}\nCurrent Price: ${usd_price:,.8f}\" if isinstance(usd_price, (int, float)) else f\"Current Price: {usd_price}\nMarket Cap: {format_number(market_cap)}\n24h Volume: {format_number(volume_24h)}\n24h Change: {change_24h:+.2f}%\" if isinstance(change_24h, (int, float)) else f\"24h Change: {change_24h}\nLast Updated: {last_updated}\n        \"\"\".strip()\n\n        return result\n\n    except requests.exceptions.RequestException as e:\n        print(f\"Request Error: {e}\")\n        raise\n    except ValueError as e:\n        print(f\"Value Error: {e}\")\n        raise\n    except Exception as e:\n        print(f\"Error fetching crypto data: {e}\")\n        raise\n\n# Initialize the financial analysis agent\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",\n    system_prompt=(\n        \"You are a professional financial analyst agent specializing in stock and \"\n        \"cryptocurrency analysis. Use the provided tools to fetch real-time market \"\n        \"data and provide comprehensive financial insights. Always present data \"\n        \"in a clear, professional format with actionable recommendations.\"\n    ),\n    model_name=\"gpt-4o\",\n    max_loops=3,\n    autosave=True,\n    dashboard=False,\n    verbose=True,\n    streaming_on=True,\n    dynamic_temperature_enabled=True,\n    saved_state_path=\"financial_agent.json\",\n    tools=[get_stock_price, get_crypto_price],\n    user_name=\"financial_analyst\",\n    retry_attempts=3,\n    context_length=200000,\n)\n\n# Run the agent\nresponse = agent(\"What are the current prices and market data for Apple stock and Bitcoin? Provide a brief analysis of their performance.\")\nprint(response)\n</code></pre>"},{"location":"swarms/tools/main/","title":"The Swarms Tool System: Functions, Pydantic BaseModels as Tools, and Radical Customization","text":"<p>This guide provides an in-depth look at the Swarms Tool System, focusing on its functions, the use of Pydantic BaseModels as tools, and the extensive customization options available. Aimed at developers, this documentation highlights how the Swarms framework works and offers detailed examples of creating and customizing tools and agents, specifically for accounting tasks.</p> <p>The Swarms Tool System is a flexible and extensible component of the Swarms framework that allows for the creation, registration, and utilization of various tools. These tools can perform a wide range of tasks and are integrated into agents to provide specific functionalities. The system supports multiple ways to define tools, including using Pydantic BaseModels, functions, and dictionaries.</p>"},{"location":"swarms/tools/main/#architecture","title":"Architecture","text":"<p>The architecture of the Swarms Tool System is designed to be highly modular. It consists of the following main components:</p> <ol> <li>Agents: The primary entities that execute tasks.</li> <li>Tools: Functions or classes that perform specific operations.</li> <li>Schemas: Definitions of input and output data formats using Pydantic BaseModels.</li> </ol>"},{"location":"swarms/tools/main/#key-concepts","title":"Key Concepts","text":""},{"location":"swarms/tools/main/#tools","title":"Tools","text":"<p>Tools are the core functional units within the Swarms framework. They can be defined in various ways:</p> <ul> <li>Pydantic BaseModels: Tools can be defined using Pydantic BaseModels to ensure data validation and serialization.</li> <li>Functions: Tools can be simple or complex functions.</li> <li>Dictionaries: Tools can be represented as dictionaries for flexibility.</li> </ul>"},{"location":"swarms/tools/main/#agents","title":"Agents","text":"<p>Agents utilize tools to perform tasks. They are configured with a set of tools and schemas, and they execute the tools based on the input they receive.</p>"},{"location":"swarms/tools/main/#detailed-documentation","title":"Detailed Documentation","text":""},{"location":"swarms/tools/main/#tool-definition","title":"Tool Definition","text":""},{"location":"swarms/tools/main/#using-pydantic-basemodels","title":"Using Pydantic BaseModels","text":"<p>Pydantic BaseModels provide a structured way to define tool inputs and outputs. They ensure data validation and serialization, making them ideal for complex data handling.</p> <p>Example:</p> <p>Define Pydantic BaseModels for accounting tasks:</p> <pre><code>from pydantic import BaseModel\n\nclass CalculateTax(BaseModel):\n    income: float\n\nclass GenerateInvoice(BaseModel):\n    client_name: str\n    amount: float\n    date: str\n\nclass SummarizeExpenses(BaseModel):\n    expenses: list[dict]\n</code></pre> <p>Define tool functions using these models:</p> <pre><code>def calculate_tax(data: CalculateTax) -&gt; dict:\n    tax_rate = 0.3  # Example tax rate\n    tax = data.income * tax_rate\n    return {\"income\": data.income, \"tax\": tax}\n\ndef generate_invoice(data: GenerateInvoice) -&gt; dict:\n    invoice = {\n        \"client_name\": data.client_name,\n        \"amount\": data.amount,\n        \"date\": data.date,\n        \"invoice_id\": \"INV12345\"\n    }\n    return invoice\n\ndef summarize_expenses(data: SummarizeExpenses) -&gt; dict:\n    total_expenses = sum(expense['amount'] for expense in data.expenses)\n    return {\"total_expenses\": total_expenses}\n</code></pre>"},{"location":"swarms/tools/main/#using-functions-directly","title":"Using Functions Directly","text":"<p>Tools can also be defined directly as functions without using Pydantic models. This approach is suitable for simpler tasks where complex validation is not required.</p> <p>Example:</p> <pre><code>def basic_tax_calculation(income: float) -&gt; dict:\n    tax_rate = 0.25\n    tax = income * tax_rate\n    return {\"income\": income, \"tax\": tax}\n</code></pre>"},{"location":"swarms/tools/main/#using-dictionaries","title":"Using Dictionaries","text":"<p>Tools can be represented as dictionaries, providing maximum flexibility. This method is useful when the tool's functionality is more dynamic or when integrating with external systems.</p> <p>Example:</p> <pre><code>basic_tool_schema = {\n    \"name\": \"basic_tax_tool\",\n    \"description\": \"A basic tax calculation tool\",\n    \"parameters\": {\n        \"type\": \"object\",\n        \"properties\": {\n            \"income\": {\"type\": \"number\", \"description\": \"Income amount\"}\n        },\n        \"required\": [\"income\"]\n    }\n}\n\ndef basic_tax_tool(income: float) -&gt; dict:\n    tax_rate = 0.2\n    tax = income * tax_rate\n    return {\"income\": income, \"tax\": tax}\n</code></pre>"},{"location":"swarms/tools/main/#tool-registration","title":"Tool Registration","text":"<p>Tools need to be registered with the agent for it to utilize them. This can be done by specifying the tools in the <code>tools</code> parameter during agent initialization.</p> <p>Example:</p> <pre><code>from swarms import Agent\nfrom llama_hosted import llama3Hosted\n\n# Define Pydantic BaseModels for accounting tasks\nclass CalculateTax(BaseModel):\n    income: float\n\nclass GenerateInvoice(BaseModel):\n    client_name: str\n    amount: float\n    date: str\n\nclass SummarizeExpenses(BaseModel):\n    expenses: list[dict]\n\n# Define tool functions using these models\ndef calculate_tax(data: CalculateTax) -&gt; dict:\n    tax_rate = 0.3\n    tax = data.income * tax_rate\n    return {\"income\": data.income, \"tax\": tax}\n\ndef generate_invoice(data: GenerateInvoice) -&gt; dict:\n    invoice = {\n        \"client_name\": data.client_name,\n        \"amount\": data.amount,\n        \"date\": data.date,\n        \"invoice_id\": \"INV12345\"\n    }\n    return invoice\n\ndef summarize_expenses(data: SummarizeExpenses) -&gt; dict:\n    total_expenses = sum(expense['amount'] for expense in data.expenses)\n    return {\"total_expenses\": total_expenses}\n\n# Function to generate a tool schema for demonstration purposes\ndef create_tool_schema():\n    return {\n        \"name\": \"execute\",\n        \"description\": \"Executes code on the user's machine\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"language\": {\n                    \"type\": \"string\",\n                    \"description\": \"Programming language\",\n                    \"enum\": [\"python\", \"java\"]\n                },\n                \"code\": {\"type\": \"string\", \"description\": \"Code to execute\"}\n            },\n            \"required\": [\"language\", \"code\"]\n        }\n    }\n\n# Initialize the agent with the tools\nagent = Agent(\n    agent_name=\"Accounting Agent\",\n    system_prompt=\"This agent assists with various accounting tasks.\",\n    sop_list=[\"Provide accurate and timely accounting services.\"],\n    llm=llama3Hosted(),\n    max_loops=\"auto\",\n    interactive=True,\n    verbose=True,\n    tool_schema=BaseModel,\n    list_base_models=[\n        CalculateTax,\n        GenerateInvoice,\n        SummarizeExpenses\n    ],\n    output_type=str,\n    metadata_output_type=\"json\",\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\",\n    tools=[\n        calculate_tax,\n        generate_invoice,\n        summarize_expenses\n    ],\n    list_base_models_json=create_tool_schema(),\n)\n</code></pre>"},{"location":"swarms/tools/main/#running-the-agent","title":"Running the Agent","text":"<p>The agent can execute tasks using the <code>run</code> method. This method takes a prompt and determines the appropriate tool to use based on the input.</p> <p>Example:</p> <pre><code># Example task: Calculate tax for an income\nresult = agent.run(\"Calculate the tax for an income of $50,000.\")\nprint(f\"Result: {result}\")\n\n# Example task: Generate an invoice\ninvoice_data = agent.run(\"Generate an invoice for John Doe for $1500 on 2024-06-01.\")\nprint(f\"Invoice Data: {invoice_data}\")\n\n# Example task: Summarize expenses\nexpenses = [\n    {\"amount\": 200.0, \"description\": \"Office supplies\"},\n    {\"amount\": 1500.0, \"description\": \"Software licenses\"},\n    {\"amount\": 300.0, \"description\": \"Travel expenses\"}\n]\nsummary = agent.run(\"Summarize these expenses: \" + str(expenses))\nprint(f\"Expenses Summary: {summary}\")\n</code></pre>"},{"location":"swarms/tools/main/#customizing-tools","title":"Customizing Tools","text":"<p>Custom tools can be created to extend the functionality of the Swarms framework. This can include integrating external APIs, performing complex calculations, or handling specialized data formats.</p> <p>Example: Custom Accounting Tool</p> <pre><code>from pydantic import BaseModel\n\nclass CustomAccountingTool(BaseModel):\n    data: dict\n\ndef custom_accounting_tool(data: CustomAccountingTool) -&gt; dict:\n    # Custom logic for the accounting tool\n    result = {\n        \"status\": \"success\",\n        \"data_processed\": len(data.data)\n    }\n    return result\n\n# Register the custom tool with the agent\nagent = Agent(\n    agent_name=\"Accounting Agent\",\n    system_prompt=\"This agent assists with various accounting tasks.\",\n    sop_list=[\"Provide accurate and timely accounting services.\"],\n    llm=llama3Hosted(),\n    max_loops=\"auto\",\n    interactive=True,\n    verbose=True,\n    tool_schema=BaseModel,\n    list_base_models=[\n        CalculateTax,\n        GenerateInvoice,\n        SummarizeExpenses,\n        CustomAccountingTool\n    ],\n    output_type=str,\n    metadata_output_type=\"json\",\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\",\n    tools=[\n        calculate_tax,\n        generate_invoice,\n        summarize_expenses,\n        custom_accounting_tool\n    ],\n    list_base_models_json=create_tool_schema(),\n)\n</code></pre>"},{"location":"swarms/tools/main/#advanced-customization","title":"Advanced Customization","text":"<p>Advanced customization involves modifying the core components of the Swarms framework. This includes extending existing classes, adding new methods, or integrating third-party libraries.</p> <p>Example: Extending the Agent Class</p> <pre><code>from swarms import Agent\n\nclass AdvancedAccountingAgent(Agent):\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n    def custom_behavior(self):\n        print(\"Executing custom behavior\")\n\n    def another_custom_method(self):\n        print(\"Another\n\n custom method\")\n\n# Initialize the advanced agent\nadvanced_agent = AdvancedAccountingAgent(\n    agent_name=\"Advanced Accounting Agent\",\n    system_prompt=\"This agent performs advanced accounting tasks.\",\n    sop_list=[\"Provide advanced accounting services.\"],\n    llm=llama3Hosted(),\n    max_loops=\"auto\",\n    interactive=True,\n    verbose=True,\n    tool_schema=BaseModel,\n    list_base_models=[\n        CalculateTax,\n        GenerateInvoice,\n        SummarizeExpenses,\n        CustomAccountingTool\n    ],\n    output_type=str,\n    metadata_output_type=\"json\",\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\",\n    tools=[\n        calculate_tax,\n        generate_invoice,\n        summarize_expenses,\n        custom_accounting_tool\n    ],\n    list_base_models_json=create_tool_schema(),\n)\n\n# Call custom methods\nadvanced_agent.custom_behavior()\nadvanced_agent.another_custom_method()\n</code></pre>"},{"location":"swarms/tools/main/#integrating-external-libraries","title":"Integrating External Libraries","text":"<p>You can integrate external libraries to extend the functionality of your tools. This is useful for adding new capabilities or leveraging existing libraries for complex tasks.</p> <p>Example: Integrating Pandas for Data Processing</p> <pre><code>import pandas as pd\nfrom pydantic import BaseModel\n\nclass DataFrameTool(BaseModel):\n    data: list[dict]\n\ndef process_data_frame(data: DataFrameTool) -&gt; dict:\n    df = pd.DataFrame(data.data)\n    summary = df.describe().to_dict()\n    return {\"summary\": summary}\n\n# Register the tool with the agent\nagent = Agent(\n    agent_name=\"Data Processing Agent\",\n    system_prompt=\"This agent processes data frames.\",\n    sop_list=[\"Provide data processing services.\"],\n    llm=llama3Hosted(),\n    max_loops=\"auto\",\n    interactive=True,\n    verbose=True,\n    tool_schema=BaseModel,\n    list_base_models=[DataFrameTool],\n    output_type=str,\n    metadata_output_type=\"json\",\n    function_calling_format_type=\"OpenAI\",\n    function_calling_type=\"json\",\n    tools=[process_data_frame],\n    list_base_models_json=create_tool_schema(),\n)\n\n# Example task: Process a data frame\ndata = [\n    {\"col1\": 1, \"col2\": 2},\n    {\"col1\": 3, \"col2\": 4},\n    {\"col1\": 5, \"col2\": 6}\n]\nresult = agent.run(\"Process this data frame: \" + str(data))\nprint(f\"Data Frame Summary: {result}\")\n</code></pre>"},{"location":"swarms/tools/main/#conclusion","title":"Conclusion","text":"<p>The Swarms Tool System provides a robust and flexible framework for defining and utilizing tools within agents. By leveraging Pydantic BaseModels, functions, and dictionaries, developers can create highly customized tools to perform a wide range of tasks. The extensive customization options allow for the integration of external libraries and the extension of core components, making the Swarms framework suitable for diverse applications.</p> <p>This guide has covered the fundamental concepts and provided detailed examples to help you get started with the Swarms Tool System. With this foundation, you can explore and implement advanced features to build powerful</p>"},{"location":"swarms/tools/mcp_client_call/","title":"MCP Client Call Reference Documentation","text":"<p>This document provides a comprehensive reference for the MCP (Model Control Protocol) client call functions, including detailed parameter descriptions, return types, and usage examples.</p>"},{"location":"swarms/tools/mcp_client_call/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>aget_mcp_tools</p> </li> <li> <p>get_mcp_tools_sync</p> </li> <li> <p>get_tools_for_multiple_mcp_servers</p> </li> <li> <p>execute_tool_call_simple</p> </li> </ul>"},{"location":"swarms/tools/mcp_client_call/#function-reference","title":"Function Reference","text":""},{"location":"swarms/tools/mcp_client_call/#aget_mcp_tools","title":"aget_mcp_tools","text":"<p>Asynchronously fetches available MCP tools from the server with retry logic.</p>"},{"location":"swarms/tools/mcp_client_call/#parameters","title":"Parameters","text":"Parameter Type Required Description server_path Optional[str] No Path to the MCP server script format str No Format of the returned tools (default: \"openai\") connection Optional[MCPConnection] No MCP connection object *args Any No Additional positional arguments **kwargs Any No Additional keyword arguments"},{"location":"swarms/tools/mcp_client_call/#returns","title":"Returns","text":"<ul> <li><code>List[Dict[str, Any]]</code>: List of available MCP tools in OpenAI format</li> </ul>"},{"location":"swarms/tools/mcp_client_call/#raises","title":"Raises","text":"<ul> <li> <p><code>MCPValidationError</code>: If server_path is invalid</p> </li> <li> <p><code>MCPConnectionError</code>: If connection to server fails</p> </li> </ul>"},{"location":"swarms/tools/mcp_client_call/#example","title":"Example","text":"<pre><code>import asyncio\nfrom swarms.tools.mcp_client_call import aget_mcp_tools\nfrom swarms.tools.mcp_connection import MCPConnection\n\nasync def main():\n    # Using server path\n    tools = await aget_mcp_tools(server_path=\"http://localhost:8000\")\n\n    # Using connection object\n    connection = MCPConnection(\n        host=\"localhost\",\n        port=8000,\n        headers={\"Authorization\": \"Bearer token\"}\n    )\n    tools = await aget_mcp_tools(connection=connection)\n\n    print(f\"Found {len(tools)} tools\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"swarms/tools/mcp_client_call/#get_mcp_tools_sync","title":"get_mcp_tools_sync","text":"<p>Synchronous version of get_mcp_tools that handles event loop management.</p>"},{"location":"swarms/tools/mcp_client_call/#parameters_1","title":"Parameters","text":"Parameter Type Required Description server_path Optional[str] No Path to the MCP server script format str No Format of the returned tools (default: \"openai\") connection Optional[MCPConnection] No MCP connection object *args Any No Additional positional arguments **kwargs Any No Additional keyword arguments"},{"location":"swarms/tools/mcp_client_call/#returns_1","title":"Returns","text":"<ul> <li><code>List[Dict[str, Any]]</code>: List of available MCP tools in OpenAI format</li> </ul>"},{"location":"swarms/tools/mcp_client_call/#raises_1","title":"Raises","text":"<ul> <li> <p><code>MCPValidationError</code>: If server_path is invalid</p> </li> <li> <p><code>MCPConnectionError</code>: If connection to server fails</p> </li> <li> <p><code>MCPExecutionError</code>: If event loop management fails</p> </li> </ul>"},{"location":"swarms/tools/mcp_client_call/#example_1","title":"Example","text":"<pre><code>from swarms.tools.mcp_client_call import get_mcp_tools_sync\nfrom swarms.tools.mcp_connection import MCPConnection\n\n# Using server path\ntools = get_mcp_tools_sync(server_path=\"http://localhost:8000\")\n\n# Using connection object\nconnection = MCPConnection(\n    host=\"localhost\",\n    port=8000,\n    headers={\"Authorization\": \"Bearer token\"}\n)\ntools = get_mcp_tools_sync(connection=connection)\n\nprint(f\"Found {len(tools)} tools\")\n</code></pre>"},{"location":"swarms/tools/mcp_client_call/#get_tools_for_multiple_mcp_servers","title":"get_tools_for_multiple_mcp_servers","text":"<p>Get tools for multiple MCP servers concurrently using ThreadPoolExecutor.</p>"},{"location":"swarms/tools/mcp_client_call/#parameters_2","title":"Parameters","text":"Parameter Type Required Description urls List[str] Yes List of server URLs to fetch tools from connections List[MCPConnection] No Optional list of MCPConnection objects format str No Format to return tools in (default: \"openai\") output_type Literal[\"json\", \"dict\", \"str\"] No Type of output format (default: \"str\") max_workers Optional[int] No Maximum number of worker threads"},{"location":"swarms/tools/mcp_client_call/#returns_2","title":"Returns","text":"<ul> <li><code>List[Dict[str, Any]]</code>: Combined list of tools from all servers</li> </ul>"},{"location":"swarms/tools/mcp_client_call/#raises_2","title":"Raises","text":"<ul> <li><code>MCPExecutionError</code>: If fetching tools from any server fails</li> </ul>"},{"location":"swarms/tools/mcp_client_call/#example_2","title":"Example","text":"<pre><code>from swarms.tools.mcp_client_call import get_tools_for_multiple_mcp_servers\nfrom swarms.tools.mcp_connection import MCPConnection\n\n# Define server URLs\nurls = [\n    \"http://server1:8000\",\n    \"http://server2:8000\"\n]\n\n# Optional: Define connections\nconnections = [\n    MCPConnection(host=\"server1\", port=8000),\n    MCPConnection(host=\"server2\", port=8000)\n]\n\n# Get tools from all servers\ntools = get_tools_for_multiple_mcp_servers(\n    urls=urls,\n    connections=connections,\n    format=\"openai\",\n    output_type=\"dict\",\n    max_workers=4\n)\n\nprint(f\"Found {len(tools)} tools across all servers\")\n</code></pre>"},{"location":"swarms/tools/mcp_client_call/#execute_tool_call_simple","title":"execute_tool_call_simple","text":"<p>Execute a tool call using the MCP client.</p>"},{"location":"swarms/tools/mcp_client_call/#parameters_3","title":"Parameters","text":"Parameter Type Required Description response Any No Tool call response object server_path str No Path to the MCP server connection Optional[MCPConnection] No MCP connection object output_type Literal[\"json\", \"dict\", \"str\", \"formatted\"] No Type of output format (default: \"str\") *args Any No Additional positional arguments **kwargs Any No Additional keyword arguments"},{"location":"swarms/tools/mcp_client_call/#returns_3","title":"Returns","text":"<ul> <li><code>List[Dict[str, Any]]</code>: Result of the tool execution</li> </ul>"},{"location":"swarms/tools/mcp_client_call/#raises_3","title":"Raises","text":"<ul> <li> <p><code>MCPConnectionError</code>: If connection to server fails</p> </li> <li> <p><code>MCPExecutionError</code>: If tool execution fails</p> </li> </ul>"},{"location":"swarms/tools/mcp_client_call/#example_3","title":"Example","text":"<pre><code>import asyncio\nfrom swarms.tools.mcp_client_call import execute_tool_call_simple\nfrom swarms.tools.mcp_connection import MCPConnection\n\nasync def main():\n    # Example tool call response\n    response = {\n        \"name\": \"example_tool\",\n        \"parameters\": {\"param1\": \"value1\"}\n    }\n\n    # Using server path\n    result = await execute_tool_call_simple(\n        response=response,\n        server_path=\"http://localhost:8000\",\n        output_type=\"json\"\n    )\n\n    # Using connection object\n    connection = MCPConnection(\n        host=\"localhost\",\n        port=8000,\n        headers={\"Authorization\": \"Bearer token\"}\n    )\n    result = await execute_tool_call_simple(\n        response=response,\n        connection=connection,\n        output_type=\"dict\"\n    )\n\n    print(f\"Tool execution result: {result}\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"swarms/tools/mcp_client_call/#error-handling","title":"Error Handling","text":"<p>The MCP client functions use a retry mechanism with exponential backoff for failed requests. The following error types may be raised:</p> <ul> <li> <p><code>MCPValidationError</code>: Raised when input validation fails</p> </li> <li> <p><code>MCPConnectionError</code>: Raised when connection to the MCP server fails</p> </li> <li> <p><code>MCPExecutionError</code>: Raised when tool execution fails</p> </li> </ul>"},{"location":"swarms/tools/mcp_client_call/#best-practices","title":"Best Practices","text":"<ol> <li>Always handle potential exceptions when using these functions</li> <li>Use connection objects for authenticated requests</li> <li>Consider using the async versions for better performance in async applications</li> <li>Use appropriate output types based on your needs</li> <li>When working with multiple servers, adjust max_workers based on your system's capabilities</li> </ol>"},{"location":"swarms/tools/tool_storage/","title":"ToolStorage","text":"<p>The <code>ToolStorage</code> module provides a structured and efficient way to manage and utilize various tool functions. It is designed to store tool functions, manage settings, and ensure smooth registration and retrieval of tools. This module is particularly useful in applications that require dynamic management of a collection of functions, such as plugin systems, modular software, or any application where functions need to be registered and called dynamically.</p>"},{"location":"swarms/tools/tool_storage/#class-toolstorage","title":"Class: ToolStorage","text":"<p>The <code>ToolStorage</code> class is the core component of the module. It provides functionalities to add, retrieve, and list tool functions as well as manage settings.</p>"},{"location":"swarms/tools/tool_storage/#attributes","title":"Attributes","text":"Attribute Type Description <code>verbose</code> <code>bool</code> A flag to enable verbose logging. <code>tools</code> <code>List[Callable]</code> A list of tool functions. <code>_tools</code> <code>Dict[str, Callable]</code> A dictionary that stores the tools, where the key is the tool name and the value is the tool function. <code>_settings</code> <code>Dict[str, Any]</code> A dictionary that stores the settings, where the key is the setting name and the value is the setting value."},{"location":"swarms/tools/tool_storage/#methods","title":"Methods","text":""},{"location":"swarms/tools/tool_storage/#__init__","title":"<code>__init__</code>","text":"<p>Initializes the <code>ToolStorage</code> instance.</p> Parameter Type Default Description <code>verbose</code> <code>bool</code> <code>None</code> A flag to enable verbose logging. <code>tools</code> <code>List[Callable]</code> <code>None</code> A list of tool functions to initialize the storage with. <code>*args</code> <code>tuple</code> <code>None</code> Additional positional arguments. <code>**kwargs</code> <code>dict</code> <code>None</code> Additional keyword arguments."},{"location":"swarms/tools/tool_storage/#add_tool","title":"<code>add_tool</code>","text":"<p>Adds a tool to the storage.</p> Parameter Type Description <code>func</code> <code>Callable</code> The tool function to be added. <p>Raises: - <code>ValueError</code>: If a tool with the same name already exists.</p>"},{"location":"swarms/tools/tool_storage/#get_tool","title":"<code>get_tool</code>","text":"<p>Retrieves a tool by its name.</p> Parameter Type Description <code>name</code> <code>str</code> The name of the tool to retrieve. <p>Returns: - <code>Callable</code>: The tool function.</p> <p>Raises: - <code>ValueError</code>: If no tool with the given name is found.</p>"},{"location":"swarms/tools/tool_storage/#set_setting","title":"<code>set_setting</code>","text":"<p>Sets a setting in the storage.</p> Parameter Type Description <code>key</code> <code>str</code> The key for the setting. <code>value</code> <code>Any</code> The value for the setting."},{"location":"swarms/tools/tool_storage/#get_setting","title":"<code>get_setting</code>","text":"<p>Gets a setting from the storage.</p> Parameter Type Description <code>key</code> <code>str</code> The key for the setting. <p>Returns: - <code>Any</code>: The value of the setting.</p> <p>Raises: - <code>KeyError</code>: If the setting is not found.</p>"},{"location":"swarms/tools/tool_storage/#list_tools","title":"<code>list_tools</code>","text":"<p>Lists all registered tools.</p> <p>Returns: - <code>List[str]</code>: A list of tool names.</p>"},{"location":"swarms/tools/tool_storage/#decorator-tool_registry","title":"Decorator: tool_registry","text":"<p>The <code>tool_registry</code> decorator registers a function as a tool in the storage.</p> Parameter Type Description <code>storage</code> <code>ToolStorage</code> The storage instance to register the tool in. <p>Returns: - <code>Callable</code>: The decorator function.</p>"},{"location":"swarms/tools/tool_storage/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms/tools/tool_storage/#full-example","title":"Full Example","text":"<pre><code>from swarms import ToolStorage, tool_registry\n\nstorage = ToolStorage()\n\n\n# Example usage\n@tool_registry(storage)\ndef example_tool(x: int, y: int) -&gt; int:\n    \"\"\"\n    Example tool function that adds two numbers.\n\n    Args:\n        x (int): The first number.\n        y (int): The second number.\n\n    Returns:\n        int: The sum of the two numbers.\n    \"\"\"\n    return x + y\n\n\n# Query all the tools and get the example tool\nprint(storage.list_tools())  # Should print ['example_tool']\n# print(storage.get_tool('example_tool'))  # Should print &lt;function example_tool at 0x...&gt;\n\n# Find the tool by names and call it\nprint(storage.get_tool(\"example_tool\"))  # Should print 5\n\n\n# Test the storage and querying\nif __name__ == \"__main__\":\n    print(storage.list_tools())  # Should print ['example_tool']\n    print(storage.get_tool(\"example_tool\"))  # Should print 5\n    storage.set_setting(\"example_setting\", 42)\n    print(storage.get_setting(\"example_setting\"))  # Should print 42\n</code></pre>"},{"location":"swarms/tools/tool_storage/#basic-usage","title":"Basic Usage","text":""},{"location":"swarms/tools/tool_storage/#example-1-initializing-toolstorage-and-adding-a-tool","title":"Example 1: Initializing ToolStorage and Adding a Tool","text":"<pre><code>from swarms.tools.tool_registry import ToolStorage, tool_registry\n\n# Initialize ToolStorage\nstorage = ToolStorage()\n\n# Define a tool function\n@tool_registry(storage)\ndef add_numbers(x: int, y: int) -&gt; int:\n    return x + y\n\n# List tools\nprint(storage.list_tools())  # Output: ['add_numbers']\n\n# Retrieve and use the tool\nadd_tool = storage.get_tool('add_numbers')\nprint(add_tool(5, 3))  # Output: 8\n</code></pre>"},{"location":"swarms/tools/tool_storage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms/tools/tool_storage/#example-2-managing-settings","title":"Example 2: Managing Settings","text":"<pre><code># Set a setting\nstorage.set_setting('max_retries', 5)\n\n# Get a setting\nmax_retries = storage.get_setting('max_retries')\nprint(max_retries)  # Output: 5\n</code></pre>"},{"location":"swarms/tools/tool_storage/#error-handling","title":"Error Handling","text":""},{"location":"swarms/tools/tool_storage/#example-3-handling-errors-in-tool-retrieval","title":"Example 3: Handling Errors in Tool Retrieval","text":"<pre><code>try:\n    non_existent_tool = storage.get_tool('non_existent')\nexcept ValueError as e:\n    print(e)  # Output: No tool found with name: non_existent\n</code></pre>"},{"location":"swarms/tools/tool_storage/#example-4-handling-duplicate-tool-addition","title":"Example 4: Handling Duplicate Tool Addition","text":"<pre><code>try:\n    @tool_registry(storage)\n    def add_numbers(x: int, y: int) -&gt; int:\n        return x + y\nexcept ValueError as e:\n    print(e)  # Output: Tool with name add_numbers already exists.\n</code></pre>"},{"location":"swarms/tools/tool_storage/#conclusion","title":"Conclusion","text":"<p>The <code>ToolStorage</code> module provides a robust solution for managing tool functions and settings. Its design allows for easy registration, retrieval, and management of tools, making it a valuable asset in various applications requiring dynamic function handling. The inclusion of detailed logging ensures that the operations are transparent and any issues can be quickly identified and resolved.</p>"},{"location":"swarms/tools/tools_examples/","title":"Swarms Tools Documentation","text":"<p>Swarms provides a comprehensive toolkit for integrating various types of tools into your AI agents. This guide covers all available tool options including callable functions, MCP servers, schemas, and more.</p>"},{"location":"swarms/tools/tools_examples/#installation","title":"Installation","text":"<pre><code>pip install swarms\n</code></pre>"},{"location":"swarms/tools/tools_examples/#overview","title":"Overview","text":"<p>Swarms provides a comprehensive suite of tool integration methods to enhance your AI agents' capabilities:</p> Tool Type Description Callable Functions Direct integration of Python functions with proper type hints and comprehensive docstrings for immediate tool functionality MCP Servers Model Context Protocol servers enabling distributed tool functionality across multiple services and environments Tool Schemas Structured tool definitions that provide standardized interfaces and validation for tool integration Tool Collections Pre-built tool packages offering ready-to-use functionality for common use cases"},{"location":"swarms/tools/tools_examples/#method-1-callable-functions","title":"Method 1: Callable Functions","text":"<p>Callable functions are the simplest way to add tools to your Swarms agents. They are regular Python functions with type hints and comprehensive docstrings.</p>"},{"location":"swarms/tools/tools_examples/#step-1-define-your-tool-functions","title":"Step 1: Define Your Tool Functions","text":"<p>Create functions with the following requirements:</p> <ul> <li> <p>Type hints for all parameters and return values</p> </li> <li> <p>Comprehensive docstrings with Args, Returns, Raises, and Examples sections</p> </li> <li> <p>Error handling for robust operation</p> </li> </ul>"},{"location":"swarms/tools/tools_examples/#example-cryptocurrency-price-tools","title":"Example: Cryptocurrency Price Tools","text":"<pre><code>import json\nimport requests\nfrom swarms import Agent\n\n\ndef get_coin_price(coin_id: str, vs_currency: str = \"usd\") -&gt; str:\n    \"\"\"\n    Get the current price of a specific cryptocurrency.\n\n    Args:\n        coin_id (str): The CoinGecko ID of the cryptocurrency \n                      Examples: 'bitcoin', 'ethereum', 'cardano'\n        vs_currency (str, optional): The target currency for price conversion.\n                                   Supported: 'usd', 'eur', 'gbp', 'jpy', etc.\n                                   Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing the coin's current price and market data\n             including market cap, 24h volume, and price changes\n\n    Raises:\n        requests.RequestException: If the API request fails due to network issues\n        ValueError: If coin_id is empty or invalid\n        TimeoutError: If the request takes longer than 10 seconds\n\n    Example:\n        &gt;&gt;&gt; result = get_coin_price(\"bitcoin\", \"usd\")\n        &gt;&gt;&gt; print(result)\n        {\"bitcoin\": {\"usd\": 45000, \"usd_market_cap\": 850000000000, ...}}\n\n        &gt;&gt;&gt; result = get_coin_price(\"ethereum\", \"eur\")\n        &gt;&gt;&gt; print(result)\n        {\"ethereum\": {\"eur\": 3200, \"eur_market_cap\": 384000000000, ...}}\n    \"\"\"\n    try:\n        # Validate input parameters\n        if not coin_id or not coin_id.strip():\n            raise ValueError(\"coin_id cannot be empty\")\n\n        url = \"https://api.coingecko.com/api/v3/simple/price\"\n        params = {\n            \"ids\": coin_id.lower().strip(),\n            \"vs_currencies\": vs_currency.lower(),\n            \"include_market_cap\": True,\n            \"include_24hr_vol\": True,\n            \"include_24hr_change\": True,\n            \"include_last_updated_at\": True,\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Check if the coin was found\n        if not data:\n            return json.dumps({\n                \"error\": f\"Cryptocurrency '{coin_id}' not found. Please check the coin ID.\"\n            })\n\n        return json.dumps(data, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps({\n            \"error\": f\"Failed to fetch price for {coin_id}: {str(e)}\",\n            \"suggestion\": \"Check your internet connection and try again\"\n        })\n    except ValueError as e:\n        return json.dumps({\"error\": str(e)})\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef get_top_cryptocurrencies(limit: int = 10, vs_currency: str = \"usd\") -&gt; str:\n    \"\"\"\n    Fetch the top cryptocurrencies by market capitalization.\n\n    Args:\n        limit (int, optional): Number of coins to retrieve. \n                              Range: 1-250 coins\n                              Defaults to 10.\n        vs_currency (str, optional): The target currency for price conversion.\n                                   Supported: 'usd', 'eur', 'gbp', 'jpy', etc.\n                                   Defaults to \"usd\".\n\n    Returns:\n        str: JSON formatted string containing top cryptocurrencies with detailed market data\n             including: id, symbol, name, current_price, market_cap, market_cap_rank,\n             total_volume, price_change_24h, price_change_7d, last_updated\n\n    Raises:\n        requests.RequestException: If the API request fails\n        ValueError: If limit is not between 1 and 250\n\n    Example:\n        &gt;&gt;&gt; result = get_top_cryptocurrencies(5, \"usd\")\n        &gt;&gt;&gt; print(result)\n        [{\"id\": \"bitcoin\", \"name\": \"Bitcoin\", \"current_price\": 45000, ...}]\n\n        &gt;&gt;&gt; result = get_top_cryptocurrencies(limit=3, vs_currency=\"eur\")\n        &gt;&gt;&gt; print(result)\n        [{\"id\": \"bitcoin\", \"name\": \"Bitcoin\", \"current_price\": 38000, ...}]\n    \"\"\"\n    try:\n        # Validate parameters\n        if not isinstance(limit, int) or not 1 &lt;= limit &lt;= 250:\n            raise ValueError(\"Limit must be an integer between 1 and 250\")\n\n        url = \"https://api.coingecko.com/api/v3/coins/markets\"\n        params = {\n            \"vs_currency\": vs_currency.lower(),\n            \"order\": \"market_cap_desc\",\n            \"per_page\": limit,\n            \"page\": 1,\n            \"sparkline\": False,\n            \"price_change_percentage\": \"24h,7d\",\n        }\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Simplify and structure the data for better readability\n        simplified_data = []\n        for coin in data:\n            simplified_data.append({\n                \"id\": coin.get(\"id\"),\n                \"symbol\": coin.get(\"symbol\", \"\").upper(),\n                \"name\": coin.get(\"name\"),\n                \"current_price\": coin.get(\"current_price\"),\n                \"market_cap\": coin.get(\"market_cap\"),\n                \"market_cap_rank\": coin.get(\"market_cap_rank\"),\n                \"total_volume\": coin.get(\"total_volume\"),\n                \"price_change_24h\": round(coin.get(\"price_change_percentage_24h\", 0), 2),\n                \"price_change_7d\": round(coin.get(\"price_change_percentage_7d_in_currency\", 0), 2),\n                \"last_updated\": coin.get(\"last_updated\"),\n            })\n\n        return json.dumps(simplified_data, indent=2)\n\n    except (requests.RequestException, ValueError) as e:\n        return json.dumps({\n            \"error\": f\"Failed to fetch top cryptocurrencies: {str(e)}\"\n        })\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n\n\ndef search_cryptocurrencies(query: str) -&gt; str:\n    \"\"\"\n    Search for cryptocurrencies by name or symbol.\n\n    Args:\n        query (str): The search term (coin name or symbol)\n                    Examples: 'bitcoin', 'btc', 'ethereum', 'eth'\n                    Case-insensitive search\n\n    Returns:\n        str: JSON formatted string containing search results with coin details\n             including: id, name, symbol, market_cap_rank, thumb (icon URL)\n             Limited to top 10 results for performance\n\n    Raises:\n        requests.RequestException: If the API request fails\n        ValueError: If query is empty\n\n    Example:\n        &gt;&gt;&gt; result = search_cryptocurrencies(\"ethereum\")\n        &gt;&gt;&gt; print(result)\n        {\"coins\": [{\"id\": \"ethereum\", \"name\": \"Ethereum\", \"symbol\": \"eth\", ...}]}\n\n        &gt;&gt;&gt; result = search_cryptocurrencies(\"btc\")\n        &gt;&gt;&gt; print(result)\n        {\"coins\": [{\"id\": \"bitcoin\", \"name\": \"Bitcoin\", \"symbol\": \"btc\", ...}]}\n    \"\"\"\n    try:\n        # Validate input\n        if not query or not query.strip():\n            raise ValueError(\"Search query cannot be empty\")\n\n        url = \"https://api.coingecko.com/api/v3/search\"\n        params = {\"query\": query.strip()}\n\n        response = requests.get(url, params=params, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Extract and format the results\n        coins = data.get(\"coins\", [])[:10]  # Limit to top 10 results\n\n        result = {\n            \"coins\": coins,\n            \"query\": query,\n            \"total_results\": len(data.get(\"coins\", [])),\n            \"showing\": min(len(coins), 10)\n        }\n\n        return json.dumps(result, indent=2)\n\n    except requests.RequestException as e:\n        return json.dumps({\n            \"error\": f'Failed to search for \"{query}\": {str(e)}'\n        })\n    except ValueError as e:\n        return json.dumps({\"error\": str(e)})\n    except Exception as e:\n        return json.dumps({\"error\": f\"Unexpected error: {str(e)}\"})\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-2-configure-your-agent","title":"Step 2: Configure Your Agent","text":"<p>Create an agent with the following key parameters:</p> <pre><code># Initialize the agent with cryptocurrency tools\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",                    # Unique identifier for your agent\n    agent_description=\"Personal finance advisor agent with cryptocurrency market analysis capabilities\",\n    system_prompt=\"\"\"You are a personal finance advisor agent with access to real-time \n    cryptocurrency data from CoinGecko. You can help users analyze market trends, check \n    coin prices, find trending cryptocurrencies, and search for specific coins. Always \n    provide accurate, up-to-date information and explain market data in an easy-to-understand way.\"\"\",\n    max_loops=1,                                              # Number of reasoning loops\n    max_tokens=4096,                                          # Maximum response length\n    model_name=\"anthropic/claude-3-opus-20240229\",          # LLM model to use\n    dynamic_temperature_enabled=True,                         # Enable adaptive creativity\n    output_type=\"all\",                                        # Return complete response\n    tools=[                                                   # List of callable functions\n        get_coin_price,\n        get_top_cryptocurrencies,\n        search_cryptocurrencies,\n    ],\n)\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-3-use-your-agent","title":"Step 3: Use Your Agent","text":"<pre><code># Example usage with different queries\nresponse = agent.run(\"What are the top 5 cryptocurrencies by market cap?\")\nprint(response)\n\n# Query with specific parameters\nresponse = agent.run(\"Get the current price of Bitcoin and Ethereum in EUR\")\nprint(response)\n\n# Search functionality\nresponse = agent.run(\"Search for cryptocurrencies related to 'cardano'\")\nprint(response)\n</code></pre>"},{"location":"swarms/tools/tools_examples/#method-2-mcp-model-context-protocol-servers","title":"Method 2: MCP (Model Context Protocol) Servers","text":"<p>MCP servers provide a standardized way to create distributed tool functionality. They're ideal for:</p> <ul> <li> <p>Reusable tools across multiple agents</p> </li> <li> <p>Complex tool logic that needs isolation</p> </li> <li> <p>Third-party tool integration</p> </li> <li> <p>Scalable architectures</p> </li> </ul>"},{"location":"swarms/tools/tools_examples/#step-1-create-your-mcp-server","title":"Step 1: Create Your MCP Server","text":"<pre><code>from mcp.server.fastmcp import FastMCP\nimport requests\n\n# Initialize the MCP server with configuration\nmcp = FastMCP(\"OKXCryptoPrice\")  # Server name for identification\nmcp.settings.port = 8001         # Port for server communication\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-2-define-mcp-tools","title":"Step 2: Define MCP Tools","text":"<p>Each MCP tool requires the <code>@mcp.tool</code> decorator with specific parameters:</p> <pre><code>@mcp.tool(\n    name=\"get_okx_crypto_price\",                              # Tool identifier (must be unique)\n    description=\"Get the current price and basic information for a given cryptocurrency from OKX exchange.\",\n)\ndef get_okx_crypto_price(symbol: str) -&gt; str:\n    \"\"\"\n    Get the current price and basic information for a given cryptocurrency using OKX API.\n\n    Args:\n        symbol (str): The cryptocurrency trading pair\n                     Format: 'BASE-QUOTE' (e.g., 'BTC-USDT', 'ETH-USDT')\n                     If only base currency provided, '-USDT' will be appended\n                     Case-insensitive input\n\n    Returns:\n        str: A formatted string containing:\n             - Current price in USDT\n             - 24-hour price change percentage\n             - Formatted for human readability\n\n    Raises:\n        requests.RequestException: If the OKX API request fails\n        ValueError: If symbol format is invalid\n        ConnectionError: If unable to connect to OKX servers\n\n    Example:\n        &gt;&gt;&gt; get_okx_crypto_price('BTC-USDT')\n        'Current price of BTC/USDT: $45,000.00\\n24h Change: +2.34%'\n\n        &gt;&gt;&gt; get_okx_crypto_price('eth')  # Automatically converts to ETH-USDT\n        'Current price of ETH/USDT: $3,200.50\\n24h Change: -1.23%'\n    \"\"\"\n    try:\n        # Input validation and formatting\n        if not symbol or not symbol.strip():\n            return \"Error: Please provide a valid trading pair (e.g., 'BTC-USDT')\"\n\n        # Normalize symbol format\n        symbol = symbol.upper().strip()\n        if not symbol.endswith(\"-USDT\"):\n            symbol = f\"{symbol}-USDT\"\n\n        # OKX API endpoint for ticker information\n        url = f\"https://www.okx.com/api/v5/market/ticker?instId={symbol}\"\n\n        # Make the API request with timeout\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Check API response status\n        if data.get(\"code\") != \"0\":\n            return f\"Error: {data.get('msg', 'Unknown error from OKX API')}\"\n\n        # Extract ticker data\n        ticker_data = data.get(\"data\", [{}])[0]\n        if not ticker_data:\n            return f\"Error: Could not find data for {symbol}. Please verify the trading pair exists.\"\n\n        # Parse numerical data\n        price = float(ticker_data.get(\"last\", 0))\n        change_percent = float(ticker_data.get(\"change24h\", 0)) * 100  # Convert to percentage\n\n        # Format response\n        base_currency = symbol.split(\"-\")[0]\n        change_symbol = \"+\" if change_percent &gt;= 0 else \"\"\n\n        return (f\"Current price of {base_currency}/USDT: ${price:,.2f}\\n\"\n                f\"24h Change: {change_symbol}{change_percent:.2f}%\")\n\n    except requests.exceptions.Timeout:\n        return \"Error: Request timed out. OKX servers may be slow.\"\n    except requests.exceptions.RequestException as e:\n        return f\"Error fetching OKX data: {str(e)}\"\n    except (ValueError, KeyError) as e:\n        return f\"Error parsing OKX response: {str(e)}\"\n    except Exception as e:\n        return f\"Unexpected error: {str(e)}\"\n\n\n@mcp.tool(\n    name=\"get_okx_crypto_volume\",                             # Second tool with different functionality\n    description=\"Get the 24-hour trading volume for a given cryptocurrency from OKX exchange.\",\n)\ndef get_okx_crypto_volume(symbol: str) -&gt; str:\n    \"\"\"\n    Get the 24-hour trading volume for a given cryptocurrency using OKX API.\n\n    Args:\n        symbol (str): The cryptocurrency trading pair\n                     Format: 'BASE-QUOTE' (e.g., 'BTC-USDT', 'ETH-USDT')\n                     If only base currency provided, '-USDT' will be appended\n                     Case-insensitive input\n\n    Returns:\n        str: A formatted string containing:\n             - 24-hour trading volume in the base currency\n             - Volume formatted with thousand separators\n             - Currency symbol for clarity\n\n    Raises:\n        requests.RequestException: If the OKX API request fails\n        ValueError: If symbol format is invalid\n\n    Example:\n        &gt;&gt;&gt; get_okx_crypto_volume('BTC-USDT')\n        '24h Trading Volume for BTC/USDT: 12,345.67 BTC'\n\n        &gt;&gt;&gt; get_okx_crypto_volume('ethereum')  # Converts to ETH-USDT\n        '24h Trading Volume for ETH/USDT: 98,765.43 ETH'\n    \"\"\"\n    try:\n        # Input validation and formatting\n        if not symbol or not symbol.strip():\n            return \"Error: Please provide a valid trading pair (e.g., 'BTC-USDT')\"\n\n        # Normalize symbol format\n        symbol = symbol.upper().strip()\n        if not symbol.endswith(\"-USDT\"):\n            symbol = f\"{symbol}-USDT\"\n\n        # OKX API endpoint\n        url = f\"https://www.okx.com/api/v5/market/ticker?instId={symbol}\"\n\n        # Make API request\n        response = requests.get(url, timeout=10)\n        response.raise_for_status()\n\n        data = response.json()\n\n        # Validate API response\n        if data.get(\"code\") != \"0\":\n            return f\"Error: {data.get('msg', 'Unknown error from OKX API')}\"\n\n        ticker_data = data.get(\"data\", [{}])[0]\n        if not ticker_data:\n            return f\"Error: Could not find data for {symbol}. Please verify the trading pair.\"\n\n        # Extract volume data\n        volume_24h = float(ticker_data.get(\"vol24h\", 0))\n        base_currency = symbol.split(\"-\")[0]\n\n        return f\"24h Trading Volume for {base_currency}/USDT: {volume_24h:,.2f} {base_currency}\"\n\n    except requests.exceptions.RequestException as e:\n        return f\"Error fetching OKX data: {str(e)}\"\n    except Exception as e:\n        return f\"Error: {str(e)}\"\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-3-start-your-mcp-server","title":"Step 3: Start Your MCP Server","text":"<pre><code>if __name__ == \"__main__\":\n    # Run the MCP server with SSE (Server-Sent Events) transport\n    # Server will be available at http://localhost:8001/sse\n    mcp.run(transport=\"sse\")\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-4-connect-agent-to-mcp-server","title":"Step 4: Connect Agent to MCP Server","text":"<pre><code>from swarms import Agent\n\n# Method 2: Using direct URL (simpler for development)\nmcp_url = \"http://0.0.0.0:8001/sse\"\n\n# Initialize agent with MCP tools\nagent = Agent(\n    agent_name=\"Financial-Analysis-Agent\",                    # Agent identifier\n    agent_description=\"Personal finance advisor with OKX exchange data access\",\n    system_prompt=\"\"\"You are a financial analysis agent with access to real-time \n    cryptocurrency data from OKX exchange. You can check prices, analyze trading volumes, \n    and provide market insights. Always format numerical data clearly and explain \n    market movements in context.\"\"\",\n    max_loops=1,                                              # Processing loops\n    mcp_url=mcp_url,                                         # MCP server connection\n    output_type=\"all\",                                        # Complete response format\n    # Note: tools are automatically loaded from MCP server\n)\n</code></pre>"},{"location":"swarms/tools/tools_examples/#step-5-use-your-mcp-enabled-agent","title":"Step 5: Use Your MCP-Enabled Agent","text":"<pre><code># The agent automatically discovers and uses tools from the MCP server\nresponse = agent.run(\n    \"Fetch the price for Bitcoin using the OKX exchange and also get its trading volume\"\n)\nprint(response)\n\n# Multiple tool usage\nresponse = agent.run(\n    \"Compare the prices of BTC, ETH, and ADA on OKX, and show their trading volumes\"\n)\nprint(response)\n</code></pre>"},{"location":"swarms/tools/tools_examples/#best-practices","title":"Best Practices","text":""},{"location":"swarms/tools/tools_examples/#function-design","title":"Function Design","text":"Practice Description Type Hints Always use type hints for all parameters and return values Docstrings Write comprehensive docstrings with Args, Returns, Raises, and Examples Error Handling Implement proper error handling with specific exception types Input Validation Validate input parameters before processing Data Structure Return structured data (preferably JSON) for consistency"},{"location":"swarms/tools/tools_examples/#mcp-server-development","title":"MCP Server Development","text":"Practice Description Tool Naming Use descriptive tool names that clearly indicate functionality Timeouts Set appropriate timeouts for external API calls Error Handling Implement graceful error handling for network issues Configuration Use environment variables for sensitive configuration Testing Test tools independently before integration"},{"location":"swarms/tools/tools_examples/#agent-configuration","title":"Agent Configuration","text":"Practice Description Loop Control Choose appropriate max_loops based on task complexity Token Management Set reasonable token limits to control response length System Prompts Write clear system prompts that explain tool capabilities Agent Naming Use meaningful agent names for debugging and logging Tool Integration Consider tool combinations for comprehensive functionality"},{"location":"swarms/tools/tools_examples/#performance-optimization","title":"Performance Optimization","text":"Practice Description Data Caching Cache frequently requested data when possible Connection Management Use connection pooling for multiple API calls Rate Control Implement rate limiting to respect API constraints Performance Monitoring Monitor tool execution times and optimize slow operations Async Operations Use async operations for concurrent tool execution when supported"},{"location":"swarms/tools/tools_examples/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms/tools/tools_examples/#common-issues","title":"Common Issues","text":""},{"location":"swarms/tools/tools_examples/#tool-not-found","title":"Tool Not Found","text":"<pre><code># Ensure function is in tools list\nagent = Agent(\n    # ... other config ...\n    tools=[your_function_name],  # Function object, not string\n)\n</code></pre>"},{"location":"swarms/tools/tools_examples/#mcp-connection-failed","title":"MCP Connection Failed","text":"<pre><code># Check server status and URL\nimport requests\nresponse = requests.get(\"http://localhost:8001/health\")  # Health check endpoint\n</code></pre>"},{"location":"swarms/tools/tools_examples/#type-hint-errors","title":"Type Hint Errors","text":"<pre><code># Always specify return types\ndef my_tool(param: str) -&gt; str:  # Not just -&gt; None\n    return \"result\"\n</code></pre>"},{"location":"swarms/tools/tools_examples/#json-parsing-issues","title":"JSON Parsing Issues","text":"<pre><code># Always return valid JSON strings\nimport json\nreturn json.dumps({\"result\": data}, indent=2)\n</code></pre>"},{"location":"swarms/ui/main/","title":"Swarms Chat UI Documentation","text":"<p>The Swarms Chat interface provides a customizable, multi-agent chat experience using Gradio. It supports various specialized AI agents\u2014from finance to healthcare and news analysis\u2014by leveraging Swarms models.</p>"},{"location":"swarms/ui/main/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Installation</li> <li>Quick Start</li> <li>Parameters Overview</li> <li>Specialized Agents<ul> <li>Finance Agents</li> <li>Healthcare Agents</li> <li>News &amp; Research Agents</li> </ul> </li> <li>Swarms Integration Features</li> <li>Usage Examples<ul> <li>Finance Agent Example</li> <li>Healthcare Agent Example</li> <li>News Analysis Agent Example</li> </ul> </li> <li>Setup and Deployment</li> <li>Best Practices</li> <li>Notes</li> </ol>"},{"location":"swarms/ui/main/#installation","title":"Installation","text":"<p>Make sure you have Python 3.7+ installed, then install the required packages using pip:</p> <pre><code>pip install gradio ai-gradio swarms\n</code></pre>"},{"location":"swarms/ui/main/#quick-start","title":"Quick Start","text":"<p>Below is a minimal example to get the Swarms Chat interface up and running. Customize the agent, title, and description as needed.</p> <pre><code>import gradio as gr\nimport ai_gradio\n\n# Create and launch a Swarms Chat interface\ngr.load(\n    name='swarms:gpt-4-turbo',  # Model identifier (supports OpenAI and others)\n    src=ai_gradio.registry,      # Source module for model configurations\n    agent_name=\"Stock-Analysis-Agent\",  # Example agent from Finance category\n    title='Swarms Chat',\n    description='Chat with an AI agent powered by Swarms'\n).launch()\n</code></pre>"},{"location":"swarms/ui/main/#parameters-overview","title":"Parameters Overview","text":"<p>When configuring your interface, consider the following parameters:</p> <ul> <li> <p><code>name</code> (str):   Model identifier (e.g., <code>'swarms:gpt-4-turbo'</code>) that specifies which Swarms model to use.</p> </li> <li> <p><code>src</code> (module):   The source module (typically <code>ai_gradio.registry</code>) that contains model configurations.</p> </li> <li> <p><code>agent_name</code> (str):   The name of the specialized agent you wish to use (e.g., \"Stock-Analysis-Agent\").</p> </li> <li> <p><code>title</code> (str):   The title that appears at the top of the web interface.</p> </li> <li> <p><code>description</code> (str):   A short summary describing the functionality of the chat interface.</p> </li> </ul>"},{"location":"swarms/ui/main/#specialized-agents","title":"Specialized Agents","text":"<p>Swarms Chat supports multiple specialized agents designed for different domains. Below is an overview of available agent types.</p>"},{"location":"swarms/ui/main/#finance-agents","title":"Finance Agents","text":"<ol> <li>Stock Analysis Agent</li> <li> <p>Capabilities:</p> <ul> <li>Market analysis and stock recommendations.</li> <li>Both technical and fundamental analysis.</li> <li>Portfolio management suggestions.</li> </ul> </li> <li> <p>Tax Planning Agent</p> </li> <li>Capabilities:<ul> <li>Tax optimization strategies.</li> <li>Deduction analysis.</li> <li>Guidance on tax law compliance.</li> </ul> </li> </ol>"},{"location":"swarms/ui/main/#healthcare-agents","title":"Healthcare Agents","text":"<ol> <li>Medical Diagnosis Assistant</li> <li> <p>Capabilities:</p> <ul> <li>Analysis of symptoms.</li> <li>Treatment recommendations.</li> <li>Research using current medical literature.</li> </ul> </li> <li> <p>Healthcare Management Agent</p> </li> <li>Capabilities:<ul> <li>Patient care coordination.</li> <li>Organization of medical records.</li> <li>Monitoring and tracking treatment plans.</li> </ul> </li> </ol>"},{"location":"swarms/ui/main/#news-research-agents","title":"News &amp; Research Agents","text":"<ol> <li>News Analysis Agent</li> <li> <p>Capabilities:</p> <ul> <li>Real-time news aggregation.</li> <li>Filtering news by topics.</li> <li>Trend analysis and insights.</li> </ul> </li> <li> <p>Research Assistant</p> </li> <li>Capabilities:<ul> <li>Analysis of academic papers.</li> <li>Literature review support.</li> <li>Guidance on research methodologies.</li> </ul> </li> </ol>"},{"location":"swarms/ui/main/#swarms-integration-features","title":"Swarms Integration Features","text":""},{"location":"swarms/ui/main/#core-capabilities","title":"Core Capabilities","text":"<ul> <li>Multi-Agent Collaboration: Multiple agents can be engaged simultaneously for a coordinated experience.</li> <li>Real-Time Data Processing: The interface processes and responds to queries in real time.</li> <li>Natural Language Understanding: Advanced NLP for context-aware and coherent responses.</li> <li>Context-Aware Responses: Responses are tailored based on conversation context.</li> </ul>"},{"location":"swarms/ui/main/#technical-features","title":"Technical Features","text":"<ul> <li>API Integration Support: Easily connect with external APIs.</li> <li>Custom Model Selection: Choose the appropriate model for your specific task.</li> <li>Concurrent Processing: Supports multiple sessions concurrently.</li> <li>Session Management: Built-in session management ensures smooth user interactions.</li> </ul>"},{"location":"swarms/ui/main/#usage-examples","title":"Usage Examples","text":"<p>Below are detailed examples for each type of specialized agent.</p>"},{"location":"swarms/ui/main/#finance-agent-example","title":"Finance Agent Example","text":"<p>This example configures a chat interface for stock analysis:</p> <pre><code>import gradio as gr\nimport ai_gradio\n\nfinance_interface = gr.load(\n    name='swarms:gpt-4-turbo',\n    src=ai_gradio.registry,\n    agent_name=\"Stock-Analysis-Agent\",\n    title='Finance Assistant',\n    description='Expert financial analysis and advice tailored to your investment needs.'\n)\nfinance_interface.launch()\n</code></pre>"},{"location":"swarms/ui/main/#healthcare-agent-example","title":"Healthcare Agent Example","text":"<p>This example sets up a chat interface for healthcare assistance:</p> <pre><code>import gradio as gr\nimport ai_gradio\n\nhealthcare_interface = gr.load(\n    name='swarms:gpt-4-turbo',\n    src=ai_gradio.registry,\n    agent_name=\"Medical-Assistant-Agent\",\n    title='Healthcare Assistant',\n    description='Access medical information, symptom analysis, and treatment recommendations.'\n)\nhealthcare_interface.launch()\n</code></pre>"},{"location":"swarms/ui/main/#news-analysis-agent-example","title":"News Analysis Agent Example","text":"<p>This example creates an interface for real-time news analysis:</p> <pre><code>import gradio as gr\nimport ai_gradio\n\nnews_interface = gr.load(\n    name='swarms:gpt-4-turbo',\n    src=ai_gradio.registry,\n    agent_name=\"News-Analysis-Agent\",\n    title='News Analyzer',\n    description='Get real-time insights and analysis of trending news topics.'\n)\nnews_interface.launch()\n</code></pre>"},{"location":"swarms/ui/main/#setup-and-deployment","title":"Setup and Deployment","text":"<ol> <li>Install Dependencies:    Make sure all required packages are installed.</li> </ol> <pre><code>pip install gradio ai-gradio swarms\n</code></pre> <ol> <li>Import Modules:    Import Gradio and ai_gradio in your Python script.</li> </ol> <pre><code>import gradio as gr\nimport ai_gradio\n</code></pre> <ol> <li>Configure and Launch the Interface:    Configure your interface with the desired parameters and then launch.</li> </ol> <pre><code>interface = gr.load(\n    name='swarms:gpt-4-turbo',\n    src=ai_gradio.registry,\n    agent_name=\"Your-Desired-Agent\",\n    title='Your Interface Title',\n    description='A brief description of your interface.'\n)\ninterface.launch()\n</code></pre> <ol> <li>Deployment Options: </li> <li>Local: By default, the interface runs at http://localhost:7860.</li> <li>Cloud Deployment: Use cloud platforms like Heroku, AWS, or Google Cloud for remote access.</li> <li>Concurrent Sessions: The system supports multiple users at the same time. Monitor resources and use proper scaling.</li> </ol>"},{"location":"swarms/ui/main/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Select the Right Agent:    Use the agent that best suits your specific domain needs.</p> </li> <li> <p>Model Configuration:    Adjust model parameters based on your computational resources to balance performance and cost.</p> </li> <li> <p>Error Handling:    Implement error handling to manage unexpected inputs or API failures gracefully.</p> </li> <li> <p>Resource Monitoring:    Keep an eye on system performance, especially during high-concurrency sessions.</p> </li> <li> <p>Regular Updates:    Keep your Swarms and Gradio packages updated to ensure compatibility with new features and security patches.</p> </li> </ol>"},{"location":"swarms/ui/main/#notes","title":"Notes","text":"<ul> <li> <p>Local vs. Remote:   The interface runs locally by default but can be deployed on remote servers for wider accessibility.</p> </li> <li> <p>Customization:   You can configure custom model parameters and integrate additional APIs as needed.</p> </li> <li> <p>Session Management:   Built-in session handling ensures that users can interact concurrently without interfering with each other's sessions.</p> </li> <li> <p>Error Handling &amp; Rate Limiting:   The system includes basic error handling and rate limiting to maintain performance under load.</p> </li> </ul> <p>This documentation is designed to provide clarity, reliability, and comprehensive guidance for integrating and using the Swarms Chat UI. For further customization or troubleshooting, consult the respective package documentation and community forums.</p>"},{"location":"swarms_cloud/add_agent/","title":"Publishing an Agent to Agent Marketplace","text":""},{"location":"swarms_cloud/add_agent/#requirements","title":"Requirements","text":"<ul> <li> <p><code>swarms-cloud</code> package with <code>pip3 install -U swarms-cloud</code></p> </li> <li> <p>Onboarding Process with <code>swarms-cloud onboarding</code></p> </li> <li> <p>A Dockerfile <code>Dockerfile</code> containing the API of your agent code with FastAPI</p> </li> <li> <p>A YAML file for configuration <code>agent.yaml</code></p> </li> </ul>"},{"location":"swarms_cloud/add_agent/#deployment-yaml","title":"Deployment YAML","text":"<pre><code># Agent metadata and description\nagent_name: \"example-agent\"  # The name of the agent\ndescription: \"This agent performs financial data analysis.\"  # A brief description of the agent's purpose\nversion: \"v1.0\"  # The version number of the agent\nauthor: \"Agent Creator Name\"  # The name of the person or entity that created the agent\ncontact_email: \"creator@example.com\"  # The email address for contacting the agent's creator\ntags:\n  - \"financial\"  # Tag indicating the agent is related to finance\n  - \"data-analysis\"  # Tag indicating the agent performs data analysis\n  - \"agent\"  # Tag indicating this is an agent\n\n\n# Deployment configuration\ndeployment_config:\n  # Dockerfile configuration\n  dockerfile_path: \"./Dockerfile\"  # The path to the Dockerfile for building the agent's image\n  dockerfile_port: 8080  # The port number the agent will listen on\n\n  # Resource allocation for the agent\n  resources:\n    cpu: 2  # Number of CPUs allocated to the agent\n    memory: \"2Gi\"  # Memory allocation for the agent in gigabytes\n    max_instances: 5  # Maximum number of instances to scale up to\n    min_instances: 1  # Minimum number of instances to keep running\n    timeout: 300s  # Request timeout setting in seconds\n\n  # Autoscaling configuration\n  autoscaling:\n    max_concurrency: 80  # Maximum number of requests the agent can handle concurrently\n    target_utilization: 0.6  # CPU utilization target for auto-scaling\n\n  # Environment variables for the agent\n  environment_variables:\n    DATABASE_URL: \"postgres://user:password@db-url\"  # URL for the database connection\n    API_KEY: \"your-secret-api-key\"  # API key for authentication\n    LOG_LEVEL: \"info\"  # Log level for the agent\n\n  # Secrets configuration\n  secrets:\n    SECRET_NAME_1: \"projects/my-project/secrets/my-secret/versions/latest\"  # Path to a secret\n</code></pre>"},{"location":"swarms_cloud/agent_api/","title":"Agent API","text":"<p>The Swarms.ai Agent API provides powerful endpoints for running individual AI agents and batch agent operations. This documentation explains how to use these endpoints for effective agent-based task execution.</p>"},{"location":"swarms_cloud/agent_api/#getting-started","title":"Getting Started","text":"<p>To use the Agent API, you'll need a Swarms.ai API key:</p> <ol> <li>Go to https://swarms.world/platform/api-keys</li> <li>Generate a new API key</li> <li>Store your API key securely - it won't be shown again</li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\n\n# Load API key from environment\nload_dotenv()\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\n# Configure headers with your API key\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n</code></pre>"},{"location":"swarms_cloud/agent_api/#individual-agent-api","title":"Individual Agent API","text":"<p>The Individual Agent API allows you to run a single agent with a specific configuration and task.</p>"},{"location":"swarms_cloud/agent_api/#agent-configuration-agentspec","title":"Agent Configuration (<code>AgentSpec</code>)","text":"<p>The <code>AgentSpec</code> class defines the configuration for an individual agent.</p> Parameter Type Default Description <code>agent_name</code> string Required Unique name identifying the agent and its functionality <code>description</code> string None Detailed explanation of the agent's purpose and capabilities <code>system_prompt</code> string None Initial instructions guiding the agent's behavior and responses <code>model_name</code> string \"gpt-4o-mini\" The AI model used by the agent (e.g., gpt-4o, gpt-4o-mini, openai/o3-mini) <code>auto_generate_prompt</code> boolean false Whether the agent should automatically create prompts based on task requirements <code>max_tokens</code> integer 8192 Maximum number of tokens the agent can generate in its responses <code>temperature</code> float 0.5 Controls output randomness (lower values = more deterministic responses) <code>role</code> string \"worker\" The agent's role within a swarm, influencing its behavior and interactions <code>max_loops</code> integer 1 Maximum number of times the agent can repeat its task for iterative processing <code>tools_dictionary</code> array None Dictionary of tools the agent can use to complete its task <code>mcp_url</code> string None URL for the MCP server that the agent can connect to"},{"location":"swarms_cloud/agent_api/#agent-completion","title":"Agent Completion","text":"<p>The <code>AgentCompletion</code> class combines an agent configuration with a specific task.</p> Parameter Type Description <code>agent_config</code> AgentSpec Configuration of the agent to be completed <code>task</code> string The task to be completed by the agent <code>history</code> Optional[Union[Dict[Any, Any], List[Dict[str, str]]]] The history of the agent's previous tasks and responses. Can be either a dictionary or a list of message objects."},{"location":"swarms_cloud/agent_api/#single-agent-endpoint","title":"Single Agent Endpoint","text":"<p>Endpoint: <code>POST /v1/agent/completions</code></p> <p>Run a single agent with a specific configuration and task.</p>"},{"location":"swarms_cloud/agent_api/#request","title":"Request","text":"<pre><code>def run_single_agent(agent_config, task):\n    \"\"\"\n    Run a single agent with the AgentCompletion format.\n\n    Args:\n        agent_config: Dictionary containing agent configuration\n        task: String describing the task for the agent\n\n    Returns:\n        Dictionary containing the agent's response\n    \"\"\"\n    payload = {\n        \"agent_config\": agent_config,\n        \"task\": task\n    }\n\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/v1/agent/completions\", \n            headers=headers, \n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error making request: {e}\")\n        return None\n</code></pre>"},{"location":"swarms_cloud/agent_api/#example-usage","title":"Example Usage","text":"<pre><code>agent_config = {\n    \"agent_name\": \"Research Analyst\",\n    \"description\": \"An expert in analyzing and synthesizing research data\",\n    \"system_prompt\": (\n        \"You are a Research Analyst with expertise in data analysis and synthesis. \"\n        \"Your role is to analyze provided information, identify key insights, \"\n        \"and present findings in a clear, structured format. \"\n        \"Focus on accuracy, clarity, and actionable recommendations.\"\n    ),\n    \"model_name\": \"gpt-4o\",\n    \"role\": \"worker\",\n    \"max_loops\": 2,\n    \"max_tokens\": 8192,\n    \"temperature\": 0.5,\n    \"auto_generate_prompt\": False,\n}\n\ntask = \"Analyze the impact of artificial intelligence on healthcare delivery and provide a comprehensive report with key findings and recommendations.\"\n\nresult = run_single_agent(agent_config, task)\nprint(result)\n</code></pre>"},{"location":"swarms_cloud/agent_api/#response-structure","title":"Response Structure","text":"<pre><code>{\n  \"id\": \"agent-6a8b9c0d1e2f3g4h5i6j7k8l9m0n\",\n  \"success\": true,\n  \"name\": \"Research Analyst\",\n  \"description\": \"An expert in analyzing and synthesizing research data\",\n  \"temperature\": 0.5,\n  \"outputs\": {\n    \"content\": \"# Impact of Artificial Intelligence on Healthcare Delivery\\n\\n## Executive Summary\\n...\",\n    \"role\": \"assistant\"\n  },\n  \"usage\": {\n    \"input_tokens\": 1250,\n    \"output_tokens\": 3822,\n    \"total_tokens\": 5072\n  },\n  \"timestamp\": \"2025-05-10T18:35:29.421Z\"\n}\n</code></pre>"},{"location":"swarms_cloud/agent_api/#batch-agent-api","title":"Batch Agent API","text":"<p>The Batch Agent API allows you to run multiple agents in parallel, each with different configurations and tasks.</p>"},{"location":"swarms_cloud/agent_api/#batch-agent-endpoint","title":"Batch Agent Endpoint","text":"<p>Endpoint: <code>POST /v1/agent/batch/completions</code></p> <p>Run multiple agents with different configurations and tasks in a single API call.</p>"},{"location":"swarms_cloud/agent_api/#request_1","title":"Request","text":"<pre><code>def run_batch_agents(agent_completions):\n    \"\"\"\n    Run multiple agents in batch.\n\n    Args:\n        agent_completions: List of dictionaries, each containing agent_config and task\n\n    Returns:\n        List of agent responses\n    \"\"\"\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/v1/agent/batch/completions\",\n            headers=headers,\n            json=agent_completions\n        )\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error making batch request: {e}\")\n        return None\n</code></pre>"},{"location":"swarms_cloud/agent_api/#example-usage_1","title":"Example Usage","text":"<pre><code>batch_completions = [\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Research Analyst\",\n            \"description\": \"An expert in analyzing research data\",\n            \"system_prompt\": \"You are a Research Analyst...\",\n            \"model_name\": \"gpt-4o\",\n            \"max_loops\": 2\n        },\n        \"task\": \"Analyze the impact of AI on healthcare delivery.\"\n    },\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Market Analyst\",\n            \"description\": \"An expert in market analysis\",\n            \"system_prompt\": \"You are a Market Analyst...\",\n            \"model_name\": \"gpt-4o\",\n            \"max_loops\": 1\n        },\n        \"task\": \"Analyze the AI startup landscape in 2025.\"\n    }\n]\n\nbatch_results = run_batch_agents(batch_completions)\nprint(batch_results)\n</code></pre>"},{"location":"swarms_cloud/agent_api/#response-structure_1","title":"Response Structure","text":"<pre><code>[\n  {\n    \"id\": \"agent-1a2b3c4d5e6f7g8h9i0j\",\n    \"success\": true,\n    \"name\": \"Research Analyst\",\n    \"description\": \"An expert in analyzing research data\",\n    \"temperature\": 0.5,\n    \"outputs\": {\n      \"content\": \"# Impact of AI on Healthcare Delivery\\n...\",\n      \"role\": \"assistant\"\n    },\n    \"usage\": {\n      \"input_tokens\": 1250,\n      \"output_tokens\": 3822,\n      \"total_tokens\": 5072\n    },\n    \"timestamp\": \"2025-05-10T18:35:29.421Z\"\n  },\n  {\n    \"id\": \"agent-9i8h7g6f5e4d3c2b1a0\",\n    \"success\": true,\n    \"name\": \"Market Analyst\",\n    \"description\": \"An expert in market analysis\",\n    \"temperature\": 0.5,\n    \"outputs\": {\n      \"content\": \"# AI Startup Landscape 2025\\n...\",\n      \"role\": \"assistant\"\n    },\n    \"usage\": {\n      \"input_tokens\": 980,\n      \"output_tokens\": 4120,\n      \"total_tokens\": 5100\n    },\n    \"timestamp\": \"2025-05-10T18:35:31.842Z\"\n  }\n]\n</code></pre>"},{"location":"swarms_cloud/agent_api/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes to indicate success or failure:</p> Status Code Meaning 200 Success 400 Bad Request - Check your request parameters 401 Unauthorized - Invalid or missing API key 403 Forbidden - Insufficient permissions 429 Too Many Requests - Rate limit exceeded 500 Server Error - Something went wrong on the server <p>When an error occurs, the response body will contain additional information:</p> <pre><code>{\n  \"detail\": \"Error message explaining what went wrong\"\n}\n</code></pre>"},{"location":"swarms_cloud/agent_api/#common-errors-and-solutions","title":"Common Errors and Solutions","text":"Error Possible Solution \"Invalid API Key\" Verify your API key is correct and properly included in the request headers \"Rate limit exceeded\" Reduce the number of requests or contact support to increase your rate limit \"Invalid agent configuration\" Check your agent_config parameters for any missing or invalid values \"Failed to create agent\" Ensure your system_prompt and model_name are valid \"Insufficient credits\" Add credits to your account at https://swarms.world/platform/account"},{"location":"swarms_cloud/agent_api/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms_cloud/agent_api/#setting-dynamic-temperature","title":"Setting Dynamic Temperature","text":"<p>The agent can dynamically adjust its temperature for optimal outputs:</p> <pre><code>agent_config = {\n    # Other config options...\n    \"temperature\": 0.7,\n    \"dynamic_temperature_enabled\": True\n}\n</code></pre>"},{"location":"swarms_cloud/agent_api/#using-agent-tools","title":"Using Agent Tools","text":"<p>Agents can utilize various tools to enhance their capabilities:</p> <pre><code>agent_config = {\n    # Other config options...\n    \"tools_dictionary\": [\n        {\n            \"name\": \"web_search\",\n            \"description\": \"Search the web for information\",\n            \"parameters\": {\n                \"query\": \"string\"\n            }\n        },\n        {\n            \"name\": \"calculator\",\n            \"description\": \"Perform mathematical calculations\",\n            \"parameters\": {\n                \"expression\": \"string\"\n            }\n        }\n    ]\n}\n</code></pre>"},{"location":"swarms_cloud/agent_api/#best-practices","title":"Best Practices","text":"<p>API Key Security</p> <p>Store API keys in environment variables or secure vaults, never in code repositories. <pre><code># DON'T do this\napi_key = \"sk-123456789abcdef\"\n\n# DO this instead\nimport os\nfrom dotenv import load_dotenv\nload_dotenv()\napi_key = os.getenv(\"SWARMS_API_KEY\")\n</code></pre></p> <p>Agent Naming Conventions</p> <p>Use a consistent naming pattern for your agents to make your code more maintainable. <pre><code># Good naming convention\nagent_configs = {\n    \"market_analyst\": {...},\n    \"research_specialist\": {...},\n    \"code_reviewer\": {...}\n}\n</code></pre></p> <p>Crafting Effective System Prompts</p> <p>A well-crafted system prompt acts as your agent's personality and instruction set.</p> Basic PromptEnhanced Prompt <pre><code>You are a research analyst. Analyze the data and provide insights.\n</code></pre> <pre><code>You are a Research Analyst with 15+ years of experience in biotech market analysis.\n\nYour task is to:\n1. Analyze the provided market data methodically\n2. Identify key trends and emerging patterns\n3. Highlight potential investment opportunities\n4. Assess risks and regulatory considerations\n5. Provide actionable recommendations supported by the data\n\nFormat your response as a professional report with clear sections,\nfocusing on data-driven insights rather than generalities.\n</code></pre> <p>Token Management</p> <p>Manage your token usage carefully to control costs.</p> <ul> <li>Higher token limits provide more complete responses but increase costs</li> <li>Consider using different models based on task complexity</li> <li>For gpt-4o models, typical settings:<ul> <li>Simple tasks: 2048 tokens (lower cost)</li> <li>Medium complexity: 4096 tokens (balanced)</li> <li>Complex analysis: 8192+ tokens (higher cost, more detail)</li> </ul> </li> </ul> <p>Error Handling</p> <p>Implement comprehensive error handling to make your application resilient.</p> <pre><code>try:\n    response = requests.post(\n        f\"{BASE_URL}/v1/agent/completions\",\n        headers=headers,\n        json=payload,\n        timeout=30  # Add timeout to prevent hanging requests\n    )\n    response.raise_for_status()\n    return response.json()\nexcept requests.exceptions.HTTPError as e:\n    if e.response.status_code == 429:\n        # Implement exponential backoff for rate limiting\n        retry_after = int(e.response.headers.get('Retry-After', 5))\n        time.sleep(retry_after)\n        return run_agent(payload)  # Retry the request\n    elif e.response.status_code == 401:\n        logger.error(\"Authentication failed. Check your API key.\")\n    else:\n        logger.error(f\"HTTP Error: {e.response.status_code} - {e.response.text}\")\n    return {\"error\": e.response.text}\nexcept requests.exceptions.Timeout:\n    logger.error(\"Request timed out. The server might be busy.\")\n    return {\"error\": \"Request timed out\"}\nexcept requests.exceptions.RequestException as e:\n    logger.error(f\"Request Error: {e}\")\n    return {\"error\": str(e)}\n</code></pre> <p>Implementing Caching</p> <p>Cache identical requests to improve performance and reduce costs.</p> <pre><code>import hashlib\nimport json\nfrom functools import lru_cache\n\ndef generate_cache_key(agent_config, task):\n    \"\"\"Generate a unique cache key for an agent request.\"\"\"\n    cache_data = json.dumps({\"agent_config\": agent_config, \"task\": task}, sort_keys=True)\n    return hashlib.md5(cache_data.encode()).hexdigest()\n\n@lru_cache(maxsize=100)\ndef cached_agent_run(cache_key, agent_config, task):\n    \"\"\"Run agent with caching based on config and task.\"\"\"\n    # Convert agent_config back to a dictionary if it's a string representation\n    if isinstance(agent_config, str):\n        agent_config = json.loads(agent_config)\n\n    payload = {\n        \"agent_config\": agent_config,\n        \"task\": task\n    }\n\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/v1/agent/completions\",\n            headers=headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n    except Exception as e:\n        return {\"error\": str(e)}\n\ndef run_agent_with_cache(agent_config, task):\n    \"\"\"Wrapper function to run agent with caching.\"\"\"\n    # Generate a cache key\n    cache_key = generate_cache_key(agent_config, task)\n\n    # Convert agent_config to a hashable type for lru_cache\n    hashable_config = json.dumps(agent_config, sort_keys=True)\n\n    # Call the cached function\n    return cached_agent_run(cache_key, hashable_config, task)\n</code></pre> <p>Usage &amp; Cost Monitoring</p> <p>Set up a monitoring system to track your API usage and costs.</p> <pre><code>def log_api_usage(api_call_type, tokens_used, cost_estimate):\n    \"\"\"Log API usage for monitoring.\"\"\"\n    with open(\"api_usage_log.csv\", \"a\") as f:\n        timestamp = datetime.now().isoformat()\n        f.write(f\"{timestamp},{api_call_type},{tokens_used},{cost_estimate}\\n\")\n\ndef estimate_cost(tokens):\n    \"\"\"Estimate cost based on token usage.\"\"\"\n    # Example pricing: $0.002 per 1K tokens (adjust according to current pricing)\n    return (tokens / 1000) * 0.002\n\ndef run_agent_with_logging(agent_config, task):\n    \"\"\"Run agent and log usage.\"\"\"\n    result = run_single_agent(agent_config, task)\n\n    if \"usage\" in result:\n        total_tokens = result[\"usage\"][\"total_tokens\"]\n        cost = estimate_cost(total_tokens)\n        log_api_usage(\"single_agent\", total_tokens, cost)\n\n    return result\n</code></pre>"},{"location":"swarms_cloud/agent_api/#faq","title":"FAQ","text":"What's the difference between Single Agent and Batch Agent APIs? <p>The Single Agent API (<code>/v1/agent/completions</code>) runs one agent with one task, while the Batch Agent API (<code>/v1/agent/batch/completions</code>) allows running multiple agents with different configurations and tasks in parallel. Use Batch Agent when you need to process multiple independent tasks efficiently.</p> How do I choose the right model for my agent? <p>Model selection depends on your task complexity, performance requirements, and budget:</p> Model Best For Characteristics gpt-4o Complex analysis, creative tasks Highest quality, most expensive gpt-4o-mini General purpose tasks Good balance of quality and cost openai/o3-mini Simple, factual tasks Fast, economical <p>For exploratory work, start with gpt-4o-mini and adjust based on results.</p> What should I include in my system prompt? <p>A good system prompt should include:</p> <ol> <li>Role definition: Who the agent is and their expertise</li> <li>Task instructions: Specific, clear directions on what to do</li> <li>Output format: How results should be structured</li> <li>Constraints: Any limitations or requirements</li> <li>Examples: Sample inputs and outputs when helpful</li> </ol> <p>Keep prompts focused and avoid contradictory instructions.</p> How can I optimize costs when using the Agent API? <p>Cost optimization strategies include:</p> <ul> <li>Use the appropriate model for your task complexity</li> <li>Set reasonable token limits based on expected output length</li> <li>Implement caching for repeated or similar requests</li> <li>Batch related requests together</li> <li>Use <code>max_loops: 1</code> unless you specifically need iterative refinement</li> <li>Monitor usage patterns and adjust configurations accordingly</li> </ul> What's the maximum number of agents I can run in a batch? <p>While there's no hard limit specified, we recommend keeping batch sizes under 20 agents for optimal performance. For very large batches, consider splitting them into multiple calls or contacting support for guidance on handling high-volume processing.</p> How do I handle rate limiting? <p>Implement exponential backoff in your error handling:</p> <pre><code>import time\n\ndef run_with_backoff(func, max_retries=5, initial_delay=1):\n    \"\"\"Run a function with exponential backoff retry logic.\"\"\"\n    retries = 0\n    delay = initial_delay\n\n    while retries &lt; max_retries:\n        try:\n            return func()\n        except requests.exceptions.HTTPError as e:\n            if e.response.status_code == 429:  # Too Many Requests\n                retry_after = int(e.response.headers.get('Retry-After', delay))\n                print(f\"Rate limited. Retrying after {retry_after} seconds...\")\n                time.sleep(retry_after)\n                retries += 1\n                delay *= 2  # Exponential backoff\n            else:\n                raise\n        except Exception as e:\n            raise\n\n    raise Exception(f\"Failed after {max_retries} retries\")\n</code></pre> Can I use tools with my agents? <p>Yes, you can enable tools through the <code>tools_dictionary</code> parameter in your agent configuration. This allows agents to access external functionality like web searches, calculations, or custom tools.</p> <pre><code>agent_config = {\n    # Other configuration...\n    \"tools_dictionary\": [\n        {\n            \"name\": \"web_search\",\n            \"description\": \"Search the web for current information\",\n            \"parameters\": {\n                \"query\": {\n                    \"type\": \"string\",\n                    \"description\": \"The search query\"\n                }\n            }\n        }\n    ]\n}\n</code></pre> How do I debug agent performance issues? <p>Debugging steps for agent performance issues:</p> <ol> <li>Check system prompts: Ensure they're clear and not overly restrictive</li> <li>Review model selection: Try a more capable model if output quality is poor</li> <li>Adjust token limits: Increase max_tokens if outputs are getting truncated</li> <li>Examine temperature: Lower for more deterministic outputs, higher for creativity</li> <li>Test with simpler tasks: Isolate whether the issue is with the task complexity</li> <li>Enable verbose logging: Add detailed logging to track request/response cycles</li> <li>Contact support: For persistent issues, reach out with example payloads and responses</li> </ol> What's the pricing model for the Agent API? <p>The Agent API uses a token-based pricing model:</p> <ol> <li>Input tokens: Text sent to the API (task, system prompts)</li> <li>Output tokens: Text generated by the agent</li> </ol> <p>Pricing varies by model and is calculated per 1,000 tokens. Check the pricing page for current rates.</p> <p>The API also offers a \"flex\" tier for lower-priority, cost-effective processing.</p>"},{"location":"swarms_cloud/agent_api/#further-resources","title":"Further Resources","text":"<p> Swarms.ai Documentation  Swarms.ai Platform  API Key Management  Swarms.ai Community</p>"},{"location":"swarms_cloud/api_clients/","title":"Swarms API Clients","text":"<p>Production-Ready Client Libraries for Every Programming Language</p>"},{"location":"swarms_cloud/api_clients/#overview","title":"Overview","text":"<p>The Swarms API provides official client libraries across multiple programming languages, enabling developers to integrate powerful multi-agent AI capabilities into their applications with ease. Our clients are designed for production use, featuring robust error handling, comprehensive documentation, and seamless integration with existing codebases.</p> <p>Whether you're building enterprise applications, research prototypes, or innovative AI products, our client libraries provide the tools you need to harness the full power of the Swarms platform.</p>"},{"location":"swarms_cloud/api_clients/#available-clients","title":"Available Clients","text":"Language Status Repository Documentation Description Python \u2705 Available swarms-sdk Docs Production-grade Python client with comprehensive error handling, retry logic, and extensive examples TypeScript/Node.js \u2705 Available swarms-ts \ud83d\udcda Coming Soon Modern TypeScript client with full type safety, Promise-based API, and Node.js compatibility Go \u2705 Available swarms-client-go \ud83d\udcda Coming Soon High-performance Go client optimized for concurrent operations and microservices Java \u2705 Available swarms-java \ud83d\udcda Coming Soon Enterprise Java client with Spring Boot integration and comprehensive SDK features Kotlin \ud83d\udea7 Coming Soon In Development \ud83d\udcda Coming Soon Modern Kotlin client with coroutines support and Android compatibility Ruby \ud83d\udea7 Coming Soon In Development \ud83d\udcda Coming Soon Elegant Ruby client with Rails integration and gem packaging Rust \ud83d\udea7 Coming Soon In Development \ud83d\udcda Coming Soon Ultra-fast Rust client with memory safety and zero-cost abstractions C#/.NET \ud83d\udea7 Coming Soon In Development \ud83d\udcda Coming Soon .NET client with async/await support and NuGet packaging"},{"location":"swarms_cloud/api_clients/#client-features","title":"Client Features","text":"<p>All Swarms API clients are built with the following enterprise-grade features:</p>"},{"location":"swarms_cloud/api_clients/#core-functionality","title":"\ud83d\udd27 Core Functionality","text":"Feature Description Full API Coverage Complete access to all Swarms API endpoints Type Safety Strongly-typed interfaces for all request/response objects Error Handling Comprehensive error handling with detailed error messages Retry Logic Automatic retries with exponential backoff for transient failures"},{"location":"swarms_cloud/api_clients/#performance-reliability","title":"\ud83d\ude80 Performance &amp; Reliability","text":"Feature Description Connection Pooling Efficient HTTP connection management Rate Limiting Built-in rate limit handling and backoff strategies Timeout Configuration Configurable timeouts for different operation types Streaming Support Real-time streaming for long-running operations"},{"location":"swarms_cloud/api_clients/#security-authentication","title":"\ud83d\udee1\ufe0f Security &amp; Authentication","text":"Feature Description API Key Management Secure API key handling and rotation TLS/SSL End-to-end encryption for all communications Request Signing Optional request signing for enhanced security Environment Configuration Secure environment-based configuration"},{"location":"swarms_cloud/api_clients/#monitoring-debugging","title":"\ud83d\udcca Monitoring &amp; Debugging","text":"Feature Description Comprehensive Logging Detailed logging for debugging and monitoring Request/Response Tracing Full request/response tracing capabilities Metrics Integration Built-in metrics for monitoring client performance Debug Mode Enhanced debugging features for development"},{"location":"swarms_cloud/api_clients/#client-specific-features","title":"Client-Specific Features","text":""},{"location":"swarms_cloud/api_clients/#python-client","title":"Python Client","text":"Feature Description Async Support Full async/await support with <code>asyncio</code> Pydantic Integration Type-safe request/response models Context Managers Resource management with context managers Rich Logging Integration with Python's <code>logging</code> module"},{"location":"swarms_cloud/api_clients/#typescriptnodejs-client","title":"TypeScript/Node.js Client","text":"Feature Description TypeScript First Built with TypeScript for maximum type safety Promise-Based Modern Promise-based API with async/await Browser Compatible Works in both Node.js and modern browsers Zero Dependencies Minimal dependency footprint"},{"location":"swarms_cloud/api_clients/#go-client","title":"Go Client","text":"Feature Description Context Support Full context.Context support for cancellation Structured Logging Integration with structured logging libraries Concurrency Safe Thread-safe design for concurrent operations Minimal Allocation Optimized for minimal memory allocation"},{"location":"swarms_cloud/api_clients/#java-client","title":"Java Client","text":"Feature Description Spring Boot Ready Built-in Spring Boot auto-configuration Reactive Support Optional reactive streams support Enterprise Features JMX metrics, health checks, and more Maven &amp; Gradle Available on Maven Central"},{"location":"swarms_cloud/api_clients/#advanced-configuration","title":"Advanced Configuration","text":""},{"location":"swarms_cloud/api_clients/#environment-variables","title":"Environment Variables","text":"<p>All clients support standard environment variables for configuration:</p> <pre><code># API Configuration\nSWARMS_API_KEY=your_api_key_here\nSWARMS_BASE_URL=https://api.swarms.world\n\n# Client Configuration\nSWARMS_TIMEOUT=60\nSWARMS_MAX_RETRIES=3\nSWARMS_LOG_LEVEL=INFO\n</code></pre>"},{"location":"swarms_cloud/api_clients/#community-support","title":"Community &amp; Support","text":""},{"location":"swarms_cloud/api_clients/#documentation-resources","title":"\ud83d\udcda Documentation &amp; Resources","text":"Resource Link Complete API Documentation View Docs Python Client Docs View Docs API Examples &amp; Tutorials View Examples"},{"location":"swarms_cloud/api_clients/#community-support_1","title":"\ud83d\udcac Community Support","text":"Community Channel Description Link Discord Community Join our active developer community for real-time support and discussions Join Discord GitHub Discussions Ask questions and share ideas GitHub Discussions Twitter/X Follow for updates and announcements Twitter/X"},{"location":"swarms_cloud/api_clients/#issue-reporting-contributions","title":"\ud83d\udc1b Issue Reporting &amp; Contributions","text":"Contribution Area Description Link Report Bugs Help us improve by reporting issues Report Bugs Feature Requests Suggest new features and improvements Feature Requests Contributing Guide Learn how to contribute to the project Contributing Guide"},{"location":"swarms_cloud/api_clients/#direct-support","title":"\ud83d\udce7 Direct Support","text":"Support Type Contact Information Support Call Book a call Enterprise Support Contact us for dedicated enterprise support options"},{"location":"swarms_cloud/api_clients/#contributing-to-client-development","title":"Contributing to Client Development","text":"<p>We welcome contributions to all our client libraries! Here's how you can help:</p>"},{"location":"swarms_cloud/api_clients/#development","title":"\ud83d\udee0\ufe0f Development","text":"Task Description Implement new features and endpoints Add new API features and expand client coverage Improve error handling and retry logic Enhance robustness and reliability Add comprehensive test coverage Ensure code quality and prevent regressions Optimize performance and memory usage Improve speed and reduce resource consumption"},{"location":"swarms_cloud/api_clients/#documentation","title":"\ud83d\udcdd Documentation","text":"Task Description Write tutorials and examples Create guides and sample code for users Improve API documentation Clarify and expand reference docs Create integration guides Help users connect clients to their applications Translate documentation Make docs accessible in multiple languages"},{"location":"swarms_cloud/api_clients/#testing","title":"\ud83e\uddea Testing","text":"Task Description Add unit and integration tests Test individual components and end-to-end flows Test with different language versions Ensure compatibility across environments Performance benchmarking Measure and optimize speed and efficiency Security testing Identify and fix vulnerabilities"},{"location":"swarms_cloud/api_clients/#packaging","title":"\ud83d\udce6 Packaging","text":"Task Description Package managers (npm, pip, Maven, etc.) Publish to popular package repositories Distribution optimization Streamline builds and reduce package size Version management Maintain clear versioning and changelogs Release automation Automate build, test, and deployment pipelines"},{"location":"swarms_cloud/api_clients/#enterprise-features","title":"Enterprise Features","text":"<p>For enterprise customers, we offer additional features and support:</p>"},{"location":"swarms_cloud/api_clients/#enterprise-client-features","title":"\ud83c\udfe2 Enterprise Client Features","text":"Feature Description Priority Support Dedicated support team with SLA guarantees Custom Integrations Tailored integrations for your specific needs On-Premises Deployment Support for on-premises or private cloud deployments Advanced Security Enhanced security features and compliance support Training &amp; Onboarding Comprehensive training for your development team"},{"location":"swarms_cloud/api_clients/#contact-enterprise-sales","title":"\ud83d\udcde Contact Enterprise Sales","text":"Contact Type Details Sales kye@swarms.world Schedule Demo Book a Demo Partnership kye@swarms.world <p>Ready to build the future with AI agents? Start with any of our client libraries and join our growing community of developers building the next generation of intelligent applications. </p>"},{"location":"swarms_cloud/api_pricing/","title":"Swarm Agent API Pricing","text":"<p>\ud83c\udf89 Get Started with $20 Free Credits!</p> <p>New users receive $20 in free credits when they sign up! Create your account now to start building with our powerful multi-agent platform.</p> <p>Overview</p> <p>The Swarm Agent API provides a powerful platform for managing multi-agent collaboration at scale and orchestrating swarms of LLM agents in the cloud. Our pricing model is designed to be transparent and cost-effective, enabling you to harness the full potential of your agents with ease.</p>"},{"location":"swarms_cloud/api_pricing/#credit-system","title":"Credit System","text":"<p>The Swarm API operates on a credit-based system with the following characteristics:</p> <ul> <li> <p>Credits are the currency used within the platform</p> </li> <li> <p>1 credit = $1 USD</p> </li> <li> <p>Credits can be purchased with USD or $swarms Solana tokens</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#credit-types","title":"Credit Types","text":"Type Description Expiration Standard Credits Purchased credits Never expires Free Credits Promotional credits May have expiration dates"},{"location":"swarms_cloud/api_pricing/#pricing-structure","title":"Pricing Structure","text":""},{"location":"swarms_cloud/api_pricing/#base-costs","title":"Base Costs","text":"Cost Component Price Base cost per agent $0.01 per agent"},{"location":"swarms_cloud/api_pricing/#token-usage-costs","title":"Token Usage Costs","text":"Token Type Cost Input tokens $2.00 per 1M tokens Output tokens $4.50 per 1M tokens"},{"location":"swarms_cloud/api_pricing/#night-time-discount","title":"Night-Time Discount","text":"<p>Off-Peak Hours Discount</p> <p>To encourage efficient resource usage during off-peak hours, we offer significant discounts for operations performed during California night-time hours:</p> Time Period (Pacific Time) Discount 8:00 PM to 6:00 AM 75% off token costs"},{"location":"swarms_cloud/api_pricing/#cost-calculation","title":"Cost Calculation","text":""},{"location":"swarms_cloud/api_pricing/#formula","title":"Formula","text":"<p>The total cost for a swarm execution is calculated as follows:</p> <pre><code>Total Cost = (Number of Agents \u00d7 $0.01) + \n             (Total Input Tokens / 1M \u00d7 $2.00 \u00d7 Number of Agents) +\n             (Total Output Tokens / 1M \u00d7 $4.50 \u00d7 Number of Agents)\n</code></pre> <p>With night-time discount applied: <pre><code>Input Token Cost = Input Token Cost \u00d7 0.25\nOutput Token Cost = Output Token Cost \u00d7 0.25\n</code></pre></p>"},{"location":"swarms_cloud/api_pricing/#example-scenarios","title":"Example Scenarios","text":""},{"location":"swarms_cloud/api_pricing/#scenario-1-basic-workflow-day-time","title":"Scenario 1: Basic Workflow (Day-time)","text":"<p>Basic Workflow Example</p> <p>Parameters:</p> <ul> <li> <p>3 agents</p> </li> <li> <p>10,000 input tokens total</p> </li> <li> <p>25,000 output tokens total</p> </li> </ul> <p>Calculation:</p> <ul> <li> <p>Agent cost: 3 \u00d7 $0.01 = $0.03</p> </li> <li> <p>Input token cost: (10,000 / 1,000,000) \u00d7 $2.00 \u00d7 3 = $0.06</p> </li> <li> <p>Output token cost: (25,000 / 1,000,000) \u00d7 $4.50 \u00d7 3 = $0.3375</p> </li> <li> <p>Total cost: $0.4275</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#scenario-2-complex-workflow-night-time","title":"Scenario 2: Complex Workflow (Night-time)","text":"<p>Complex Workflow Example</p> <p>Parameters:</p> <ul> <li> <p>5 agents</p> </li> <li> <p>50,000 input tokens total</p> </li> <li> <p>125,000 output tokens total</p> </li> </ul> <p>Calculation:</p> <ul> <li> <p>Agent cost: 5 \u00d7 $0.01 = $0.05</p> </li> <li> <p>Input token cost: (50,000 / 1,000,000) \u00d7 $2.00 \u00d7 5 \u00d7 0.25 = $0.125</p> </li> <li> <p>Output token cost: (125,000 / 1,000,000) \u00d7 $4.50 \u00d7 5 \u00d7 0.25 = $0.703125</p> </li> <li> <p>Total cost: $0.878125</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#purchasing-credits","title":"Purchasing Credits","text":"<p>Credits can be purchased through our platform in two ways:</p>"},{"location":"swarms_cloud/api_pricing/#usd-payment","title":"USD Payment","text":"<ul> <li> <p>Available through our account page</p> </li> <li> <p>Secure payment processing</p> </li> <li> <p>Minimum purchase: $10</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#swarms-token-payment","title":"$swarms Token Payment","text":"<ul> <li> <p>Use Solana-based $swarms tokens</p> </li> <li> <p>Tokens can be purchased on supported exchanges</p> </li> <li> <p>Connect your Solana wallet on our account page</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#free-credits","title":"Free Credits","text":"<p>Free Credit Program</p> <p>We occasionally offer free credits to:</p> <ul> <li> <p>New users (welcome bonus)</p> </li> <li> <p>During promotional periods</p> </li> <li> <p>For educational and research purposes</p> </li> </ul> <p>Important Notes:</p> <ul> <li> <p>Used before standard credits</p> </li> <li> <p>May have expiration dates</p> </li> <li> <p>May have usage restrictions</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#billing-and-usage-tracking","title":"Billing and Usage Tracking","text":"<p>Track your credit usage through our comprehensive logging and reporting features:</p>"},{"location":"swarms_cloud/api_pricing/#api-logs","title":"API Logs","text":"<ul> <li> <p>Access detailed logs via the <code>/v1/swarm/logs</code> endpoint</p> </li> <li> <p>View cost breakdowns for each execution</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#dashboard","title":"Dashboard","text":"<ul> <li> <p>Real-time credit balance display</p> </li> <li> <p>Historical usage graphs</p> </li> <li> <p>Detailed cost analysis</p> </li> <li> <p>Available at https://swarms.world/platform/dashboard</p> </li> </ul>"},{"location":"swarms_cloud/api_pricing/#faq","title":"FAQ","text":"Is there a minimum credit purchase? <p>Yes, the minimum credit purchase is $10 USD equivalent.</p> Do credits expire? <p>Standard credits do not expire. Free promotional credits may have expiration dates.</p> How is the night-time discount applied? <p>The system automatically detects the execution time based on Pacific Time (America/Los_Angeles) and applies a 75% discount to token costs for executions between 8:00 PM and 6:00 AM.</p> What happens if I run out of credits during execution? <p>Executions will fail with a 402 Payment Required error if sufficient credits are not available. We recommend maintaining a credit balance appropriate for your usage patterns.</p> Can I get a refund for unused credits? <p>Please contact our support team for refund requests for unused credits.</p> Are there volume discounts available? <p>Yes, please contact our sales team for enterprise pricing and volume discounts.</p>"},{"location":"swarms_cloud/api_pricing/#references","title":"References","text":"<ul> <li>Swarm API Documentation</li> <li>Account Management Portal</li> <li>Swarm Types Reference</li> </ul> <p>Need Help?</p> <p>For additional questions or custom pricing options, please contact our support team at kye@swarms.world.</p>"},{"location":"swarms_cloud/architecture/","title":"Under The Hood: The Swarm Cloud Serving Infrastructure","text":"<p>This blog post delves into the intricate workings of our serving model infrastructure, providing a comprehensive understanding for both users and infrastructure engineers. We'll embark on a journey that starts with an API request and culminates in a response generated by your chosen model, all orchestrated within a multi-cloud environment.</p>"},{"location":"swarms_cloud/architecture/#the-journey-of-an-api-request","title":"The Journey of an API Request","text":"<ol> <li> <p>The Gateway: Your API request first arrives at an EC2 instance running SkyPilot, a lightweight controller.</p> </li> <li> <p>Intelligent Routing: SkyPilot, wielding its decision-making prowess, analyzes the request and identifies the most suitable GPU in our multi-cloud setup. Factors like resource availability, latency, and cost might influence this choice.</p> </li> <li> <p>Multi-Cloud Agility: Based on the chosen cloud provider (AWS or Azure), SkyPilot seamlessly directs the request to the appropriate containerized model residing in a sky clusters cluster. Here's where the magic of cloud-agnostic deployments comes into play.</p> </li> </ol>"},{"location":"swarms_cloud/architecture/#unveiling-the-architecture","title":"Unveiling the Architecture","text":"<p>Let's dissect the technical architecture behind this process:</p> <ul> <li> <p>SkyPilot (EC2 Instance): This lightweight controller, deployed on an EC2 instance, acts as the central hub for orchestrating requests and routing them to suitable model instances.</p> </li> <li> <p>Swarm Cloud Repositories: Each model resides within its own dedicated folder on the Swarms Cloud GitHub repository (https://github.com/kyegomez/swarms-cloud). Here, you'll find a folder structure like this:</p> </li> </ul> <pre><code>servers/\n  &lt;model_name_1&gt;/\n    sky-serve.yaml  # Deployment configuration file\n  &lt;model_name_2&gt;/\n    sky-serve.yaml\n  ...\n</code></pre> <ul> <li>SkyServe Deployment Tool: This is the workhorse responsible for deploying models within sky clusters. Each model's folder contains a <code>sky-serve.yaml</code> file that dictates the deployment configuration.</li> </ul>"},{"location":"swarms_cloud/architecture/#infrastructure-engineers-toolkit-commands-for-model-deployment","title":"Infrastructure Engineer's Toolkit: Commands for Model Deployment","text":"<p>Here's a breakdown of the <code>sky serve</code> command and its subcommands:</p> <ul> <li><code>sky serve -h</code>: Displays the help message for the <code>sky serve</code> CLI tool.</li> </ul> <p>Commands:</p> <ul> <li><code>sky serve up yaml.yaml -n --cloud aws/azure</code>: This command deploys a SkyServe service based on the provided <code>yaml.yaml</code> configuration file. The <code>-n</code> flag indicates a new deployment, and the <code>--cloud</code> flag specifies the target cloud platform (AWS or Azure).</li> </ul> <p>Additional Commands:</p> <ul> <li> <p><code>sky serve update</code>: Updates a running SkyServe service.</p> </li> <li> <p><code>sky serve status</code>: Shows the status of deployed SkyServe services.</p> </li> <li> <p><code>sky serve down</code>: Tears down (stops and removes) a SkyServe service.</p> </li> <li> <p><code>sky serve logs</code>: Tails the logs of a running SkyServe service, providing valuable insights into its operation.</p> </li> </ul> <p>By leveraging these commands, infrastructure engineers can efficiently manage the deployment and lifecycle of models within the multi-cloud environment.</p> <p>Building the Cluster and Accessing the Model:</p> <p>When you deploy a model using <code>sky serve up</code>, SkyServe triggers the building of a sky clusters cluster, if one doesn't already exist. Once the deployment is complete, SkyServe provides you with an endpoint URL for interacting with the model. This URL allows you to send requests to the deployed model and receive its predictions.</p>"},{"location":"swarms_cloud/architecture/#understanding-the-sky-serveyaml-configuration","title":"Understanding the <code>sky-serve.yaml</code> Configuration","text":"<p>The <code>sky-serve.yaml</code> file plays a crucial role in defining the deployment parameters for your model. This file typically includes properties such as:</p> <ul> <li> <p>Image: Specifies the Docker image containing your model code and dependencies.</p> </li> <li> <p>Replicas: Defines the number of model replicas to be deployed in the Swarm cluster. This allows for load balancing and fault tolerance.</p> </li> <li> <p>Resources: Sets memory and CPU resource constraints for the deployed model containers.</p> </li> <li> <p>Networking: Configures network settings for communication within the sky clusters and with the outside world.</p> </li> </ul> <p>Benefits of Our Infrastructure:</p> <ul> <li> <p>Multi-Cloud Flexibility: Deploy models seamlessly across AWS and Azure, taking advantage of whichever platform best suits your needs.</p> </li> <li> <p>Scalability: Easily scale model deployments up or down based on traffic demands.</p> </li> <li> <p>Cost Optimization: The intelligent routing by SkyPilot helps optimize costs by utilizing the most cost-effective cloud resources.</p> </li> <li> <p>Simplified Management: Manage models across clouds with a single set of commands using <code>sky serve</code>.</p> </li> </ul>"},{"location":"swarms_cloud/architecture/#deep-dive-technical-architecture","title":"Deep Dive: Technical Architecture","text":"<p>Cloud Considerations:</p> <p>Our multi-cloud architecture offers several advantages, but it also introduces complexities that need to be addressed. Here's a closer look at some key considerations:</p> <ul> <li> <p>Cloud Provider APIs and SDKs: SkyPilot interacts with the APIs and SDKs of the chosen cloud provider (AWS or Azure) to manage resources like virtual machines, storage, and networking. Infrastructure engineers need to be familiar with the specific APIs and SDKs for each cloud platform to ensure smooth operation and troubleshooting.</p> </li> <li> <p>Security: Maintaining consistent security across different cloud environments is crucial. This involves aspects like IAM (Identity and Access Management) configuration, network segmentation, and encryption of sensitive data at rest and in transit. Infrastructure engineers need to implement robust security measures tailored to each cloud provider's offerings.</p> </li> <li> <p>Network Connectivity: Establishing secure and reliable network connectivity between SkyPilot (running on EC2), sky clusters clusters (deployed on cloud VMs), and your client applications is essential. This might involve setting up VPN tunnels or utilizing cloud-native networking solutions offered by each provider.</p> </li> <li> <p>Monitoring and Logging: Monitoring the health and performance of SkyPilot, sky clusters clusters, and deployed models across clouds is critical for proactive issue identification and resolution. Infrastructure engineers can leverage cloud provider-specific monitoring tools alongside centralized logging solutions for comprehensive oversight.</p> </li> </ul> <p>sky clusters Clusters</p> <p>sky clusters is a container orchestration platform that facilitates the deployment and management of containerized applications, including your machine learning models. When you deploy a model with <code>sky serve up</code>, SkyPilot launches an node with:</p> <ul> <li> <p>Provision Resources: SkyPilot requests resources from the chosen cloud provider (e.g., VMs with GPUs) to create a sky clusters cluster if one doesn't already exist.</p> </li> <li> <p>Deploy Containerized Models: SkyPilot leverages the <code>sky-serve.yaml</code> configuration to build Docker images containing your model code and dependencies. These images are then pushed to a container registry (e.g., Docker Hub) and deployed as containers within the Swarm cluster.</p> </li> <li> <p>Load Balancing and Service Discovery: sky clusters provides built-in load balancing capabilities to distribute incoming requests across multiple model replicas, ensuring high availability and performance. Additionally, service discovery mechanisms allow models to find each other and communicate within the cluster.</p> </li> </ul> <p>SkyPilot - The Orchestrator</p> <p>SkyPilot, the lightweight controller running on an EC2 instance, plays a central role in this infrastructure. Here's a deeper look at its functionalities:</p> <ul> <li> <p>API Gateway Integration: SkyPilot can be integrated with your API gateway or service mesh to receive incoming requests for model predictions.</p> </li> <li> <p>Request Routing: SkyPilot analyzes the incoming request, considering factors like model compatibility, resource availability, and latency. Based on this analysis, SkyPilot selects the most suitable model instance within the appropriate sky clusters cluster.</p> </li> <li> <p>Cloud Provider Interaction: SkyPilot interacts with the chosen cloud provider's APIs to manage resources required for the sky clusters cluster and model deployment.</p> </li> <li> <p>Model Health Monitoring: SkyPilot can be configured to monitor the health and performance of deployed models. This might involve collecting metrics like model response times, resource utilization, and error rates.</p> </li> <li> <p>Scalability Management: Based on pre-defined policies or real-time traffic patterns, SkyPilot can trigger the scaling of model deployments (adding or removing replicas) within the sky clusters cluster.</p> </li> </ul> <p>Advanced Considerations</p> <p>This blog post has provided a foundational understanding of our serving model infrastructure. For infrastructure engineers seeking a deeper dive, here are some additional considerations:</p> <ul> <li> <p>Container Security: Explore container image scanning for vulnerabilities, enforcing least privilege principles within container runtime environments, and utilizing secrets management solutions for secure access to sensitive data.</p> </li> <li> <p>Model Versioning and Rollbacks: Implement a model versioning strategy to track changes and facilitate rollbacks to previous versions if necessary.</p> </li> <li> <p>A/B Testing: Integrate A/B testing frameworks to evaluate the performance of different model versions and configurations before full-scale deployment.</p> </li> <li> <p>Auto-Scaling with Cloud Monitoring: Utilize cloud provider-specific monitoring services like Amazon CloudWatch or Azure Monitor to trigger auto-scaling of sky clusters clusters based on predefined metrics.</p> </li> </ul> <p>By understanding these technical aspects and considerations, infrastructure engineers can effectively manage and optimize our multi-cloud serving model infrastructure.</p>"},{"location":"swarms_cloud/architecture/#conclusion","title":"Conclusion","text":"<p>This comprehensive exploration has shed light on the intricate workings of our serving model infrastructure. We've covered the journey of an API request, delved into the technical architecture with a focus on cloud considerations, sky clusters clusters, and SkyPilot's role as the orchestrator. We've also explored advanced considerations for infrastructure engineers seeking to further optimize and secure this multi-cloud environment.</p> <p>This understanding empowers both users and infrastructure engineers to leverage this technology effectively for deploying and managing your machine learning models at scale.</p>"},{"location":"swarms_cloud/best_practices/","title":"Swarms API Best Practices Guide","text":"<p>This comprehensive guide outlines production-grade best practices for using the Swarms API effectively. Learn how to choose the right swarm architecture, optimize costs, and implement robust error handling.</p>"},{"location":"swarms_cloud/best_practices/#quick-reference-cards","title":"Quick Reference Cards","text":"Swarm TypesApplication PatternsCost OptimizationService TiersIndustry SolutionsError Handling <p>Available Swarm Architectures</p> Swarm Type Best For Use Cases <code>AgentRearrange</code> Dynamic workflows - Complex task decomposition- Adaptive processing- Multi-stage analysis- Dynamic resource allocation <code>MixtureOfAgents</code> Diverse expertise - Cross-domain problems- Comprehensive analysis- Multi-perspective tasks- Research synthesis <code>SpreadSheetSwarm</code> Data processing - Financial analysis- Data transformation- Batch calculations- Report generation <code>SequentialWorkflow</code> Linear processes - Document processing- Step-by-step analysis- Quality control- Content pipeline <code>ConcurrentWorkflow</code> Parallel tasks - Batch processing- Independent analyses- High-throughput needs- Multi-market analysis <code>GroupChat</code> Collaborative solving - Brainstorming- Decision making- Problem solving- Strategy development <code>MultiAgentRouter</code> Task distribution - Load balancing- Specialized processing- Resource optimization- Service routing <code>AutoSwarmBuilder</code> Automated setup - Quick prototyping- Simple tasks- Testing- MVP development <code>HiearchicalSwarm</code> Complex organization - Project management- Research analysis- Enterprise workflows- Team automation <code>MajorityVoting</code> Consensus needs - Quality assurance- Decision validation- Risk assessment- Content moderation <p>Specialized Application Configurations</p> Application Recommended Swarm Benefits Team Automation <code>HiearchicalSwarm</code> - Automated team coordination- Clear responsibility chain- Scalable team structure Research Pipeline <code>SequentialWorkflow</code> - Structured research process- Quality control at each stage- Comprehensive output Trading System <code>ConcurrentWorkflow</code> - Multi-market coverage- Real-time analysis- Risk distribution Content Factory <code>MixtureOfAgents</code> - Automated content creation- Consistent quality- High throughput <p>Advanced Cost Management Strategies</p> Strategy Implementation Impact Batch Processing Group related tasks 20-30% cost reduction Off-peak Usage Schedule for 8 PM - 6 AM PT 15-25% cost reduction Token Optimization Precise prompts, focused tasks 10-20% cost reduction Caching Store reusable results 30-40% cost reduction Agent Optimization Use minimum required agents 15-25% cost reduction Smart Routing Route to specialized agents 10-15% cost reduction Prompt Engineering Optimize input tokens 15-20% cost reduction Flex Processing Use flex tier for non-urgent tasks 75% cost reduction <p>Choosing the Right Service Tier</p> Tier Best For Benefits Considerations Standard - Real-time processing- Time-sensitive tasks- Critical workflows - Immediate execution- Higher priority- Predictable timing - Higher cost- 5-min timeout Flex - Batch processing- Non-urgent tasks- Cost-sensitive workloads - 75% cost reduction- Longer timeouts- Auto-retries - Variable timing- Resource contention <p>Industry-Specific Swarm Patterns</p> Industry Use Case Applications Finance Automated trading desk - Portfolio management- Risk assessment- Market analysis- Trading execution Healthcare Clinical workflow automation - Patient analysis- Diagnostic support- Treatment planning- Follow-up care Legal Legal document processing - Document review- Case analysis- Contract review- Compliance checks E-commerce E-commerce operations - Product management- Pricing optimization- Customer support- Inventory management <p>Advanced Error Management Strategies</p> Error Code Strategy Recovery Pattern 400 Input Validation Pre-request validation with fallback 401 Auth Management Secure key rotation and storage 429 Rate Limiting Exponential backoff with queuing 500 Resilience Retry with circuit breaking 503 High Availability Multi-region redundancy 504 Timeout Handling Adaptive timeouts with partial results"},{"location":"swarms_cloud/best_practices/#choosing-the-right-swarm-architecture","title":"Choosing the Right Swarm Architecture","text":""},{"location":"swarms_cloud/best_practices/#decision-framework","title":"Decision Framework","text":"<p>Use this framework to select the optimal swarm architecture for your use case:</p> <ol> <li> <p>Task Complexity Analysis</p> <ul> <li>Simple tasks \u2192 <code>AutoSwarmBuilder</code></li> <li>Complex tasks \u2192 <code>HiearchicalSwarm</code> or <code>MultiAgentRouter</code></li> <li>Dynamic tasks \u2192 <code>AgentRearrange</code></li> </ul> </li> <li> <p>Workflow Pattern</p> <ul> <li>Linear processes \u2192 <code>SequentialWorkflow</code></li> <li>Parallel operations \u2192 <code>ConcurrentWorkflow</code></li> <li>Collaborative tasks \u2192 <code>GroupChat</code></li> </ul> </li> <li> <p>Domain Requirements</p> <ul> <li>Multi-domain expertise \u2192 <code>MixtureOfAgents</code></li> <li>Data processing \u2192 <code>SpreadSheetSwarm</code></li> <li>Quality assurance \u2192 <code>MajorityVoting</code></li> </ul> </li> </ol>"},{"location":"swarms_cloud/best_practices/#industry-specific-recommendations","title":"Industry-Specific Recommendations","text":"FinanceHealthcareLegal <p>Financial Applications</p> <ul> <li>Risk Analysis: <code>HiearchicalSwarm</code></li> <li>Market Research: <code>MixtureOfAgents</code></li> <li>Trading Strategies: <code>ConcurrentWorkflow</code></li> <li>Portfolio Management: <code>SpreadSheetSwarm</code></li> </ul> <p>Healthcare Applications</p> <ul> <li>Patient Analysis: <code>SequentialWorkflow</code></li> <li>Research Review: <code>MajorityVoting</code></li> <li>Treatment Planning: <code>GroupChat</code></li> <li>Medical Records: <code>MultiAgentRouter</code></li> </ul> <p>Legal Applications</p> <ul> <li>Document Review: <code>SequentialWorkflow</code></li> <li>Case Analysis: <code>MixtureOfAgents</code></li> <li>Compliance Check: <code>HiearchicalSwarm</code></li> <li>Contract Analysis: <code>ConcurrentWorkflow</code></li> </ul>"},{"location":"swarms_cloud/best_practices/#production-best-practices","title":"Production Best Practices","text":""},{"location":"swarms_cloud/best_practices/#best-practices-summary","title":"Best Practices Summary","text":"<p>Recommended Patterns</p> <ul> <li>Use appropriate swarm types for tasks</li> <li>Implement robust error handling</li> <li>Monitor and log executions</li> <li>Cache repeated results</li> <li>Rotate API keys regularly</li> <li>Choose appropriate service tier based on task urgency</li> <li>Use flex processing for batch and non-urgent tasks</li> </ul> <p>Anti-patterns to Avoid</p> <ul> <li>Hardcoding API keys</li> <li>Ignoring rate limits</li> <li>Missing error handling</li> <li>Excessive agent count</li> <li>Inadequate monitoring</li> <li>Using standard tier for non-urgent tasks</li> <li>Not implementing retry logic for flex tier</li> </ul>"},{"location":"swarms_cloud/best_practices/#performance-benchmarks","title":"Performance Benchmarks","text":"<p>Typical Performance Metrics</p> Metric Target Range Warning Threshold Response Time &lt; 2s (standard)&lt; 15s (flex) &gt; 5s (standard)&gt; 30s (flex) Success Rate &gt; 99% &lt; 95% Cost per Task &lt; $0.05 (standard)&lt; $0.0125 (flex) &gt; $0.10 (standard)&gt; $0.025 (flex) Cache Hit Rate &gt; 80% &lt; 60% Error Rate &lt; 1% &gt; 5% Retry Rate (flex) &lt; 10% &gt; 30%"},{"location":"swarms_cloud/best_practices/#additional-resources","title":"Additional Resources","text":"<p>Useful Links</p> <ul> <li>Swarms API Documentation</li> <li>API Dashboard</li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/","title":"Swarm Agent API \u5b9a\u4ef7\u6587\u6863","text":"<p>Swarm Agent API \u63d0\u4f9b\u4e86\u4e00\u4e2a\u5f3a\u5927\u7684\u5e73\u53f0\uff0c\u7528\u4e8e\u5927\u89c4\u6a21\u7ba1\u7406\u591a\u4ee3\u7406\u534f\u4f5c\u548c\u5728\u4e91\u7aef\u7f16\u6392 LLM \u4ee3\u7406\u7fa4\u3002\u672c\u6587\u6863\u6982\u8ff0\u4e86\u5b9a\u4ef7\u6a21\u578b\u3001\u6210\u672c\u8ba1\u7b97\u65b9\u5f0f\u4ee5\u53ca\u5982\u4f55\u8d2d\u4e70\u548c\u7ba1\u7406\u60a8\u7684\u79ef\u5206\u3002</p> <p>\u6211\u4eec\u7684\u5b9a\u4ef7\u8bbe\u8ba1\u65e8\u5728\u900f\u660e\u4e14\u5177\u6709\u6210\u672c\u6548\u76ca\uff0c\u4f7f\u60a8\u80fd\u591f\u8f7b\u677e\u53d1\u6325\u4ee3\u7406\u7684\u5168\u90e8\u6f5c\u529b\u3002\u6210\u672c\u57fa\u4e8e\uff1a</p> <ul> <li> <p>\u4f7f\u7528\u7684\u4ee3\u7406\u6570\u91cf</p> </li> <li> <p>\u8f93\u5165\u548c\u8f93\u51fa\u4ee4\u724c\u4f7f\u7528\u91cf</p> </li> <li> <p>\u6267\u884c\u65f6\u95f4</p> </li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/#_1","title":"\u79ef\u5206\u7cfb\u7edf","text":"<p>Swarm API \u91c7\u7528\u57fa\u4e8e\u79ef\u5206\u7684\u7cfb\u7edf\uff1a</p> <ul> <li> <p>**\u79ef\u5206**\u662f\u5e73\u53f0\u5185\u4f7f\u7528\u7684\u8d27\u5e01</p> </li> <li> <p>1\u79ef\u5206 = 1\u7f8e\u5143</p> </li> <li> <p>\u79ef\u5206\u53ef\u4ee5\u7528\u7f8e\u5143\u6216 $swarms Solana \u4ee3\u5e01\u8d2d\u4e70</p> </li> <li> <p>\u4e24\u79cd\u7c7b\u578b\u7684\u79ef\u5206\uff1a</p> </li> <li> <p>\u6807\u51c6\u79ef\u5206\uff1a\u8d2d\u4e70\u7684\u79ef\u5206\u6c38\u4e0d\u8fc7\u671f</p> </li> <li> <p>\u514d\u8d39\u79ef\u5206\uff1a\u4fc3\u9500\u79ef\u5206\uff0c\u53ef\u80fd\u6709\u4f7f\u7528\u9650\u5236</p> </li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/#_2","title":"\u5b9a\u4ef7\u7ed3\u6784","text":""},{"location":"swarms_cloud/chinese_api_pricing/#_3","title":"\u57fa\u672c\u6210\u672c","text":"\u6210\u672c\u7ec4\u6210 \u4ef7\u683c \u6bcf\u4e2a\u4ee3\u7406\u7684\u57fa\u672c\u6210\u672c \u6bcf\u4e2a\u4ee3\u7406$0.01"},{"location":"swarms_cloud/chinese_api_pricing/#_4","title":"\u4ee4\u724c\u4f7f\u7528\u6210\u672c","text":"\u4ee4\u724c\u7c7b\u578b \u6210\u672c \u8f93\u5165\u4ee4\u724c \u6bcf\u767e\u4e07\u4ee4\u724c$2.00 \u8f93\u51fa\u4ee4\u724c \u6bcf\u767e\u4e07\u4ee4\u724c$4.50"},{"location":"swarms_cloud/chinese_api_pricing/#_5","title":"\u591c\u95f4\u6298\u6263","text":"<p>\u4e3a\u4e86\u9f13\u52b1\u5728\u975e\u9ad8\u5cf0\u65f6\u6bb5\u9ad8\u6548\u5229\u7528\u8d44\u6e90\uff0c\u6211\u4eec\u5728\u52a0\u5dde\u591c\u95f4\u65f6\u6bb5\u63d0\u4f9b\u663e\u8457\u6298\u6263\uff1a</p> \u65f6\u95f4\u6bb5\uff08\u592a\u5e73\u6d0b\u65f6\u95f4\uff09 \u6298\u6263 \u665a\u4e0a8:00\u81f3\u65e9\u4e0a6:00 \u4ee4\u724c\u6210\u672c75%\u6298\u6263"},{"location":"swarms_cloud/chinese_api_pricing/#_6","title":"\u6210\u672c\u8ba1\u7b97","text":""},{"location":"swarms_cloud/chinese_api_pricing/#_7","title":"\u516c\u5f0f","text":"<p>\u7fa4\u4f53\u6267\u884c\u7684\u603b\u6210\u672c\u8ba1\u7b97\u5982\u4e0b\uff1a</p> <pre><code>\u603b\u6210\u672c = (\u4ee3\u7406\u6570\u91cf \u00d7 $0.01) + \n        (\u603b\u8f93\u5165\u4ee4\u724c\u6570 / 1M \u00d7 $2.00 \u00d7 \u4ee3\u7406\u6570\u91cf) +\n        (\u603b\u8f93\u51fa\u4ee4\u724c\u6570 / 1M \u00d7 $4.50 \u00d7 \u4ee3\u7406\u6570\u91cf)\n</code></pre> <p>\u5e94\u7528\u591c\u95f4\u6298\u6263\u65f6\uff1a <pre><code>\u8f93\u5165\u4ee4\u724c\u6210\u672c = \u8f93\u5165\u4ee4\u724c\u6210\u672c \u00d7 0.25\n\u8f93\u51fa\u4ee4\u724c\u6210\u672c = \u8f93\u51fa\u4ee4\u724c\u6210\u672c \u00d7 0.25\n</code></pre></p>"},{"location":"swarms_cloud/chinese_api_pricing/#_8","title":"\u793a\u4f8b\u573a\u666f","text":""},{"location":"swarms_cloud/chinese_api_pricing/#1","title":"\u573a\u666f1\uff1a\u57fa\u672c\u5de5\u4f5c\u6d41\uff08\u767d\u5929\uff09","text":"<ul> <li> <p>3\u4e2a\u4ee3\u7406</p> </li> <li> <p>\u603b\u517110,000\u4e2a\u8f93\u5165\u4ee4\u724c</p> </li> <li> <p>\u603b\u517125,000\u4e2a\u8f93\u51fa\u4ee4\u724c</p> </li> </ul> <p>\u8ba1\u7b97\uff1a</p> <ul> <li> <p>\u4ee3\u7406\u6210\u672c\uff1a3 \u00d7 $0.01 = $0.03</p> </li> <li> <p>\u8f93\u5165\u4ee4\u724c\u6210\u672c\uff1a(10,000 / 1,000,000) \u00d7 $2.00 \u00d7 3 = $0.06</p> </li> <li> <p>\u8f93\u51fa\u4ee4\u724c\u6210\u672c\uff1a(25,000 / 1,000,000) \u00d7 $4.50 \u00d7 3 = $0.3375</p> </li> <li> <p>\u603b\u6210\u672c\uff1a$0.4275</p> </li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/#2","title":"\u573a\u666f2\uff1a\u590d\u6742\u5de5\u4f5c\u6d41\uff08\u591c\u95f4\uff09","text":"<ul> <li> <p>5\u4e2a\u4ee3\u7406</p> </li> <li> <p>\u603b\u517150,000\u4e2a\u8f93\u5165\u4ee4\u724c</p> </li> <li> <p>\u603b\u5171125,000\u4e2a\u8f93\u51fa\u4ee4\u724c</p> </li> </ul> <p>\u8ba1\u7b97\uff1a</p> <ul> <li> <p>\u4ee3\u7406\u6210\u672c\uff1a5 \u00d7 $0.01 = $0.05</p> </li> <li> <p>\u8f93\u5165\u4ee4\u724c\u6210\u672c\uff1a(50,000 / 1,000,000) \u00d7 $2.00 \u00d7 5 \u00d7 0.25 = $0.125</p> </li> <li> <p>\u8f93\u51fa\u4ee4\u724c\u6210\u672c\uff1a(125,000 / 1,000,000) \u00d7 $4.50 \u00d7 5 \u00d7 0.25 = $0.703125</p> </li> <li> <p>\u603b\u6210\u672c\uff1a$0.878125</p> </li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/#_9","title":"\u8d2d\u4e70\u79ef\u5206","text":"<p>\u53ef\u4ee5\u901a\u8fc7\u6211\u4eec\u7684\u5e73\u53f0\u4ee5\u4e24\u79cd\u65b9\u5f0f\u8d2d\u4e70\u79ef\u5206\uff1a</p> <ol> <li>\u7f8e\u5143\u652f\u4ed8</li> <li>\u53ef\u901a\u8fc7\u6211\u4eec\u7684\u8d26\u6237\u9875\u9762\u4f7f\u7528</li> <li>\u5b89\u5168\u652f\u4ed8\u5904\u7406</li> <li> <p>\u6700\u4f4e\u8d2d\u4e70\u989d\uff1a$10</p> </li> <li> <p>$swarms \u4ee3\u5e01\u652f\u4ed8</p> </li> <li>\u4f7f\u7528\u57fa\u4e8eSolana\u7684$swarms\u4ee3\u5e01</li> <li>\u53ef\u5728\u652f\u6301\u7684\u4ea4\u6613\u6240\u8d2d\u4e70\u4ee3\u5e01</li> <li>\u5728\u6211\u4eec\u7684\u8d26\u6237\u9875\u9762\u8fde\u63a5\u60a8\u7684Solana\u94b1\u5305</li> </ol>"},{"location":"swarms_cloud/chinese_api_pricing/#_10","title":"\u514d\u8d39\u79ef\u5206","text":"<p>\u6211\u4eec\u5076\u5c14\u4f1a\u5411\u4ee5\u4e0b\u5bf9\u8c61\u63d0\u4f9b\u514d\u8d39\u79ef\u5206\uff1a</p> <ul> <li> <p>\u65b0\u7528\u6237\uff08\u6b22\u8fce\u5956\u52b1\uff09</p> </li> <li> <p>\u4fc3\u9500\u671f\u95f4</p> </li> <li> <p>\u6559\u80b2\u548c\u7814\u7a76\u76ee\u7684</p> </li> </ul> <p>\u5173\u4e8e\u514d\u8d39\u79ef\u5206\u7684\u8bf4\u660e\uff1a</p> <ul> <li> <p>\u5728\u6807\u51c6\u79ef\u5206\u4e4b\u524d\u4f7f\u7528</p> </li> <li> <p>\u53ef\u80fd\u6709\u8fc7\u671f\u65e5\u671f</p> </li> <li> <p>\u53ef\u80fd\u6709\u4f7f\u7528\u9650\u5236</p> </li> </ul>"},{"location":"swarms_cloud/chinese_api_pricing/#_11","title":"\u8d26\u5355\u548c\u4f7f\u7528\u8ddf\u8e2a","text":"<p>\u901a\u8fc7\u6211\u4eec\u5168\u9762\u7684\u65e5\u5fd7\u548c\u62a5\u544a\u529f\u80fd\u8ddf\u8e2a\u60a8\u7684\u79ef\u5206\u4f7f\u7528\u60c5\u51b5\uff1a</p> <ol> <li> <p>API\u65e5\u5fd7</p> </li> <li> <p>\u901a\u8fc7<code>/v1/swarm/logs</code>\u7aef\u70b9\u8bbf\u95ee\u8be6\u7ec6\u65e5\u5fd7</p> </li> <li> <p>\u67e5\u770b\u6bcf\u6b21\u6267\u884c\u7684\u6210\u672c\u660e\u7ec6</p> </li> <li> <p>\u4eea\u8868\u677f</p> </li> <li> <p>\u5b9e\u65f6\u79ef\u5206\u4f59\u989d\u663e\u793a</p> </li> <li> <p>\u5386\u53f2\u4f7f\u7528\u56fe\u8868</p> </li> <li> <p>\u8be6\u7ec6\u6210\u672c\u5206\u6790</p> </li> <li> <p>\u53ef\u5728https://swarms.world/platform/dashboard\u8bbf\u95ee</p> </li> </ol>"},{"location":"swarms_cloud/chinese_api_pricing/#_12","title":"\u5e38\u89c1\u95ee\u9898","text":"<p>\u95ee\uff1a\u662f\u5426\u6709\u6700\u4f4e\u79ef\u5206\u8d2d\u4e70\u8981\u6c42\uff1f \u7b54\uff1a\u662f\u7684\uff0c\u6700\u4f4e\u79ef\u5206\u8d2d\u4e70\u989d\u4e3a10\u7f8e\u5143\u7b49\u503c\u3002</p> <p>\u95ee\uff1a\u79ef\u5206\u4f1a\u8fc7\u671f\u5417\uff1f \u7b54\uff1a\u6807\u51c6\u79ef\u5206\u4e0d\u4f1a\u8fc7\u671f\u3002\u514d\u8d39\u4fc3\u9500\u79ef\u5206\u53ef\u80fd\u6709\u8fc7\u671f\u65e5\u671f\u3002</p> <p>\u95ee\uff1a\u591c\u95f4\u6298\u6263\u5982\u4f55\u5e94\u7528\uff1f \u7b54\uff1a\u7cfb\u7edf\u4f1a\u6839\u636e\u592a\u5e73\u6d0b\u65f6\u95f4\uff08America/Los_Angeles\uff09\u81ea\u52a8\u68c0\u6d4b\u6267\u884c\u65f6\u95f4\uff0c\u5e76\u5728\u665a\u4e0a8:00\u81f3\u65e9\u4e0a6:00\u4e4b\u95f4\u7684\u6267\u884c\u5e94\u752875%\u7684\u4ee4\u724c\u6210\u672c\u6298\u6263\u3002</p> <p>\u95ee\uff1a\u5982\u679c\u6211\u5728\u6267\u884c\u8fc7\u7a0b\u4e2d\u79ef\u5206\u7528\u5b8c\u4e86\u4f1a\u600e\u6837\uff1f \u7b54\uff1a\u5982\u679c\u6ca1\u6709\u8db3\u591f\u7684\u79ef\u5206\uff0c\u6267\u884c\u5c06\u5931\u8d25\u5e76\u663e\u793a402 Payment Required\u9519\u8bef\u3002\u6211\u4eec\u5efa\u8bae\u7ef4\u6301\u9002\u5408\u60a8\u4f7f\u7528\u6a21\u5f0f\u7684\u79ef\u5206\u4f59\u989d\u3002</p> <p>\u95ee\uff1a\u6211\u53ef\u4ee5\u83b7\u5f97\u672a\u4f7f\u7528\u79ef\u5206\u7684\u9000\u6b3e\u5417\uff1f \u7b54\uff1a\u8bf7\u8054\u7cfb\u6211\u4eec\u7684\u652f\u6301\u56e2\u961f\u5904\u7406\u672a\u4f7f\u7528\u79ef\u5206\u7684\u9000\u6b3e\u8bf7\u6c42\u3002</p> <p>\u95ee\uff1a\u662f\u5426\u6709\u6279\u91cf\u6298\u6263\uff1f \u7b54\uff1a\u662f\u7684\uff0c\u8bf7\u8054\u7cfb\u6211\u4eec\u7684\u9500\u552e\u56e2\u961f\u4e86\u89e3\u4f01\u4e1a\u5b9a\u4ef7\u548c\u6279\u91cf\u6298\u6263\u3002</p>"},{"location":"swarms_cloud/chinese_api_pricing/#_13","title":"\u53c2\u8003\u8d44\u6599","text":"<ul> <li> <p>Swarm API \u6587\u6863</p> </li> <li> <p>\u8d26\u6237\u7ba1\u7406\u95e8\u6237</p> </li> <li> <p>Swarm \u7c7b\u578b\u53c2\u8003</p> </li> <li> <p>\u4ee4\u724c\u4f7f\u7528\u6307\u5357</p> </li> <li> <p>API \u53c2\u8003</p> </li> </ul> <p>\u5982\u6709\u5176\u4ed6\u95ee\u9898\u6216\u81ea\u5b9a\u4e49\u5b9a\u4ef7\u9009\u9879\uff0c\u8bf7\u8054\u7cfb\u6211\u4eec\u7684\u652f\u6301\u56e2\u961f\uff0c\u90ae\u7bb1\uff1akye@swarms.world</p>"},{"location":"swarms_cloud/cloud_run/","title":"Hosting Agents on Google Cloud Run","text":"<p>This documentation provides a highly detailed, step-by-step guide to hosting your agents using Google Cloud Run. It uses a well-structured project setup that includes a Dockerfile at the root level, a folder dedicated to your API file, and a <code>requirements.txt</code> file to manage all dependencies. This guide will ensure your deployment is scalable, efficient, and easy to maintain.</p>"},{"location":"swarms_cloud/cloud_run/#project-structure","title":"Project Structure","text":"<p>Your project directory should adhere to the following structure to ensure compatibility and ease of deployment:</p> <pre><code>.\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 requirements.txt\n\u2514\u2500\u2500 api/\n    \u2514\u2500\u2500 api.py\n</code></pre> <p>Each component serves a specific purpose in the deployment pipeline, ensuring modularity and maintainability.</p>"},{"location":"swarms_cloud/cloud_run/#step-1-prerequisites","title":"Step 1: Prerequisites","text":"<p>Before you begin, make sure to satisfy the following prerequisites to avoid issues during deployment:</p> <ol> <li>Google Cloud Account:</li> <li>Create a Google Cloud account at Google Cloud Console.</li> <li> <p>Enable billing for your project. Billing is necessary for accessing Cloud Run services.</p> </li> <li> <p>Install Google Cloud SDK:</p> </li> <li> <p>Follow the installation guide to set up the Google Cloud SDK on your local machine.</p> </li> <li> <p>Install Docker:</p> </li> <li> <p>Download and install Docker by following the official Docker installation guide. Docker is crucial for containerizing your application.</p> </li> <li> <p>Create a Google Cloud Project:</p> </li> <li> <p>Navigate to the Google Cloud Console and create a new project. Assign it a meaningful name and note the Project ID, as it will be used throughout this guide.</p> </li> <li> <p>Enable Required APIs:</p> </li> <li>Visit the API Library and enable the following APIs:<ul> <li>Cloud Run API</li> <li>Cloud Build API</li> <li>Artifact Registry API</li> </ul> </li> <li>These APIs are essential for deploying and managing your application in Cloud Run.</li> </ol>"},{"location":"swarms_cloud/cloud_run/#step-2-creating-the-files","title":"Step 2: Creating the Files","text":""},{"location":"swarms_cloud/cloud_run/#1-apiapipy","title":"1. <code>api/api.py</code>","text":"<p>This is the main Python script where you define your Swarms agents and expose an API endpoint for interacting with them. Here\u2019s an example:</p> <pre><code>from flask import Flask, request, jsonify\nfrom swarms import Agent  # Assuming `swarms` is the framework you're using\n\napp = Flask(__name__)\n\n# Example Swarm agent\nagent = Agent(\n    agent_name=\"Stock-Analysis-Agent\",\n    model_name=\"gpt-4o-mini\",\n    max_loops=\"auto\",\n    interactive=True,\n    streaming_on=True,\n)\n\n@app.route('/run-agent', methods=['POST'])\ndef run_agent():\n    data = request.json\n    task = data.get('task', '')\n    result = agent.run(task)\n    return jsonify({\"result\": result})\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n</code></pre> <p>This example sets up a basic API that listens for POST requests, processes a task using a Swarm agent, and returns the result as a JSON response. Customize it based on your agent\u2019s functionality.</p>"},{"location":"swarms_cloud/cloud_run/#2-requirementstxt","title":"2. <code>requirements.txt</code>","text":"<p>This file lists all Python dependencies required for your project. Example:</p> <pre><code>flask\nswarms\n# add any other dependencies here\n</code></pre> <p>Be sure to include any additional libraries your agents rely on. Keeping this file up to date ensures smooth dependency management during deployment.</p>"},{"location":"swarms_cloud/cloud_run/#3-dockerfile","title":"3. <code>Dockerfile</code>","text":"<p>The Dockerfile specifies how your application is containerized. Below is a sample Dockerfile for your setup:</p> <pre><code># Use an official Python runtime as the base image\nFROM python:3.10-slim\n\n# Set the working directory\nWORKDIR /app\n\n# Copy requirements.txt and install dependencies\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n\n# Copy the application code\nCOPY api/ ./api/\n\n# Expose port 8080 (Cloud Run default port)\nEXPOSE 8080\n\n# Run the application\nCMD [\"python\", \"api/api.py\"]\n</code></pre> <p>This Dockerfile ensures your application is containerized with minimal overhead, focusing on slim images for efficiency.</p>"},{"location":"swarms_cloud/cloud_run/#step-3-deploying-to-google-cloud-run","title":"Step 3: Deploying to Google Cloud Run","text":""},{"location":"swarms_cloud/cloud_run/#1-authenticate-with-google-cloud","title":"1. Authenticate with Google Cloud","text":"<p>Log in to your Google Cloud account by running:</p> <pre><code>gcloud auth login\n</code></pre> <p>Set the active project to match your deployment target:</p> <pre><code>gcloud config set project [PROJECT_ID]\n</code></pre> <p>Replace <code>[PROJECT_ID]</code> with your actual Project ID.</p>"},{"location":"swarms_cloud/cloud_run/#2-build-the-docker-image","title":"2. Build the Docker Image","text":"<p>Use Google Cloud's Artifact Registry to store and manage your Docker image. Follow these steps:</p> <ol> <li>Create a Repository:</li> </ol> <pre><code>gcloud artifacts repositories create my-repo --repository-format=Docker --location=us-central1\n</code></pre> <ol> <li>Authenticate Docker with Google Cloud:</li> </ol> <pre><code>gcloud auth configure-docker us-central1-docker.pkg.dev\n</code></pre> <ol> <li>Build and Tag the Image:</li> </ol> <pre><code>docker build -t us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image .\n</code></pre> <ol> <li>Push the Image:</li> </ol> <pre><code>docker push us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image\n</code></pre>"},{"location":"swarms_cloud/cloud_run/#3-deploy-to-cloud-run","title":"3. Deploy to Cloud Run","text":"<p>Deploy the application to Cloud Run with the following command:</p> <pre><code>gcloud run deploy my-agent-service \\\n  --image us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated\n</code></pre> <p>Key points: - Replace <code>[PROJECT_ID]</code> with your actual Project ID. - The <code>--allow-unauthenticated</code> flag makes the service publicly accessible. Exclude it to restrict access.</p>"},{"location":"swarms_cloud/cloud_run/#step-4-testing-the-deployment","title":"Step 4: Testing the Deployment","text":"<p>Once the deployment is complete, test the service:</p> <ol> <li>Note the URL provided by Cloud Run.</li> <li>Use <code>curl</code> or Postman to send a request. Example:</li> </ol> <pre><code>curl -X POST [CLOUD_RUN_URL]/run-agent \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"task\": \"example task\"}'\n</code></pre> <p>This tests whether your agent processes the task correctly and returns the expected output.</p>"},{"location":"swarms_cloud/cloud_run/#step-5-updating-the-service","title":"Step 5: Updating the Service","text":"<p>To apply changes to your application:</p> <ol> <li>Edit the necessary files.</li> <li>Rebuild and push the updated Docker image:</li> </ol> <pre><code>docker build -t us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image .\ndocker push us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image\n</code></pre> <ol> <li>Redeploy the service:</li> </ol> <pre><code>gcloud run deploy my-agent-service \\\n  --image us-central1-docker.pkg.dev/[PROJECT_ID]/my-repo/my-image\n</code></pre> <p>This ensures the latest version of your application is live.</p>"},{"location":"swarms_cloud/cloud_run/#troubleshooting","title":"Troubleshooting","text":"<ul> <li>Permission Errors:   Ensure your account has roles like Cloud Run Admin and Artifact Registry Reader.</li> <li>Port Issues:   Confirm the application listens on port 8080. Cloud Run expects this port by default.</li> <li>Logs:   Use the Google Cloud Console or CLI to review logs for debugging:</li> </ul> <pre><code>gcloud logs read --project [PROJECT_ID]\n</code></pre>"},{"location":"swarms_cloud/cloud_run/#conclusion","title":"Conclusion","text":"<p>By following this comprehensive guide, you can deploy your agents on Google Cloud Run with ease. This method leverages Docker for containerization and Google Cloud services for seamless scalability and management. With a robust setup like this, you can focus on enhancing your agents\u2019 capabilities rather than worrying about deployment challenges.</p>"},{"location":"swarms_cloud/launch/","title":"Swarms Cloud API Client Documentation","text":""},{"location":"swarms_cloud/launch/#overview","title":"Overview","text":"<p>The Swarms Cloud API Client is a production-grade Python library for interacting with the Swarms Cloud Agent API. It provides a comprehensive interface for managing, executing, and monitoring cloud-based agents.</p>"},{"location":"swarms_cloud/launch/#installation","title":"Installation","text":"<pre><code>pip install swarms-cloud\n</code></pre>"},{"location":"swarms_cloud/launch/#quick-start","title":"Quick Start","text":"<pre><code>from swarms_cloud import SwarmCloudAPI, AgentCreate\n\n# Initialize the client\nclient = SwarmCloudAPI(\n    base_url=\"https://swarmcloud-285321057562.us-central1.run.app\",\n    api_key=\"your_api_key_here\"\n)\n\n# Create an agent\nagent_data = AgentCreate(\n    name=\"TranslateAgent\",\n    description=\"Translates text between languages\",\n    code=\"\"\"\n    def main(request, store):\n        text = request.payload.get('text', '')\n        return f'Translated: {text}'\n    \"\"\",\n    requirements=\"requests==2.25.1\",\n    envs=\"DEBUG=True\"\n)\n\nnew_agent = client.create_agent(agent_data)\nprint(f\"Created agent with ID: {new_agent.id}\")\n</code></pre>"},{"location":"swarms_cloud/launch/#client-configuration","title":"Client Configuration","text":""},{"location":"swarms_cloud/launch/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Required Default Description base_url str No https://swarmcloud-285321057562.us-central1.run.app The base URL of the SwarmCloud API api_key str Yes None Your SwarmCloud API key timeout float No 10.0 Request timeout in seconds"},{"location":"swarms_cloud/launch/#data-models","title":"Data Models","text":""},{"location":"swarms_cloud/launch/#agentcreate","title":"AgentCreate","text":"<p>Model for creating new agents.</p> Field Type Required Default Description name str Yes - Name of the agent description str No None Description of the agent's purpose code str Yes - Python code that defines the agent's behavior requirements str No None Python package requirements (pip format) envs str No None Environment variables for the agent autoscaling bool No False Enable/disable concurrent execution scaling"},{"location":"swarms_cloud/launch/#agentupdate","title":"AgentUpdate","text":"<p>Model for updating existing agents.</p> Field Type Required Default Description name str No None Updated name of the agent description str No None Updated description code str No None Updated Python code requirements str No None Updated package requirements autoscaling bool No None Updated autoscaling setting"},{"location":"swarms_cloud/launch/#api-methods","title":"API Methods","text":""},{"location":"swarms_cloud/launch/#list-agents","title":"List Agents","text":"<p>Retrieve all available agents.</p> <pre><code>agents = client.list_agents()\nfor agent in agents:\n    print(f\"Agent: {agent.name} (ID: {agent.id})\")\n</code></pre> <p>Returns: List[AgentOut]</p>"},{"location":"swarms_cloud/launch/#create-agent","title":"Create Agent","text":"<p>Create a new agent with the specified configuration.</p> <pre><code>agent_data = AgentCreate(\n    name=\"DataProcessor\",\n    description=\"Processes incoming data streams\",\n    code=\"\"\"\n    def main(request, store):\n        data = request.payload.get('data', [])\n        return {'processed': len(data)}\n    \"\"\",\n    requirements=\"pandas==1.4.0\\nnumpy==1.21.0\",\n    envs=\"PROCESSING_MODE=fast\",\n    autoscaling=True\n)\n\nnew_agent = client.create_agent(agent_data)\n</code></pre> <p>Returns: AgentOut</p>"},{"location":"swarms_cloud/launch/#get-agent","title":"Get Agent","text":"<p>Retrieve details of a specific agent.</p> <pre><code>agent = client.get_agent(\"agent_id_here\")\nprint(f\"Agent details: {agent}\")\n</code></pre> <p>Parameters: - agent_id (str): The unique identifier of the agent</p> <p>Returns: AgentOut</p>"},{"location":"swarms_cloud/launch/#update-agent","title":"Update Agent","text":"<p>Update an existing agent's configuration.</p> <pre><code>update_data = AgentUpdate(\n    name=\"UpdatedProcessor\",\n    description=\"Enhanced data processing capabilities\",\n    code=\"def main(request, store):\\n    return {'status': 'updated'}\"\n)\n\nupdated_agent = client.update_agent(\"agent_id_here\", update_data)\n</code></pre> <p>Parameters: - agent_id (str): The unique identifier of the agent - update (AgentUpdate): The update data</p> <p>Returns: AgentOut</p>"},{"location":"swarms_cloud/launch/#execute-agent","title":"Execute Agent","text":"<p>Manually execute an agent with optional payload data.</p> <pre><code># Execute with payload\nresult = client.execute_agent(\n    \"agent_id_here\",\n    payload={\"text\": \"Hello, World!\"}\n)\n\n# Execute without payload\nresult = client.execute_agent(\"agent_id_here\")\n</code></pre> <p>Parameters: - agent_id (str): The unique identifier of the agent - payload (Optional[Dict[str, Any]]): Execution payload data</p> <p>Returns: Dict[str, Any]</p>"},{"location":"swarms_cloud/launch/#get-agent-history","title":"Get Agent History","text":"<p>Retrieve the execution history and logs for an agent.</p> <pre><code>history = client.get_agent_history(\"agent_id_here\")\nfor execution in history.executions:\n    print(f\"[{execution.timestamp}] {execution.log}\")\n</code></pre> <p>Parameters: - agent_id (str): The unique identifier of the agent</p> <p>Returns: AgentExecutionHistory</p>"},{"location":"swarms_cloud/launch/#batch-execute-agents","title":"Batch Execute Agents","text":"<p>Execute multiple agents simultaneously with the same payload.</p> <pre><code># Get list of agents\nagents = client.list_agents()\n\n# Execute batch with payload\nresults = client.batch_execute_agents(\n    agents=agents[:3],  # Execute first three agents\n    payload={\"data\": \"test\"}\n)\n\nprint(f\"Batch execution results: {results}\")\n</code></pre> <p>Parameters: - agents (List[AgentOut]): List of agents to execute - payload (Optional[Dict[str, Any]]): Shared execution payload</p> <p>Returns: List[Any]</p>"},{"location":"swarms_cloud/launch/#health-check","title":"Health Check","text":"<p>Check the API's health status.</p> <pre><code>status = client.health()\nprint(f\"API Status: {status}\")\n</code></pre> <p>Returns: Dict[str, Any]</p>"},{"location":"swarms_cloud/launch/#error-handling","title":"Error Handling","text":"<p>The client uses exception handling to manage various error scenarios:</p> <pre><code>from swarms_cloud import SwarmCloudAPI\nimport httpx\n\ntry:\n    client = SwarmCloudAPI(api_key=\"your_api_key_here\")\n    agents = client.list_agents()\nexcept httpx.HTTPError as http_err:\n    print(f\"HTTP error occurred: {http_err}\")\nexcept Exception as err:\n    print(f\"An unexpected error occurred: {err}\")\nfinally:\n    client.close()\n</code></pre>"},{"location":"swarms_cloud/launch/#context-manager-support","title":"Context Manager Support","text":"<p>The client can be used with Python's context manager:</p> <pre><code>with SwarmCloudAPI(api_key=\"your_api_key_here\") as client:\n    status = client.health()\n    print(f\"API Status: {status}\")\n    # Client automatically closes after the with block\n</code></pre>"},{"location":"swarms_cloud/launch/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always close the client when finished: <pre><code>client = SwarmCloudAPI(api_key=\"your_api_key_here\")\ntry:\n    # Your code here\nfinally:\n    client.close()\n</code></pre></p> </li> <li> <p>Use context managers for automatic cleanup: <pre><code>with SwarmCloudAPI(api_key=\"your_api_key_here\") as client:\n    # Your code here\n</code></pre></p> </li> <li> <p>Handle errors appropriately: <pre><code>try:\n    result = client.execute_agent(\"agent_id\", payload={\"data\": \"test\"})\nexcept httpx.HTTPError as e:\n    logger.error(f\"HTTP error: {e}\")\n    # Handle error appropriately\n</code></pre></p> </li> <li> <p>Set appropriate timeouts for your use case: <pre><code>client = SwarmCloudAPI(\n    api_key=\"your_api_key_here\",\n    timeout=30.0  # Longer timeout for complex operations\n)\n</code></pre></p> </li> </ol>"},{"location":"swarms_cloud/launch/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showcasing various features of the client:</p> <pre><code>from swarms_cloud import SwarmCloudAPI, AgentCreate, AgentUpdate\nimport httpx\n\ndef main():\n    with SwarmCloudAPI(api_key=\"your_api_key_here\") as client:\n        # Create an agent\n        agent_data = AgentCreate(\n            name=\"DataAnalyzer\",\n            description=\"Analyzes incoming data streams\",\n            code=\"\"\"\n            def main(request, store):\n                data = request.payload.get('data', [])\n                return {\n                    'count': len(data),\n                    'summary': 'Data processed successfully'\n                }\n            \"\"\",\n            requirements=\"pandas==1.4.0\",\n            autoscaling=True\n        )\n\n        try:\n            # Create the agent\n            new_agent = client.create_agent(agent_data)\n            print(f\"Created agent: {new_agent.name} (ID: {new_agent.id})\")\n\n            # Execute the agent\n            result = client.execute_agent(\n                new_agent.id,\n                payload={\"data\": [1, 2, 3, 4, 5]}\n            )\n            print(f\"Execution result: {result}\")\n\n            # Update the agent\n            update_data = AgentUpdate(\n                description=\"Enhanced data analysis capabilities\"\n            )\n            updated_agent = client.update_agent(new_agent.id, update_data)\n            print(f\"Updated agent: {updated_agent.name}\")\n\n            # Get execution history\n            history = client.get_agent_history(new_agent.id)\n            print(f\"Execution history: {history}\")\n\n        except httpx.HTTPError as e:\n            print(f\"HTTP error occurred: {e}\")\n        except Exception as e:\n            print(f\"Unexpected error: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"swarms_cloud/launch/#logging","title":"Logging","text":"<p>The client uses the <code>loguru</code> library for logging. You can configure the logging level and format:</p> <pre><code>from loguru import logger\n\n# Configure logging\nlogger.add(\"swarmcloud.log\", rotation=\"500 MB\")\n\nclient = SwarmCloudAPI(api_key=\"your_api_key_here\")\n</code></pre>"},{"location":"swarms_cloud/launch/#performance-considerations","title":"Performance Considerations","text":"<ol> <li> <p>Connection Reuse: The client reuses HTTP connections by default, improving performance for multiple requests.</p> </li> <li> <p>Timeout Configuration: Set appropriate timeouts based on your use case: <pre><code>client = SwarmCloudAPI(\n    api_key=\"your_api_key_here\",\n    timeout=5.0  # Shorter timeout for time-sensitive operations\n)\n</code></pre></p> </li> <li> <p>Batch Operations: Use batch_execute_agents for multiple agent executions: <pre><code>results = client.batch_execute_agents(\n    agents=agents,\n    payload=shared_payload\n)\n</code></pre></p> </li> </ol>"},{"location":"swarms_cloud/launch/#rate-limiting","title":"Rate Limiting","text":"<p>The client respects API rate limits but does not implement retry logic. Implement your own retry mechanism if needed:</p> <pre><code>from tenacity import retry, stop_after_attempt, wait_exponential\n\n@retry(stop=stop_after_attempt(3), wait=wait_exponential(multiplier=1, min=4, max=10))\ndef execute_with_retry(client, agent_id, payload):\n    return client.execute_agent(agent_id, payload)\n</code></pre>"},{"location":"swarms_cloud/launch/#thread-safety","title":"Thread Safety","text":"<p>The client is not thread-safe by default. For concurrent usage, create separate client instances for each thread or implement appropriate synchronization mechanisms.</p>"},{"location":"swarms_cloud/mcp/","title":"Swarms API as MCP","text":"<ul> <li>Launch MCP server as a tool</li> <li>Put <code>SWARMS_API_KEY</code> in <code>.env</code></li> <li>Client side code below</li> </ul>"},{"location":"swarms_cloud/mcp/#server-side","title":"Server Side","text":"<pre><code># server.py\nfrom datetime import datetime\nimport os\nfrom typing import Any, Dict, List, Optional\n\nimport requests\nimport httpx\nfrom fastmcp import FastMCP\nfrom pydantic import BaseModel, Field\nfrom swarms import SwarmType\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nclass AgentSpec(BaseModel):\n    agent_name: Optional[str] = Field(\n        description=\"The unique name assigned to the agent, which identifies its role and functionality within the swarm.\",\n    )\n    description: Optional[str] = Field(\n        description=\"A detailed explanation of the agent's purpose, capabilities, and any specific tasks it is designed to perform.\",\n    )\n    system_prompt: Optional[str] = Field(\n        description=\"The initial instruction or context provided to the agent, guiding its behavior and responses during execution.\",\n    )\n    model_name: Optional[str] = Field(\n        default=\"gpt-4o-mini\",\n        description=\"The name of the AI model that the agent will utilize for processing tasks and generating outputs. For example: gpt-4o, gpt-4o-mini, openai/o3-mini\",\n    )\n    auto_generate_prompt: Optional[bool] = Field(\n        default=False,\n        description=\"A flag indicating whether the agent should automatically create prompts based on the task requirements.\",\n    )\n    max_tokens: Optional[int] = Field(\n        default=8192,\n        description=\"The maximum number of tokens that the agent is allowed to generate in its responses, limiting output length.\",\n    )\n    temperature: Optional[float] = Field(\n        default=0.5,\n        description=\"A parameter that controls the randomness of the agent's output; lower values result in more deterministic responses.\",\n    )\n    role: Optional[str] = Field(\n        default=\"worker\",\n        description=\"The designated role of the agent within the swarm, which influences its behavior and interaction with other agents.\",\n    )\n    max_loops: Optional[int] = Field(\n        default=1,\n        description=\"The maximum number of times the agent is allowed to repeat its task, enabling iterative processing if necessary.\",\n    )\n    # New fields for RAG functionality\n    rag_collection: Optional[str] = Field(\n        None,\n        description=\"The Qdrant collection name for RAG functionality. If provided, this agent will perform RAG queries.\",\n    )\n    rag_documents: Optional[List[str]] = Field(\n        None,\n        description=\"Documents to ingest into the Qdrant collection for RAG. (List of text strings)\",\n    )\n    tools: Optional[List[Dict[str, Any]]] = Field(\n        None,\n        description=\"A dictionary of tools that the agent can use to complete its task.\",\n    )\n\n\nclass AgentCompletion(BaseModel):\n    \"\"\"\n    Configuration for a single agent that works together as a swarm to accomplish tasks.\n    \"\"\"\n\n    agent: AgentSpec = Field(\n        ...,\n        description=\"The agent to run.\",\n    )\n    task: Optional[str] = Field(\n        ...,\n        description=\"The task to run.\",\n    )\n    img: Optional[str] = Field(\n        None,\n        description=\"An optional image URL that may be associated with the swarm's task or representation.\",\n    )\n    output_type: Optional[str] = Field(\n        \"list\",\n        description=\"The type of output to return.\",\n    )\n\n\nclass AgentCompletionResponse(BaseModel):\n    \"\"\"\n    Response from an agent completion.\n    \"\"\"\n\n    agent_id: str = Field(\n        ...,\n        description=\"The unique identifier for the agent that completed the task.\",\n    )\n    agent_name: str = Field(\n        ...,\n        description=\"The name of the agent that completed the task.\",\n    )\n    agent_description: str = Field(\n        ...,\n        description=\"The description of the agent that completed the task.\",\n    )\n    messages: Any = Field(\n        ...,\n        description=\"The messages from the agent completion.\",\n    )\n\n    cost: Dict[str, Any] = Field(\n        ...,\n        description=\"The cost of the agent completion.\",\n    )\n\n\nclass Agents(BaseModel):\n    \"\"\"Configuration for a collection of agents that work together as a swarm to accomplish tasks.\"\"\"\n\n    agents: List[AgentSpec] = Field(\n        description=\"A list containing the specifications of each agent that will participate in the swarm, detailing their roles and functionalities.\"\n    )\n\n\nclass ScheduleSpec(BaseModel):\n    scheduled_time: datetime = Field(\n        ...,\n        description=\"The exact date and time (in UTC) when the swarm is scheduled to execute its tasks.\",\n    )\n    timezone: Optional[str] = Field(\n        \"UTC\",\n        description=\"The timezone in which the scheduled time is defined, allowing for proper scheduling across different regions.\",\n    )\n\n\nclass SwarmSpec(BaseModel):\n    name: Optional[str] = Field(\n        None,\n        description=\"The name of the swarm, which serves as an identifier for the group of agents and their collective task.\",\n        max_length=100,\n    )\n    description: Optional[str] = Field(\n        None,\n        description=\"A comprehensive description of the swarm's objectives, capabilities, and intended outcomes.\",\n    )\n    agents: Optional[List[AgentSpec]] = Field(\n        None,\n        description=\"A list of agents or specifications that define the agents participating in the swarm.\",\n    )\n    max_loops: Optional[int] = Field(\n        default=1,\n        description=\"The maximum number of execution loops allowed for the swarm, enabling repeated processing if needed.\",\n    )\n    swarm_type: Optional[SwarmType] = Field(\n        None,\n        description=\"The classification of the swarm, indicating its operational style and methodology.\",\n    )\n    rearrange_flow: Optional[str] = Field(\n        None,\n        description=\"Instructions on how to rearrange the flow of tasks among agents, if applicable.\",\n    )\n    task: Optional[str] = Field(\n        None,\n        description=\"The specific task or objective that the swarm is designed to accomplish.\",\n    )\n    img: Optional[str] = Field(\n        None,\n        description=\"An optional image URL that may be associated with the swarm's task or representation.\",\n    )\n    return_history: Optional[bool] = Field(\n        True,\n        description=\"A flag indicating whether the swarm should return its execution history along with the final output.\",\n    )\n    rules: Optional[str] = Field(\n        None,\n        description=\"Guidelines or constraints that govern the behavior and interactions of the agents within the swarm.\",\n    )\n    schedule: Optional[ScheduleSpec] = Field(\n        None,\n        description=\"Details regarding the scheduling of the swarm's execution, including timing and timezone information.\",\n    )\n    tasks: Optional[List[str]] = Field(\n        None,\n        description=\"A list of tasks that the swarm should complete.\",\n    )\n    messages: Optional[List[Dict[str, Any]]] = Field(\n        None,\n        description=\"A list of messages that the swarm should complete.\",\n    )\n    # rag_on: Optional[bool] = Field(\n    #     None,\n    #     description=\"A flag indicating whether the swarm should use RAG.\",\n    # )\n    # collection_name: Optional[str] = Field(\n    #     None,\n    #     description=\"The name of the collection to use for RAG.\",\n    # )\n    stream: Optional[bool] = Field(\n        False,\n        description=\"A flag indicating whether the swarm should stream its output.\",\n    )\n\n\nclass SwarmCompletionResponse(BaseModel):\n    \"\"\"\n    Response from a swarm completion.\n    \"\"\"\n\n    status: str = Field(..., description=\"The status of the swarm completion.\")\n    swarm_name: str = Field(..., description=\"The name of the swarm.\")\n    description: str = Field(..., description=\"Description of the swarm.\")\n    swarm_type: str = Field(..., description=\"The type of the swarm.\")\n    task: str = Field(\n        ..., description=\"The task that the swarm is designed to accomplish.\"\n    )\n    output: List[Dict[str, Any]] = Field(\n        ..., description=\"The output generated by the swarm.\"\n    )\n    number_of_agents: int = Field(\n        ..., description=\"The number of agents involved in the swarm.\"\n    )\n    # \"input_config\": Optional[Dict[str, Any]] = Field(None, description=\"The input configuration for the swarm.\")\n\n\nBASE_URL = \"https://swarms-api-285321057562.us-east1.run.app\"\n\n\n# Create an MCP server\nmcp = FastMCP(\"swarms-api\")\n\n\n# Add an addition tool\n@mcp.tool(name=\"swarm_completion\", description=\"Run a swarm completion.\")\ndef swarm_completion(swarm: SwarmSpec) -&gt; Dict[str, Any]:\n    api_key = os.getenv(\"SWARMS_API_KEY\")\n    headers = {\"x-api-key\": api_key, \"Content-Type\": \"application/json\"}\n\n    payload = swarm.model_dump()\n\n    response = requests.post(f\"{BASE_URL}/v1/swarm/completions\", json=payload, headers=headers)\n\n    return response.json()\n\n@mcp.tool(name=\"swarms_available\", description=\"Get the list of available swarms.\")\nasync def swarms_available() -&gt; Any:\n    \"\"\"\n    Get the list of available swarms.\n    \"\"\"\n    headers = {\"Content-Type\": \"application/json\"}\n\n    async with httpx.AsyncClient() as client:\n        response = await client.get(f\"{BASE_URL}/v1/models/available\", headers=headers)\n        response.raise_for_status()  # Raise an error for bad responses\n        return response.json()\n\n\nif __name__ == \"__main__\":\n    mcp.run(transport=\"sse\")\n</code></pre>"},{"location":"swarms_cloud/mcp/#client-side","title":"Client side","text":"<ul> <li>Call the tool with it's name and the payload config</li> </ul> <pre><code>import asyncio\nfrom fastmcp import Client\n\nswarm_config = {\n    \"name\": \"Simple Financial Analysis\",\n    \"description\": \"A swarm to analyze financial data\",\n    \"agents\": [\n        {\n            \"agent_name\": \"Data Analyzer\",\n            \"description\": \"Looks at financial data\",\n            \"system_prompt\": \"Analyze the data.\",\n            \"model_name\": \"gpt-4o\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 1000,\n            \"temperature\": 0.5,\n            \"auto_generate_prompt\": False,\n        },\n        {\n            \"agent_name\": \"Risk Analyst\",\n            \"description\": \"Checks risk levels\",\n            \"system_prompt\": \"Evaluate the risks.\",\n            \"model_name\": \"gpt-4o\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 1000,\n            \"temperature\": 0.5,\n            \"auto_generate_prompt\": False,\n        },\n        {\n            \"agent_name\": \"Strategy Checker\",\n            \"description\": \"Validates strategies\",\n            \"system_prompt\": \"Review the strategy.\",\n            \"model_name\": \"gpt-4o\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 1000,\n            \"temperature\": 0.5,\n            \"auto_generate_prompt\": False,\n        },\n    ],\n    \"max_loops\": 1,\n    \"swarm_type\": \"SequentialWorkflow\",\n    \"task\": \"Analyze the financial data and provide insights.\",\n    \"return_history\": False,  # Added required field\n    \"stream\": False,  # Added required field\n    \"rules\": None,  # Added optional field\n    \"img\": None,  # Added optional field\n}\n\n\nasync def swarm_completion():\n    \"\"\"Connect to a server over SSE and fetch available swarms.\"\"\"\n\n    async with Client(\n        transport=\"http://localhost:8000/sse\"\n    ) as client:\n        # Basic connectivity testing\n        # print(\"Ping check:\", await client.ping())\n        # print(\"Available tools:\", await client.list_tools())\n        # print(\"Swarms available:\", await client.call_tool(\"swarms_available\", None))\n        result = await client.call_tool(\"swarm_completion\", {\"swarm\": swarm_config})\n        print(\"Swarm completion:\", result)\n\n\n# Execute the function\nif __name__ == \"__main__\":\n    asyncio.run(swarm_completion())\n</code></pre>"},{"location":"swarms_cloud/mcs_api/","title":"Medical Coder Swarm API Documentation","text":"<p>Base URL: <code>https://mcs-285321057562.us-central1.run.app</code></p>"},{"location":"swarms_cloud/mcs_api/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Authentication</li> <li>Rate Limits</li> <li>Endpoints</li> <li>Health Check</li> <li>Run Medical Coder</li> <li>Run Batch Medical Coder</li> <li>Get Patient Data</li> <li>Get All Patients</li> <li>Code Examples</li> <li>Error Handling</li> </ul>"},{"location":"swarms_cloud/mcs_api/#authentication","title":"Authentication","text":"<p>Authentication details will be provided by the MCS team. Contact support for API credentials.</p>"},{"location":"swarms_cloud/mcs_api/#rate-limits","title":"Rate Limits","text":"Endpoint GET Rate Limit Status <code>GET /rate-limits</code> Returns current rate limit status for your IP address"},{"location":"swarms_cloud/mcs_api/#endpoints","title":"Endpoints","text":""},{"location":"swarms_cloud/mcs_api/#health-check","title":"Health Check","text":"<p>Check if the API is operational.</p> Method Endpoint Description <code>GET</code> <code>/health</code> Returns 200 OK if service is running"},{"location":"swarms_cloud/mcs_api/#run-medical-coder","title":"Run Medical Coder","text":"<p>Process a single patient case through the Medical Coder Swarm.</p> Method Endpoint Description <code>POST</code> <code>/v1/medical-coder/run</code> Process a single patient case <p>Request Body Parameters:</p> Parameter Type Required Description patient_id string Yes Unique identifier for the patient case_description string Yes Medical case details to be processed <p>Response Schema:</p> Field Type Description patient_id string Patient identifier case_data string Processed case data"},{"location":"swarms_cloud/mcs_api/#run-batch-medical-coder","title":"Run Batch Medical Coder","text":"<p>Process multiple patient cases in a single request.</p> Method Endpoint Description <code>POST</code> <code>/v1/medical-coder/run-batch</code> Process multiple patient cases <p>Request Body Parameters:</p> Parameter Type Required Description cases array Yes Array of PatientCase objects"},{"location":"swarms_cloud/mcs_api/#get-patient-data","title":"Get Patient Data","text":"<p>Retrieve data for a specific patient.</p> Method Endpoint Description <code>GET</code> <code>/v1/medical-coder/patient/{patient_id}</code> Get patient data by ID <p>Path Parameters:</p> Parameter Type Required Description patient_id string Yes Patient identifier"},{"location":"swarms_cloud/mcs_api/#get-all-patients","title":"Get All Patients","text":"<p>Retrieve data for all patients.</p> Method Endpoint Description <code>GET</code> <code>/v1/medical-coder/patients</code> Get all patient data"},{"location":"swarms_cloud/mcs_api/#code-examples","title":"Code Examples","text":""},{"location":"swarms_cloud/mcs_api/#python","title":"Python","text":"<pre><code>import requests\nimport json\n\nclass MCSClient:\n    def __init__(self, base_url=\"https://mcs.swarms.ai\", api_key=None):\n        self.base_url = base_url\n        self.headers = {\n            \"Content-Type\": \"application/json\",\n            \"Authorization\": f\"Bearer {api_key}\" if api_key else None\n        }\n\n    def run_medical_coder(self, patient_id, case_description):\n        endpoint = f\"{self.base_url}/v1/medical-coder/run\"\n        payload = {\n            \"patient_id\": patient_id,\n            \"case_description\": case_description\n        }\n        response = requests.post(endpoint, json=payload, headers=self.headers)\n        return response.json()\n\n    def run_batch(self, cases):\n        endpoint = f\"{self.base_url}/v1/medical-coder/run-batch\"\n        payload = {\"cases\": cases}\n        response = requests.post(endpoint, json=payload, headers=self.headers)\n        return response.json()\n\n# Usage example\nclient = MCSClient(api_key=\"your_api_key\")\nresult = client.run_medical_coder(\"P123\", \"Patient presents with...\")\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#nextjs-typescript","title":"Next.js (TypeScript)","text":"<pre><code>// types.ts\ninterface PatientCase {\n  patient_id: string;\n  case_description: string;\n}\n\ninterface QueryResponse {\n  patient_id: string;\n  case_data: string;\n}\n\n// api.ts\nexport class MCSApi {\n  private baseUrl: string;\n  private apiKey: string;\n\n  constructor(apiKey: string, baseUrl = 'https://mcs.swarms.ai') {\n    this.baseUrl = baseUrl;\n    this.apiKey = apiKey;\n  }\n\n  private async fetchWithAuth(endpoint: string, options: RequestInit = {}) {\n    const response = await fetch(`${this.baseUrl}${endpoint}`, {\n      ...options,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${this.apiKey}`,\n        ...options.headers,\n      },\n    });\n    return response.json();\n  }\n\n  async runMedicalCoder(patientCase: PatientCase): Promise&lt;QueryResponse&gt; {\n    return this.fetchWithAuth('/v1/medical-coder/run', {\n      method: 'POST',\n      body: JSON.stringify(patientCase),\n    });\n  }\n\n  async getPatientData(patientId: string): Promise&lt;QueryResponse&gt; {\n    return this.fetchWithAuth(`/v1/medical-coder/patient/${patientId}`);\n  }\n}\n\n// Usage in component\nconst mcsApi = new MCSApi(process.env.MCS_API_KEY);\n\nexport async function ProcessPatientCase({ patientId, caseDescription }) {\n  const result = await mcsApi.runMedicalCoder({\n    patient_id: patientId,\n    case_description: caseDescription,\n  });\n  return result;\n}\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#go","title":"Go","text":"<pre><code>package mcs\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\ntype MCSClient struct {\n    BaseURL string\n    APIKey  string\n    Client  *http.Client\n}\n\ntype PatientCase struct {\n    PatientID      string `json:\"patient_id\"`\n    CaseDescription string `json:\"case_description\"`\n}\n\ntype QueryResponse struct {\n    PatientID string `json:\"patient_id\"`\n    CaseData  string `json:\"case_data\"`\n}\n\nfunc NewMCSClient(apiKey string) *MCSClient {\n    return &amp;MCSClient{\n        BaseURL: \"https://mcs.swarms.ai\",\n        APIKey:  apiKey,\n        Client:  &amp;http.Client{},\n    }\n}\n\nfunc (c *MCSClient) RunMedicalCoder(patientCase PatientCase) (*QueryResponse, error) {\n    payload, err := json.Marshal(patientCase)\n    if err != nil {\n        return nil, err\n    }\n\n    req, err := http.NewRequest(\"POST\", \n        fmt.Sprintf(\"%s/v1/medical-coder/run\", c.BaseURL),\n        bytes.NewBuffer(payload))\n    if err != nil {\n        return nil, err\n    }\n\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", fmt.Sprintf(\"Bearer %s\", c.APIKey))\n\n    resp, err := c.Client.Do(req)\n    if err != nil {\n        return nil, err\n    }\n    defer resp.Body.Close()\n\n    var result QueryResponse\n    if err := json.NewDecoder(resp.Body).Decode(&amp;result); err != nil {\n        return nil, err\n    }\n\n    return &amp;result, nil\n}\n\n// Usage example\nfunc main() {\n    client := NewMCSClient(\"your_api_key\")\n\n    result, err := client.RunMedicalCoder(PatientCase{\n        PatientID:      \"P123\",\n        CaseDescription: \"Patient presents with...\",\n    })\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Printf(\"Result: %+v\\n\", result)\n}\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#c-sharp","title":"C Sharp","text":"<pre><code>using System;\nusing System.Net.Http;\nusing System.Text;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace MedicalCoderSwarm\n{\n    public class PatientCase\n    {\n        public string PatientId { get; set; }\n        public string CaseDescription { get; set; }\n    }\n\n    public class QueryResponse\n    {\n        public string PatientId { get; set; }\n        public string CaseData { get; set; }\n    }\n\n    public class MCSClient : IDisposable\n    {\n        private readonly HttpClient _httpClient;\n        private readonly string _baseUrl;\n\n        public MCSClient(string apiKey, string baseUrl = \"https://mcs-285321057562.us-central1.run.app\")\n        {\n            _baseUrl = baseUrl;\n            _httpClient = new HttpClient();\n            _httpClient.DefaultRequestHeaders.Add(\"Authorization\", $\"Bearer {apiKey}\");\n            _httpClient.DefaultRequestHeaders.Add(\"Content-Type\", \"application/json\");\n        }\n\n        public async Task&lt;QueryResponse&gt; RunMedicalCoderAsync(string patientId, string caseDescription)\n        {\n            var payload = new PatientCase\n            {\n                PatientId = patientId,\n                CaseDescription = caseDescription\n            };\n\n            var content = new StringContent(\n                JsonSerializer.Serialize(payload),\n                Encoding.UTF8,\n                \"application/json\"\n            );\n\n            var response = await _httpClient.PostAsync(\n                $\"{_baseUrl}/v1/medical-coder/run\",\n                content\n            );\n\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            return JsonSerializer.Deserialize&lt;QueryResponse&gt;(responseContent);\n        }\n\n        public async Task&lt;QueryResponse&gt; GetPatientDataAsync(string patientId)\n        {\n            var response = await _httpClient.GetAsync(\n                $\"{_baseUrl}/v1/medical-coder/patient/{patientId}\"\n            );\n\n            response.EnsureSuccessStatusCode();\n\n            var responseContent = await response.Content.ReadAsStringAsync();\n            return JsonSerializer.Deserialize&lt;QueryResponse&gt;(responseContent);\n        }\n\n        public async Task&lt;bool&gt; HealthCheckAsync()\n        {\n            var response = await _httpClient.GetAsync($\"{_baseUrl}/health\");\n            return response.IsSuccessStatusCode;\n        }\n\n        public void Dispose()\n        {\n            _httpClient?.Dispose();\n        }\n    }\n\n    // Example usage\n    public class Program\n    {\n        public static async Task Main()\n        {\n            try\n            {\n                using var client = new MCSClient(\"your_api_key\");\n\n                // Check API health\n                var isHealthy = await client.HealthCheckAsync();\n                Console.WriteLine($\"API Health: {(isHealthy ? \"Healthy\" : \"Unhealthy\")}\");\n\n                // Process a single case\n                var result = await client.RunMedicalCoderAsync(\n                    \"P123\",\n                    \"Patient presents with acute respiratory symptoms...\"\n                );\n                Console.WriteLine($\"Processed case for patient {result.PatientId}\");\n                Console.WriteLine($\"Case data: {result.CaseData}\");\n\n                // Get patient data\n                var patientData = await client.GetPatientDataAsync(\"P123\");\n                Console.WriteLine($\"Retrieved data for patient {patientData.PatientId}\");\n            }\n            catch (HttpRequestException ex)\n            {\n                Console.WriteLine($\"API request failed: {ex.Message}\");\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine($\"An error occurred: {ex.Message}\");\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#error-handling","title":"Error Handling","text":"<p>The API uses standard HTTP status codes and returns detailed error messages in JSON format.</p> <p>Common Status Codes:</p> Status Code Description 200 Success 400 Bad Request - Invalid input 401 Unauthorized - Invalid or missing API key 422 Validation Error - Request validation failed 429 Too Many Requests - Rate limit exceeded 500 Internal Server Error <p>Error Response Format:</p> <pre><code>{\n  \"detail\": [\n    {\n      \"loc\": [\"body\", \"patient_id\"],\n      \"msg\": \"field required\",\n      \"type\": \"value_error.missing\"\n    }\n  ]\n}\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#mcs-python-client-documentation","title":"MCS Python Client Documentation","text":""},{"location":"swarms_cloud/mcs_api/#installation","title":"Installation","text":"<pre><code>pip install mcs\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#quick-start","title":"Quick Start","text":"<pre><code>from mcs import MCSClient, PatientCase\n\n# Using context manager (recommended)\nwith MCSClient() as client:\n    # Process a single case\n    response = client.run_medical_coder(\n        patient_id=\"P123\",\n        case_description=\"Patient presents with acute respiratory symptoms...\"\n    )\n    print(f\"Processed case: {response.case_data}\")\n\n    # Process multiple cases\n    cases = [\n        PatientCase(\"P124\", \"Case 1 description...\"),\n        PatientCase(\"P125\", \"Case 2 description...\")\n    ]\n    batch_response = client.run_batch(cases)\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#client-configuration","title":"Client Configuration","text":""},{"location":"swarms_cloud/mcs_api/#constructor-arguments","title":"Constructor Arguments","text":"Parameter Type Required Default Description api_key str Yes - Authentication API key base_url str No \"https://mcs.swarms.ai\" API base URL timeout int No 30 Request timeout in seconds max_retries int No 3 Maximum retry attempts logger_name str No \"mcs\" Name for the logger instance"},{"location":"swarms_cloud/mcs_api/#example-configuration","title":"Example Configuration","text":"<pre><code>client = MCSClient(\n    base_url=\"https://custom-url.example.com\",\n    timeout=45,\n    max_retries=5,\n    logger_name=\"custom_logger\"\n)\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#data-models","title":"Data Models","text":""},{"location":"swarms_cloud/mcs_api/#patientcase","title":"PatientCase","text":"Field Type Required Description patient_id str Yes Unique identifier for the patient case_description str Yes Medical case details"},{"location":"swarms_cloud/mcs_api/#queryresponse","title":"QueryResponse","text":"Field Type Description patient_id str Patient identifier case_data str Processed case data"},{"location":"swarms_cloud/mcs_api/#methods","title":"Methods","text":""},{"location":"swarms_cloud/mcs_api/#run_medical_coder","title":"run_medical_coder","text":"<p>Process a single patient case.</p> <pre><code>def run_medical_coder(\n    self,\n    patient_id: str,\n    case_description: str\n) -&gt; QueryResponse:\n</code></pre> <p>Arguments:</p> Parameter Type Required Description patient_id str Yes Patient identifier case_description str Yes Case details <p>Example: <pre><code>response = client.run_medical_coder(\n    patient_id=\"P123\",\n    case_description=\"Patient presents with...\"\n)\nprint(response.case_data)\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#run_batch","title":"run_batch","text":"<p>Process multiple patient cases in batch.</p> <pre><code>def run_batch(\n    self,\n    cases: List[PatientCase]\n) -&gt; List[QueryResponse]:\n</code></pre> <p>Arguments:</p> Parameter Type Required Description cases List[PatientCase] Yes List of patient cases <p>Example: <pre><code>cases = [\n    PatientCase(\"P124\", \"Case 1 description...\"),\n    PatientCase(\"P125\", \"Case 2 description...\")\n]\nresponses = client.run_batch(cases)\nfor response in responses:\n    print(f\"Patient {response.patient_id}: {response.case_data}\")\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#get_patient_data","title":"get_patient_data","text":"<p>Retrieve data for a specific patient.</p> <pre><code>def get_patient_data(\n    self,\n    patient_id: str\n) -&gt; QueryResponse:\n</code></pre> <p>Example: <pre><code>patient_data = client.get_patient_data(\"P123\")\nprint(f\"Patient data: {patient_data.case_data}\")\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#get_all_patients","title":"get_all_patients","text":"<p>Retrieve data for all patients.</p> <pre><code>def get_all_patients(self) -&gt; List[QueryResponse]:\n</code></pre> <p>Example: <pre><code>all_patients = client.get_all_patients()\nfor patient in all_patients:\n    print(f\"Patient {patient.patient_id}: {patient.case_data}\")\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#get_rate_limits","title":"get_rate_limits","text":"<p>Get current rate limit status.</p> <pre><code>def get_rate_limits(self) -&gt; Dict[str, Any]:\n</code></pre> <p>Example: <pre><code>rate_limits = client.get_rate_limits()\nprint(f\"Rate limit status: {rate_limits}\")\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#health_check","title":"health_check","text":"<p>Check if the API is operational.</p> <pre><code>def health_check(self) -&gt; bool:\n</code></pre> <p>Example: <pre><code>is_healthy = client.health_check()\nprint(f\"API health: {'Healthy' if is_healthy else 'Unhealthy'}\")\n</code></pre></p>"},{"location":"swarms_cloud/mcs_api/#error-handling_1","title":"Error Handling","text":""},{"location":"swarms_cloud/mcs_api/#exception-hierarchy","title":"Exception Hierarchy","text":"Exception Description MCSClientError Base exception for all client errors RateLimitError Raised when API rate limit is exceeded AuthenticationError Raised when API authentication fails ValidationError Raised when request validation fails"},{"location":"swarms_cloud/mcs_api/#example-error-handling","title":"Example Error Handling","text":"<pre><code>from mcs import MCSClient, MCSClientError, RateLimitError\n\nwith MCSClient() as client:\n    try:\n        response = client.run_medical_coder(\"P123\", \"Case description...\")\n    except RateLimitError:\n        print(\"Rate limit exceeded. Please wait before retrying.\")\n    except MCSClientError as e:\n        print(f\"An error occurred: {str(e)}\")\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#advanced-usage","title":"Advanced Usage","text":""},{"location":"swarms_cloud/mcs_api/#retry-configuration","title":"Retry Configuration","text":"<p>The client implements two levels of retry logic:</p> <ol> <li> <p>Connection-level retries (using <code>HTTPAdapter</code>): <pre><code>client = MCSClient(\n    ,\n    max_retries=5  # Adjusts connection-level retries\n)\n</code></pre></p> </li> <li> <p>Application-level retries (using <code>tenacity</code>): <pre><code>from tenacity import retry, stop_after_attempt\n\n@retry(stop=stop_after_attempt(5))\ndef process_with_custom_retries():\n    with MCSClient() as client:\n        return client.run_medical_coder(\"P123\", \"Case description...\")\n</code></pre></p> </li> </ol>"},{"location":"swarms_cloud/mcs_api/#batch-processing-with-progress-tracking","title":"Batch Processing with Progress Tracking","text":"<pre><code>from tqdm import tqdm\n\nwith MCSClient() as client:\n    cases = [\n        PatientCase(f\"P{i}\", f\"Case description {i}\")\n        for i in range(100)\n    ]\n\n    # Process in smaller batches\n    batch_size = 10\n    results = []\n\n    for i in tqdm(range(0, len(cases), batch_size)):\n        batch = cases[i:i + batch_size]\n        batch_results = client.run_batch(batch)\n        results.extend(batch_results)\n</code></pre>"},{"location":"swarms_cloud/mcs_api/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Always use context managers: <pre><code>with MCSClient() as client:\n    # Your code here\n    pass\n</code></pre></p> </li> <li> <p>Handle rate limits appropriately: <pre><code>from time import sleep\n\ndef process_with_rate_limit_handling():\n    with MCSClient() as client:\n        try:\n            return client.run_medical_coder(\"P123\", \"Case...\")\n        except RateLimitError:\n            sleep(60)  # Wait before retry\n            return client.run_medical_coder(\"P123\", \"Case...\")\n</code></pre></p> </li> <li> <p>Implement proper logging: <pre><code>from loguru import logger\n\nlogger.add(\"mcs.log\", rotation=\"500 MB\")\n\nwith MCSClient() as client:\n    try:\n        response = client.run_medical_coder(\"P123\", \"Case...\")\n    except Exception as e:\n        logger.exception(f\"Error processing case: {str(e)}\")\n</code></pre></p> </li> <li> <p>Monitor API health: <pre><code>def ensure_healthy_api():\n    with MCSClient() as client:\n        if not client.health_check():\n            raise SystemExit(\"API is not healthy\")\n</code></pre></p> </li> </ol>"},{"location":"swarms_cloud/phala_deploy/","title":"\ud83d\udd10 Swarms x Phala Deployment Guide","text":"<p>This guide will walk you through deploying your project to Phala's Trusted Execution Environment (TEE).</p>"},{"location":"swarms_cloud/phala_deploy/#prerequisites","title":"\ud83d\udccb Prerequisites","text":"<ul> <li>Docker installed on your system</li> <li>A DockerHub account</li> <li>Access to Phala Cloud dashboard</li> </ul>"},{"location":"swarms_cloud/phala_deploy/#tee-overview","title":"\ud83d\udee1\ufe0f TEE Overview","text":"<p>For detailed instructions about Trusted Execution Environment setup, please refer to our TEE Documentation.</p>"},{"location":"swarms_cloud/phala_deploy/#deployment-steps","title":"\ud83d\ude80 Deployment Steps","text":""},{"location":"swarms_cloud/phala_deploy/#1-build-and-publish-docker-image","title":"1. Build and Publish Docker Image","text":"<pre><code># Build the Docker image\ndocker compose build -t &lt;your-dockerhub-username&gt;/swarm-agent-node:latest\n\n# Push to DockerHub\ndocker push &lt;your-dockerhub-username&gt;/swarm-agent-node:latest\n</code></pre>"},{"location":"swarms_cloud/phala_deploy/#2-deploy-to-phala-cloud","title":"2. Deploy to Phala Cloud","text":"<p>Choose one of these deployment methods: - Use tee-cloud-cli (Recommended) - Deploy manually via the Phala Cloud Dashboard</p>"},{"location":"swarms_cloud/phala_deploy/#3-verify-tee-attestation","title":"3. Verify TEE Attestation","text":"<p>Visit the TEE Attestation Explorer to check and verify your agent's TEE proof.</p>"},{"location":"swarms_cloud/phala_deploy/#docker-configuration","title":"\ud83d\udcdd Docker Configuration","text":"<p>Below is a sample Docker Compose configuration for your Swarms agent:</p> <pre><code>services:\n  swarms-agent-server:\n    image: swarms-agent-node:latest\n    platform: linux/amd64\n    volumes:\n      - /var/run/tappd.sock:/var/run/tappd.sock\n      - swarms:/app\n    restart: always\n    ports:\n      - 8000:8000\n    command: # Sample MCP Server\n      - /bin/sh\n      - -c\n      - |\n        cd /app/mcp_example\n        python mcp_test.py\nvolumes:\n  swarms:\n</code></pre>"},{"location":"swarms_cloud/phala_deploy/#additional-resources","title":"\ud83d\udcda Additional Resources","text":"<p>For more comprehensive documentation and examples, visit our Official Documentation.</p> <p>Note: Make sure to replace <code>&lt;your-dockerhub-username&gt;</code> with your actual DockerHub username when building and pushing the image.</p>"},{"location":"swarms_cloud/production_deployment/","title":"Enterprise Guide to High-Performance Multi-Agent LLM Deployments","text":"<p>As large language models (LLMs) continue to advance and enable a wide range of powerful applications, enterprises are increasingly exploring multi-agent architectures to leverage the collective capabilities of multiple LLMs. However, coordinating and optimizing the performance of these complex multi-agent systems presents significant challenges.</p> <p>This comprehensive guide provides enterprise architects, engineering leaders, and technical decision-makers with a strategic framework for maximizing performance across multi-agent LLM deployments. Developed through extensive research and collaboration with industry partners, this guide distills best practices, proven techniques, and cutting-edge methodologies into seven core principles.</p> <p>By implementing the recommendations outlined in this guide, organizations can achieve superior latency, throughput, and resource utilization while ensuring scalability, cost-effectiveness, and optimal user experiences. Whether powering customer-facing conversational agents, driving internal knowledge management systems, or fueling mission-critical decision support tools, high-performance multi-agent LLM deployments will be pivotal to unlocking the full potential of this transformative technology.</p>"},{"location":"swarms_cloud/production_deployment/#introduction","title":"Introduction","text":"<p>The rise of large language models (LLMs) has ushered in a new era of human-machine interaction, enabling enterprises to develop sophisticated natural language processing (NLP) applications that can understand, generate, and reason with human-like text. However, as the complexity and scale of LLM deployments grow, traditional monolithic architectures are increasingly challenged to meet the stringent performance, scalability, and cost requirements of enterprise environments.</p> <p>Multi-agent architectures, which coordinate the collective capabilities of multiple specialized LLMs, have emerged as a powerful paradigm for addressing these challenges. By distributing workloads across a cohort of agents, each optimized for specific tasks or domains, multi-agent systems can deliver superior performance, resilience, and adaptability compared to single-model solutions.</p> <p>However, realizing the full potential of multi-agent LLM deployments requires a strategic approach to system design, optimization, and ongoing management. This guide presents a comprehensive framework for maximizing performance across seven core principles, each underpinned by a range of proven techniques and methodologies.</p> <p>Whether you are architecting a customer-facing conversational agent, building an internal knowledge management platform, or developing a mission-critical decision support system, this guide will equip you with the insights and best practices necessary to unlock the full potential of multi-agent LLM deployments within your enterprise.</p>"},{"location":"swarms_cloud/production_deployment/#principle-1-distribute-token-processing","title":"Principle 1: Distribute Token Processing","text":"<p>At the heart of every LLM deployment lies the fundamental challenge of optimizing token processing -- the rate at which the model consumes and generates text inputs and outputs. In multi-agent architectures, distributing and parallelizing token processing across multiple agents is a critical performance optimization strategy.</p>"},{"location":"swarms_cloud/production_deployment/#agent-specialization","title":"Agent Specialization","text":"<p>One of the key advantages of multi-agent architectures is the ability to dedicate specific agents to specialized tasks or domains. By carefully matching agents to the workloads they are optimized for, enterprises can maximize overall throughput and minimize latency.</p> <p>For example, in a conversational agent deployment, one agent may be optimized for intent recognition and query understanding, while another is fine-tuned for generating coherent, context-aware responses. In a document processing pipeline, separate agents could be dedicated to tasks such as named entity recognition, sentiment analysis, and summarization.</p> <p>To effectively leverage agent specialization, enterprises should:</p> <ul> <li>Conduct a thorough analysis of their application's workflow and identify distinct tasks or domains that could benefit from dedicated agents.</li> <li>Evaluate the strengths and weaknesses of available LLM models and agents, and map them to the identified tasks or domains based on their capabilities and performance characteristics.</li> <li>Implement continuous monitoring and performance tuning processes to ensure agents remain optimized for their assigned workloads as models evolve and domain requirements shift.</li> </ul>"},{"location":"swarms_cloud/production_deployment/#load-balancing","title":"Load Balancing","text":"<p>Even with a well-designed allocation of tasks across specialized agents, fluctuations in workload and demand can create bottlenecks and performance degradation. Effective load balancing strategies are essential to ensure that token processing capacity is dynamically distributed across available agents based on real-time conditions.</p> <p>Load balancing in multi-agent LLM deployments can be accomplished through a combination of techniques, including:</p> <ul> <li>Round-Robin: Distributing incoming requests across agents in a cyclical fashion, ensuring an even distribution of workload.</li> <li>Least Connections: Routing requests to the agent with the fewest active connections or outstanding tasks, minimizing the risk of overloading any single agent.</li> <li>Response Time Monitoring: Continuously monitoring the response times of each agent and dynamically adjusting request routing to favor faster-responding agents.</li> <li>Resource-Based Routing: Factoring in agent-level resource consumption (e.g., CPU, memory) when making routing decisions, ensuring that overloaded agents are relieved of additional workload.</li> </ul> <p>Implementing effective load balancing requires careful consideration of the specific characteristics and requirements of your multi-agent deployment, as well as the integration of robust monitoring and analytics capabilities to inform dynamic routing decisions.</p>"},{"location":"swarms_cloud/production_deployment/#horizontal-scaling","title":"Horizontal Scaling","text":"<p>While load balancing optimizes the utilization of existing agent resources, horizontal scaling strategies enable organizations to dynamically provision additional token processing capacity to meet demand spikes or handle larger overall workloads.</p> <p>In multi-agent LLM deployments, horizontal scaling can be achieved through:</p> <ul> <li>Agent Replication: Spin up additional instances of existing agents to increase parallel processing capacity for specific tasks or domains.</li> <li>Hybrid Scaling: Combine agent replication with the dynamic provisioning of additional compute resources (e.g., CPU, GPU) to support the increased agent count.</li> <li>Serverless Deployment: Leverage serverless computing platforms (e.g., AWS Lambda, Google Cloud Functions) to automatically scale agent instances based on real-time demand, minimizing idle resource consumption.</li> </ul> <p>Effective horizontal scaling requires robust orchestration and management capabilities, as well as seamless integration with load balancing mechanisms to ensure that incoming workloads are efficiently distributed across the dynamically scaled agent pool.</p>"},{"location":"swarms_cloud/production_deployment/#principle-2-optimize-agent-communication","title":"Principle 2: Optimize Agent Communication","text":"<p>In multi-agent LLM deployments, efficient inter-agent communication is crucial for coordinating tasks, exchanging context and intermediate results, and maintaining overall system coherence. However, communication overhead can quickly become a performance bottleneck if not carefully managed.</p>"},{"location":"swarms_cloud/production_deployment/#minimizing-overhead","title":"Minimizing Overhead","text":"<p>Reducing the volume and complexity of information exchanged between agents is a key strategy for optimizing communication performance. Techniques for minimizing overhead include:</p> <ul> <li>Data Compression: Applying lossless or lossy compression algorithms to reduce the size of data payloads exchanged between agents, lowering bandwidth requirements and transmission latencies.</li> <li>Information Summarization: Distilling and summarizing context, results, or other data exchanged between agents to its essential elements, minimizing redundant or non-critical information.</li> <li>Differential Updates: Rather than transmitting entire data payloads, agents can exchange only the differential updates or deltas required to synchronize their respective states.</li> </ul> <p>Implementing these techniques requires careful analysis of the specific data exchange patterns and communication requirements within your multi-agent deployment, as well as the integration of appropriate compression, summarization, and differential update algorithms.</p>"},{"location":"swarms_cloud/production_deployment/#prioritizing-critical-information","title":"Prioritizing Critical Information","text":"<p>In scenarios where communication bandwidth or latency constraints cannot be fully alleviated through overhead reduction techniques, enterprises can prioritize the exchange of critical information over non-essential data.</p> <p>This can be achieved through:</p> <ul> <li>Prioritized Queuing: Implementing queuing mechanisms that prioritize the transmission of high-priority, time-sensitive data over lower-priority, non-critical information.</li> <li>Selective Communication: Dynamically determining which agents require specific pieces of information based on their roles and responsibilities, and selectively transmitting data only to those agents that truly need it.</li> <li>Progressive Information Exchange: Exchanging information in a progressive or staged manner, with critical elements transmitted first, followed by supplementary or contextual data as bandwidth becomes available.</li> </ul> <p>Effective prioritization requires a deep understanding of the interdependencies and information flow within your multi-agent system, as well as the ability to dynamically assess and prioritize data based on its criticality and urgency.</p>"},{"location":"swarms_cloud/production_deployment/#caching-and-reusing-context","title":"Caching and Reusing Context","text":"<p>In many multi-agent LLM deployments, agents frequently exchange or operate on shared context, such as user profiles, conversation histories, or domain-specific knowledge bases. Caching and reusing this context information can significantly reduce redundant communication and processing overhead.</p> <p>Strategies for optimizing context caching and reuse include:</p> <ul> <li>Agent-Level Caching: Implementing caching mechanisms within individual agents to store and retrieve frequently accessed context data, minimizing the need for inter-agent communication.</li> <li>Centralized Context Management: Deploying a dedicated context management service or data store that agents can query and update, ensuring consistent access to the latest context information across the system.</li> <li>Context Versioning and Invalidation: Implementing versioning and invalidation mechanisms to ensure that cached context data remains fresh and consistent, avoiding stale or outdated information from propagating through the system.</li> </ul>"},{"location":"swarms_cloud/production_deployment/#principle-3-leverage-agent-specialization","title":"Principle 3: Leverage Agent Specialization","text":"<p>One of the key advantages of multi-agent architectures is the ability to optimize individual agents for specific tasks, domains, or capabilities. By leveraging agent specialization, enterprises can ensure that each component of their LLM system is finely tuned for maximum performance and quality.</p>"},{"location":"swarms_cloud/production_deployment/#task-specific-optimization","title":"Task-Specific Optimization","text":"<p>Within a multi-agent LLM deployment, different agents may be responsible for distinct tasks such as language understanding, knowledge retrieval, response generation, or post-processing. Optimizing each agent for its designated task can yield significant performance gains and quality improvements.</p> <p>Techniques for task-specific optimization include:</p> <ul> <li>Prompt Engineering: Crafting carefully designed prompts that provide the necessary context, instructions, and examples to guide an agent towards optimal performance for its assigned task.</li> <li>Fine-Tuning: Adapting a pre-trained LLM to a specific task or domain by fine-tuning it on a curated dataset, allowing the agent to specialize and improve its performance on that particular workload.</li> <li>Model Distillation: Transferring the knowledge and capabilities of a larger, more capable LLM into a smaller, more efficient model specialized for a specific task, balancing performance and quality trade-offs.</li> </ul> <p>Implementing these optimization techniques requires a deep understanding of the capabilities and requirements of each task within your multi-agent system, as well as access to relevant training data and computational resources for fine-tuning and distillation processes.</p>"},{"location":"swarms_cloud/production_deployment/#domain-adaptation","title":"Domain Adaptation","text":"<p>Many enterprise applications operate within specific domains or verticals, such as finance, healthcare, or legal. Adapting agents to these specialized domains can significantly improve their performance, accuracy, and compliance within the target domain.</p> <p>Strategies for domain adaptation include:</p> <ul> <li>Domain-Specific Pre-Training: Leveraging domain-specific corpora to pre-train LLM agents, imbuing them with a foundational understanding of the language, concepts, and nuances specific to the target domain.</li> <li>Transfer Learning: Fine-tuning agents that have been pre-trained on general or adjacent domains, transferring their existing knowledge and capabilities to the target domain while optimizing for its specific characteristics.</li> <li>Domain Persona Injection: Injecting domain-specific personas, traits, or constraints into agents during fine-tuning or deployment, shaping their behavior and outputs to align with domain-specific norms and requirements.</li> </ul> <p>Effective domain adaptation requires access to high-quality, domain-specific training data, as well as close collaboration with subject matter experts to ensure that agents are properly calibrated to meet the unique demands of the target domain.</p>"},{"location":"swarms_cloud/production_deployment/#ensemble-techniques","title":"Ensemble Techniques","text":"<p>In complex multi-agent deployments, individual agents may excel at specific subtasks or aspects of the overall workflow. Ensemble techniques that combine the outputs or predictions of multiple specialized agents can often outperform any single agent, leveraging the collective strengths of the ensemble.</p> <p>Common ensemble techniques for multi-agent LLM systems include:</p> <ul> <li>Voting: Combining the outputs or predictions of multiple agents through majority voting, weighted voting, or other consensus mechanisms.</li> <li>Stacking: Training a meta-agent to combine and optimize the outputs of multiple base agents, effectively learning to leverage their collective strengths.</li> <li>Blending: Combining the outputs of multiple agents through weighted averaging, linear interpolation, or other blending techniques, allowing for nuanced integration of diverse perspectives.</li> </ul> <p>Implementing effective ensemble techniques requires careful analysis of the strengths, weaknesses, and complementary capabilities of individual agents, as well as the development of robust combination strategies that can optimally leverage the ensemble's collective intelligence.</p>"},{"location":"swarms_cloud/production_deployment/#principle-4-implement-dynamic-scaling","title":"Principle 4: Implement Dynamic Scaling","text":"<p>The demand and workload patterns of enterprise LLM deployments can be highly dynamic, with significant fluctuations driven by factors such as user activity, data ingestion schedules, or periodic batch processing. Implementing dynamic scaling strategies allows organizations to optimally provision and allocate resources in response to these fluctuations, ensuring consistent performance while minimizing unnecessary costs.</p>"},{"location":"swarms_cloud/production_deployment/#autoscaling","title":"Autoscaling","text":"<p>Autoscaling is a core capability that enables the automatic adjustment of compute resources (e.g., CPU, GPU, memory) and agent instances based on real-time demand patterns and workload metrics. By dynamically scaling resources up or down, enterprises can maintain optimal performance and resource utilization, avoiding both over-provisioning and under-provisioning scenarios.</p> <p>Effective autoscaling in multi-agent LLM deployments requires:</p> <ul> <li>Monitoring and Metrics: Implementing robust monitoring and metrics collection mechanisms to track key performance indicators (KPIs) such as request rates, response times, resource utilization, and agent-level metrics.</li> <li>Scaling Policies: Defining scaling policies that specify the conditions and thresholds for triggering automatic scaling actions, such as provisioning additional agents or compute resources when certain KPIs are breached.</li> <li>Scaling Orchestration: Integrating autoscaling capabilities with resource orchestration and management tools (e.g., Kubernetes, AWS Auto Scaling) to seamlessly provision, configure, and integrate new resources into the existing multi-agent deployment.</li> </ul> <p>By automating the scaling process, enterprises can respond rapidly to workload fluctuations, ensuring consistent performance and optimal resource utilization without the need for manual intervention.</p>"},{"location":"swarms_cloud/production_deployment/#spot-instance-utilization","title":"Spot Instance Utilization","text":"<p>Many cloud providers offer spot instances or preemptible resources at significantly discounted prices compared to on-demand or reserved instances. While these resources may be reclaimed with little notice, they can be leveraged judiciously within multi-agent LLM deployments to reduce operational costs.</p> <p>Strategies for leveraging spot instances include:</p> <ul> <li>Fault-Tolerant Agent Deployment: Deploying certain agents or components of the multi-agent system on spot instances, while ensuring that these components can be rapidly and seamlessly replaced or migrated in the event of instance preemption.</li> <li>Batch Workload Offloading: Offloading batch processing workloads or non-time-sensitive tasks to spot instances, leveraging their cost-effectiveness while minimizing the impact of potential disruptions.</li> <li>Hybrid Provisioning: Implementing a hybrid approach that combines on-demand or reserved instances for mission-critical components with spot instances for more flexible or elastic workloads.</li> </ul> <p>Effective spot instance utilization requires careful architectural considerations to ensure fault tolerance and minimize the impact of potential disruptions, as well as robust monitoring and automation capabilities to seamlessly replace or migrate workloads in response to instance preemption events.</p>"},{"location":"swarms_cloud/production_deployment/#serverless-deployments","title":"Serverless Deployments","text":"<p>Serverless computing platforms, such as AWS Lambda, Google Cloud Functions, or Azure Functions, offer a compelling alternative to traditional server-based deployments. By automatically scaling compute resources based on real-time demand and charging only for the resources consumed, serverless architectures can provide significant cost savings and operational simplicity.</p> <p>Leveraging serverless deployments for multi-agent LLM systems can be achieved through:</p> <ul> <li>Function-as-a-Service (FaaS) Agents: Deploying individual agents or components of the multi-agent system as serverless functions, allowing for rapid and automatic scaling in response to fluctuating workloads.</li> <li>Event-Driven Architectures: Designing the multi-agent system to operate in an event-driven manner, with agents triggered and executed in response to specific events or data ingestion, aligning with the serverless execution model.</li> <li>Hybrid Deployments: Combining serverless components with traditional server-based components, leveraging the strengths and cost advantages of each deployment model for different aspects of the multi-agent system.</li> </ul> <p>Adopting serverless architectures requires careful consideration of factors such as execution duration limits, cold start latencies, and integration with other components of the multi-agent deployment. However, when implemented effectively, serverless deployments can provide unparalleled scalability, cost-efficiency, and operational simplicity for dynamic, event-driven workloads.</p>"},{"location":"swarms_cloud/production_deployment/#principle-5-employ-selective-execution","title":"Principle 5: Employ Selective Execution","text":"<p>Not every input or request within a multi-agent LLM deployment requires the full execution of all agents or the complete processing pipeline. Selectively invoking agents or tasks based on input characteristics or intermediate results can significantly optimize performance by avoiding unnecessary computation and resource consumption.</p>"},{"location":"swarms_cloud/production_deployment/#input-filtering","title":"Input Filtering","text":"<p>Implementing input filtering mechanisms allows enterprises to reject or bypass certain inputs before they are processed by the multi-agent system. This can be achieved through techniques such as:</p> <ul> <li>Blacklisting/Whitelisting: Maintaining lists of inputs (e.g., specific phrases, URLs, or content types) that should be automatically rejected or allowed, based on predefined criteria.</li> <li>Rules-Based Filtering: Defining a set of rules or heuristics to assess the suitability or relevance of an input for further processing, based on factors such as language, content, or metadata.</li> <li>Confidence Thresholding: Leveraging pre-processing agents or models to assess the likelihood that an input is relevant or valuable, and filtering out inputs that fall below a predetermined confidence threshold.</li> </ul> <p>Effective input filtering requires careful consideration of the specific requirements, constraints, and objectives of your multi-agent deployment, as well as ongoing monitoring and adjustment of filtering rules and thresholds to maintain optimal performance and accuracy.</p>"},{"location":"swarms_cloud/production_deployment/#early-stopping","title":"Early Stopping","text":"<p>In many multi-agent LLM deployments, intermediate results or predictions generated by early-stage agents can be used to determine whether further processing is required or valuable. Early stopping mechanisms allow enterprises to terminate execution pipelines when specific conditions or thresholds are met, avoiding unnecessary downstream processing.</p> <p>Techniques for implementing early stopping include:</p> <ul> <li>Confidence-Based Stopping: Monitoring the confidence scores or probabilities associated with intermediate results, and terminating execution if a predefined confidence threshold is exceeded.</li> <li>Exception-Based Stopping: Defining specific intermediate results or conditions that indicate that further processing is unnecessary or undesirable, and terminating execution upon encountering these exceptions.</li> <li>Adaptive Stopping: Employing machine learning models or reinforcement learning agents to dynamically determine when to terminate execution based on learned patterns and trade-offs between accuracy, latency, and resource consumption.</li> </ul> <p>Effective early stopping requires a deep understanding of the interdependencies and decision points within your multi-agent workflow, as well as careful tuning and monitoring to ensure that stopping conditions are calibrated to maintain an optimal balance between performance and accuracy.</p>"},{"location":"swarms_cloud/production_deployment/#conditional-branching","title":"Conditional Branching","text":"<p>Rather than executing a linear, fixed pipeline of agents, conditional branching allows multi-agent systems to dynamically invoke different agents or execution paths based on input characteristics or intermediate results. This can significantly optimize resource utilization by ensuring that only the necessary agents and processes are executed for a given input or scenario.</p> <p>Implementing conditional branching involves:</p> <ul> <li>Decision Points: Identifying key points within the multi-agent workflow where branching decisions can be made based on input or intermediate data.</li> <li>Branching Logic: Defining the rules, conditions, or machine learning models that will evaluate the input or intermediate data and determine the appropriate execution path or agent invocation.</li> <li>Execution Routing: Integrating mechanisms to dynamically route inputs or intermediate data to the appropriate agents or processes based on the branching decision.</li> </ul> <p>Conditional branching can be particularly effective in scenarios where inputs or workloads exhibit distinct characteristics or require significantly different processing pipelines, allowing enterprises to optimize resource allocation and minimize unnecessary computation.</p>"},{"location":"swarms_cloud/production_deployment/#principle-6-optimize-user-experience","title":"Principle 6: Optimize User Experience","text":"<p>While many of the principles outlined in this guide focus on optimizing backend performance and resource utilization, delivering an exceptional user experience is also a critical consideration for enterprise multi-agent LLM deployments. By minimizing perceived wait times and providing real-time progress updates, organizations can ensure that users remain engaged and satisfied, even during periods of high workload or resource constraints.</p>"},{"location":"swarms_cloud/production_deployment/#streaming-responses","title":"Streaming Responses","text":"<p>One of the most effective techniques for minimizing perceived wait times is to stream responses or outputs to users as they are generated, rather than waiting for the entire response to be completed before delivering it. This approach is particularly valuable in conversational agents, document summarization, or other scenarios where outputs can be naturally segmented and delivered incrementally.</p> <p>Implementing streaming responses requires:</p> <ul> <li>Partial Output Generation: Modifying agents or models to generate and emit outputs in a streaming or incremental fashion, rather than producing the entire output in a single, monolithic operation.</li> <li>Streaming Data Pipelines: Integrating streaming data pipelines and message queues to enable the efficient and reliable transmission of partial outputs from agents to user-facing interfaces or applications.</li> <li>Incremental Rendering: Updating user interfaces and displays to incrementally render or populate with newly streamed output segments, providing a seamless and real-time experience for end-users.</li> </ul> <p>By delivering outputs as they are generated, streaming responses can significantly improve the perceived responsiveness and interactivity of multi-agent LLM deployments, even in scenarios where the overall processing time remains unchanged.</p>"},{"location":"swarms_cloud/production_deployment/#progress-indicators","title":"Progress Indicators","text":"<p>In cases where streaming responses may not be feasible or appropriate, providing visual or textual indicators of ongoing processing and progress can help manage user expectations and improve the overall experience. Progress indicators can be implemented through techniques such as:</p> <ul> <li>Loader Animations: Displaying simple animations or spinner graphics to indicate that processing is underway and provide a sense of activity and progress.</li> <li>Progress Bars: Rendering progress bars or completion indicators based on estimated or actual progress through multi-agent workflows or processing pipelines.</li> <li>Status Updates: Periodically updating user interfaces with textual status messages or descriptions of the current processing stage, providing users with a more detailed understanding of the system's activities.</li> </ul> <p>Effective progress indicators require careful integration with monitoring and telemetry capabilities to accurately track and communicate the progress of multi-agent workflows, as well as thoughtful user experience design to ensure that indicators are clear, unobtrusive, and aligned with user expectations.</p>"},{"location":"swarms_cloud/production_deployment/#chunked-delivery","title":"Chunked Delivery","text":"<p>In scenarios where outputs or responses cannot be effectively streamed or rendered incrementally, chunked delivery can provide a middle ground between delivering the entire output at once and streaming individual tokens or characters. By breaking larger outputs into smaller, more manageable chunks and delivering them individually, enterprises can improve perceived responsiveness and provide a more engaging user experience.</p> <p>Implementing chunked delivery involves:</p> <ul> <li>Output Segmentation: Identifying logical breakpoints or segmentation boundaries within larger outputs, such as paragraphs, sections, or other structural elements.</li> <li>Chunking Mechanisms: Integrating mechanisms to efficiently break outputs into individual chunks and transmit or render them sequentially, with minimal delay between chunks.</li> <li>Chunk Rendering: Updating user interfaces or displays to seamlessly render or append new output chunks as they are received, providing a sense of continuous progress and minimizing the perception of extended waiting periods.</li> </ul> <p>Chunked delivery can be particularly effective in scenarios where outputs are inherently structured or segmented, such as document generation, report creation, or multi-step instructions or workflows.</p>"},{"location":"swarms_cloud/production_deployment/#principle-7-leverage-hybrid-approaches","title":"Principle 7: Leverage Hybrid Approaches","text":"<p>While multi-agent LLM architectures offer numerous advantages, they should not be viewed as a one-size-fits-all solution. In many cases, combining LLM agents with traditional techniques, optimized components, or external services can yield superior performance, cost-effectiveness, and resource utilization compared to a pure LLM-based approach.</p>"},{"location":"swarms_cloud/production_deployment/#task-offloading","title":"Task Offloading","text":"<p>Certain tasks or subtasks within a larger multi-agent workflow may be more efficiently handled by dedicated, optimized components or external services, rather than relying solely on LLM agents. Task offloading involves identifying these opportunities and integrating the appropriate components or services into the overall architecture.</p> <p>Examples of task offloading in multi-agent LLM deployments include:</p> <ul> <li>Regular Expression Matching: Offloading pattern matching or text extraction tasks to dedicated regular expression engines, which can often outperform LLM-based approaches in terms of speed and efficiency.</li> <li>Structured Data Processing: Leveraging specialized data processing engines or databases for tasks involving structured data, such as querying, filtering, or transforming tabular or relational data.</li> <li>External APIs and Services: Integrating with external APIs or cloud services for specific tasks, such as speech recognition, translation, or knowledge base lookup, leveraging the specialized capabilities and optimizations of these dedicated services.</li> </ul> <p>Effective task offloading requires a thorough understanding of the strengths and limitations of both LLM agents and traditional components, as well as careful consideration of integration points, data flows, and performance trade-offs within the overall multi-agent architecture.</p>"},{"location":"swarms_cloud/production_deployment/#caching-and-indexing","title":"Caching and Indexing","text":"<p>While LLMs excel at generating dynamic, context-aware outputs, they can be less efficient when dealing with static or frequently accessed information or knowledge. Caching and indexing strategies can help mitigate this limitation by minimizing redundant LLM processing and enabling faster retrieval of commonly accessed data.</p> <p>Techniques for leveraging caching and indexing in multi-agent LLM deployments include:</p> <p>Output Caching: Caching the outputs or responses generated by LLM agents, allowing for rapid retrieval and reuse in cases where the same or similar input is encountered in the future.</p> <p>Knowledge Base Indexing: Indexing domain-specific knowledge bases, data repositories, or other static information sources using traditional search and information retrieval techniques. This allows LLM agents to efficiently query and incorporate relevant information into their outputs, without needing to process or generate this content from scratch.</p> <p>Contextual Caching: Caching not only outputs but also the contextual information and intermediate results generated during multi-agent workflows. This enables more efficient reuse and continuation of previous processing in scenarios where contexts are long-lived or recurring.</p> <p>Implementing effective caching and indexing strategies requires careful consideration of data freshness, consistency, and invalidation mechanisms, as well as seamless integration with LLM agents and multi-agent workflows to ensure that cached or indexed data is appropriately leveraged and updated.</p>"},{"location":"swarms_cloud/production_deployment/#pre-computation-and-lookup","title":"Pre-computation and Lookup","text":"<p>In certain scenarios, especially those involving constrained or well-defined inputs, pre-computing and lookup strategies can be leveraged to minimize or entirely avoid the need for real-time LLM processing. By generating and storing potential outputs or responses in advance, enterprises can significantly improve performance and reduce resource consumption.</p> <p>Approaches for pre-computation and lookup include:</p> <p>Output Pre-generation: For inputs or scenarios with a limited set of potential outputs, pre-generating and storing all possible responses, allowing for rapid retrieval and delivery without the need for real-time LLM execution.</p> <p>Retrieval-Based Responses: Developing retrieval models or techniques that can identify and surface pre-computed or curated responses based on input characteristics, leveraging techniques such as nearest neighbor search, embedding-based retrieval, or example-based generation.</p> <p>Hybrid Approaches: Combining pre-computed or retrieved responses with real-time LLM processing, allowing for the generation of dynamic, context-aware content while still leveraging pre-computed components to optimize performance and resource utilization.</p> <p>Effective implementation of pre-computation and lookup strategies requires careful analysis of input patterns, output distributions, and potential performance gains, as well as robust mechanisms for managing and updating pre-computed data as application requirements or domain knowledge evolves.</p>"},{"location":"swarms_cloud/production_deployment/#conclusion","title":"Conclusion","text":"<p>As enterprises increasingly embrace the transformative potential of large language models, optimizing the performance, scalability, and cost-effectiveness of these deployments has become a critical imperative. Multi-agent architectures, which coordinate the collective capabilities of multiple specialized LLM agents, offer a powerful paradigm for addressing these challenges.</p> <p>By implementing the seven principles outlined in this guide -- distributing token processing, optimizing agent communication, leveraging agent specialization, implementing dynamic scaling, employing selective execution, optimizing user experience, and leveraging hybrid approaches -- organizations can unlock the full potential of multi-agent LLM deployments.</p> <p>However, realizing these benefits requires a strategic and holistic approach that accounts for the unique requirements, constraints, and objectives of each enterprise. From task-specific optimizations and domain adaptation to dynamic scaling and user experience considerations, maximizing the performance of multi-agent LLM systems demands a deep understanding of the underlying technologies, as well as the ability to navigate the inherent complexities of these sophisticated architectures.</p> <p>To learn more about how Swarm Corporation can assist your organization in architecting, deploying, and optimizing high-performance multi-agent LLM solutions, we invite you to book a consultation with one of our agent specialists. Visit https://calendly.com/swarm-corp/30min to schedule a 30-minute call and explore how our expertise and cutting-edge technologies can drive transformative outcomes for your business.</p> <p>In the rapidly evolving landscape of artificial intelligence and natural language processing, staying ahead of the curve is essential. Partner with Swarm Corporation, and unlock the full potential of multi-agent LLM deployments, today.</p> <p>Book a call with us now:</p>"},{"location":"swarms_cloud/python_client/","title":"Swarms Cloud API Client Documentation","text":""},{"location":"swarms_cloud/python_client/#introduction","title":"Introduction","text":"<p>The Swarms Cloud API client is a production-grade Python package for interacting with the Swarms API. It provides both synchronous and asynchronous interfaces, making it suitable for a wide range of applications from simple scripts to high-performance, scalable services.</p> <p>Key features include: - Connection pooling and efficient session management - Automatic retries with exponential backoff - Circuit breaker pattern for improved reliability - In-memory caching for frequently accessed resources - Comprehensive error handling with detailed exceptions - Full support for asynchronous operations - Type checking with Pydantic</p> <p>This documentation covers all available client methods with detailed descriptions, parameter references, and usage examples.</p>"},{"location":"swarms_cloud/python_client/#installation","title":"Installation","text":"<pre><code>pip install swarms-client\n</code></pre>"},{"location":"swarms_cloud/python_client/#authentication","title":"Authentication","text":"<p>To use the Swarms API, you need an API key. You can obtain your API key from the Swarms Platform API Keys page.</p>"},{"location":"swarms_cloud/python_client/#client-initialization","title":"Client Initialization","text":"<p>The <code>SwarmsClient</code> is the main entry point for interacting with the Swarms API. It can be initialized with various configuration options to customize its behavior.</p> <pre><code>from swarms_client import SwarmsClient\n\n# Initialize with default settings\nclient = SwarmsClient(api_key=\"your-api-key\")\n\n# Or with custom settings\nclient = SwarmsClient(\n    api_key=\"your-api-key\",\n    base_url=\"https://swarms-api-285321057562.us-east1.run.app\",\n    timeout=60,\n    max_retries=3,\n    retry_delay=1,\n    log_level=\"INFO\",\n    pool_connections=100,\n    pool_maxsize=100,\n    keep_alive_timeout=5,\n    max_concurrent_requests=100,\n    circuit_breaker_threshold=5,\n    circuit_breaker_timeout=60,\n    enable_cache=True\n)\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>api_key</code> <code>str</code> Environment variable <code>SWARMS_API_KEY</code> API key for authentication <code>base_url</code> <code>str</code> <code>\"https://swarms-api-285321057562.us-east1.run.app\"</code> Base URL for the API <code>timeout</code> <code>int</code> <code>60</code> Timeout for API requests in seconds <code>max_retries</code> <code>int</code> <code>3</code> Maximum number of retry attempts for failed requests <code>retry_delay</code> <code>int</code> <code>1</code> Initial delay between retries in seconds (uses exponential backoff) <code>log_level</code> <code>str</code> <code>\"INFO\"</code> Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL) <code>pool_connections</code> <code>int</code> <code>100</code> Number of connection pools to cache <code>pool_maxsize</code> <code>int</code> <code>100</code> Maximum number of connections to save in the pool <code>keep_alive_timeout</code> <code>int</code> <code>5</code> Keep-alive timeout for connections in seconds <code>max_concurrent_requests</code> <code>int</code> <code>100</code> Maximum number of concurrent requests <code>circuit_breaker_threshold</code> <code>int</code> <code>5</code> Failure threshold for the circuit breaker <code>circuit_breaker_timeout</code> <code>int</code> <code>60</code> Reset timeout for the circuit breaker in seconds <code>enable_cache</code> <code>bool</code> <code>True</code> Whether to enable in-memory caching"},{"location":"swarms_cloud/python_client/#client-methods","title":"Client Methods","text":""},{"location":"swarms_cloud/python_client/#clear_cache","title":"clear_cache","text":"<p>Clears the in-memory cache used for caching API responses.</p> <pre><code>client.clear_cache()\n</code></pre>"},{"location":"swarms_cloud/python_client/#agent-resource","title":"Agent Resource","text":"<p>The Agent resource provides methods for creating and managing agent completions.</p> <p></p>"},{"location":"swarms_cloud/python_client/#create","title":"create","text":"<p>Creates an agent completion.</p> <pre><code>response = client.agent.create(\n    agent_config={\n        \"agent_name\": \"Researcher\",\n        \"description\": \"Conducts in-depth research on topics\",\n        \"model_name\": \"gpt-4o\",\n        \"temperature\": 0.7\n    },\n    task=\"Research the latest advancements in quantum computing and summarize the key findings\"\n)\n\nprint(f\"Agent ID: {response.id}\")\nprint(f\"Output: {response.outputs}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_1","title":"Parameters","text":"Parameter Type Required Description <code>agent_config</code> <code>dict</code> or <code>AgentSpec</code> Yes Configuration for the agent <code>task</code> <code>str</code> Yes The task for the agent to complete <code>history</code> <code>dict</code> No Optional conversation history <p>The <code>agent_config</code> parameter can include the following fields:</p> Field Type Default Description <code>agent_name</code> <code>str</code> Required Name of the agent <code>description</code> <code>str</code> <code>None</code> Description of the agent's purpose <code>system_prompt</code> <code>str</code> <code>None</code> System prompt to guide the agent's behavior <code>model_name</code> <code>str</code> <code>\"gpt-4o-mini\"</code> Name of the model to use <code>auto_generate_prompt</code> <code>bool</code> <code>False</code> Whether to automatically generate a prompt <code>max_tokens</code> <code>int</code> <code>8192</code> Maximum tokens in the response <code>temperature</code> <code>float</code> <code>0.5</code> Temperature for sampling (0-1) <code>role</code> <code>str</code> <code>None</code> Role of the agent <code>max_loops</code> <code>int</code> <code>1</code> Maximum number of reasoning loops <code>tools_dictionary</code> <code>List[Dict]</code> <code>None</code> Tools available to the agent"},{"location":"swarms_cloud/python_client/#returns","title":"Returns","text":"<p><code>AgentCompletionResponse</code> object with the following properties:</p> <ul> <li><code>id</code>: Unique identifier for the completion</li> <li><code>success</code>: Whether the completion was successful</li> <li><code>name</code>: Name of the agent</li> <li><code>description</code>: Description of the agent</li> <li><code>temperature</code>: Temperature used for the completion</li> <li><code>outputs</code>: Output from the agent</li> <li><code>usage</code>: Token usage information</li> <li><code>timestamp</code>: Timestamp of the completion</li> </ul> <p></p>"},{"location":"swarms_cloud/python_client/#create_batch","title":"create_batch","text":"<p>Creates multiple agent completions in batch.</p> <pre><code>responses = client.agent.create_batch([\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Researcher\",\n            \"model_name\": \"gpt-4o-mini\",\n            \"temperature\": 0.5\n        },\n        \"task\": \"Summarize the latest quantum computing research\"\n    },\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Writer\",\n            \"model_name\": \"gpt-4o\",\n            \"temperature\": 0.7\n        },\n        \"task\": \"Write a blog post about AI safety\"\n    }\n])\n\nfor i, response in enumerate(responses):\n    print(f\"Agent {i+1} ID: {response.id}\")\n    print(f\"Output: {response.outputs}\")\n    print(\"---\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_2","title":"Parameters","text":"Parameter Type Required Description <code>completions</code> <code>List[Dict or AgentCompletion]</code> Yes List of agent completion requests <p>Each item in the <code>completions</code> list should have the same structure as the parameters for the <code>create</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_1","title":"Returns","text":"<p>List of <code>AgentCompletionResponse</code> objects with the same properties as the return value of the <code>create</code> method.</p> <p></p>"},{"location":"swarms_cloud/python_client/#acreate","title":"acreate","text":"<p>Creates an agent completion asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        response = await client.agent.acreate(\n            agent_config={\n                \"agent_name\": \"Researcher\",\n                \"description\": \"Conducts in-depth research\",\n                \"model_name\": \"gpt-4o\"\n            },\n            task=\"Research the impact of quantum computing on cryptography\"\n        )\n\n        print(f\"Agent ID: {response.id}\")\n        print(f\"Output: {response.outputs}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_3","title":"Parameters","text":"<p>Same as the <code>create</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_2","title":"Returns","text":"<p>Same as the <code>create</code> method.</p> <p></p>"},{"location":"swarms_cloud/python_client/#acreate_batch","title":"acreate_batch","text":"<p>Creates multiple agent completions in batch asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        responses = await client.agent.acreate_batch([\n            {\n                \"agent_config\": {\n                    \"agent_name\": \"Researcher\",\n                    \"model_name\": \"gpt-4o-mini\"\n                },\n                \"task\": \"Summarize the latest quantum computing research\"\n            },\n            {\n                \"agent_config\": {\n                    \"agent_name\": \"Writer\",\n                    \"model_name\": \"gpt-4o\"\n                },\n                \"task\": \"Write a blog post about AI safety\"\n            }\n        ])\n\n        for i, response in enumerate(responses):\n            print(f\"Agent {i+1} ID: {response.id}\")\n            print(f\"Output: {response.outputs}\")\n            print(\"---\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_4","title":"Parameters","text":"<p>Same as the <code>create_batch</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_3","title":"Returns","text":"<p>Same as the <code>create_batch</code> method.</p>"},{"location":"swarms_cloud/python_client/#swarm-resource","title":"Swarm Resource","text":"<p>The Swarm resource provides methods for creating and managing swarm completions.</p> <p></p>"},{"location":"swarms_cloud/python_client/#create_1","title":"create","text":"<p>Creates a swarm completion.</p> <pre><code>response = client.swarm.create(\n    name=\"Research Swarm\",\n    description=\"A swarm for research tasks\",\n    swarm_type=\"SequentialWorkflow\",\n    task=\"Research quantum computing advances in 2024 and summarize the key findings\",\n    agents=[\n        {\n            \"agent_name\": \"Researcher\",\n            \"description\": \"Conducts in-depth research\",\n            \"model_name\": \"gpt-4o\",\n            \"temperature\": 0.5\n        },\n        {\n            \"agent_name\": \"Critic\",\n            \"description\": \"Evaluates arguments for flaws\",\n            \"model_name\": \"gpt-4o-mini\",\n            \"temperature\": 0.3\n        }\n    ],\n    max_loops=3,\n    return_history=True\n)\n\nprint(f\"Job ID: {response.job_id}\")\nprint(f\"Status: {response.status}\")\nprint(f\"Output: {response.output}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_5","title":"Parameters","text":"Parameter Type Required Description <code>name</code> <code>str</code> No Name of the swarm <code>description</code> <code>str</code> No Description of the swarm <code>agents</code> <code>List[Dict or AgentSpec]</code> No List of agent specifications <code>max_loops</code> <code>int</code> No Maximum number of loops (default: 1) <code>swarm_type</code> <code>str</code> No Type of swarm (see available types) <code>task</code> <code>str</code> Conditional The task to complete (required if tasks and messages are not provided) <code>tasks</code> <code>List[str]</code> Conditional List of tasks for batch processing (required if task and messages are not provided) <code>messages</code> <code>List[Dict]</code> Conditional List of messages to process (required if task and tasks are not provided) <code>return_history</code> <code>bool</code> No Whether to return the execution history (default: True) <code>rules</code> <code>str</code> No Rules for the swarm <code>schedule</code> <code>Dict</code> No Schedule specification for delayed execution <code>stream</code> <code>bool</code> No Whether to stream the response (default: False) <code>service_tier</code> <code>str</code> No Service tier ('standard' or 'flex', default: 'standard')"},{"location":"swarms_cloud/python_client/#returns_4","title":"Returns","text":"<p><code>SwarmCompletionResponse</code> object with the following properties:</p> <ul> <li><code>job_id</code>: Unique identifier for the job</li> <li><code>status</code>: Status of the job</li> <li><code>swarm_name</code>: Name of the swarm</li> <li><code>description</code>: Description of the swarm</li> <li><code>swarm_type</code>: Type of swarm used</li> <li><code>output</code>: Output from the swarm</li> <li><code>number_of_agents</code>: Number of agents in the swarm</li> <li><code>service_tier</code>: Service tier used</li> <li><code>tasks</code>: List of tasks processed (if applicable)</li> <li><code>messages</code>: List of messages processed (if applicable)</li> </ul> <p></p>"},{"location":"swarms_cloud/python_client/#create_batch_1","title":"create_batch","text":"<p>Creates multiple swarm completions in batch.</p> <pre><code>responses = client.swarm.create_batch([\n    {\n        \"name\": \"Research Swarm\",\n        \"swarm_type\": \"auto\",\n        \"task\": \"Research quantum computing advances\",\n        \"agents\": [\n            {\"agent_name\": \"Researcher\", \"model_name\": \"gpt-4o\"}\n        ]\n    },\n    {\n        \"name\": \"Writing Swarm\",\n        \"swarm_type\": \"SequentialWorkflow\",\n        \"task\": \"Write a blog post about AI safety\",\n        \"agents\": [\n            {\"agent_name\": \"Writer\", \"model_name\": \"gpt-4o\"},\n            {\"agent_name\": \"Editor\", \"model_name\": \"gpt-4o-mini\"}\n        ]\n    }\n])\n\nfor i, response in enumerate(responses):\n    print(f\"Swarm {i+1} Job ID: {response.job_id}\")\n    print(f\"Status: {response.status}\")\n    print(f\"Output: {response.output}\")\n    print(\"---\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_6","title":"Parameters","text":"Parameter Type Required Description <code>swarms</code> <code>List[Dict or SwarmSpec]</code> Yes List of swarm specifications <p>Each item in the <code>swarms</code> list should have the same structure as the parameters for the <code>create</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_5","title":"Returns","text":"<p>List of <code>SwarmCompletionResponse</code> objects with the same properties as the return value of the <code>create</code> method.</p> <p></p>"},{"location":"swarms_cloud/python_client/#list_types","title":"list_types","text":"<p>Lists available swarm types.</p> <pre><code>response = client.swarm.list_types()\n\nprint(f\"Available swarm types:\")\nfor swarm_type in response.swarm_types:\n    print(f\"- {swarm_type}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_6","title":"Returns","text":"<p><code>SwarmTypesResponse</code> object with the following properties:</p> <ul> <li><code>success</code>: Whether the request was successful</li> <li><code>swarm_types</code>: List of available swarm types</li> </ul> <p></p>"},{"location":"swarms_cloud/python_client/#alist_types","title":"alist_types","text":"<p>Lists available swarm types asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        response = await client.swarm.alist_types()\n\n        print(f\"Available swarm types:\")\n        for swarm_type in response.swarm_types:\n            print(f\"- {swarm_type}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_7","title":"Returns","text":"<p>Same as the <code>list_types</code> method.</p> <p></p>"},{"location":"swarms_cloud/python_client/#acreate_1","title":"acreate","text":"<p>Creates a swarm completion asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        response = await client.swarm.acreate(\n            name=\"Research Swarm\",\n            swarm_type=\"SequentialWorkflow\",\n            task=\"Research quantum computing advances in 2024\",\n            agents=[\n                {\n                    \"agent_name\": \"Researcher\",\n                    \"description\": \"Conducts in-depth research\",\n                    \"model_name\": \"gpt-4o\"\n                },\n                {\n                    \"agent_name\": \"Critic\",\n                    \"description\": \"Evaluates arguments for flaws\",\n                    \"model_name\": \"gpt-4o-mini\"\n                }\n            ]\n        )\n\n        print(f\"Job ID: {response.job_id}\")\n        print(f\"Status: {response.status}\")\n        print(f\"Output: {response.output}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_7","title":"Parameters","text":"<p>Same as the <code>create</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_8","title":"Returns","text":"<p>Same as the <code>create</code> method.</p> <p></p>"},{"location":"swarms_cloud/python_client/#acreate_batch_1","title":"acreate_batch","text":"<p>Creates multiple swarm completions in batch asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        responses = await client.swarm.acreate_batch([\n            {\n                \"name\": \"Research Swarm\",\n                \"swarm_type\": \"auto\",\n                \"task\": \"Research quantum computing\",\n                \"agents\": [\n                    {\"agent_name\": \"Researcher\", \"model_name\": \"gpt-4o\"}\n                ]\n            },\n            {\n                \"name\": \"Writing Swarm\",\n                \"swarm_type\": \"SequentialWorkflow\",\n                \"task\": \"Write a blog post about AI safety\",\n                \"agents\": [\n                    {\"agent_name\": \"Writer\", \"model_name\": \"gpt-4o\"}\n                ]\n            }\n        ])\n\n        for i, response in enumerate(responses):\n            print(f\"Swarm {i+1} Job ID: {response.job_id}\")\n            print(f\"Status: {response.status}\")\n            print(f\"Output: {response.output}\")\n            print(\"---\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#parameters_8","title":"Parameters","text":"<p>Same as the <code>create_batch</code> method.</p>"},{"location":"swarms_cloud/python_client/#returns_9","title":"Returns","text":"<p>Same as the <code>create_batch</code> method.</p>"},{"location":"swarms_cloud/python_client/#models-resource","title":"Models Resource","text":"<p>The Models resource provides methods for retrieving information about available models.</p> <p></p>"},{"location":"swarms_cloud/python_client/#list","title":"list","text":"<p>Lists available models.</p> <pre><code>response = client.models.list()\n\nprint(f\"Available models:\")\nfor model in response.models:\n    print(f\"- {model}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_10","title":"Returns","text":"<p><code>ModelsResponse</code> object with the following properties:</p> <ul> <li><code>success</code>: Whether the request was successful</li> <li><code>models</code>: List of available model names</li> </ul> <p></p>"},{"location":"swarms_cloud/python_client/#alist","title":"alist","text":"<p>Lists available models asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient(api_key=\"your-api-key\") as client:\n        response = await client.models.alist()\n\n        print(f\"Available models:\")\n        for model in response.models:\n            print(f\"- {model}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_11","title":"Returns","text":"<p>Same as the <code>list</code> method.</p>"},{"location":"swarms_cloud/python_client/#logs-resource","title":"Logs Resource","text":"<p>The Logs resource provides methods for retrieving API request logs.</p> <p></p>"},{"location":"swarms_cloud/python_client/#list_1","title":"list","text":"<p>Lists API request logs.</p> <pre><code>response = client.logs.list()\n\nprint(f\"Found {response.count} logs:\")\nfor log in response.logs:\n    print(f\"- ID: {log.id}, Created at: {log.created_at}\")\n    print(f\"  Data: {log.data}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_12","title":"Returns","text":"<p><code>LogsResponse</code> object with the following properties:</p> <ul> <li><code>status</code>: Status of the request</li> <li><code>count</code>: Number of logs</li> <li><code>logs</code>: List of log entries</li> <li><code>timestamp</code>: Timestamp of the request</li> </ul> <p>Each log entry is a <code>LogEntry</code> object with the following properties:</p> <ul> <li><code>id</code>: Unique identifier for the log entry</li> <li><code>api_key</code>: API key used for the request</li> <li><code>data</code>: Request data</li> <li><code>created_at</code>: Timestamp when the log entry was created</li> </ul> <p></p>"},{"location":"swarms_cloud/python_client/#alist_1","title":"alist","text":"<p>Lists API request logs asynchronously.</p> <pre><code>import asyncio\nfrom swarms_client import SwarmsClient\n\nasync def main():\n    async with SwarmsClient() as client:\n        response = await client.logs.alist()\n\n        print(f\"Found {response.count} logs:\")\n        for log in response.logs:\n            print(f\"- ID: {log.id}, Created at: {log.created_at}\")\n            print(f\"  Data: {log.data}\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"swarms_cloud/python_client/#returns_13","title":"Returns","text":"<p>Same as the <code>list</code> method.</p>"},{"location":"swarms_cloud/python_client/#error-handling","title":"Error Handling","text":"<p>The Swarms API client provides detailed error handling with specific exception types for different error scenarios. All exceptions inherit from the base <code>SwarmsError</code> class.</p> <pre><code>from swarms_client import SwarmsClient, SwarmsError, AuthenticationError, RateLimitError, APIError\n\ntry:\n    client = SwarmsClient(api_key=\"invalid-api-key\")\n    response = client.agent.create(\n        agent_config={\"agent_name\": \"Researcher\", \"model_name\": \"gpt-4o\"},\n        task=\"Research quantum computing\"\n    )\nexcept AuthenticationError as e:\n    print(f\"Authentication error: {e}\")\nexcept RateLimitError as e:\n    print(f\"Rate limit exceeded: {e}\")\nexcept APIError as e:\n    print(f\"API error: {e}\")\nexcept SwarmsError as e:\n    print(f\"Swarms error: {e}\")\n</code></pre>"},{"location":"swarms_cloud/python_client/#exception-types","title":"Exception Types","text":"Exception Description <code>SwarmsError</code> Base exception for all Swarms API errors <code>AuthenticationError</code> Raised when there's an issue with authentication <code>RateLimitError</code> Raised when the rate limit is exceeded <code>APIError</code> Raised when the API returns an error <code>InvalidRequestError</code> Raised when the request is invalid <code>InsufficientCreditsError</code> Raised when the user doesn't have enough credits <code>TimeoutError</code> Raised when a request times out <code>NetworkError</code> Raised when there's a network issue"},{"location":"swarms_cloud/python_client/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms_cloud/python_client/#connection-pooling","title":"Connection Pooling","text":"<p>The Swarms API client uses connection pooling to efficiently manage HTTP connections, which can significantly improve performance when making multiple requests.</p> <pre><code>client = SwarmsClient(\n    api_key=\"your-api-key\",\n    pool_connections=100,  # Number of connection pools to cache\n    pool_maxsize=100,      # Maximum number of connections to save in the pool\n    keep_alive_timeout=5   # Keep-alive timeout for connections in seconds\n)\n</code></pre>"},{"location":"swarms_cloud/python_client/#circuit-breaker-pattern","title":"Circuit Breaker Pattern","text":"<p>The client implements the circuit breaker pattern to prevent cascading failures when the API is experiencing issues.</p> <pre><code>client = SwarmsClient(\n    api_key=\"your-api-key\",\n    circuit_breaker_threshold=5,  # Number of failures before the circuit opens\n    circuit_breaker_timeout=60    # Time in seconds before attempting to close the circuit\n)\n</code></pre>"},{"location":"swarms_cloud/python_client/#caching","title":"Caching","text":"<p>The client includes in-memory caching for frequently accessed resources to reduce API calls and improve performance.</p> <pre><code>client = SwarmsClient(\n    api_key=\"your-api-key\",\n    enable_cache=True  # Enable in-memory caching\n)\n\n# Clear the cache manually if needed\nclient.clear_cache()\n</code></pre>"},{"location":"swarms_cloud/python_client/#complete-example","title":"Complete Example","text":"<p>Here's a complete example that demonstrates how to use the Swarms API client to create a research swarm and process its output:</p> <pre><code>import os\nfrom swarms_client import SwarmsClient\nfrom dotenv import load_dotenv\n\n# Load API key from environment\nload_dotenv()\napi_key = os.getenv(\"SWARMS_API_KEY\")\n\n# Initialize client\nclient = SwarmsClient(api_key=api_key)\n\n# Create a research swarm\ntry:\n    # Define the agents\n    researcher = {\n        \"agent_name\": \"Researcher\",\n        \"description\": \"Conducts thorough research on specified topics\",\n        \"model_name\": \"gpt-4o\",\n        \"temperature\": 0.5,\n        \"system_prompt\": \"You are a diligent researcher focused on finding accurate and comprehensive information.\"\n    }\n\n    analyst = {\n        \"agent_name\": \"Analyst\",\n        \"description\": \"Analyzes research findings and identifies key insights\",\n        \"model_name\": \"gpt-4o\",\n        \"temperature\": 0.3,\n        \"system_prompt\": \"You are an insightful analyst who can identify patterns and extract meaningful insights from research data.\"\n    }\n\n    summarizer = {\n        \"agent_name\": \"Summarizer\",\n        \"description\": \"Creates concise summaries of complex information\",\n        \"model_name\": \"gpt-4o-mini\",\n        \"temperature\": 0.4,\n        \"system_prompt\": \"You specialize in distilling complex information into clear, concise summaries.\"\n    }\n\n    # Create the swarm\n    response = client.swarm.create(\n        name=\"Quantum Computing Research Swarm\",\n        description=\"A swarm for researching and analyzing quantum computing advancements\",\n        swarm_type=\"SequentialWorkflow\",\n        task=\"Research the latest advancements in quantum computing in 2024, analyze their potential impact on cryptography and data security, and provide a concise summary of the findings.\",\n        agents=[researcher, analyst, summarizer],\n        max_loops=2,\n        return_history=True\n    )\n\n    # Process the response\n    print(f\"Job ID: {response.job_id}\")\n    print(f\"Status: {response.status}\")\n    print(f\"Number of agents: {response.number_of_agents}\")\n    print(f\"Swarm type: {response.swarm_type}\")\n\n    # Print the output\n    if \"final_output\" in response.output:\n        print(\"\\nFinal Output:\")\n        print(response.output[\"final_output\"])\n    else:\n        print(\"\\nOutput:\")\n        print(response.output)\n\n    # Access agent-specific outputs if available\n    if \"agent_outputs\" in response.output:\n        print(\"\\nAgent Outputs:\")\n        for agent, output in response.output[\"agent_outputs\"].items():\n            print(f\"\\n{agent}:\")\n            print(output)\n\nexcept Exception as e:\n    print(f\"Error: {e}\")\n</code></pre> <p>This example creates a sequential workflow swarm with three agents to research quantum computing, analyze the findings, and create a summary of the results.</p>"},{"location":"swarms_cloud/quickstart/","title":"Swarms Quickstart Guide","text":"<p>This guide will help you get started with both single agent and multi-agent functionalities in Swarms API.</p>"},{"location":"swarms_cloud/quickstart/#prerequisites","title":"Prerequisites","text":"<p>Requirements</p> <ul> <li>Python 3.7+</li> <li>API key from Swarms Platform</li> <li><code>requests</code> library for Python</li> <li><code>axios</code> for TypeScript/JavaScript</li> <li><code>curl</code> for shell commands</li> </ul>"},{"location":"swarms_cloud/quickstart/#installation","title":"Installation","text":"pipnpm <pre><code>pip install requests python-dotenv\n</code></pre> <pre><code>npm install axios dotenv\n</code></pre>"},{"location":"swarms_cloud/quickstart/#authentication","title":"Authentication","text":"<p>API Key Security</p> <p>Never hardcode your API key in your code. Always use environment variables or secure configuration management.</p> <p>The API is accessible through two base URLs:</p> <ul> <li>Production: <code>https://api.swarms.world</code></li> <li>Alternative: <code>https://swarms-api-285321057562.us-east1.run.app</code></li> </ul>"},{"location":"swarms_cloud/quickstart/#single-agent-usage","title":"Single Agent Usage","text":""},{"location":"swarms_cloud/quickstart/#health-check","title":"Health Check","text":"PythoncURLTypeScript health_check.py<pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv()\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\nresponse = requests.get(f\"{BASE_URL}/health\", headers=headers)\nprint(response.json())\n</code></pre> health_check.sh<pre><code>curl -X GET \"https://api.swarms.world/health\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\"\n</code></pre> health_check.ts<pre><code>import axios from 'axios';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\nconst API_KEY = process.env.SWARMS_API_KEY;\nconst BASE_URL = 'https://api.swarms.world';\n\nasync function checkHealth() {\n  try {\n    const response = await axios.get(`${BASE_URL}/health`, {\n      headers: {\n        'x-api-key': API_KEY,\n        'Content-Type': 'application/json'\n      }\n    });\n    console.log(response.data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\n\ncheckHealth();\n</code></pre>"},{"location":"swarms_cloud/quickstart/#basic-agent","title":"Basic Agent","text":"PythoncURLTypeScript single_agent.py<pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")  # (1)\nBASE_URL = \"https://api.swarms.world\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\ndef run_single_agent():\n    \"\"\"Run a single agent with the AgentCompletion format\"\"\"\n    payload = {\n        \"agent_config\": {\n            \"agent_name\": \"Research Analyst\",  # (2)\n            \"description\": \"An expert in analyzing and synthesizing research data\",\n            \"system_prompt\": (  # (3)\n                \"You are a Research Analyst with expertise in data analysis and synthesis. \"\n                \"Your role is to analyze provided information, identify key insights, \"\n                \"and present findings in a clear, structured format.\"\n            ),\n            \"model_name\": \"claude-3-5-sonnet-20240620\",  # (4)\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 8192,\n            \"temperature\": 1,\n            \"auto_generate_prompt\": False,\n            \"tools_list_dictionary\": None,\n        },\n        \"task\": \"What are the key trends in renewable energy adoption?\",  # (5)\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/agent/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n\n# Run the agent\nresult = run_single_agent()\nprint(result)\n</code></pre> <ol> <li>Load API key from environment variables</li> <li>Give your agent a descriptive name</li> <li>Define the agent's capabilities and role</li> <li>Choose from available models</li> <li>Specify the task for the agent</li> </ol> single_agent.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/agent/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"agent_config\": {\n      \"agent_name\": \"Research Analyst\",\n      \"description\": \"An expert in analyzing and synthesizing research data\",\n      \"system_prompt\": \"You are a Research Analyst with expertise in data analysis and synthesis. Your role is to analyze provided information, identify key insights, and present findings in a clear, structured format.\",\n      \"model_name\": \"claude-3-5-sonnet-20240620\",\n      \"role\": \"worker\",\n      \"max_loops\": 1,\n      \"max_tokens\": 8192,\n      \"temperature\": 1,\n      \"auto_generate_prompt\": false,\n      \"tools_list_dictionary\": null\n    },\n    \"task\": \"What are the key trends in renewable energy adoption?\"\n  }'\n</code></pre> single_agent.ts<pre><code>import axios from 'axios';\nimport * as dotenv from 'dotenv';\n\ndotenv.config();\n\nconst API_KEY = process.env.SWARMS_API_KEY;\nconst BASE_URL = 'https://api.swarms.world';\n\ninterface AgentConfig {\n  agent_name: string;\n  description: string;\n  system_prompt: string;\n  model_name: string;\n  role: string;\n  max_loops: number;\n  max_tokens: number;\n  temperature: number;\n  auto_generate_prompt: boolean;\n  tools_list_dictionary: null | object[];\n}\n\ninterface AgentPayload {\n  agent_config: AgentConfig;\n  task: string;\n}\n\nasync function runSingleAgent() {\n  const payload: AgentPayload = {\n    agent_config: {\n      agent_name: \"Research Analyst\",\n      description: \"An expert in analyzing and synthesizing research data\",\n      system_prompt: \"You are a Research Analyst with expertise in data analysis and synthesis.\",\n      model_name: \"claude-3-5-sonnet-20240620\",\n      role: \"worker\",\n      max_loops: 1,\n      max_tokens: 8192,\n      temperature: 1,\n      auto_generate_prompt: false,\n      tools_list_dictionary: null\n    },\n    task: \"What are the key trends in renewable energy adoption?\"\n  };\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/agent/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n\n// Run the agent\nrunSingleAgent()\n  .then(result =&gt; console.log(result))\n  .catch(error =&gt; console.error(error));\n</code></pre>"},{"location":"swarms_cloud/quickstart/#agent-with-history","title":"Agent with History","text":"PythoncURLTypeScript agent_with_history.py<pre><code>def run_agent_with_history():\n    payload = {\n        \"agent_config\": {\n            \"agent_name\": \"Conversation Agent\",\n            \"description\": \"An agent that maintains conversation context\",\n            \"system_prompt\": \"You are a helpful assistant that maintains context.\",\n            \"model_name\": \"claude-3-5-sonnet-20240620\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 8192,\n            \"temperature\": 0.7,\n            \"auto_generate_prompt\": False,\n        },\n        \"task\": \"What's the weather like?\",\n        \"history\": [  # (1)\n            {\n                \"role\": \"user\",\n                \"content\": \"I'm planning a trip to New York.\"\n            },\n            {\n                \"role\": \"assistant\",\n                \"content\": \"That's great! When are you planning to visit?\"\n            },\n            {\n                \"role\": \"user\",\n                \"content\": \"Next week.\"\n            }\n        ]\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/agent/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre> <ol> <li>Include conversation history for context</li> </ol> agent_with_history.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/agent/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"agent_config\": {\n      \"agent_name\": \"Conversation Agent\",\n      \"description\": \"An agent that maintains conversation context\",\n      \"system_prompt\": \"You are a helpful assistant that maintains context.\",\n      \"model_name\": \"claude-3-5-sonnet-20240620\",\n      \"role\": \"worker\",\n      \"max_loops\": 1,\n      \"max_tokens\": 8192,\n      \"temperature\": 0.7,\n      \"auto_generate_prompt\": false\n    },\n    \"task\": \"What'\\''s the weather like?\",\n    \"history\": [\n      {\n        \"role\": \"user\",\n        \"content\": \"I'\\''m planning a trip to New York.\"\n      },\n      {\n        \"role\": \"assistant\",\n        \"content\": \"That'\\''s great! When are you planning to visit?\"\n      },\n      {\n        \"role\": \"user\",\n        \"content\": \"Next week.\"\n      }\n    ]\n  }'\n</code></pre> agent_with_history.ts<pre><code>interface Message {\n  role: 'user' | 'assistant';\n  content: string;\n}\n\ninterface AgentWithHistoryPayload extends AgentPayload {\n  history: Message[];\n}\n\nasync function runAgentWithHistory() {\n  const payload: AgentWithHistoryPayload = {\n    agent_config: {\n      agent_name: \"Conversation Agent\",\n      description: \"An agent that maintains conversation context\",\n      system_prompt: \"You are a helpful assistant that maintains context.\",\n      model_name: \"claude-3-5-sonnet-20240620\",\n      role: \"worker\",\n      max_loops: 1,\n      max_tokens: 8192,\n      temperature: 0.7,\n      auto_generate_prompt: false,\n      tools_list_dictionary: null\n    },\n    task: \"What's the weather like?\",\n    history: [\n      {\n        role: \"user\",\n        content: \"I'm planning a trip to New York.\"\n      },\n      {\n        role: \"assistant\",\n        content: \"That's great! When are you planning to visit?\"\n      },\n      {\n        role: \"user\",\n        content: \"Next week.\"\n      }\n    ]\n  };\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/agent/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#multi-agent-swarms","title":"Multi-Agent Swarms","text":"<p>Swarm Types</p> <p>Swarms API supports two types of agent workflows:</p> <ol> <li><code>SequentialWorkflow</code>: Agents work in sequence, each building on previous output</li> <li><code>ConcurrentWorkflow</code>: Agents work in parallel on the same task</li> </ol>"},{"location":"swarms_cloud/quickstart/#sequential-workflow","title":"Sequential Workflow","text":"PythoncURLTypeScript sequential_swarm.py<pre><code>def run_sequential_swarm():\n    payload = {\n        \"name\": \"Financial Analysis Swarm\",\n        \"description\": \"Market analysis swarm\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Market Analyst\",  # (1)\n                \"description\": \"Analyzes market trends\",\n                \"system_prompt\": \"You are a financial analyst expert.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Economic Forecaster\",  # (2)\n                \"description\": \"Predicts economic trends\",\n                \"system_prompt\": \"You are an expert in economic forecasting.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"SequentialWorkflow\",  # (3)\n        \"task\": \"Analyze the current market conditions and provide economic forecasts.\"\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre> <ol> <li>First agent analyzes market trends</li> <li>Second agent builds on first agent's analysis</li> <li>Sequential workflow ensures ordered execution</li> </ol> sequential_swarm.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/swarm/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Financial Analysis Swarm\",\n    \"description\": \"Market analysis swarm\",\n    \"agents\": [\n      {\n        \"agent_name\": \"Market Analyst\",\n        \"description\": \"Analyzes market trends\",\n        \"system_prompt\": \"You are a financial analyst expert.\",\n        \"model_name\": \"gpt-4o\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      },\n      {\n        \"agent_name\": \"Economic Forecaster\",\n        \"description\": \"Predicts economic trends\",\n        \"system_prompt\": \"You are an expert in economic forecasting.\",\n        \"model_name\": \"gpt-4o\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      }\n    ],\n    \"max_loops\": 1,\n    \"swarm_type\": \"SequentialWorkflow\",\n    \"task\": \"Analyze the current market conditions and provide economic forecasts.\"\n  }'\n</code></pre> sequential_swarm.ts<pre><code>interface SwarmAgent {\n  agent_name: string;\n  description: string;\n  system_prompt: string;\n  model_name: string;\n  role: string;\n  max_loops: number;\n  max_tokens: number;\n  temperature: number;\n  auto_generate_prompt: boolean;\n}\n\ninterface SwarmPayload {\n  name: string;\n  description: string;\n  agents: SwarmAgent[];\n  max_loops: number;\n  swarm_type: 'SequentialWorkflow' | 'ConcurrentWorkflow';\n  task: string;\n}\n\nasync function runSequentialSwarm() {\n  const payload: SwarmPayload = {\n    name: \"Financial Analysis Swarm\",\n    description: \"Market analysis swarm\",\n    agents: [\n      {\n        agent_name: \"Market Analyst\",\n        description: \"Analyzes market trends\",\n        system_prompt: \"You are a financial analyst expert.\",\n        model_name: \"gpt-4o\",\n        role: \"worker\",\n        max_loops: 1,\n        max_tokens: 8192,\n        temperature: 0.5,\n        auto_generate_prompt: false\n      },\n      {\n        agent_name: \"Economic Forecaster\",\n        description: \"Predicts economic trends\",\n        system_prompt: \"You are an expert in economic forecasting.\",\n        model_name: \"gpt-4o\",\n        role: \"worker\",\n        max_loops: 1,\n        max_tokens: 8192,\n        temperature: 0.5,\n        auto_generate_prompt: false\n      }\n    ],\n    max_loops: 1,\n    swarm_type: \"SequentialWorkflow\",\n    task: \"Analyze the current market conditions and provide economic forecasts.\"\n  };\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/swarm/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#concurrent-workflow","title":"Concurrent Workflow","text":"PythoncURLTypeScript concurrent_swarm.py<pre><code>def run_concurrent_swarm():\n    payload = {\n        \"name\": \"Medical Analysis Swarm\",\n        \"description\": \"Analyzes medical data concurrently\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Lab Data Analyzer\",  # (1)\n                \"description\": \"Analyzes lab report data\",\n                \"system_prompt\": \"You are a medical data analyst specializing in lab results.\",\n                \"model_name\": \"claude-3-5-sonnet-20240620\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False\n            },\n            {\n                \"agent_name\": \"Clinical Specialist\",  # (2)\n                \"description\": \"Provides clinical interpretations\",\n                \"system_prompt\": \"You are an expert in clinical diagnosis.\",\n                \"model_name\": \"claude-3-5-sonnet-20240620\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"ConcurrentWorkflow\",  # (3)\n        \"task\": \"Analyze these lab results and provide clinical interpretations.\"\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre> <ol> <li>First agent processes lab data</li> <li>Second agent works simultaneously</li> <li>Concurrent workflow for parallel processing</li> </ol> concurrent_swarm.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/swarm/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Medical Analysis Swarm\",\n    \"description\": \"Analyzes medical data concurrently\",\n    \"agents\": [\n      {\n        \"agent_name\": \"Lab Data Analyzer\",\n        \"description\": \"Analyzes lab report data\",\n        \"system_prompt\": \"You are a medical data analyst specializing in lab results.\",\n        \"model_name\": \"claude-3-5-sonnet-20240620\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      },\n      {\n        \"agent_name\": \"Clinical Specialist\",\n        \"description\": \"Provides clinical interpretations\",\n        \"system_prompt\": \"You are an expert in clinical diagnosis.\",\n        \"model_name\": \"claude-3-5-sonnet-20240620\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      }\n    ],\n    \"max_loops\": 1,\n    \"swarm_type\": \"ConcurrentWorkflow\",\n    \"task\": \"Analyze these lab results and provide clinical interpretations.\"\n  }'\n</code></pre> concurrent_swarm.ts<pre><code>async function runConcurrentSwarm() {\n  const payload: SwarmPayload = {\n    name: \"Medical Analysis Swarm\",\n    description: \"Analyzes medical data concurrently\",\n    agents: [\n      {\n        agent_name: \"Lab Data Analyzer\",\n        description: \"Analyzes lab report data\",\n        system_prompt: \"You are a medical data analyst specializing in lab results.\",\n        model_name: \"claude-3-5-sonnet-20240620\",\n        role: \"worker\",\n        max_loops: 1,\n        max_tokens: 8192,\n        temperature: 0.5,\n        auto_generate_prompt: false\n      },\n      {\n        agent_name: \"Clinical Specialist\",\n        description: \"Provides clinical interpretations\",\n        system_prompt: \"You are an expert in clinical diagnosis.\",\n        model_name: \"claude-3-5-sonnet-20240620\",\n        role: \"worker\",\n        max_loops: 1,\n        max_tokens: 8192,\n        temperature: 0.5,\n        auto_generate_prompt: false\n      }\n    ],\n    max_loops: 1,\n    swarm_type: \"ConcurrentWorkflow\",\n    task: \"Analyze these lab results and provide clinical interpretations.\"\n  };\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/swarm/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#batch-processing","title":"Batch Processing","text":"<p>Batch Processing</p> <p>Process multiple swarms in a single request for improved efficiency.</p> PythoncURLTypeScript batch_swarms.py<pre><code>def run_batch_swarms():\n    payload = [\n        {\n            \"name\": \"Batch Swarm 1\",\n            \"description\": \"First swarm in batch\",\n            \"agents\": [\n                {\n                    \"agent_name\": \"Research Agent\",\n                    \"description\": \"Conducts research\",\n                    \"system_prompt\": \"You are a research assistant.\",\n                    \"model_name\": \"gpt-4\",\n                    \"role\": \"worker\",\n                    \"max_loops\": 1\n                },\n                {\n                    \"agent_name\": \"Analysis Agent\",\n                    \"description\": \"Analyzes data\",\n                    \"system_prompt\": \"You are a data analyst.\",\n                    \"model_name\": \"gpt-4\",\n                    \"role\": \"worker\",\n                    \"max_loops\": 1\n                }\n            ],\n            \"max_loops\": 1,\n            \"swarm_type\": \"SequentialWorkflow\",\n            \"task\": \"Research AI advancements.\"\n        }\n    ]\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/batch/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre> batch_swarms.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/swarm/batch/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '[\n    {\n      \"name\": \"Batch Swarm 1\",\n      \"description\": \"First swarm in batch\",\n      \"agents\": [\n        {\n          \"agent_name\": \"Research Agent\",\n          \"description\": \"Conducts research\",\n          \"system_prompt\": \"You are a research assistant.\",\n          \"model_name\": \"gpt-4\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        },\n        {\n          \"agent_name\": \"Analysis Agent\",\n          \"description\": \"Analyzes data\",\n          \"system_prompt\": \"You are a data analyst.\",\n          \"model_name\": \"gpt-4\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        }\n      ],\n      \"max_loops\": 1,\n      \"swarm_type\": \"SequentialWorkflow\",\n      \"task\": \"Research AI advancements.\"\n    }\n  ]'\n</code></pre> batch_swarms.ts<pre><code>async function runBatchSwarms() {\n  const payload: SwarmPayload[] = [\n    {\n      name: \"Batch Swarm 1\",\n      description: \"First swarm in batch\",\n      agents: [\n        {\n          agent_name: \"Research Agent\",\n          description: \"Conducts research\",\n          system_prompt: \"You are a research assistant.\",\n          model_name: \"gpt-4\",\n          role: \"worker\",\n          max_loops: 1,\n          max_tokens: 8192,\n          temperature: 0.7,\n          auto_generate_prompt: false\n        },\n        {\n          agent_name: \"Analysis Agent\",\n          description: \"Analyzes data\",\n          system_prompt: \"You are a data analyst.\",\n          model_name: \"gpt-4\",\n          role: \"worker\",\n          max_loops: 1,\n          max_tokens: 8192,\n          temperature: 0.7,\n          auto_generate_prompt: false\n        }\n      ],\n      max_loops: 1,\n      swarm_type: \"SequentialWorkflow\",\n      task: \"Research AI advancements.\"\n    }\n  ];\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/swarm/batch/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#advanced-features","title":"Advanced Features","text":""},{"location":"swarms_cloud/quickstart/#tools-integration","title":"Tools Integration","text":"<p>Tools</p> <p>Enhance agent capabilities by providing them with specialized tools.</p> PythoncURLTypeScript tools_example.py<pre><code>def run_agent_with_tools():\n    tools_dictionary = [\n        {\n            \"type\": \"function\",\n            \"function\": {\n                \"name\": \"search_topic\",\n                \"description\": \"Conduct an in-depth search on a topic\",\n                \"parameters\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"depth\": {\n                            \"type\": \"integer\",\n                            \"description\": \"Search depth (1-3)\"\n                        },\n                        \"detailed_queries\": {\n                            \"type\": \"array\",\n                            \"description\": \"Specific search queries\",\n                            \"items\": {\n                                \"type\": \"string\"\n                            }\n                        }\n                    },\n                    \"required\": [\"depth\", \"detailed_queries\"]\n                }\n            }\n        }\n    ]\n\n    payload = {\n        \"agent_config\": {\n            \"agent_name\": \"Research Assistant\",\n            \"description\": \"Expert in research with search capabilities\",\n            \"system_prompt\": \"You are a research assistant with search capabilities.\",\n            \"model_name\": \"gpt-4\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 8192,\n            \"temperature\": 0.7,\n            \"auto_generate_prompt\": False,\n            \"tools_dictionary\": tools_dictionary\n        },\n        \"task\": \"Research the latest developments in quantum computing.\"\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/agent/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre> tools_example.sh<pre><code>curl -X POST \"https://api.swarms.world/v1/agent/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"agent_config\": {\n      \"agent_name\": \"Research Assistant\",\n      \"description\": \"Expert in research with search capabilities\",\n      \"system_prompt\": \"You are a research assistant with search capabilities.\",\n      \"model_name\": \"gpt-4\",\n      \"role\": \"worker\",\n      \"max_loops\": 1,\n      \"max_tokens\": 8192,\n      \"temperature\": 0.7,\n      \"auto_generate_prompt\": false,\n      \"tools_dictionary\": [\n        {\n          \"type\": \"function\",\n          \"function\": {\n            \"name\": \"search_topic\",\n            \"description\": \"Conduct an in-depth search on a topic\",\n            \"parameters\": {\n              \"type\": \"object\",\n              \"properties\": {\n                \"depth\": {\n                  \"type\": \"integer\",\n                  \"description\": \"Search depth (1-3)\"\n                },\n                \"detailed_queries\": {\n                  \"type\": \"array\",\n                  \"description\": \"Specific search queries\",\n                  \"items\": {\n                    \"type\": \"string\"\n                  }\n                }\n              },\n              \"required\": [\"depth\", \"detailed_queries\"]\n            }\n          }\n        }\n      ]\n    },\n    \"task\": \"Research the latest developments in quantum computing.\"\n  }'\n</code></pre> tools_example.ts<pre><code>interface ToolFunction {\n  name: string;\n  description: string;\n  parameters: {\n    type: string;\n    properties: {\n      [key: string]: {\n        type: string;\n        description: string;\n        items?: {\n          type: string;\n        };\n      };\n    };\n    required: string[];\n  };\n}\n\ninterface Tool {\n  type: string;\n  function: ToolFunction;\n}\n\ninterface AgentWithToolsConfig extends AgentConfig {\n  tools_dictionary: Tool[];\n}\n\ninterface AgentWithToolsPayload {\n  agent_config: AgentWithToolsConfig;\n  task: string;\n}\n\nasync function runAgentWithTools() {\n  const toolsDictionary: Tool[] = [\n    {\n      type: \"function\",\n      function: {\n        name: \"search_topic\",\n        description: \"Conduct an in-depth search on a topic\",\n        parameters: {\n          type: \"object\",\n          properties: {\n            depth: {\n              type: \"integer\",\n              description: \"Search depth (1-3)\"\n            },\n            detailed_queries: {\n              type: \"array\",\n              description: \"Specific search queries\",\n              items: {\n                type: \"string\"\n              }\n            }\n          },\n          required: [\"depth\", \"detailed_queries\"]\n        }\n      }\n    }\n  ];\n\n  const payload: AgentWithToolsPayload = {\n    agent_config: {\n      agent_name: \"Research Assistant\",\n      description: \"Expert in research with search capabilities\",\n      system_prompt: \"You are a research assistant with search capabilities.\",\n      model_name: \"gpt-4\",\n      role: \"worker\",\n      max_loops: 1,\n      max_tokens: 8192,\n      temperature: 0.7,\n      auto_generate_prompt: false,\n      tools_dictionary: toolsDictionary\n    },\n    task: \"Research the latest developments in quantum computing.\"\n  };\n\n  try {\n    const response = await axios.post(\n      `${BASE_URL}/v1/agent/completions`,\n      payload,\n      {\n        headers: {\n          'x-api-key': API_KEY,\n          'Content-Type': 'application/json'\n        }\n      }\n    );\n    return response.data;\n  } catch (error) {\n    console.error('Error:', error);\n    throw error;\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#available-models","title":"Available Models","text":"<p>Supported Models</p> <p>Choose the right model for your use case:</p> OpenAIAnthropicGroq <ul> <li><code>gpt-4</code></li> <li><code>gpt-4o</code></li> <li><code>gpt-4o-mini</code></li> </ul> <ul> <li><code>claude-3-5-sonnet-20240620</code></li> <li><code>claude-3-7-sonnet-latest</code></li> </ul> <ul> <li><code>groq/llama3-70b-8192</code></li> <li><code>groq/deepseek-r1-distill-llama-70b</code></li> </ul>"},{"location":"swarms_cloud/quickstart/#best-practices","title":"Best Practices","text":"<p>Security</p> <p>Never commit API keys or sensitive credentials to version control.</p> <p>Rate Limits</p> <p>Implement proper rate limiting and error handling in production.</p> <p>Testing</p> <p>Start with simple tasks and gradually increase complexity.</p> PythonTypeScript best_practices.py<pre><code># Error Handling\ntry:\n    response = requests.post(url, headers=headers, json=payload)\n    response.raise_for_status()\nexcept requests.exceptions.RequestException as e:\n    print(f\"Error: {e}\")\n\n# Rate Limiting\nimport time\nfrom tenacity import retry, wait_exponential\n\n@retry(wait=wait_exponential(multiplier=1, min=4, max=10))\ndef make_api_call():\n    response = requests.post(url, headers=headers, json=payload)\n    response.raise_for_status()\n    return response\n\n# Input Validation\ndef validate_payload(payload):\n    required_fields = [\"agent_config\", \"task\"]\n    if not all(field in payload for field in required_fields):\n        raise ValueError(\"Missing required fields\")\n</code></pre> best_practices.ts<pre><code>// Error Handling\ntry {\n  const response = await axios.post(url, payload, { headers });\n} catch (error) {\n  if (axios.isAxiosError(error)) {\n    console.error('API Error:', error.response?.data);\n  }\n  throw error;\n}\n\n// Rate Limiting\nimport { rateLimit } from 'axios-rate-limit';\n\nconst http = rateLimit(axios.create(), { \n  maxRequests: 2,\n  perMilliseconds: 1000\n});\n\n// Input Validation\nfunction validatePayload(payload: unknown): asserts payload is AgentPayload {\n  if (!payload || typeof payload !== 'object') {\n    throw new Error('Invalid payload');\n  }\n\n  const { agent_config, task } = payload as Partial&lt;AgentPayload&gt;;\n\n  if (!agent_config || !task) {\n    throw new Error('Missing required fields');\n  }\n}\n</code></pre>"},{"location":"swarms_cloud/quickstart/#connect-with-us","title":"Connect With Us","text":"<p>Join our community of agent engineers and researchers for technical support, cutting-edge updates, and exclusive access to world-class agent engineering insights!</p> Platform Description Link \ud83d\udcda Documentation Official documentation and guides docs.swarms.world \ud83d\udcdd Blog Latest updates and technical articles Medium \ud83d\udcac Discord Live chat and community support Join Discord \ud83d\udc26 Twitter Latest news and announcements @kyegomez \ud83d\udc65 LinkedIn Professional network and updates The Swarm Corporation \ud83d\udcfa YouTube Tutorials and demos Swarms Channel \ud83c\udfab Events Join our community events Sign up here \ud83d\ude80 Onboarding Session Get onboarded with Kye Gomez, creator and lead maintainer of Swarms Book Session"},{"location":"swarms_cloud/rate_limits/","title":"Swarms API Rate Limits","text":"<p>The Swarms API implements a comprehensive rate limiting system that tracks API requests across multiple time windows and enforces various limits to ensure fair usage and system stability.</p>"},{"location":"swarms_cloud/rate_limits/#rate-limits-summary","title":"Rate Limits Summary","text":"Rate Limit Type Free Tier Premium Tier Time Window Description Requests per Minute 100 2,000 1 minute Maximum API calls per minute Requests per Hour 50 10,000 1 hour Maximum API calls per hour Requests per Day 1,200 100,000 24 hours Maximum API calls per day Tokens per Agent 200,000 2,000,000 Per request Maximum tokens per agent Prompt Length 200,000 200,000 Per request Maximum input tokens per request Batch Size 10 10 Per request Maximum agents in batch requests IP-based Fallback 100 100 60 seconds For requests without API keys"},{"location":"swarms_cloud/rate_limits/#detailed-rate-limit-explanations","title":"Detailed Rate Limit Explanations","text":""},{"location":"swarms_cloud/rate_limits/#1-request-rate-limits","title":"1. Request Rate Limits","text":"<p>These limits control how many API calls you can make within specific time windows.</p>"},{"location":"swarms_cloud/rate_limits/#per-minute-limit","title":"Per-Minute Limit","text":"Tier Requests per Minute Reset Interval Applies To Free 100 Every minute (sliding) All API endpoints Premium 2,000 Every minute (sliding) All API endpoints"},{"location":"swarms_cloud/rate_limits/#per-hour-limit","title":"Per-Hour Limit","text":"<ul> <li>Free Tier: 50 requests per hour</li> <li>Premium Tier: 10,000 requests per hour</li> <li>Reset: Every hour (sliding window)</li> <li>Applies to: All API endpoints</li> </ul>"},{"location":"swarms_cloud/rate_limits/#per-day-limit","title":"Per-Day Limit","text":"<ul> <li> <p>Free Tier: 1,200 requests per day (50 \u00d7 24)</p> </li> <li> <p>Premium Tier: 100,000 requests per day</p> </li> <li> <p>Reset: Every 24 hours (sliding window)</p> </li> <li> <p>Applies to: All API endpoints</p> </li> </ul>"},{"location":"swarms_cloud/rate_limits/#2-token-limits","title":"2. Token Limits","text":"<p>These limits control the amount of text processing allowed per request.</p>"},{"location":"swarms_cloud/rate_limits/#tokens-per-agent","title":"Tokens per Agent","text":"<ul> <li> <p>Free Tier: 200,000 tokens per agent</p> </li> <li> <p>Premium Tier: 2,000,000 tokens per agent</p> </li> <li> <p>Applies to: Individual agent configurations</p> </li> <li> <p>Includes: System prompts, task descriptions, and agent names</p> </li> </ul>"},{"location":"swarms_cloud/rate_limits/#prompt-length-limit","title":"Prompt Length Limit","text":"<ul> <li> <p>All Tiers: 200,000 tokens maximum</p> </li> <li> <p>Applies to: Combined input text (task + history + system prompts)</p> </li> <li> <p>Error: Returns 400 error if exceeded</p> </li> <li> <p>Message: \"Prompt is too long. Please provide a prompt that is less than 10000 tokens.\"</p> </li> </ul>"},{"location":"swarms_cloud/rate_limits/#3-batch-processing-limits","title":"3. Batch Processing Limits","text":"<p>These limits control concurrent processing capabilities.</p>"},{"location":"swarms_cloud/rate_limits/#batch-size-limit","title":"Batch Size Limit","text":"<ul> <li> <p>All Tiers: 10 agents maximum per batch</p> </li> <li> <p>Applies to: <code>/v1/agent/batch/completions</code> endpoint</p> </li> <li> <p>Error: Returns 400 error if exceeded</p> </li> <li> <p>Message: \"ERROR: BATCH SIZE EXCEEDED - You can only run up to 10 batch agents at a time.\"</p> </li> </ul>"},{"location":"swarms_cloud/rate_limits/#how-rate-limiting-works","title":"How Rate Limiting Works","text":""},{"location":"swarms_cloud/rate_limits/#database-based-tracking","title":"Database-Based Tracking","text":"<p>The system uses a database-based approach for API key requests:</p> <ol> <li>Request Logging: Every API request is logged to the <code>swarms_api_logs</code> table</li> <li>Time Window Queries: The system queries for requests in the last minute, hour, and day</li> <li>Limit Comparison: Current counts are compared against configured limits</li> <li>Request Blocking: Requests are blocked if any limit is exceeded</li> </ol>"},{"location":"swarms_cloud/rate_limits/#sliding-windows","title":"Sliding Windows","text":"<p>Rate limits use sliding windows rather than fixed windows:</p> <ul> <li> <p>Minute: Counts requests in the last 60 seconds</p> </li> <li> <p>Hour: Counts requests in the last 60 minutes  </p> </li> <li> <p>Day: Counts requests in the last 24 hours</p> </li> </ul> <p>This provides more accurate rate limiting compared to fixed time windows.</p>"},{"location":"swarms_cloud/rate_limits/#checking-your-rate-limits","title":"Checking Your Rate Limits","text":""},{"location":"swarms_cloud/rate_limits/#api-endpoint","title":"API Endpoint","text":"<p>Use the <code>/v1/rate/limits</code> endpoint to check your current usage:</p> <pre><code>curl -H \"x-api-key: your-api-key\" \\\n     https://api.swarms.world/v1/rate/limits\n</code></pre>"},{"location":"swarms_cloud/rate_limits/#response-format","title":"Response Format","text":"<pre><code>{\n  \"success\": true,\n  \"rate_limits\": {\n    \"minute\": {\n      \"count\": 5,\n      \"limit\": 100,\n      \"exceeded\": false,\n      \"remaining\": 95,\n      \"reset_time\": \"2024-01-15T10:30:00Z\"\n    },\n    \"hour\": {\n      \"count\": 25,\n      \"limit\": 50,\n      \"exceeded\": false,\n      \"remaining\": 25,\n      \"reset_time\": \"2024-01-15T11:00:00Z\"\n    },\n    \"day\": {\n      \"count\": 150,\n      \"limit\": 1200,\n      \"exceeded\": false,\n      \"remaining\": 1050,\n      \"reset_time\": \"2024-01-16T10:00:00Z\"\n    }\n  },\n  \"limits\": {\n    \"maximum_requests_per_minute\": 100,\n    \"maximum_requests_per_hour\": 50,\n    \"maximum_requests_per_day\": 1200,\n    \"tokens_per_agent\": 200000\n  },\n  \"timestamp\": \"2024-01-15T10:29:30Z\"\n}\n</code></pre>"},{"location":"swarms_cloud/rate_limits/#handling-rate-limit-errors","title":"Handling Rate Limit Errors","text":""},{"location":"swarms_cloud/rate_limits/#error-response","title":"Error Response","text":"<p>When rate limits are exceeded, you'll receive a 429 status code:</p> <pre><code>{\n  \"detail\": \"Rate limit exceeded for minute window(s). Upgrade to Premium for increased limits (2,000/min, 10,000/hour, 100,000/day) at https://swarms.world/platform/account for just $99/month.\"\n}\n</code></pre>"},{"location":"swarms_cloud/rate_limits/#best-practices","title":"Best Practices","text":"<ol> <li>Monitor Usage: Regularly check your rate limits using the <code>/v1/rate/limits</code> endpoint</li> <li>Implement Retry Logic: Use exponential backoff when hitting rate limits</li> <li>Optimize Requests: Combine multiple operations into single requests when possible</li> <li>Upgrade When Needed: Consider upgrading to Premium for higher limits</li> </ol>"},{"location":"swarms_cloud/rate_limits/#premium-tier-benefits","title":"Premium Tier Benefits","text":"<p>Upgrade to Premium for significantly higher limits:</p> <ul> <li> <p>20x more requests per minute (2,000 vs 100)</p> </li> <li> <p>200x more requests per hour (10,000 vs 50)</p> </li> <li> <p>83x more requests per day (100,000 vs 1,200)</p> </li> <li> <p>10x more tokens per agent (2M vs 200K)</p> </li> </ul> <p>Visit Swarms Platform Account to upgrade for just $99/month.</p>"},{"location":"swarms_cloud/rate_limits/#performance-considerations","title":"Performance Considerations","text":"<ul> <li>Database queries are optimized to only count request IDs</li> <li>Rate limit checks are cached per request</li> <li>Fallback mechanisms ensure system reliability</li> <li>Minimal impact on request latency</li> <li>Persistent tracking across server restarts </li> </ul>"},{"location":"swarms_cloud/rust_client/","title":"Swarms Client - Production Grade Rust SDK","text":"<p>A high-performance, production-ready Rust client for the Swarms API with comprehensive features for building multi-agent AI systems.</p>"},{"location":"swarms_cloud/rust_client/#features","title":"Features","text":"<ul> <li>\ud83d\ude80 High Performance: Built with <code>reqwest</code> and <code>tokio</code> for maximum throughput</li> <li>\ud83d\udd04 Connection Pooling: Automatic HTTP connection reuse and pooling</li> <li>\u26a1 Circuit Breaker: Automatic failure detection and recovery</li> <li>\ud83d\udcbe Intelligent Caching: TTL-based in-memory caching with concurrent access</li> <li>\ud83d\udcca Rate Limiting: Configurable concurrent request limits</li> <li>\ud83d\udd04 Retry Logic: Exponential backoff with jitter</li> <li>\ud83d\udcdd Comprehensive Logging: Structured logging with <code>tracing</code></li> <li>\u2705 Type Safety: Full compile-time type checking with <code>serde</code></li> </ul>"},{"location":"swarms_cloud/rust_client/#installation","title":"Installation","text":"<p>Install <code>swarms-rs</code> globally using cargo:</p> <pre><code>cargo install swarms-rs\n</code></pre>"},{"location":"swarms_cloud/rust_client/#quick-start","title":"Quick Start","text":"<pre><code>use swarms_client::SwarmsClient;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize the client with API key from environment\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?  // Loads API key from SWARMS_API_KEY environment variable\n        .timeout(std::time::Duration::from_secs(60))\n        .max_retries(3)\n        .build()?;\n\n    // Make a simple swarm completion request\n    let response = client.swarm()\n        .completion()\n        .name(\"My First Swarm\")\n        .swarm_type(SwarmType::Auto)\n        .task(\"Analyze the pros and cons of quantum computing\")\n        .agent(|agent| {\n            agent\n                .name(\"Researcher\")\n                .description(\"Conducts in-depth research\")\n                .model(\"gpt-4o\")\n        })\n        .send()\n        .await?;\n\n    println!(\"Swarm output: {}\", response.output);\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#api-reference","title":"API Reference","text":""},{"location":"swarms_cloud/rust_client/#swarmsclient","title":"SwarmsClient","text":"<p>The main client for interacting with the Swarms API.</p>"},{"location":"swarms_cloud/rust_client/#constructor-methods","title":"Constructor Methods","text":""},{"location":"swarms_cloud/rust_client/#swarmsclientbuilder","title":"<code>SwarmsClient::builder()</code>","text":"<p>Creates a new client builder for configuring the client.</p> <p>Returns: <code>Result&lt;ClientBuilder, SwarmsError&gt;</code></p> <p>Example: <pre><code>let client = SwarmsClient::builder()\n    .unwrap()\n    .api_key(\"your-api-key\")\n    .timeout(Duration::from_secs(60))\n    .build()?;\n</code></pre></p>"},{"location":"swarms_cloud/rust_client/#swarmsclientwith_configconfig-clientconfig","title":"<code>SwarmsClient::with_config(config: ClientConfig)</code>","text":"<p>Creates a client with custom configuration.</p> Parameter Type Description <code>config</code> <code>ClientConfig</code> Client configuration settings <p>Returns: <code>Result&lt;SwarmsClient, SwarmsError&gt;</code></p> <p>Example: <pre><code>let config = ClientConfig {\n    api_key: \"your-api-key\".to_string(),\n    base_url: \"https://api.swarms.com/\".parse().unwrap(),\n    timeout: Duration::from_secs(120),\n    max_retries: 5,\n    ..Default::default()\n};\n\nlet client = SwarmsClient::with_config(config)?;\n</code></pre></p>"},{"location":"swarms_cloud/rust_client/#resource-access-methods","title":"Resource Access Methods","text":"Method Returns Description <code>agent()</code> <code>AgentResource</code> Access agent-related operations <code>swarm()</code> <code>SwarmResource</code> Access swarm-related operations <code>models()</code> <code>ModelsResource</code> Access model listing operations <code>logs()</code> <code>LogsResource</code> Access logging operations"},{"location":"swarms_cloud/rust_client/#cache-management-methods","title":"Cache Management Methods","text":"Method Parameters Returns Description <code>clear_cache()</code> None <code>()</code> Clears all cached responses <code>cache_stats()</code> None <code>Option&lt;(usize, usize)&gt;</code> Returns (valid_entries, total_entries)"},{"location":"swarms_cloud/rust_client/#clientbuilder","title":"ClientBuilder","text":"<p>Builder for configuring the Swarms client.</p>"},{"location":"swarms_cloud/rust_client/#configuration-methods","title":"Configuration Methods","text":"Method Parameters Returns Description <code>new()</code> None <code>ClientBuilder</code> Creates a new builder with defaults <code>from_env()</code> None <code>Result&lt;ClientBuilder, SwarmsError&gt;</code> Loads API key from environment <code>api_key(key)</code> <code>String</code> <code>ClientBuilder</code> Sets the API key <code>base_url(url)</code> <code>&amp;str</code> <code>Result&lt;ClientBuilder, SwarmsError&gt;</code> Sets the base URL <code>timeout(duration)</code> <code>Duration</code> <code>ClientBuilder</code> Sets request timeout <code>max_retries(count)</code> <code>usize</code> <code>ClientBuilder</code> Sets maximum retry attempts <code>retry_delay(duration)</code> <code>Duration</code> <code>ClientBuilder</code> Sets retry delay duration <code>max_concurrent_requests(count)</code> <code>usize</code> <code>ClientBuilder</code> Sets concurrent request limit <code>enable_cache(enabled)</code> <code>bool</code> <code>ClientBuilder</code> Enables/disables caching <code>cache_ttl(duration)</code> <code>Duration</code> <code>ClientBuilder</code> Sets cache TTL <code>build()</code> None <code>Result&lt;SwarmsClient, SwarmsError&gt;</code> Builds the client <p>Example: <pre><code>let client = SwarmsClient::builder()\n    .unwrap()\n    .from_env()?\n    .timeout(Duration::from_secs(120))\n    .max_retries(5)\n    .max_concurrent_requests(50)\n    .enable_cache(true)\n    .cache_ttl(Duration::from_secs(600))\n    .build()?;\n</code></pre></p>"},{"location":"swarms_cloud/rust_client/#swarmresource","title":"SwarmResource","text":"<p>Resource for swarm-related operations.</p>"},{"location":"swarms_cloud/rust_client/#methods","title":"Methods","text":"Method Parameters Returns Description <code>completion()</code> None <code>SwarmCompletionBuilder</code> Creates a new swarm completion builder <code>create(request)</code> <code>SwarmSpec</code> <code>Result&lt;SwarmCompletionResponse, SwarmsError&gt;</code> Creates a swarm completion directly <code>create_batch(requests)</code> <code>Vec&lt;SwarmSpec&gt;</code> <code>Result&lt;Vec&lt;SwarmCompletionResponse&gt;, SwarmsError&gt;</code> Creates multiple swarm completions <code>list_types()</code> None <code>Result&lt;SwarmTypesResponse, SwarmsError&gt;</code> Lists available swarm types"},{"location":"swarms_cloud/rust_client/#swarmcompletionbuilder","title":"SwarmCompletionBuilder","text":"<p>Builder for creating swarm completion requests.</p>"},{"location":"swarms_cloud/rust_client/#configuration-methods_1","title":"Configuration Methods","text":"Method Parameters Returns Description <code>name(name)</code> <code>String</code> <code>SwarmCompletionBuilder</code> Sets the swarm name <code>description(desc)</code> <code>String</code> <code>SwarmCompletionBuilder</code> Sets the swarm description <code>swarm_type(type)</code> <code>SwarmType</code> <code>SwarmCompletionBuilder</code> Sets the swarm type <code>task(task)</code> <code>String</code> <code>SwarmCompletionBuilder</code> Sets the main task <code>agent(builder_fn)</code> <code>Fn(AgentSpecBuilder) -&gt; AgentSpecBuilder</code> <code>SwarmCompletionBuilder</code> Adds an agent using a builder function <code>max_loops(count)</code> <code>u32</code> <code>SwarmCompletionBuilder</code> Sets maximum execution loops <code>service_tier(tier)</code> <code>String</code> <code>SwarmCompletionBuilder</code> Sets the service tier <code>send()</code> None <code>Result&lt;SwarmCompletionResponse, SwarmsError&gt;</code> Sends the request"},{"location":"swarms_cloud/rust_client/#agentresource","title":"AgentResource","text":"<p>Resource for agent-related operations.</p>"},{"location":"swarms_cloud/rust_client/#methods_1","title":"Methods","text":"Method Parameters Returns Description <code>completion()</code> None <code>AgentCompletionBuilder</code> Creates a new agent completion builder <code>create(request)</code> <code>AgentCompletion</code> <code>Result&lt;AgentCompletionResponse, SwarmsError&gt;</code> Creates an agent completion directly <code>create_batch(requests)</code> <code>Vec&lt;AgentCompletion&gt;</code> <code>Result&lt;Vec&lt;AgentCompletionResponse&gt;, SwarmsError&gt;</code> Creates multiple agent completions"},{"location":"swarms_cloud/rust_client/#agentcompletionbuilder","title":"AgentCompletionBuilder","text":"<p>Builder for creating agent completion requests.</p>"},{"location":"swarms_cloud/rust_client/#configuration-methods_2","title":"Configuration Methods","text":"Method Parameters Returns Description <code>agent_name(name)</code> <code>String</code> <code>AgentCompletionBuilder</code> Sets the agent name <code>task(task)</code> <code>String</code> <code>AgentCompletionBuilder</code> Sets the task <code>model(model)</code> <code>String</code> <code>AgentCompletionBuilder</code> Sets the AI model <code>description(desc)</code> <code>String</code> <code>AgentCompletionBuilder</code> Sets the agent description <code>system_prompt(prompt)</code> <code>String</code> <code>AgentCompletionBuilder</code> Sets the system prompt <code>temperature(temp)</code> <code>f32</code> <code>AgentCompletionBuilder</code> Sets the temperature (0.0-1.0) <code>max_tokens(tokens)</code> <code>u32</code> <code>AgentCompletionBuilder</code> Sets maximum tokens <code>max_loops(loops)</code> <code>u32</code> <code>AgentCompletionBuilder</code> Sets maximum loops <code>send()</code> None <code>Result&lt;AgentCompletionResponse, SwarmsError&gt;</code> Sends the request"},{"location":"swarms_cloud/rust_client/#swarmtype-enum","title":"SwarmType Enum","text":"<p>Available swarm types for different execution patterns.</p> Variant Description <code>AgentRearrange</code> Agents can be rearranged based on task requirements <code>MixtureOfAgents</code> Combines multiple agents with different specializations <code>SpreadSheetSwarm</code> Organized like a spreadsheet with structured data flow <code>SequentialWorkflow</code> Agents execute in a sequential order <code>ConcurrentWorkflow</code> Agents execute concurrently <code>GroupChat</code> Agents interact in a group chat format <code>MultiAgentRouter</code> Routes tasks between multiple agents <code>AutoSwarmBuilder</code> Automatically builds swarm structure <code>HiearchicalSwarm</code> Hierarchical organization of agents <code>Auto</code> Automatically selects the best swarm type <code>MajorityVoting</code> Agents vote on decisions <code>Malt</code> Multi-Agent Language Tasks <code>DeepResearchSwarm</code> Specialized for deep research tasks"},{"location":"swarms_cloud/rust_client/#detailed-examples","title":"Detailed Examples","text":""},{"location":"swarms_cloud/rust_client/#1-simple-agent-completion","title":"1. Simple Agent Completion","text":"<pre><code>use swarms_client::{SwarmsClient};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?\n        .build()?;\n\n    let response = client.agent()\n        .completion()\n        .agent_name(\"Content Writer\")\n        .task(\"Write a blog post about sustainable technology\")\n        .model(\"gpt-4o\")\n        .temperature(0.7)\n        .max_tokens(2000)\n        .description(\"An expert content writer specializing in technology topics\")\n        .system_prompt(\"You are a professional content writer with expertise in technology and sustainability. Write engaging, informative content that is well-structured and SEO-friendly.\")\n        .send()\n        .await?;\n\n    println!(\"Agent Response: {}\", response.outputs);\n    println!(\"Tokens Used: {}\", response.usage.total_tokens);\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#2-multi-agent-research-swarm","title":"2. Multi-Agent Research Swarm","text":"<pre><code>use swarms_client::{SwarmsClient, SwarmType};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?\n        .timeout(Duration::from_secs(300)) // 5 minutes for complex tasks\n        .build()?;\n\n    let response = client.swarm()\n        .completion()\n        .name(\"AI Research Swarm\")\n        .description(\"A comprehensive research team analyzing AI trends and developments\")\n        .swarm_type(SwarmType::SequentialWorkflow)\n        .task(\"Conduct a comprehensive analysis of the current state of AI in healthcare, including recent developments, challenges, and future prospects\")\n\n        // Data Collection Agent\n        .agent(|agent| {\n            agent\n                .name(\"Data Collector\")\n                .description(\"Gathers comprehensive data and recent developments\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a research data collector specializing in AI and healthcare. Your job is to gather the most recent and relevant information about AI applications in healthcare, including clinical trials, FDA approvals, and industry developments.\")\n                .temperature(0.3)\n                .max_tokens(3000)\n        })\n\n        // Technical Analyst\n        .agent(|agent| {\n            agent\n                .name(\"Technical Analyst\")\n                .description(\"Analyzes technical aspects and implementation details\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a technical analyst with deep expertise in AI/ML technologies. Analyze the technical feasibility, implementation challenges, and technological requirements of AI solutions in healthcare.\")\n                .temperature(0.4)\n                .max_tokens(3000)\n        })\n\n        // Market Analyst\n        .agent(|agent| {\n            agent\n                .name(\"Market Analyst\")\n                .description(\"Analyzes market trends, adoption rates, and economic factors\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a market research analyst specializing in healthcare technology markets. Analyze market size, growth projections, key players, investment trends, and economic factors affecting AI adoption in healthcare.\")\n                .temperature(0.5)\n                .max_tokens(3000)\n        })\n\n        // Regulatory Expert\n        .agent(|agent| {\n            agent\n                .name(\"Regulatory Expert\")\n                .description(\"Analyzes regulatory landscape and compliance requirements\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a regulatory affairs expert with deep knowledge of healthcare regulations and AI governance. Analyze regulatory challenges, compliance requirements, ethical considerations, and policy developments affecting AI in healthcare.\")\n                .temperature(0.3)\n                .max_tokens(3000)\n        })\n\n        // Report Synthesizer\n        .agent(|agent| {\n            agent\n                .name(\"Report Synthesizer\")\n                .description(\"Synthesizes all analyses into a comprehensive report\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are an expert report writer and strategic analyst. Synthesize all the previous analyses into a comprehensive, well-structured executive report with clear insights, recommendations, and future outlook.\")\n                .temperature(0.6)\n                .max_tokens(4000)\n        })\n\n        .max_loops(1)\n        .service_tier(\"premium\")\n        .send()\n        .await?;\n\n    println!(\"Research Report:\");\n    println!(\"{}\", response.output);\n    println!(\"\\nSwarm executed with {} agents\", response.number_of_agents);\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#3-financial-analysis-swarm-from-example","title":"3. Financial Analysis Swarm (From Example)","text":"<pre><code>use swarms_client::{SwarmsClient, SwarmType};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?\n        .timeout(Duration::from_secs(120))\n        .max_retries(3)\n        .build()?;\n\n    let response = client.swarm()\n        .completion()\n        .name(\"Financial Health Analysis Swarm\")\n        .description(\"A sequential workflow of specialized financial agents analyzing company health\")\n        .swarm_type(SwarmType::ConcurrentWorkflow)\n        .task(\"Analyze the financial health of Apple Inc. (AAPL) based on their latest quarterly report\")\n\n        // Financial Data Collector Agent\n        .agent(|agent| {\n            agent\n                .name(\"Financial Data Collector\")\n                .description(\"Specializes in gathering and organizing financial data from various sources\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a financial data collection specialist. Your role is to gather and organize relevant financial data, including revenue, expenses, profit margins, and key financial ratios. Present the data in a clear, structured format.\")\n                .temperature(0.7)\n                .max_tokens(2000)\n        })\n\n        // Financial Ratio Analyzer Agent\n        .agent(|agent| {\n            agent\n                .name(\"Ratio Analyzer\")\n                .description(\"Analyzes key financial ratios and metrics\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are a financial ratio analysis expert. Your role is to calculate and interpret key financial ratios such as P/E ratio, debt-to-equity, current ratio, and return on equity. Provide insights on what these ratios indicate about the company's financial health.\")\n                .temperature(0.7)\n                .max_tokens(2000)\n        })\n\n        // Additional agents...\n        .agent(|agent| {\n            agent\n                .name(\"Investment Advisor\")\n                .description(\"Provides investment recommendations based on analysis\")\n                .model(\"gpt-4o\")\n                .system_prompt(\"You are an investment advisory specialist. Your role is to synthesize the analysis from previous agents and provide clear, actionable investment recommendations. Consider both short-term and long-term investment perspectives.\")\n                .temperature(0.7)\n                .max_tokens(2000)\n        })\n\n        .max_loops(1)\n        .service_tier(\"standard\")\n        .send()\n        .await?;\n\n    println!(\"Financial Analysis Results:\");\n    println!(\"{}\", response.output);\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#4-batch-processing","title":"4. Batch Processing","text":"<pre><code>use swarms_client::{SwarmsClient, AgentCompletion, AgentSpec};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?\n        .max_concurrent_requests(20) // Allow more concurrent requests for batch\n        .build()?;\n\n    // Create multiple agent completion requests\n    let requests = vec![\n        AgentCompletion {\n            agent_config: AgentSpec {\n                agent_name: \"Content Creator 1\".to_string(),\n                model_name: \"gpt-4o-mini\".to_string(),\n                temperature: 0.7,\n                max_tokens: 1000,\n                ..Default::default()\n            },\n            task: \"Write a social media post about renewable energy\".to_string(),\n            history: None,\n        },\n        AgentCompletion {\n            agent_config: AgentSpec {\n                agent_name: \"Content Creator 2\".to_string(),\n                model_name: \"gpt-4o-mini\".to_string(),\n                temperature: 0.8,\n                max_tokens: 1000,\n                ..Default::default()\n            },\n            task: \"Write a social media post about electric vehicles\".to_string(),\n            history: None,\n        },\n        // Add more requests...\n    ];\n\n    // Process all requests in batch\n    let responses = client.agent()\n        .create_batch(requests)\n        .await?;\n\n    for (i, response) in responses.iter().enumerate() {\n        println!(\"Response {}: {}\", i + 1, response.outputs);\n        println!(\"Tokens used: {}\\n\", response.usage.total_tokens);\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#5-custom-configuration-with-error-handling","title":"5. Custom Configuration with Error Handling","text":"<pre><code>use swarms_client::{SwarmsClient, SwarmsError, ClientConfig};\nuse std::time::Duration;\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Custom configuration for production use\n    let config = ClientConfig {\n        api_key: std::env::var(\"SWARMS_API_KEY\")?,\n        base_url: \"https://swarms-api-285321057562.us-east1.run.app/\".parse()?,\n        timeout: Duration::from_secs(180),\n        max_retries: 5,\n        retry_delay: Duration::from_secs(2),\n        max_concurrent_requests: 50,\n        circuit_breaker_threshold: 10,\n        circuit_breaker_timeout: Duration::from_secs(120),\n        enable_cache: true,\n        cache_ttl: Duration::from_secs(600),\n    };\n\n    let client = SwarmsClient::with_config(config)?;\n\n    // Example with comprehensive error handling\n    match client.swarm()\n        .completion()\n        .name(\"Production Swarm\")\n        .swarm_type(SwarmType::Auto)\n        .task(\"Analyze market trends for Q4 2024\")\n        .agent(|agent| {\n            agent\n                .name(\"Market Analyst\")\n                .model(\"gpt-4o\")\n                .temperature(0.5)\n        })\n        .send()\n        .await\n    {\n        Ok(response) =&gt; {\n            println!(\"Success! Job ID: {}\", response.job_id);\n            println!(\"Output: {}\", response.output);\n        },\n        Err(SwarmsError::Authentication { message, .. }) =&gt; {\n            eprintln!(\"Authentication error: {}\", message);\n        },\n        Err(SwarmsError::RateLimit { message, .. }) =&gt; {\n            eprintln!(\"Rate limit exceeded: {}\", message);\n            // Implement backoff strategy\n        },\n        Err(SwarmsError::InsufficientCredits { message, .. }) =&gt; {\n            eprintln!(\"Insufficient credits: {}\", message);\n        },\n        Err(SwarmsError::CircuitBreakerOpen) =&gt; {\n            eprintln!(\"Circuit breaker is open - service temporarily unavailable\");\n        },\n        Err(e) =&gt; {\n            eprintln!(\"Other error: {}\", e);\n        }\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#6-monitoring-and-observability","title":"6. Monitoring and Observability","text":"<pre><code>use swarms_client::SwarmsClient;\nuse tracing::{info, warn, error};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {\n    // Initialize tracing for observability\n    tracing_subscriber::init();\n\n    let client = SwarmsClient::builder()\n        .unwrap()\n        .from_env()?\n        .enable_cache(true)\n        .build()?;\n\n    // Monitor cache performance\n    if let Some((valid, total)) = client.cache_stats() {\n        info!(\"Cache stats: {}/{} entries valid\", valid, total);\n    }\n\n    // Make request with monitoring\n    let start = std::time::Instant::now();\n\n    let response = client.swarm()\n        .completion()\n        .name(\"Monitored Swarm\")\n        .task(\"Analyze system performance metrics\")\n        .agent(|agent| {\n            agent\n                .name(\"Performance Analyst\")\n                .model(\"gpt-4o-mini\")\n        })\n        .send()\n        .await?;\n\n    let duration = start.elapsed();\n    info!(\"Request completed in {:?}\", duration);\n\n    if duration &gt; Duration::from_secs(30) {\n        warn!(\"Request took longer than expected: {:?}\", duration);\n    }\n\n    // Clear cache periodically in production\n    client.clear_cache();\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#error-handling","title":"Error Handling","text":"<p>The client provides comprehensive error handling with specific error types:</p>"},{"location":"swarms_cloud/rust_client/#swarmserror-types","title":"SwarmsError Types","text":"Error Type Description Recommended Action <code>Authentication</code> Invalid API key or authentication failure Check API key and permissions <code>RateLimit</code> Rate limit exceeded Implement exponential backoff <code>InvalidRequest</code> Malformed request parameters Validate input parameters <code>InsufficientCredits</code> Not enough credits for operation Check account balance <code>Api</code> General API error Check API status and retry <code>Network</code> Network connectivity issues Check internet connection <code>Timeout</code> Request timeout Increase timeout or retry <code>CircuitBreakerOpen</code> Circuit breaker preventing requests Wait for recovery period <code>Serialization</code> JSON serialization/deserialization error Check data format"},{"location":"swarms_cloud/rust_client/#error-handling-best-practices","title":"Error Handling Best Practices","text":"<pre><code>use swarms_client::{SwarmsClient, SwarmsError};\n\nasync fn handle_swarm_request(client: &amp;SwarmsClient, task: &amp;str) -&gt; Result&lt;String, SwarmsError&gt; {\n    match client.swarm()\n        .completion()\n        .task(task)\n        .agent(|agent| agent.name(\"Worker\").model(\"gpt-4o-mini\"))\n        .send()\n        .await\n    {\n        Ok(response) =&gt; Ok(response.output.to_string()),\n        Err(SwarmsError::RateLimit { .. }) =&gt; {\n            // Implement exponential backoff\n            tokio::time::sleep(Duration::from_secs(5)).await;\n            Err(SwarmsError::RateLimit {\n                message: \"Rate limited - should retry\".to_string(),\n                status: Some(429),\n                request_id: None,\n            })\n        },\n        Err(e) =&gt; Err(e),\n    }\n}\n</code></pre>"},{"location":"swarms_cloud/rust_client/#performance-features","title":"Performance Features","text":""},{"location":"swarms_cloud/rust_client/#connection-pooling","title":"Connection Pooling","text":"<p>The client automatically manages HTTP connection pooling for optimal performance:</p> <pre><code>// Connections are automatically pooled and reused\nlet client = SwarmsClient::builder()\n    .unwrap()\n    .from_env()?\n    .max_concurrent_requests(100) // Allow up to 100 concurrent requests\n    .build()?;\n</code></pre>"},{"location":"swarms_cloud/rust_client/#caching","title":"Caching","text":"<p>Intelligent caching reduces redundant API calls:</p> <pre><code>let client = SwarmsClient::builder()\n    .unwrap()\n    .from_env()?\n    .enable_cache(true)\n    .cache_ttl(Duration::from_secs(300)) // 5-minute TTL\n    .build()?;\n\n// GET requests are automatically cached\nlet models = client.models().list().await?; // First call hits API\nlet models_cached = client.models().list().await?; // Second call uses cache\n</code></pre>"},{"location":"swarms_cloud/rust_client/#circuit-breaker","title":"Circuit Breaker","text":"<p>Automatic failure detection and recovery:</p> <pre><code>let client = SwarmsClient::builder()\n    .unwrap()\n    .from_env()?\n    .build()?;\n\n// Circuit breaker automatically opens after 5 failures\n// and recovers after 60 seconds\n</code></pre>"},{"location":"swarms_cloud/rust_client/#configuration-reference","title":"Configuration Reference","text":""},{"location":"swarms_cloud/rust_client/#clientconfig-structure","title":"ClientConfig Structure","text":"Field Type Default Description <code>api_key</code> <code>String</code> <code>\"\"</code> Swarms API key <code>base_url</code> <code>Url</code> <code>https://swarms-api-285321057562.us-east1.run.app/</code> API base URL <code>timeout</code> <code>Duration</code> <code>60s</code> Request timeout <code>max_retries</code> <code>usize</code> <code>3</code> Maximum retry attempts <code>retry_delay</code> <code>Duration</code> <code>1s</code> Base retry delay <code>max_concurrent_requests</code> <code>usize</code> <code>100</code> Concurrent request limit <code>circuit_breaker_threshold</code> <code>usize</code> <code>5</code> Failure threshold for circuit breaker <code>circuit_breaker_timeout</code> <code>Duration</code> <code>60s</code> Circuit breaker recovery time <code>enable_cache</code> <code>bool</code> <code>true</code> Enable response caching <code>cache_ttl</code> <code>Duration</code> <code>300s</code> Cache time-to-live"},{"location":"swarms_cloud/rust_client/#environment-variables","title":"Environment Variables","text":"Variable Description Example <code>SWARMS_API_KEY</code> Your Swarms API key <code>sk-xxx...</code> <code>SWARMS_BASE_URL</code> Custom API base URL (optional) <code>https://api.custom.com/</code>"},{"location":"swarms_cloud/rust_client/#testing","title":"Testing","text":"<p>Run the test suite:</p> <pre><code>cargo test\n</code></pre> <p>Run specific tests:</p> <pre><code>cargo test test_cache\ncargo test test_circuit_breaker\n</code></pre>"},{"location":"swarms_cloud/rust_client/#contributing","title":"Contributing","text":"<ol> <li>Fork the repository</li> <li>Create a feature branch</li> <li>Add tests for new functionality</li> <li>Ensure all tests pass</li> <li>Submit a pull request</li> </ol>"},{"location":"swarms_cloud/rust_client/#license","title":"License","text":"<p>This project is licensed under the MIT License - see the LICENSE file for details.</p>"},{"location":"swarms_cloud/subscription_tiers/","title":"Swarms Cloud Subscription Tiers","text":"<p>Overview</p> <p>Choose the perfect plan for your agent infrastructure needs. All plans include our core features with additional benefits as you scale up.</p>"},{"location":"swarms_cloud/subscription_tiers/#pricing-plans","title":"Pricing Plans","text":""},{"location":"swarms_cloud/subscription_tiers/#free-tier","title":"Free Tier","text":"<p>Free</p> <p>$0/year</p> <p>Perfect for getting started with AI development.</p> <p>Get Started</p> <p>What's Included:</p> <ul> <li> <p> Sign up Bonus!</p> </li> <li> <p> Basic Access</p> </li> <li> <p> Pay-Per-Use Pricing</p> </li> <li> <p> Community Support</p> </li> <li> <p> Standard Processing Speed</p> </li> </ul>"},{"location":"swarms_cloud/subscription_tiers/#premium-tier","title":"Premium Tier","text":"<p>Premium</p> <p>Monthly $100/month</p> <p>Yearly $1,020/year (Save 15% on annual billing)</p> <p>Subscribe Now</p> <p>Everything in Free, plus:</p> <ul> <li> <p> Full Access to Explorer and Agents</p> </li> <li> <p> Access to Premium Multi-Modality Models</p> </li> <li> <p> Priority Access to Swarms</p> </li> <li> <p> High-Performance Infrastructure</p> </li> <li> <p> Exclusive Webinars and Tutorials</p> </li> <li> <p> Priority Support</p> </li> <li> <p> Enhanced Security Features</p> </li> <li> <p> Early Access to New Models and Features</p> </li> </ul>"},{"location":"swarms_cloud/subscription_tiers/#enterprise-tier","title":"Enterprise Tier","text":"<p>Enterprise</p> <p>Contact for more Information</p> <p>Book a Call</p> <p>Everything in Premium, plus:</p> <ul> <li> <p> High-Performance Infrastructure</p> </li> <li> <p> Batch API</p> </li> <li> <p> Early Access to New Swarms</p> </li> <li> <p> Dedicated 24/7 Support</p> </li> <li> <p> Custom Solutions Engineering</p> </li> <li> <p> Advanced Security Features</p> </li> <li> <p> Onsite Training and Onboarding</p> </li> <li> <p> Custom Model Training</p> </li> <li> <p> Priority Support</p> </li> <li> <p> Pay-Per-Use Pricing</p> </li> <li> <p> Enterprise Telemetry Platform</p> </li> <li> <p> Regular Check-In Strategy Sessions</p> </li> </ul>"},{"location":"swarms_cloud/subscription_tiers/#feature-comparison","title":"Feature Comparison","text":"Feature Free Premium Enterprise Sign up Bonus \u2705 \u2705 \u2705 Basic Access \u2705 \u2705 \u2705 Pay-Per-Use Pricing \u2705 \u2705 \u2705 Community Support \u2705 \u2705 \u2705 Standard Processing Speed \u2705 \u2705 \u2705 Full Access to Explorer and Agents \u274c \u2705 \u2705 Premium Multi-Modality Models \u274c \u2705 \u2705 Priority Access to Swarms \u274c \u2705 \u2705 High-Performance GPUs \u274c \u2705 \u2705 Exclusive Webinars and Tutorials \u274c \u2705 \u2705 Priority Support \u274c \u2705 \u2705 Enhanced Security Features \u274c \u2705 \u2705 Early Access to New Models \u274c \u2705 \u2705 Batch API \u274c \u274c \u2705 Dedicated 24/7 Support \u274c \u274c \u2705 Custom Solutions Engineering \u274c \u274c \u2705 Onsite Training and Onboarding \u274c \u274c \u2705 Custom Model Training \u274c \u274c \u2705"},{"location":"swarms_cloud/subscription_tiers/#rate-limits","title":"Rate Limits","text":"<p>Rate Limit Increases</p> <ul> <li>Premium: 100% increase in rate limits</li> <li>Enterprise: Custom rate limits based on your needs (contact us for details)</li> </ul>"},{"location":"swarms_cloud/subscription_tiers/#getting-started","title":"Getting Started","text":"<ol> <li>Choose your plan</li> <li>Create your account</li> <li>Start building with Swarms!</li> </ol> <p>Need Help?</p> <ul> <li>For general questions: Contact Support</li> <li>For enterprise inquiries: Book a Call</li> <li>Upgrade Your Membership: Upgrade Now</li> </ul>"},{"location":"swarms_cloud/swarm_types/","title":"Multi-Agent Architectures","text":"<p>Each multi-agent architecture type is designed for specific use cases and can be combined to create powerful multi-agent systems. Here's a comprehensive overview of each available swarm:</p> Swarm Type Description Learn More AgentRearrange Dynamically reorganizes agents to optimize task performance and efficiency. Optimizes agent performance by dynamically adjusting their roles and positions within the workflow. This architecture is particularly useful when the effectiveness of agents depends on their sequence or arrangement. Learn More MixtureOfAgents Creates diverse teams of specialized agents, each bringing unique capabilities to solve complex problems. Each agent contributes unique skills to achieve the overall goal, making it excel at tasks requiring multiple types of expertise or processing. Learn More SpreadSheetSwarm Provides a structured approach to data management and operations, making it ideal for tasks involving data analysis, transformation, and systematic processing in a spreadsheet-like structure. Learn More SequentialWorkflow Ensures strict process control by executing tasks in a predefined order. Perfect for workflows where each step depends on the completion of previous steps. Learn More ConcurrentWorkflow Maximizes efficiency by running independent tasks in parallel, significantly reducing overall processing time for complex operations. Ideal for independent tasks that can be processed simultaneously. Learn More GroupChat Enables dynamic collaboration between agents through a chat-based interface, facilitating real-time information sharing and decision-making. Learn More MultiAgentRouter Acts as an intelligent task dispatcher, ensuring optimal distribution of work across available agents based on their capabilities and current workload. Learn More AutoSwarmBuilder Simplifies swarm creation by automatically configuring agent architectures based on task requirements and performance metrics. Learn More HiearchicalSwarm Implements a structured approach to task management, with clear lines of authority and delegation across multiple agent levels. Learn More auto Provides intelligent swarm selection based on context, automatically choosing the most effective architecture for given tasks. Learn More MajorityVoting Implements robust decision-making through consensus, particularly useful for tasks requiring collective intelligence or verification. Learn More MALT Specialized framework for language-based tasks, optimizing agent collaboration for complex language processing operations. Learn More"},{"location":"swarms_cloud/swarm_types/#learn-more","title":"Learn More","text":"<p>To learn more about Swarms architecture and how different swarm types work together, visit our comprehensive guides:</p> <ul> <li> <p>Introduction to Multi-Agent Architectures</p> </li> <li> <p>How to Choose the Right Multi-Agent Architecture</p> </li> <li> <p>Framework Architecture Overview</p> </li> <li> <p>Building Custom Swarms</p> </li> </ul>"},{"location":"swarms_cloud/swarms_api/","title":"Swarms API Documentation","text":"<p>Enterprise-Grade Agent Swarm Management API</p> <p>Base URL: <code>https://api.swarms.world</code> or <code>https://swarms-api-285321057562.us-east1.run.app</code></p> <p>API Key Management: https://swarms.world/platform/api-keys </p>"},{"location":"swarms_cloud/swarms_api/#overview","title":"Overview","text":"<p>The Swarms API provides a robust, scalable infrastructure for deploying and managing intelligent agent swarms in the cloud. This enterprise-grade API enables organizations to create, execute, and orchestrate sophisticated AI agent workflows without managing the underlying infrastructure.</p> <p>Key capabilities include:</p> <ul> <li> <p>Intelligent Swarm Management: Create and execute swarms of specialized AI agents that collaborate to solve complex tasks</p> </li> <li> <p>Automatic Agent Generation: Dynamically create optimized agents based on task requirements</p> </li> <li> <p>Multiple Swarm Architectures: Choose from various swarm patterns to match your specific workflow needs</p> </li> <li> <p>Comprehensive Logging: Track and analyze all API interactions</p> </li> <li> <p>Cost Management: Predictable, transparent pricing with optimized resource utilization</p> </li> <li> <p>Enterprise Security: Full API key authentication and management</p> </li> </ul> <p>Swarms API is designed for production use cases requiring sophisticated AI orchestration, with applications in finance, healthcare, legal, research, and other domains where complex reasoning and multi-agent collaboration are needed.</p>"},{"location":"swarms_cloud/swarms_api/#authentication","title":"Authentication","text":"<p>All API requests require a valid API key, which must be included in the header of each request:</p> <pre><code>x-api-key: your_api_key_here\n</code></pre> <p>API keys can be obtained and managed at https://swarms.world/platform/api-keys.</p>"},{"location":"swarms_cloud/swarms_api/#api-reference","title":"API Reference","text":""},{"location":"swarms_cloud/swarms_api/#endpoints-summary","title":"Endpoints Summary","text":"Endpoint Method Description <code>/health</code> GET Simple health check endpoint <code>/v1/swarm/completions</code> POST Run a swarm with specified configuration <code>/v1/swarm/batch/completions</code> POST Run multiple swarms in batch mode <code>/v1/swarm/logs</code> GET Retrieve API request logs <code>/v1/swarms/available</code> GET Get all available swarms as a list of strings <code>/v1/models/available</code> GET Get all available models as a list of strings <code>/v1/agent/completions</code> POST Run a single agent with specified configuration <code>/v1/agent/batch/completions</code> POST Run a batch of individual agent completions"},{"location":"swarms_cloud/swarms_api/#swarmtype-reference","title":"SwarmType Reference","text":"<p>The <code>swarm_type</code> parameter defines the architecture and collaboration pattern of the agent swarm:</p> SwarmType Description <code>AgentRearrange</code> Dynamically reorganizes the workflow between agents based on task requirements <code>MixtureOfAgents</code> Combines multiple agent types to tackle diverse aspects of a problem <code>SpreadSheetSwarm</code> Specialized for spreadsheet data analysis and manipulation <code>SequentialWorkflow</code> Agents work in a predefined sequence, each handling specific subtasks <code>ConcurrentWorkflow</code> Multiple agents work simultaneously on different aspects of the task <code>GroupChat</code> Agents collaborate in a discussion format to solve problems <code>MultiAgentRouter</code> Routes subtasks to specialized agents based on their capabilities <code>AutoSwarmBuilder</code> Automatically designs and builds an optimal swarm based on the task <code>HiearchicalSwarm</code> Organizes agents in a hierarchical structure with managers and workers <code>MajorityVoting</code> Uses a consensus mechanism where multiple agents vote on the best solution <code>auto</code> Automatically selects the most appropriate swarm type for the given task"},{"location":"swarms_cloud/swarms_api/#data-models","title":"Data Models","text":""},{"location":"swarms_cloud/swarms_api/#swarmspec","title":"SwarmSpec","text":"<p>The <code>SwarmSpec</code> model defines the configuration of a swarm.</p> Field Type Description Required name string Identifier for the swarm No description string Description of the swarm's purpose No agents Array List of agent specifications No max_loops integer Maximum number of execution loops No swarm_type SwarmType Architecture of the swarm No rearrange_flow string Instructions for rearranging task flow No task string The main task for the swarm to accomplish Yes img string Optional image URL for the swarm No return_history boolean Whether to return execution history No rules string Guidelines for swarm behavior No service_tier string Service tier for processing (\"standard\" or \"flex\") No"},{"location":"swarms_cloud/swarms_api/#agentspec","title":"AgentSpec","text":"<p>The <code>AgentSpec</code> model defines the configuration of an individual agent.</p> Field Type Description Required agent_name string Unique name for the agent Yes* description string Description of the agent's purpose No system_prompt string Instructions for the agent No model_name string AI model to use (e.g., \"gpt-4o\") Yes* auto_generate_prompt boolean Whether to auto-generate prompts No max_tokens integer Maximum tokens in response No temperature float Randomness of responses (0-1) No role string Agent's role in the swarm No max_loops integer Maximum iterations for this agent No <p>*Required if agents are manually specified; not required if using auto-generated agents</p>"},{"location":"swarms_cloud/swarms_api/#endpoint-details","title":"Endpoint Details","text":""},{"location":"swarms_cloud/swarms_api/#health-check","title":"Health Check","text":"<p>Check if the API service is available and functioning correctly.</p> <p>Endpoint: <code>/health</code> Method: GET Rate Limit: 100 requests per 60 seconds</p> Shell (curl)Python (requests)TypeScript (fetch) <pre><code>curl -X GET \"https://api.swarms.world/health\" \\\n     -H \"x-api-key: your_api_key_here\"\n</code></pre> <pre><code>import requests\n\nAPI_BASE_URL = \"https://api.swarms.world\"\nAPI_KEY = \"your_api_key_here\"\n\nheaders = {\n    \"x-api-key\": API_KEY\n}\n\nresponse = requests.get(f\"{API_BASE_URL}/health\", headers=headers)\n\nif response.status_code == 200:\n    print(\"API is healthy:\", response.json())\nelse:\n    print(f\"Error: {response.status_code}\")\n</code></pre> <pre><code>const API_BASE_URL = \"https://api.swarms.world\";\nconst API_KEY = \"your_api_key_here\";\n\nasync function checkHealth(): Promise&lt;void&gt; {\n    try {\n        const response = await fetch(`${API_BASE_URL}/health`, {\n            method: 'GET',\n            headers: {\n                'x-api-key': API_KEY\n            }\n        });\n\n        if (response.ok) {\n            const data = await response.json();\n            console.log(\"API is healthy:\", data);\n        } else {\n            console.error(`Error: ${response.status}`);\n        }\n    } catch (error) {\n        console.error(\"Request failed:\", error);\n    }\n}\n\ncheckHealth();\n</code></pre> <p>Example Response: <pre><code>{\n  \"status\": \"ok\"\n}\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#run-swarm","title":"Run Swarm","text":"<p>Run a swarm with the specified configuration to complete a task.</p> <p>Endpoint: <code>/v1/swarm/completions</code> Method: POST Rate Limit: 100 requests per 60 seconds</p> <p>Request Parameters:</p> Field Type Description Required name string Identifier for the swarm No description string Description of the swarm's purpose No agents Array List of agent specifications No max_loops integer Maximum number of execution loops No swarm_type SwarmType Architecture of the swarm No rearrange_flow string Instructions for rearranging task flow No task string The main task for the swarm to accomplish Yes img string Optional image URL for the swarm No return_history boolean Whether to return execution history No rules string Guidelines for swarm behavior No Shell (curl)Python (requests)TypeScript (fetch) <pre><code>curl -X POST \"https://api.swarms.world/v1/swarm/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"Financial Analysis Swarm\",\n    \"description\": \"Market analysis swarm\",\n    \"agents\": [\n      {\n        \"agent_name\": \"Market Analyst\",\n        \"description\": \"Analyzes market trends\",\n        \"system_prompt\": \"You are a financial analyst expert.\",\n        \"model_name\": \"openai/gpt-4o\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      },\n      {\n        \"agent_name\": \"Economic Forecaster\",\n        \"description\": \"Predicts economic trends\",\n        \"system_prompt\": \"You are an expert in economic forecasting.\",\n        \"model_name\": \"gpt-4o\",\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"auto_generate_prompt\": false\n      }\n    ],\n    \"max_loops\": 1,\n    \"swarm_type\": \"ConcurrentWorkflow\",\n    \"task\": \"What are the best etfs and index funds for ai and tech?\",\n    \"output_type\": \"dict\"\n  }'\n</code></pre> <pre><code>import requests\nimport json\n\nAPI_BASE_URL = \"https://api.swarms.world\"\nAPI_KEY = \"your_api_key_here\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\nswarm_config = {\n    \"name\": \"Financial Analysis Swarm\",\n    \"description\": \"Market analysis swarm\",\n    \"agents\": [\n        {\n            \"agent_name\": \"Market Analyst\",\n            \"description\": \"Analyzes market trends\",\n            \"system_prompt\": \"You are a financial analyst expert.\",\n            \"model_name\": \"openai/gpt-4o\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 8192,\n            \"temperature\": 0.5,\n            \"auto_generate_prompt\": False\n        },\n        {\n            \"agent_name\": \"Economic Forecaster\",\n            \"description\": \"Predicts economic trends\",\n            \"system_prompt\": \"You are an expert in economic forecasting.\",\n            \"model_name\": \"gpt-4o\",\n            \"role\": \"worker\",\n            \"max_loops\": 1,\n            \"max_tokens\": 8192,\n            \"temperature\": 0.5,\n            \"auto_generate_prompt\": False\n        }\n    ],\n    \"max_loops\": 1,\n    \"swarm_type\": \"ConcurrentWorkflow\",\n    \"task\": \"What are the best etfs and index funds for ai and tech?\",\n    \"output_type\": \"dict\"\n}\n\nresponse = requests.post(\n    f\"{API_BASE_URL}/v1/swarm/completions\",\n    headers=headers,\n    json=swarm_config\n)\n\nif response.status_code == 200:\n    result = response.json()\n    print(\"Swarm completed successfully!\")\n    print(f\"Cost: ${result['metadata']['billing_info']['total_cost']}\")\n    print(f\"Execution time: {result['metadata']['execution_time_seconds']} seconds\")\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n</code></pre> <pre><code>interface AgentSpec {\n    agent_name: string;\n    description: string;\n    system_prompt: string;\n    model_name: string;\n    role: string;\n    max_loops: number;\n    max_tokens: number;\n    temperature: number;\n    auto_generate_prompt: boolean;\n}\n\ninterface SwarmConfig {\n    name: string;\n    description: string;\n    agents: AgentSpec[];\n    max_loops: number;\n    swarm_type: string;\n    task: string;\n    output_type: string;\n}\n\nconst API_BASE_URL = \"https://api.swarms.world\";\nconst API_KEY = \"your_api_key_here\";\n\nasync function runSwarm(): Promise&lt;void&gt; {\n    const swarmConfig: SwarmConfig = {\n        name: \"Financial Analysis Swarm\",\n        description: \"Market analysis swarm\",\n        agents: [\n            {\n                agent_name: \"Market Analyst\",\n                description: \"Analyzes market trends\",\n                system_prompt: \"You are a financial analyst expert.\",\n                model_name: \"openai/gpt-4o\",\n                role: \"worker\",\n                max_loops: 1,\n                max_tokens: 8192,\n                temperature: 0.5,\n                auto_generate_prompt: false\n            },\n            {\n                agent_name: \"Economic Forecaster\",\n                description: \"Predicts economic trends\",\n                system_prompt: \"You are an expert in economic forecasting.\",\n                model_name: \"gpt-4o\",\n                role: \"worker\",\n                max_loops: 1,\n                max_tokens: 8192,\n                temperature: 0.5,\n                auto_generate_prompt: false\n            }\n        ],\n        max_loops: 1,\n        swarm_type: \"ConcurrentWorkflow\",\n        task: \"What are the best etfs and index funds for ai and tech?\",\n        output_type: \"dict\"\n    };\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/v1/swarm/completions`, {\n            method: 'POST',\n            headers: {\n                'x-api-key': API_KEY,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(swarmConfig)\n        });\n\n        if (response.ok) {\n            const result = await response.json();\n            console.log(\"Swarm completed successfully!\");\n            console.log(`Cost: $${result.metadata.billing_info.total_cost}`);\n            console.log(`Execution time: ${result.metadata.execution_time_seconds} seconds`);\n        } else {\n            console.error(`Error: ${response.status} - ${await response.text()}`);\n        }\n    } catch (error) {\n        console.error(\"Request failed:\", error);\n    }\n}\n\nrunSwarm();\n</code></pre> <p>Example Response: <pre><code>{\n  \"status\": \"success\",\n  \"swarm_name\": \"financial-analysis-swarm\",\n  \"description\": \"Analyzes financial data for risk assessment\",\n  \"swarm_type\": \"SequentialWorkflow\",\n  \"task\": \"Analyze the provided quarterly financials for Company XYZ and identify potential risk factors. Summarize key insights and provide recommendations for risk mitigation.\",\n  \"output\": {\n    \"financial_analysis\": {\n      \"risk_factors\": [...],\n      \"key_insights\": [...],\n      \"recommendations\": [...]\n    }\n  },\n  \"metadata\": {\n    \"max_loops\": 2,\n    \"num_agents\": 3,\n    \"execution_time_seconds\": 12.45,\n    \"completion_time\": 1709563245.789,\n    \"billing_info\": {\n      \"cost_breakdown\": {\n        \"agent_cost\": 0.03,\n        \"input_token_cost\": 0.002134,\n        \"output_token_cost\": 0.006789,\n        \"token_counts\": {\n          \"total_input_tokens\": 1578,\n          \"total_output_tokens\": 3456,\n          \"total_tokens\": 5034,\n          \"per_agent\": {...}\n        },\n        \"num_agents\": 3,\n        \"execution_time_seconds\": 12.45\n      },\n      \"total_cost\": 0.038923\n    }\n  }\n}\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#run-batch-completions","title":"Run Batch Completions","text":"<p>Run multiple swarms as a batch operation.</p> <p>Endpoint: <code>/v1/swarm/batch/completions</code> Method: POST Rate Limit: 100 requests per 60 seconds</p> <p>Request Parameters:</p> Field Type Description Required swarms Array List of swarm specifications Yes Shell (curl)Python (requests)TypeScript (fetch) <pre><code>curl -X POST \"https://api.swarms.world/v1/swarm/batch/completions\" \\\n  -H \"x-api-key: $SWARMS_API_KEY\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '[\n    {\n      \"name\": \"Batch Swarm 1\",\n      \"description\": \"First swarm in the batch\",\n      \"agents\": [\n        {\n          \"agent_name\": \"Research Agent\",\n          \"description\": \"Conducts research\",\n          \"system_prompt\": \"You are a research assistant.\",\n          \"model_name\": \"gpt-4o\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        },\n        {\n          \"agent_name\": \"Analysis Agent\",\n          \"description\": \"Analyzes data\",\n          \"system_prompt\": \"You are a data analyst.\",\n          \"model_name\": \"gpt-4o\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        }\n      ],\n      \"max_loops\": 1,\n      \"swarm_type\": \"SequentialWorkflow\",\n      \"task\": \"Research AI advancements.\"\n    },\n    {\n      \"name\": \"Batch Swarm 2\",\n      \"description\": \"Second swarm in the batch\",\n      \"agents\": [\n        {\n          \"agent_name\": \"Writing Agent\",\n          \"description\": \"Writes content\",\n          \"system_prompt\": \"You are a content writer.\",\n          \"model_name\": \"gpt-4o\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        },\n        {\n          \"agent_name\": \"Editing Agent\",\n          \"description\": \"Edits content\",\n          \"system_prompt\": \"You are an editor.\",\n          \"model_name\": \"gpt-4o\",\n          \"role\": \"worker\",\n          \"max_loops\": 1\n        }\n      ],\n      \"max_loops\": 1,\n      \"swarm_type\": \"SequentialWorkflow\",\n      \"task\": \"Write a summary of AI research.\"\n    }\n  ]'\n</code></pre> <pre><code>import requests\nimport json\n\nAPI_BASE_URL = \"https://api.swarms.world\"\nAPI_KEY = \"your_api_key_here\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\nbatch_swarms = [\n    {\n        \"name\": \"Batch Swarm 1\",\n        \"description\": \"First swarm in the batch\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Research Agent\",\n                \"description\": \"Conducts research\",\n                \"system_prompt\": \"You are a research assistant.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1\n            },\n            {\n                \"agent_name\": \"Analysis Agent\",\n                \"description\": \"Analyzes data\",\n                \"system_prompt\": \"You are a data analyst.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"SequentialWorkflow\",\n        \"task\": \"Research AI advancements.\"\n    },\n    {\n        \"name\": \"Batch Swarm 2\",\n        \"description\": \"Second swarm in the batch\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Writing Agent\",\n                \"description\": \"Writes content\",\n                \"system_prompt\": \"You are a content writer.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1\n            },\n            {\n                \"agent_name\": \"Editing Agent\",\n                \"description\": \"Edits content\",\n                \"system_prompt\": \"You are an editor.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"SequentialWorkflow\",\n        \"task\": \"Write a summary of AI research.\"\n    }\n]\n\nresponse = requests.post(\n    f\"{API_BASE_URL}/v1/swarm/batch/completions\",\n    headers=headers,\n    json=batch_swarms\n)\n\nif response.status_code == 200:\n    results = response.json()\n    print(f\"Batch completed with {len(results)} swarms\")\n    for i, result in enumerate(results):\n        print(f\"Swarm {i+1}: {result['swarm_name']} - {result['status']}\")\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n</code></pre> <pre><code>interface AgentSpec {\n    agent_name: string;\n    description: string;\n    system_prompt: string;\n    model_name: string;\n    role: string;\n    max_loops: number;\n}\n\ninterface SwarmSpec {\n    name: string;\n    description: string;\n    agents: AgentSpec[];\n    max_loops: number;\n    swarm_type: string;\n    task: string;\n}\n\nconst API_BASE_URL = \"https://api.swarms.world\";\nconst API_KEY = \"your_api_key_here\";\n\nasync function runBatchSwarms(): Promise&lt;void&gt; {\n    const batchSwarms: SwarmSpec[] = [\n        {\n            name: \"Batch Swarm 1\",\n            description: \"First swarm in the batch\",\n            agents: [\n                {\n                    agent_name: \"Research Agent\",\n                    description: \"Conducts research\",\n                    system_prompt: \"You are a research assistant.\",\n                    model_name: \"gpt-4o\",\n                    role: \"worker\",\n                    max_loops: 1\n                },\n                {\n                    agent_name: \"Analysis Agent\",\n                    description: \"Analyzes data\",\n                    system_prompt: \"You are a data analyst.\",\n                    model_name: \"gpt-4o\",\n                    role: \"worker\",\n                    max_loops: 1\n                }\n            ],\n            max_loops: 1,\n            swarm_type: \"SequentialWorkflow\",\n            task: \"Research AI advancements.\"\n        },\n        {\n            name: \"Batch Swarm 2\",\n            description: \"Second swarm in the batch\",\n            agents: [\n                {\n                    agent_name: \"Writing Agent\",\n                    description: \"Writes content\",\n                    system_prompt: \"You are a content writer.\",\n                    model_name: \"gpt-4o\",\n                    role: \"worker\",\n                    max_loops: 1\n                },\n                {\n                    agent_name: \"Editing Agent\",\n                    description: \"Edits content\",\n                    system_prompt: \"You are an editor.\",\n                    model_name: \"gpt-4o\",\n                    role: \"worker\",\n                    max_loops: 1\n                }\n            ],\n            max_loops: 1,\n            swarm_type: \"SequentialWorkflow\",\n            task: \"Write a summary of AI research.\"\n        }\n    ];\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/v1/swarm/batch/completions`, {\n            method: 'POST',\n            headers: {\n                'x-api-key': API_KEY,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(batchSwarms)\n        });\n\n        if (response.ok) {\n            const results = await response.json();\n            console.log(`Batch completed with ${results.length} swarms`);\n            results.forEach((result: any, index: number) =&gt; {\n                console.log(`Swarm ${index + 1}: ${result.swarm_name} - ${result.status}`);\n            });\n        } else {\n            console.error(`Error: ${response.status} - ${await response.text()}`);\n        }\n    } catch (error) {\n        console.error(\"Request failed:\", error);\n    }\n}\n\nrunBatchSwarms();\n</code></pre> <p>Example Response: <pre><code>[\n  {\n    \"status\": \"success\",\n    \"swarm_name\": \"risk-analysis\",\n    \"task\": \"Analyze risk factors for investment portfolio\",\n    \"output\": {...},\n    \"metadata\": {...}\n  },\n  {\n    \"status\": \"success\",\n    \"swarm_name\": \"market-sentiment\",\n    \"task\": \"Assess current market sentiment for technology sector\",\n    \"output\": {...},\n    \"metadata\": {...}\n  }\n]\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#individual-agent-endpoints","title":"Individual Agent Endpoints","text":""},{"location":"swarms_cloud/swarms_api/#run-single-agent","title":"Run Single Agent","text":"<p>Run a single agent with the specified configuration.</p> <p>Endpoint: <code>/v1/agent/completions</code> Method: POST Rate Limit: 100 requests per 60 seconds</p> <p>Request Parameters:</p> Field Type Description Required agent_config AgentSpec Configuration for the agent Yes task string The task to be completed by the agent Yes Shell (curl)Python (requests)TypeScript (fetch) <pre><code>curl -X POST \"https://api.swarms.world/v1/agent/completions\" \\\n     -H \"x-api-key: your_api_key_here\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n       \"agent_config\": {\n         \"agent_name\": \"Research Assistant\",\n         \"description\": \"Helps with research tasks\",\n         \"system_prompt\": \"You are a research assistant expert.\",\n         \"model_name\": \"gpt-4o\",\n         \"max_loops\": 1,\n         \"max_tokens\": 8192,\n         \"temperature\": 0.5\n       },\n       \"task\": \"Research the latest developments in quantum computing.\"\n     }'\n</code></pre> <pre><code>import requests\nimport json\n\nAPI_BASE_URL = \"https://api.swarms.world\"\nAPI_KEY = \"your_api_key_here\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\nagent_request = {\n    \"agent_config\": {\n        \"agent_name\": \"Research Assistant\",\n        \"description\": \"Helps with research tasks\",\n        \"system_prompt\": \"You are a research assistant expert.\",\n        \"model_name\": \"gpt-4o\",\n        \"max_loops\": 1,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5\n    },\n    \"task\": \"Research the latest developments in quantum computing.\"\n}\n\nresponse = requests.post(\n    f\"{API_BASE_URL}/v1/agent/completions\",\n    headers=headers,\n    json=agent_request\n)\n\nif response.status_code == 200:\n    result = response.json()\n    print(f\"Agent {result['name']} completed successfully!\")\n    print(f\"Usage: {result['usage']['total_tokens']} tokens\")\n    print(f\"Output: {result['outputs']}\")\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n</code></pre> <pre><code>interface AgentConfig {\n    agent_name: string;\n    description: string;\n    system_prompt: string;\n    model_name: string;\n    max_loops: number;\n    max_tokens: number;\n    temperature: number;\n}\n\ninterface AgentRequest {\n    agent_config: AgentConfig;\n    task: string;\n}\n\nconst API_BASE_URL = \"https://api.swarms.world\";\nconst API_KEY = \"your_api_key_here\";\n\nasync function runSingleAgent(): Promise&lt;void&gt; {\n    const agentRequest: AgentRequest = {\n        agent_config: {\n            agent_name: \"Research Assistant\",\n            description: \"Helps with research tasks\",\n            system_prompt: \"You are a research assistant expert.\",\n            model_name: \"gpt-4o\",\n            max_loops: 1,\n            max_tokens: 8192,\n            temperature: 0.5\n        },\n        task: \"Research the latest developments in quantum computing.\"\n    };\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/v1/agent/completions`, {\n            method: 'POST',\n            headers: {\n                'x-api-key': API_KEY,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(agentRequest)\n        });\n\n        if (response.ok) {\n            const result = await response.json();\n            console.log(`Agent ${result.name} completed successfully!`);\n            console.log(`Usage: ${result.usage.total_tokens} tokens`);\n            console.log(`Output:`, result.outputs);\n        } else {\n            console.error(`Error: ${response.status} - ${await response.text()}`);\n        }\n    } catch (error) {\n        console.error(\"Request failed:\", error);\n    }\n}\n\nrunSingleAgent();\n</code></pre> <p>Example Response: <pre><code>{\n  \"id\": \"agent-abc123\",\n  \"success\": true,\n  \"name\": \"Research Assistant\",\n  \"description\": \"Helps with research tasks\",\n  \"temperature\": 0.5,\n  \"outputs\": {},\n  \"usage\": {\n    \"input_tokens\": 150,\n    \"output_tokens\": 450,\n    \"total_tokens\": 600\n  },\n  \"timestamp\": \"2024-03-05T12:34:56.789Z\"\n}\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#agentcompletion-model","title":"AgentCompletion Model","text":"<p>The <code>AgentCompletion</code> model defines the configuration for running a single agent task.</p> Field Type Description Required <code>agent_config</code> AgentSpec The configuration of the agent to be completed Yes <code>task</code> string The task to be completed by the agent Yes <code>history</code> Dict[str, Any] The history of the agent's previous tasks and responses No"},{"location":"swarms_cloud/swarms_api/#agentspec-model","title":"AgentSpec Model","text":"<p>The <code>AgentSpec</code> model defines the configuration for an individual agent.</p> Field Type Default Description Required <code>agent_name</code> string None The unique name assigned to the agent Yes <code>description</code> string None Detailed explanation of the agent's purpose No <code>system_prompt</code> string None Initial instruction provided to the agent No <code>model_name</code> string \"gpt-4o-mini\" Name of the AI model to use No <code>auto_generate_prompt</code> boolean false Whether to auto-generate prompts No <code>max_tokens</code> integer 8192 Maximum tokens in response No <code>temperature</code> float 0.5 Controls randomness (0-1) No <code>role</code> string \"worker\" Role of the agent No <code>max_loops</code> integer 1 Maximum iterations No <code>tools_list_dictionary</code> List[Dict] None Available tools for the agent No <code>mcp_url</code> string None URL for Model Control Protocol No <p>Execute a task using a single agent with specified configuration.</p> <p>Endpoint: <code>/v1/agent/completions</code> Method: POST Rate Limit: 100 requests per 60 seconds</p> <p>Request Body: <pre><code>{\n  \"agent_config\": {\n    \"agent_name\": \"Research Assistant\",\n    \"description\": \"Specialized in research and analysis\",\n    \"system_prompt\": \"You are an expert research assistant.\",\n    \"model_name\": \"gpt-4o\",\n    \"auto_generate_prompt\": false,\n    \"max_tokens\": 8192,\n    \"temperature\": 0.5,\n    \"role\": \"worker\",\n    \"max_loops\": 1,\n    \"tools_list_dictionary\": [\n      {\n        \"name\": \"search\",\n        \"description\": \"Search the web for information\",\n        \"parameters\": {\n          \"query\": \"string\"\n        }\n      }\n    ],\n    \"mcp_url\": \"https://example-mcp.com\"\n  },\n  \"task\": \"Research the latest developments in quantum computing and summarize key findings\",\n  \"history\": {\n    \"previous_research\": \"Earlier findings on quantum computing basics...\",\n    \"user_preferences\": \"Focus on practical applications...\"\n  }\n}\n</code></pre></p> <p>Response: <pre><code>{\n  \"id\": \"agent-abc123xyz\",\n  \"success\": true,\n  \"name\": \"Research Assistant\",\n  \"description\": \"Specialized in research and analysis\",\n  \"temperature\": 0.5,\n  \"outputs\": {\n    \"research_summary\": \"...\",\n    \"key_findings\": [\n      \"...\"\n    ]\n  },\n  \"usage\": {\n    \"input_tokens\": 450,\n    \"output_tokens\": 850,\n    \"total_tokens\": 1300,\n    \"mcp_url\": 0.1\n  },\n  \"timestamp\": \"2024-03-05T12:34:56.789Z\"\n}\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#run-batch-agents","title":"Run Batch Agents","text":"<p>Execute multiple agent tasks in parallel.</p> <p>Endpoint: <code>/v1/agent/batch/completions</code> Method: POST Rate Limit: 100 requests per 60 seconds Maximum Batch Size: 10 requests Input A list of <code>AgentCompeletion</code> inputs</p> Shell (curl)Python (requests)TypeScript (fetch) <pre><code>curl -X POST \"https://api.swarms.world/v1/agent/batch/completions\" \\\n     -H \"x-api-key: your_api_key_here\" \\\n     -H \"Content-Type: application/json\" \\\n     -d '[\n       {\n         \"agent_config\": {\n           \"agent_name\": \"Market Analyst\",\n           \"description\": \"Expert in market analysis\",\n           \"system_prompt\": \"You are a financial market analyst.\",\n           \"model_name\": \"gpt-4o\",\n           \"temperature\": 0.3\n         },\n         \"task\": \"Analyze the current market trends in AI technology sector\"\n       },\n       {\n         \"agent_config\": {\n           \"agent_name\": \"Technical Writer\",\n           \"description\": \"Specialized in technical documentation\",\n           \"system_prompt\": \"You are a technical documentation expert.\",\n           \"model_name\": \"gpt-4o\",\n           \"temperature\": 0.7\n         },\n         \"task\": \"Create a technical guide for implementing OAuth2 authentication\"\n       }\n     ]'\n</code></pre> <pre><code>import requests\nimport json\n\nAPI_BASE_URL = \"https://api.swarms.world\"\nAPI_KEY = \"your_api_key_here\"\n\nheaders = {\n    \"x-api-key\": API_KEY,\n    \"Content-Type\": \"application/json\"\n}\n\nbatch_agents = [\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Market Analyst\",\n            \"description\": \"Expert in market analysis\",\n            \"system_prompt\": \"You are a financial market analyst.\",\n            \"model_name\": \"gpt-4o\",\n            \"temperature\": 0.3\n        },\n        \"task\": \"Analyze the current market trends in AI technology sector\"\n    },\n    {\n        \"agent_config\": {\n            \"agent_name\": \"Technical Writer\",\n            \"description\": \"Specialized in technical documentation\",\n            \"system_prompt\": \"You are a technical documentation expert.\",\n            \"model_name\": \"gpt-4o\",\n            \"temperature\": 0.7\n        },\n        \"task\": \"Create a technical guide for implementing OAuth2 authentication\"\n    }\n]\n\nresponse = requests.post(\n    f\"{API_BASE_URL}/v1/agent/batch/completions\",\n    headers=headers,\n    json=batch_agents\n)\n\nif response.status_code == 200:\n    result = response.json()\n    print(f\"Batch completed with {result['total_requests']} agents\")\n    print(f\"Execution time: {result['execution_time']} seconds\")\n    print(\"\\nResults:\")\n    for i, agent_result in enumerate(result['results']):\n        print(f\"  Agent {i+1}: {agent_result['name']} - {agent_result['success']}\")\nelse:\n    print(f\"Error: {response.status_code} - {response.text}\")\n</code></pre> <pre><code>interface AgentConfig {\n    agent_name: string;\n    description: string;\n    system_prompt: string;\n    model_name: string;\n    temperature: number;\n}\n\ninterface AgentCompletion {\n    agent_config: AgentConfig;\n    task: string;\n}\n\nconst API_BASE_URL = \"https://api.swarms.world\";\nconst API_KEY = \"your_api_key_here\";\n\nasync function runBatchAgents(): Promise&lt;void&gt; {\n    const batchAgents: AgentCompletion[] = [\n        {\n            agent_config: {\n                agent_name: \"Market Analyst\",\n                description: \"Expert in market analysis\",\n                system_prompt: \"You are a financial market analyst.\",\n                model_name: \"gpt-4o\",\n                temperature: 0.3\n            },\n            task: \"Analyze the current market trends in AI technology sector\"\n        },\n        {\n            agent_config: {\n                agent_name: \"Technical Writer\",\n                description: \"Specialized in technical documentation\",\n                system_prompt: \"You are a technical documentation expert.\",\n                model_name: \"gpt-4o\",\n                temperature: 0.7\n            },\n            task: \"Create a technical guide for implementing OAuth2 authentication\"\n        }\n    ];\n\n    try {\n        const response = await fetch(`${API_BASE_URL}/v1/agent/batch/completions`, {\n            method: 'POST',\n            headers: {\n                'x-api-key': API_KEY,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(batchAgents)\n        });\n\n        if (response.ok) {\n            const result = await response.json();\n            console.log(`Batch completed with ${result.total_requests} agents`);\n            console.log(`Execution time: ${result.execution_time} seconds`);\n            console.log(\"\\nResults:\");\n            result.results.forEach((agentResult: any, index: number) =&gt; {\n                console.log(`  Agent ${index + 1}: ${agentResult.name} - ${agentResult.success}`);\n            });\n        } else {\n            console.error(`Error: ${response.status} - ${await response.text()}`);\n        }\n    } catch (error) {\n        console.error(\"Request failed:\", error);\n    }\n}\n\nrunBatchAgents();\n</code></pre> <p>Response: <pre><code>{\n  \"batch_id\": \"agent-batch-xyz789\",\n  \"total_requests\": 2,\n  \"execution_time\": 15.5,\n  \"timestamp\": \"2024-03-05T12:34:56.789Z\",\n  \"results\": [\n    {\n      \"id\": \"agent-abc123\",\n      \"success\": true,\n      \"name\": \"Market Analyst\",\n      \"outputs\": {\n        \"market_analysis\": \"...\"\n      },\n      \"usage\": {\n        \"input_tokens\": 300,\n        \"output_tokens\": 600,\n        \"total_tokens\": 900\n      }\n    },\n    {\n      \"id\": \"agent-def456\",\n      \"success\": true,\n      \"name\": \"Technical Writer\",\n      \"outputs\": {\n        \"technical_guide\": \"...\"\n      },\n      \"usage\": {\n        \"input_tokens\": 400,\n        \"output_tokens\": 800,\n        \"total_tokens\": 1200\n      }\n    }\n  ]\n}\n</code></pre></p>"},{"location":"swarms_cloud/swarms_api/#production-examples","title":"Production Examples","text":""},{"location":"swarms_cloud/swarms_api/#error-handling","title":"Error Handling","text":"<p>The Swarms API follows standard HTTP status codes for error responses:</p> Status Code Meaning Handling Strategy 400 Bad Request Validate request parameters before sending 401 Unauthorized Check API key validity 403 Forbidden Verify API key permissions 404 Not Found Check endpoint URL and resource IDs 429 Too Many Requests Implement exponential backoff retry logic 500 Internal Server Error Retry with backoff, then contact support <p>Error responses include a detailed message explaining the issue:</p> <pre><code>{\n  \"detail\": \"Failed to create swarm: Invalid swarm_type specified\"\n}\n</code></pre>"},{"location":"swarms_cloud/swarms_api/#rate-limiting","title":"Rate Limiting","text":"Description Details Rate Limit 100 requests per 60-second window Exceed Consequence 429 status code returned Recommended Action Implement retry logic with exponential backoff"},{"location":"swarms_cloud/swarms_api/#billing-cost-management","title":"Billing &amp; Cost Management","text":"Cost Factor Description Agent Count Base cost per agent Input Tokens Cost based on size of input data and prompts Output Tokens Cost based on length of generated responses Time of Day Reduced rates during nighttime hours (8 PM to 6 AM PT) Cost Information Included in each response's metadata"},{"location":"swarms_cloud/swarms_api/#best-practices","title":"Best Practices","text":""},{"location":"swarms_cloud/swarms_api/#task-description","title":"Task Description","text":"Practice Description Detail Provide detailed, specific task descriptions Context Include all necessary context and constraints Structure Structure complex inputs for easier processing"},{"location":"swarms_cloud/swarms_api/#agent-configuration","title":"Agent Configuration","text":"Practice Description Simple Tasks Use <code>AutoSwarmBuilder</code> for automatic agent generation Complex Tasks Manually define agents with specific expertise Workflow Use appropriate <code>swarm_type</code> for your workflow pattern"},{"location":"swarms_cloud/swarms_api/#production-implementation","title":"Production Implementation","text":"Practice Description Error Handling Implement robust error handling and retries Logging Log API responses for debugging and auditing Cost Monitoring Monitor costs closely during development and testing"},{"location":"swarms_cloud/swarms_api/#cost-optimization","title":"Cost Optimization","text":"Practice Description Batching Batch related tasks when possible Scheduling Schedule non-urgent tasks during discount hours Scoping Carefully scope task descriptions to reduce token usage Caching Cache results when appropriate"},{"location":"swarms_cloud/swarms_api/#support","title":"Support","text":"Support Type Contact Information Documentation https://docs.swarms.world Email kye@swarms.world Community https://discord.gg/jM3Z6M9uMq Marketplace https://swarms.world Website https://swarms.ai"},{"location":"swarms_cloud/swarms_api/#service-tiers","title":"Service Tiers","text":""},{"location":"swarms_cloud/swarms_api/#standard-tier","title":"Standard Tier","text":"Feature Description Processing Default processing tier Execution Immediate execution Priority Higher priority processing Pricing Standard pricing Timeout 5-minute timeout limit"},{"location":"swarms_cloud/swarms_api/#flex-tier","title":"Flex Tier","text":"Feature Description Cost Lower cost processing Retries Automatic retries (up to 3 attempts) Timeout 15-minute timeout Discount 75% discount on token costs Suitability Best for non-urgent tasks Backoff Exponential backoff on resource contention Configuration Set <code>service_tier: \"flex\"</code> in SwarmSpec"},{"location":"swarms_cloud/swarms_api_tools/","title":"Swarms API with Tools Guide","text":"<p>Swarms API allows you to create and manage AI agent swarms with optional tool integration. This guide will walk you through setting up and using the Swarms API with tools.</p>"},{"location":"swarms_cloud/swarms_api_tools/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.7+</li> <li>Swarms API key</li> <li>Required Python packages:</li> <li> <p><code>requests</code></p> </li> <li> <p><code>python-dotenv</code></p> </li> </ul>"},{"location":"swarms_cloud/swarms_api_tools/#installation-setup","title":"Installation &amp; Setup","text":"<ol> <li>Install required packages:</li> </ol> <pre><code>pip install requests python-dotenv\n</code></pre> <ol> <li>Create a <code>.env</code> file in your project root:</li> </ol> <pre><code>SWARMS_API_KEY=your_api_key_here\n</code></pre> <ol> <li>Basic setup code:</li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\nheaders = {\"x-api-key\": API_KEY, \"Content-Type\": \"application/json\"}\n</code></pre>"},{"location":"swarms_cloud/swarms_api_tools/#creating-a-swarm-with-tools","title":"Creating a Swarm with Tools","text":""},{"location":"swarms_cloud/swarms_api_tools/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li> <p>Define your tool dictionary: <pre><code>tool_dictionary = {\n    \"type\": \"function\",\n    \"function\": {\n        \"name\": \"search_topic\",\n        \"description\": \"Conduct an in-depth search on a specified topic\",\n        \"parameters\": {\n            \"type\": \"object\",\n            \"properties\": {\n                \"depth\": {\n                    \"type\": \"integer\",\n                    \"description\": \"Search depth (1-3)\"\n                },\n                \"detailed_queries\": {\n                    \"type\": \"array\",\n                    \"items\": {\n                        \"type\": \"string\",\n                        \"description\": \"Specific search queries\"\n                    }\n                }\n            },\n            \"required\": [\"depth\", \"detailed_queries\"]\n        }\n    }\n}\n</code></pre></p> </li> <li> <p>Create agent configurations: <pre><code>agent_config = {\n    \"agent_name\": \"Market Analyst\",\n    \"description\": \"Analyzes market trends\",\n    \"system_prompt\": \"You are a financial analyst expert.\",\n    \"model_name\": \"openai/gpt-4\",\n    \"role\": \"worker\",\n    \"max_loops\": 1,\n    \"max_tokens\": 8192,\n    \"temperature\": 0.5,\n    \"auto_generate_prompt\": False,\n    \"tools_dictionary\": [tool_dictionary]  # Optional: Add tools if needed\n}\n</code></pre></p> </li> <li> <p>Create the swarm payload: <pre><code>payload = {\n    \"name\": \"Your Swarm Name\",\n    \"description\": \"Swarm description\",\n    \"agents\": [agent_config],\n    \"max_loops\": 1,\n    \"swarm_type\": \"ConcurrentWorkflow\",\n    \"task\": \"Your task description\",\n    \"output_type\": \"dict\"\n}\n</code></pre></p> </li> <li> <p>Make the API request: <pre><code>def run_swarm(payload):\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre></p> </li> </ol>"},{"location":"swarms_cloud/swarms_api_tools/#faq","title":"FAQ","text":""},{"location":"swarms_cloud/swarms_api_tools/#do-all-agents-need-tools","title":"Do all agents need tools?","text":"<p>No, tools are optional for each agent. You can choose which agents have tools based on your specific needs. Simply omit the <code>tools_dictionary</code> field for agents that don't require tools.</p>"},{"location":"swarms_cloud/swarms_api_tools/#what-types-of-tools-can-i-use","title":"What types of tools can I use?","text":"<p>Currently, the API supports function-type tools. Each tool must have: - A unique name</p> <ul> <li> <p>A clear description</p> </li> <li> <p>Well-defined parameters with types and descriptions</p> </li> </ul>"},{"location":"swarms_cloud/swarms_api_tools/#can-i-mix-agents-with-and-without-tools","title":"Can I mix agents with and without tools?","text":"<p>Yes, you can create swarms with a mix of tool-enabled and regular agents. This allows for flexible swarm architectures.</p>"},{"location":"swarms_cloud/swarms_api_tools/#whats-the-recommended-number-of-tools-per-agent","title":"What's the recommended number of tools per agent?","text":"<p>While there's no strict limit, it's recommended to:</p> <ul> <li> <p>Keep tools focused and specific</p> </li> <li> <p>Only include tools that the agent needs</p> </li> <li> <p>Consider the complexity of tool interactions</p> </li> </ul>"},{"location":"swarms_cloud/swarms_api_tools/#example-implementation","title":"Example Implementation","text":"<p>Here's a complete example of a financial analysis swarm:</p> <pre><code>def run_financial_analysis_swarm():\n    payload = {\n        \"name\": \"Financial Analysis Swarm\",\n        \"description\": \"Market analysis swarm\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Market Analyst\",\n                \"description\": \"Analyzes market trends\",\n                \"system_prompt\": \"You are a financial analyst expert.\",\n                \"model_name\": \"openai/gpt-4\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False,\n                \"tools_dictionary\": [\n                    {\n                        \"type\": \"function\",\n                        \"function\": {\n                            \"name\": \"search_topic\",\n                            \"description\": \"Conduct market research\",\n                            \"parameters\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"depth\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Search depth (1-3)\"\n                                    },\n                                    \"detailed_queries\": {\n                                        \"type\": \"array\",\n                                        \"items\": {\"type\": \"string\"}\n                                    }\n                                },\n                                \"required\": [\"depth\", \"detailed_queries\"]\n                            }\n                        }\n                    }\n                ]\n            }\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"ConcurrentWorkflow\",\n        \"task\": \"Analyze top performing tech ETFs\",\n        \"output_type\": \"dict\"\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload\n    )\n    return response.json()\n</code></pre>"},{"location":"swarms_cloud/swarms_api_tools/#health-check","title":"Health Check","text":"<p>Always verify the API status before running swarms:</p> <pre><code>def check_api_health():\n    response = requests.get(f\"{BASE_URL}/health\", headers=headers)\n    return response.json()\n</code></pre>"},{"location":"swarms_cloud/swarms_api_tools/#best-practices","title":"Best Practices","text":"<ol> <li> <p>Error Handling: Always implement proper error handling: <pre><code>def safe_run_swarm(payload):\n    try:\n        response = requests.post(\n            f\"{BASE_URL}/v1/swarm/completions\",\n            headers=headers,\n            json=payload\n        )\n        response.raise_for_status()\n        return response.json()\n    except requests.exceptions.RequestException as e:\n        print(f\"Error running swarm: {e}\")\n        return None\n</code></pre></p> </li> <li> <p>Environment Variables: Never hardcode API keys</p> </li> <li> <p>Tool Design: Keep tools simple and focused</p> </li> <li> <p>Testing: Validate swarm configurations before production use</p> </li> </ol>"},{"location":"swarms_cloud/swarms_api_tools/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>API Key Issues</li> <li> <p>Verify key is correctly set in <code>.env</code></p> </li> <li> <p>Check key permissions</p> </li> <li> <p>Tool Execution Errors</p> </li> <li> <p>Validate tool parameters</p> </li> <li> <p>Check tool function signatures</p> </li> <li> <p>Response Timeout</p> </li> <li> <p>Consider reducing max_tokens</p> </li> <li> <p>Simplify tool complexity</p> </li> </ol> <pre><code>import os\nimport requests\nfrom dotenv import load_dotenv\nimport json\n\nload_dotenv()\n\nAPI_KEY = os.getenv(\"SWARMS_API_KEY\")\nBASE_URL = \"https://api.swarms.world\"\n\nheaders = {\"x-api-key\": API_KEY, \"Content-Type\": \"application/json\"}\n\n\ndef run_health_check():\n    response = requests.get(f\"{BASE_URL}/health\", headers=headers)\n    return response.json()\n\n\ndef run_single_swarm():\n    payload = {\n        \"name\": \"Financial Analysis Swarm\",\n        \"description\": \"Market analysis swarm\",\n        \"agents\": [\n            {\n                \"agent_name\": \"Market Analyst\",\n                \"description\": \"Analyzes market trends\",\n                \"system_prompt\": \"You are a financial analyst expert.\",\n                \"model_name\": \"openai/gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False,\n                \"tools_dictionary\": [\n                    {\n                        \"type\": \"function\",\n                        \"function\": {\n                            \"name\": \"search_topic\",\n                            \"description\": \"Conduct an in-depth search on a specified topic or subtopic, generating a comprehensive array of highly detailed search queries tailored to the input parameters.\",\n                            \"parameters\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"depth\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Indicates the level of thoroughness for the search. Values range from 1 to 3, where 1 represents a superficial search and 3 signifies an exploration of the topic.\",\n                                    },\n                                    \"detailed_queries\": {\n                                        \"type\": \"array\",\n                                        \"description\": \"An array of highly specific search queries that are generated based on the input query and the specified depth. Each query should be designed to elicit detailed and relevant information from various sources.\",\n                                        \"items\": {\n                                            \"type\": \"string\",\n                                            \"description\": \"Each item in this array should represent a unique search query that targets a specific aspect of the main topic, ensuring a comprehensive exploration of the subject matter.\",\n                                        },\n                                    },\n                                },\n                                \"required\": [\"depth\", \"detailed_queries\"],\n                            },\n                        },\n                    },\n                ],\n            },\n            {\n                \"agent_name\": \"Economic Forecaster\",\n                \"description\": \"Predicts economic trends\",\n                \"system_prompt\": \"You are an expert in economic forecasting.\",\n                \"model_name\": \"gpt-4o\",\n                \"role\": \"worker\",\n                \"max_loops\": 1,\n                \"max_tokens\": 8192,\n                \"temperature\": 0.5,\n                \"auto_generate_prompt\": False,\n                \"tools_dictionary\": [\n                    {\n                        \"type\": \"function\",\n                        \"function\": {\n                            \"name\": \"search_topic\",\n                            \"description\": \"Conduct an in-depth search on a specified topic or subtopic, generating a comprehensive array of highly detailed search queries tailored to the input parameters.\",\n                            \"parameters\": {\n                                \"type\": \"object\",\n                                \"properties\": {\n                                    \"depth\": {\n                                        \"type\": \"integer\",\n                                        \"description\": \"Indicates the level of thoroughness for the search. Values range from 1 to 3, where 1 represents a superficial search and 3 signifies an exploration of the topic.\",\n                                    },\n                                    \"detailed_queries\": {\n                                        \"type\": \"array\",\n                                        \"description\": \"An array of highly specific search queries that are generated based on the input query and the specified depth. Each query should be designed to elicit detailed and relevant information from various sources.\",\n                                        \"items\": {\n                                            \"type\": \"string\",\n                                            \"description\": \"Each item in this array should represent a unique search query that targets a specific aspect of the main topic, ensuring a comprehensive exploration of the subject matter.\",\n                                        },\n                                    },\n                                },\n                                \"required\": [\"depth\", \"detailed_queries\"],\n                            },\n                        },\n                    },\n                ],\n            },\n        ],\n        \"max_loops\": 1,\n        \"swarm_type\": \"ConcurrentWorkflow\",\n        \"task\": \"What are the best etfs and index funds for ai and tech?\",\n        \"output_type\": \"dict\",\n    }\n\n    response = requests.post(\n        f\"{BASE_URL}/v1/swarm/completions\",\n        headers=headers,\n        json=payload,\n    )\n\n    print(response)\n    print(response.status_code)\n    # return response.json()\n    output = response.json()\n\n    return json.dumps(output, indent=4)\n\n\nif __name__ == \"__main__\":\n    result = run_single_swarm()\n    print(\"Swarm Result:\")\n    print(result)\n</code></pre>"},{"location":"swarms_cloud/vision/","title":"The Swarms Cloud and Agent Marketplace","text":"<p>We stand at the dawn of a new era\u2014the Agentic Economy, where the power of intelligent automation is in the hands of everyone. The Swarms Cloud and Agent Marketplace will serve as the epicenter of this economy, enabling developers, businesses, and creators to easily publish, discover, and leverage intelligent agents. Our vision is to make publishing agents as simple as possible through an intuitive CLI, while empowering users to generate income by posting their APIs on the marketplace.</p> <p>The Swarms Marketplace is more than just a platform\u2014it\u2019s a revolutionary ecosystem that will change how we think about automation and intelligence. By building this platform, we aim to democratize access to agent-driven solutions, enabling a seamless bridge between creators and consumers of automation. With every agent posted to the marketplace, a ripple effect is created, driving innovation across industries and providing an unparalleled opportunity for monetization.</p>"},{"location":"swarms_cloud/vision/#the-agent-marketplace","title":"The Agent Marketplace","text":""},{"location":"swarms_cloud/vision/#a-unified-platform-for-automation","title":"A Unified Platform for Automation","text":"<p>In the Swarms Marketplace, agents will be the new currency of efficiency. Whether you\u2019re building agents for marketing, finance, customer service, or any other domain, the Swarms Cloud will allow you to showcase your agentic APIs, easily discoverable by anyone needing those capabilities.</p> <p>We envision the marketplace to function like an API store, where users can search for specific agent capabilities, purchase access to agents, or even integrate their existing systems with agent-based APIs that others have developed. Each agent you publish will come with a potential income stream as businesses and developers integrate your creations into their workflows.</p>"},{"location":"swarms_cloud/vision/#the-opportunity-to-monetize-your-apis","title":"The Opportunity to Monetize Your APIs","text":"<p>The Swarms Marketplace is designed to let developers and businesses generate income by sharing their agent APIs. Once your agent is published to the marketplace, other users can browse, test, and integrate it into their operations. You will be able to set custom pricing, usage tiers, and licensing terms for your API, ensuring you can profit from your innovations.</p> <p>Our vision for monetization includes:</p> <ul> <li> <p>API subscriptions: Allow users to subscribe to your agent API with recurring payments.</p> </li> <li> <p>Per-use pricing: Offer users a pay-as-you-go model where they only pay for the API calls they use.</p> </li> <li> <p>Licensing: Enable others to purchase full access to your agent for a set period or on a project basis.</p> </li> </ul>"},{"location":"swarms_cloud/vision/#publishing-agents-simplicity-through-cli","title":"Publishing Agents: Simplicity Through CLI","text":"<p>The complexity of deploying agents to a marketplace should never be a barrier. Our goal is to streamline the publishing process into something as simple as a command-line interaction. The Swarms CLI will be your one-stop solution to get your agent up and running on the marketplace.</p>"},{"location":"swarms_cloud/vision/#cli-workflow","title":"CLI Workflow:","text":"<ol> <li>Create an Agent: Build your agent using the Swarms framework or any custom framework of your choice.</li> <li>Set Agent Metadata: Through the CLI, input the metadata about your agent, including its capabilities, pricing, and target industries.</li> <li>Publish to Marketplace: Run the simple <code>swarms publish</code> command to instantly deploy your agent to the marketplace.</li> <li>Monitor Usage and Income: Use the Swarms Cloud dashboard to view your agent's interactions, track API usage, and receive payouts.</li> </ol> <p>Here\u2019s an example of how easy publishing will be:</p> <pre><code>$ swarms create-agent --name \"CustomerSupportAgent\" --type \"LLM\" \n$ swarms set-metadata --description \"An intelligent agent for customer support operations\" --pricing \"subscription\" --rate \"$20/month\"\n$ swarms publish\n</code></pre> <p>Within minutes, your agent will be live and accessible to the global marketplace!</p>"},{"location":"swarms_cloud/vision/#empowering-businesses","title":"Empowering Businesses","text":"<p>For businesses, the marketplace offers an unprecedented opportunity to automate tasks, integrate pre-built agents, and drastically cut operational costs. Companies no longer need to build every system from scratch. With the marketplace, they can simply discover and plug in the agentic solutions that best suit their needs.</p> <pre><code>graph TD\n    A[Build Agent] --&gt; B[Set Metadata]\n    B --&gt; C[Publish to Marketplace]\n    C --&gt; D{Agent Available Globally}\n    D --&gt; E[Developers Discover API]\n    D --&gt; F[Businesses Integrate API]\n    F --&gt; G[Revenue Stream for Agent Creator]\n    E --&gt; G</code></pre>"},{"location":"swarms_cloud/vision/#the-future-of-automation-agents-as-apis","title":"The Future of Automation: Agents as APIs","text":"<p>In this future we\u2019re creating, agents will be as ubiquitous as APIs. The Swarms Marketplace will be an expansive repository of intelligent agents, each contributing to the automation and streamlining of everyday tasks. Imagine a world where every business can access highly specific, pre-built intelligence for any task, from customer support to supply chain management, and integrate these agents into their processes in minutes.</p> <pre><code>graph LR\n    A[Search for Agent API] --&gt; B[Find Agent That Fits]\n    B --&gt; C[Purchase Access]\n    C --&gt; D[Integrate with Business System]\n    D --&gt; E[Business Operations Streamlined]</code></pre>"},{"location":"swarms_cloud/vision/#conclusion","title":"Conclusion","text":"<p>The Swarms Cloud and Agent Marketplace will usher in an agent-powered future, where automation is accessible to all, and monetization opportunities are boundless. Our vision is to create a space where developers can not only build and showcase their agents but can also create sustainable income streams from their creations. The CLI will remove the friction of deployment, and the marketplace will enable a self-sustaining ecosystem of agentic intelligence that powers the next generation of automation. </p> <p>Together, we will shape the Agentic Economy, where collaboration, innovation, and financial opportunity intersect. Welcome to the future of intelligent automation. Welcome to Swarms Cloud.</p>"},{"location":"swarms_memory/","title":"Announcing the Release of Swarms-Memory Package: Your Gateway to Efficient RAG Systems","text":"<p>We are thrilled to announce the release of the Swarms-Memory package, a powerful and easy-to-use toolkit designed to facilitate the implementation of Retrieval-Augmented Generation (RAG) systems. Whether you're a seasoned AI practitioner or just starting out, Swarms-Memory provides the tools you need to integrate high-performance, reliable RAG systems into your applications seamlessly.</p> <p>In this blog post, we'll walk you through getting started with the Swarms-Memory package, covering installation, usage examples, and a detailed overview of supported RAG systems like Pinecone and ChromaDB. Let's dive in!</p>"},{"location":"swarms_memory/#what-is-swarms-memory","title":"What is Swarms-Memory?","text":"<p>Swarms-Memory is a Python package that simplifies the integration of advanced RAG systems into your projects. It supports multiple databases optimized for AI tasks, providing you with the flexibility to choose the best system for your needs. With Swarms-Memory, you can effortlessly handle large-scale AI tasks, vector searches, and more.</p>"},{"location":"swarms_memory/#key-features","title":"Key Features","text":"<ul> <li>Easy Integration: Quickly set up and start using powerful RAG systems.</li> <li>Customizable: Define custom embedding, preprocessing, and postprocessing functions.</li> <li>Flexible: Supports multiple RAG systems like ChromaDB and Pinecone, with more coming soon.</li> <li>Scalable: Designed to handle large-scale AI tasks efficiently.</li> </ul>"},{"location":"swarms_memory/#supported-rag-systems","title":"Supported RAG Systems","text":"<p>Here's an overview of the RAG systems currently supported by Swarms-Memory:</p> RAG System Status Description Documentation Website ChromaDB Available A high-performance, distributed database optimized for handling large-scale AI tasks. ChromaDB Documentation ChromaDB Pinecone Available A fully managed vector database for adding vector search to your applications. Pinecone Documentation Pinecone Redis Coming Soon An open-source, in-memory data structure store, used as a database, cache, and broker. Redis Documentation Redis Faiss Coming Soon A library for efficient similarity search and clustering of dense vectors by Facebook AI. Faiss Documentation Faiss HNSW Coming Soon A graph-based algorithm for approximate nearest neighbor search, known for speed. HNSW Documentation HNSW"},{"location":"swarms_memory/#getting-started","title":"Getting Started","text":""},{"location":"swarms_memory/#requirements","title":"Requirements","text":"<p>Before you begin, ensure you have the following:</p> <ul> <li>Python 3.10</li> <li><code>.env</code> file with your respective API keys (e.g., <code>PINECONE_API_KEY</code>)</li> </ul>"},{"location":"swarms_memory/#installation","title":"Installation","text":"<p>You can install the Swarms-Memory package using pip:</p> <pre><code>$ pip install swarms-memory\n</code></pre>"},{"location":"swarms_memory/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms_memory/#pinecone","title":"Pinecone","text":"<p>Here's a step-by-step guide on how to use Pinecone with Swarms-Memory:</p> <ol> <li>Import Required Libraries:</li> </ol> <pre><code>from typing import List, Dict, Any\nfrom swarms_memory import PineconeMemory\n</code></pre> <ol> <li>Define Custom Functions:</li> </ol> <pre><code>from transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Custom embedding function using a HuggingFace model\ndef custom_embedding_function(text: str) -&gt; List[float]:\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-uncased\")\n    model = AutoModel.from_pretrained(\"bert-base-uncased\")\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True, max_length=512)\n    with torch.no_grad():\n        outputs = model(**inputs)\n    embeddings = outputs.last_hidden_state.mean(dim=1).squeeze().tolist()\n    return embeddings\n\n# Custom preprocessing function\ndef custom_preprocess(text: str) -&gt; str:\n    return text.lower().strip()\n\n# Custom postprocessing function\ndef custom_postprocess(results: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    for result in results:\n        result[\"custom_score\"] = result[\"score\"] * 2  # Example modification\n    return results\n</code></pre> <ol> <li>Initialize the Wrapper with Custom Functions:</li> </ol> <pre><code>wrapper = PineconeMemory(\n    api_key=\"your-api-key\",\n    environment=\"your-environment\",\n    index_name=\"your-index-name\",\n    embedding_function=custom_embedding_function,\n    preprocess_function=custom_preprocess,\n    postprocess_function=custom_postprocess,\n    logger_config={\n        \"handlers\": [\n            {\"sink\": \"custom_rag_wrapper.log\", \"rotation\": \"1 GB\"},\n            {\"sink\": lambda msg: print(f\"Custom log: {msg}\", end=\"\")},\n        ],\n    },\n)\n</code></pre> <ol> <li>Add Documents and Query:</li> </ol> <pre><code># Adding documents\nwrapper.add(\"This is a sample document about artificial intelligence.\", {\"category\": \"AI\"})\nwrapper.add(\"Python is a popular programming language for data science.\", {\"category\": \"Programming\"})\n\n# Querying\nresults = wrapper.query(\"What is AI?\", filter={\"category\": \"AI\"})\nfor result in results:\n    print(f\"Score: {result['score']}, Custom Score: {result['custom_score']}, Text: {result['metadata']['text']}\")\n</code></pre>"},{"location":"swarms_memory/#chromadb","title":"ChromaDB","text":"<p>Using ChromaDB with Swarms-Memory is straightforward. Here\u2019s how:</p> <ol> <li>Import ChromaDB:</li> </ol> <pre><code>from swarms_memory import ChromaDB\n</code></pre> <ol> <li>Initialize ChromaDB:</li> </ol> <pre><code>chromadb = ChromaDB(\n    metric=\"cosine\",\n    output_dir=\"results\",\n    limit_tokens=1000,\n    n_results=2,\n    docs_folder=\"path/to/docs\",\n    verbose=True,\n)\n</code></pre> <ol> <li>Add and Query Documents:</li> </ol> <pre><code># Add a document\ndoc_id = chromadb.add(\"This is a test document.\")\n\n# Query the document\nresult = chromadb.query(\"This is a test query.\")\n\n# Traverse a directory\nchromadb.traverse_directory()\n\n# Display the result\nprint(result)\n</code></pre>"},{"location":"swarms_memory/#join-the-community","title":"Join the Community","text":"<p>We're excited to see how you leverage Swarms-Memory in your projects! Join our community on Discord to share your experiences, ask questions, and stay updated on the latest developments.</p> <ul> <li>\ud83d\udc26 Twitter: Follow us on Twitter</li> <li>\ud83d\udce2 Discord: Join the Agora Discord</li> <li>Swarms Platform: Visit our website</li> <li>\ud83d\udcd9 Documentation: Read the Docs</li> </ul>"},{"location":"swarms_memory/#conclusion","title":"Conclusion","text":"<p>The Swarms-Memory package brings a new level of ease and efficiency to building and managing RAG systems. With support for leading databases like ChromaDB and Pinecone, it's never been easier to integrate powerful, scalable AI solutions into your projects. We can't wait to see what you'll create with Swarms-Memory!</p> <p>For more detailed usage examples and documentation, visit our GitHub repository and start exploring today!</p>"},{"location":"swarms_memory/chromadb/","title":"ChromaDB Documentation","text":"<p>ChromaDB is a specialized module designed to facilitate the storage and retrieval of documents using the ChromaDB system. It offers functionalities for adding documents to a local ChromaDB collection and querying this collection based on provided query texts. This module integrates with the ChromaDB client to create and manage collections, leveraging various configurations for optimizing the storage and retrieval processes.</p>"},{"location":"swarms_memory/chromadb/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>metric</code> <code>str</code> <code>\"cosine\"</code> The similarity metric to use for the collection. <code>output_dir</code> <code>str</code> <code>\"swarms\"</code> The name of the collection to store the results in. <code>limit_tokens</code> <code>Optional[int]</code> <code>1000</code> The maximum number of tokens to use for the query. <code>n_results</code> <code>int</code> <code>1</code> The number of results to retrieve. <code>docs_folder</code> <code>Optional[str]</code> <code>None</code> The folder containing documents to be added to the collection. <code>verbose</code> <code>bool</code> <code>False</code> Flag to enable verbose logging for debugging. <code>*args</code> <code>tuple</code> <code>()</code> Additional positional arguments. <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional keyword arguments."},{"location":"swarms_memory/chromadb/#methods","title":"Methods","text":"Method Description <code>__init__</code> Initializes the ChromaDB instance with specified parameters. <code>add</code> Adds a document to the ChromaDB collection. <code>query</code> Queries documents from the ChromaDB collection based on the query text. <code>traverse_directory</code> Traverses the specified directory to add documents to the collection."},{"location":"swarms_memory/chromadb/#usage","title":"Usage","text":"<pre><code>from swarms_memory import ChromaDB\n\nchromadb = ChromaDB(\n    metric=\"cosine\",\n    output_dir=\"results\",\n    limit_tokens=1000,\n    n_results=2,\n    docs_folder=\"path/to/docs\",\n    verbose=True,\n)\n</code></pre>"},{"location":"swarms_memory/chromadb/#adding-documents","title":"Adding Documents","text":"<p>The <code>add</code> method allows you to add a document to the ChromaDB collection. It generates a unique ID for each document and adds it to the collection.</p>"},{"location":"swarms_memory/chromadb/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>document</code> <code>str</code> - The document to be added to the collection. <code>*args</code> <code>tuple</code> <code>()</code> Additional positional arguments. <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional keyword arguments."},{"location":"swarms_memory/chromadb/#returns","title":"Returns","text":"Type Description <code>str</code> The ID of the added document."},{"location":"swarms_memory/chromadb/#example","title":"Example","text":"<pre><code>task = \"example_task\"\nresult = \"example_result\"\nresult_id = chromadb.add(document=\"This is a sample document.\")\nprint(f\"Document ID: {result_id}\")\n</code></pre>"},{"location":"swarms_memory/chromadb/#querying-documents","title":"Querying Documents","text":"<p>The <code>query</code> method allows you to retrieve documents from the ChromaDB collection based on the provided query text.</p>"},{"location":"swarms_memory/chromadb/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>query_text</code> <code>str</code> - The query string to search for. <code>*args</code> <code>tuple</code> <code>()</code> Additional positional arguments. <code>**kwargs</code> <code>dict</code> <code>{}</code> Additional keyword arguments."},{"location":"swarms_memory/chromadb/#returns_1","title":"Returns","text":"Type Description <code>str</code> The retrieved documents as a string."},{"location":"swarms_memory/chromadb/#example_1","title":"Example","text":"<pre><code>query_text = \"search term\"\nresults = chromadb.query(query_text=query_text)\nprint(f\"Retrieved Documents: {results}\")\n</code></pre>"},{"location":"swarms_memory/chromadb/#traversing-directory","title":"Traversing Directory","text":"<p>The <code>traverse_directory</code> method traverses through every file in the specified directory and its subdirectories, adding the contents of each file to the ChromaDB collection.</p>"},{"location":"swarms_memory/chromadb/#example_2","title":"Example","text":"<pre><code>chromadb.traverse_directory()\n</code></pre>"},{"location":"swarms_memory/chromadb/#additional-information-and-tips","title":"Additional Information and Tips","text":""},{"location":"swarms_memory/chromadb/#verbose-logging","title":"Verbose Logging","text":"<p>Enable the <code>verbose</code> flag during initialization to get detailed logs of the operations, which is useful for debugging.</p> <pre><code>chromadb = ChromaDB(verbose=True)\n</code></pre>"},{"location":"swarms_memory/chromadb/#handling-large-documents","title":"Handling Large Documents","text":"<p>When dealing with large documents, consider using the <code>limit_tokens</code> parameter to restrict the number of tokens processed in a single query.</p> <pre><code>chromadb = ChromaDB(limit_tokens=500)\n</code></pre>"},{"location":"swarms_memory/chromadb/#optimizing-query-performance","title":"Optimizing Query Performance","text":"<p>Use the appropriate similarity metric (<code>metric</code> parameter) that suits your use case for optimal query performance.</p> <pre><code>chromadb = ChromaDB(metric=\"euclidean\")\n</code></pre>"},{"location":"swarms_memory/chromadb/#references-and-resources","title":"References and Resources","text":"<ul> <li>ChromaDB Documentation</li> <li>Python UUID Module</li> <li>Python os Module</li> <li>Python logging Module</li> <li>dotenv Package</li> </ul> <p>By following this documentation, users can effectively utilize the ChromaDB module for managing document storage and retrieval in their applications.</p>"},{"location":"swarms_memory/faiss/","title":"FAISSDB: Documentation","text":"<p>The <code>FAISSDB</code> class is a highly customizable wrapper for the FAISS (Facebook AI Similarity Search) library, designed for efficient similarity search and clustering of dense vectors. This class facilitates the creation of a Retrieval-Augmented Generation (RAG) system by providing methods to add documents to a FAISS index and query the index for similar documents. It supports custom embedding models, preprocessing functions, and other customizations to fit various use cases.</p>"},{"location":"swarms_memory/faiss/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>dimension</code> <code>int</code> <code>768</code> Dimension of the document embeddings. <code>index_type</code> <code>str</code> <code>'Flat'</code> Type of FAISS index to use (<code>'Flat'</code> or <code>'IVF'</code>). <code>embedding_model</code> <code>Optional[Any]</code> <code>None</code> Custom embedding model. <code>embedding_function</code> <code>Optional[Callable[[str], List[float]]]</code> <code>None</code> Custom function to generate embeddings from text. <code>preprocess_function</code> <code>Optional[Callable[[str], str]]</code> <code>None</code> Custom function to preprocess text before embedding. <code>postprocess_function</code> <code>Optional[Callable[[List[Dict[str, Any]]], List[Dict[str, Any]]]]</code> <code>None</code> Custom function to postprocess the results. <code>metric</code> <code>str</code> <code>'cosine'</code> Distance metric for FAISS index (<code>'cosine'</code> or <code>'l2'</code>). <code>logger_config</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Configuration for the logger."},{"location":"swarms_memory/faiss/#methods","title":"Methods","text":""},{"location":"swarms_memory/faiss/#__init__","title":"<code>__init__</code>","text":"<p>Initializes the FAISSDB instance, setting up the logger, creating the FAISS index, and configuring custom functions if provided.</p>"},{"location":"swarms_memory/faiss/#add","title":"<code>add</code>","text":"<p>Adds a document to the FAISS index.</p>"},{"location":"swarms_memory/faiss/#parameters_1","title":"Parameters","text":"Parameter Type Default Description <code>doc</code> <code>str</code> None The document to be added. <code>metadata</code> <code>Optional[Dict[str, Any]]</code> None Additional metadata for the document."},{"location":"swarms_memory/faiss/#example-usage","title":"Example Usage","text":"<pre><code>db = FAISSDB(dimension=768)\ndb.add(\"This is a sample document.\", {\"category\": \"sample\"})\n</code></pre>"},{"location":"swarms_memory/faiss/#query","title":"<code>query</code>","text":"<p>Queries the FAISS index for similar documents.</p>"},{"location":"swarms_memory/faiss/#parameters_2","title":"Parameters","text":"Parameter Type Default Description <code>query</code> <code>str</code> None The query string. <code>top_k</code> <code>int</code> <code>5</code> The number of top results to return."},{"location":"swarms_memory/faiss/#returns","title":"Returns","text":"Type Description <code>List[Dict[str, Any]]</code> A list of dictionaries containing the top_k most similar documents."},{"location":"swarms_memory/faiss/#example-usage_1","title":"Example Usage","text":"<pre><code>results = db.query(\"What is artificial intelligence?\")\nfor result in results:\n    print(f\"Score: {result['score']}, Text: {result['metadata']['text']}\")\n</code></pre>"},{"location":"swarms_memory/faiss/#internal-methods","title":"Internal Methods","text":""},{"location":"swarms_memory/faiss/#_setup_logger","title":"<code>_setup_logger</code>","text":"<p>Sets up the logger with the given configuration.</p>"},{"location":"swarms_memory/faiss/#parameters_3","title":"Parameters","text":"Parameter Type Default Description <code>config</code> <code>Optional[Dict[str, Any]]</code> None Configuration for the logger."},{"location":"swarms_memory/faiss/#_create_index","title":"<code>_create_index</code>","text":"<p>Creates and returns a FAISS index based on the specified type and metric.</p>"},{"location":"swarms_memory/faiss/#parameters_4","title":"Parameters","text":"Parameter Type Default Description <code>index_type</code> <code>str</code> 'Flat' Type of FAISS index to use. <code>metric</code> <code>str</code> 'cosine' Distance metric for FAISS index."},{"location":"swarms_memory/faiss/#returns_1","title":"Returns","text":"Type Description <code>faiss.Index</code> FAISS index instance."},{"location":"swarms_memory/faiss/#_default_embedding_function","title":"<code>_default_embedding_function</code>","text":"<p>Default embedding function using the SentenceTransformer model.</p>"},{"location":"swarms_memory/faiss/#parameters_5","title":"Parameters","text":"Parameter Type Default Description <code>text</code> <code>str</code> None The input text to embed."},{"location":"swarms_memory/faiss/#returns_2","title":"Returns","text":"Type Description <code>List[float]</code> Embedding vector for the input text."},{"location":"swarms_memory/faiss/#_default_preprocess_function","title":"<code>_default_preprocess_function</code>","text":"<p>Default preprocessing function.</p>"},{"location":"swarms_memory/faiss/#parameters_6","title":"Parameters","text":"Parameter Type Default Description <code>text</code> <code>str</code> None The input text to preprocess."},{"location":"swarms_memory/faiss/#returns_3","title":"Returns","text":"Type Description <code>str</code> Preprocessed text."},{"location":"swarms_memory/faiss/#_default_postprocess_function","title":"<code>_default_postprocess_function</code>","text":"<p>Default postprocessing function.</p>"},{"location":"swarms_memory/faiss/#parameters_7","title":"Parameters","text":"Parameter Type Default Description <code>results</code> <code>List[Dict[str, Any]]</code> None The results to postprocess."},{"location":"swarms_memory/faiss/#returns_4","title":"Returns","text":"Type Description <code>List[Dict[str, Any]]</code> Postprocessed results."},{"location":"swarms_memory/faiss/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms_memory/faiss/#example-1-basic-usage","title":"Example 1: Basic Usage","text":"<pre><code># Initialize the FAISSDB instance\ndb = FAISSDB(dimension=768, index_type=\"Flat\")\n\n# Add documents to the FAISS index\ndb.add(\"This is a document about AI.\", {\"category\": \"AI\"})\ndb.add(\"Python is great for data science.\", {\"category\": \"Programming\"})\n\n# Query the FAISS index\nresults = db.query(\"Tell me about AI\")\nfor result in results:\n    print(f\"Score: {result['score']}, Text: {result['metadata']['text']}\")\n</code></pre>"},{"location":"swarms_memory/faiss/#example-2-custom-functions","title":"Example 2: Custom Functions","text":"<pre><code>from transformers import AutoTokenizer, AutoModel\nimport torch\n\n# Custom embedding function using a HuggingFace model\ndef custom_embedding_function(text: str) -&gt; List[float]:\n    tokenizer = AutoTokenizer.from_pretrained(\"bert-base-uncased\")\n    model = AutoModel.from_pretrained(\"bert-base-uncased\")\n    inputs = tokenizer(text, return_tensors=\"pt\", padding=True, truncation=True, max_length=512)\n    with torch.no_grad():\n        outputs = model(**inputs)\n    embeddings = outputs.last_hidden_state.mean(dim=1).squeeze().tolist()\n    return embeddings\n\n# Custom preprocessing function\ndef custom_preprocess(text: str) -&gt; str:\n    return text.lower().strip()\n\n# Custom postprocessing function\ndef custom_postprocess(results: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]:\n    for result in results:\n        result[\"custom_score\"] = result[\"score\"] * 2  # Example modification\n    return results\n\n# Initialize the FAISSDB instance with custom functions\ndb = FAISSDB(\n    dimension=768,\n    index_type=\"Flat\",\n    embedding_function=custom_embedding_function,\n    preprocess_function=custom_preprocess,\n    postprocess_function=custom_postprocess,\n    metric=\"cosine\",\n    logger_config={\n        \"handlers\": [\n            {\"sink\": \"custom_faiss_rag_wrapper.log\", \"rotation\": \"1 GB\"},\n            {\"sink\": lambda msg: print(f\"Custom log: {msg}\", end=\"\")}\n        ],\n    },\n)\n\n# Add documents to the FAISS index\ndb.add(\"This is a document about machine learning.\", {\"category\": \"ML\"})\ndb.add(\"Python is a versatile programming language.\", {\"category\": \"Programming\"})\n\n# Query the FAISS index\nresults = db.query(\"Explain machine learning\")\nfor result in results:\n    print(f\"Score: {result['score']}, Custom Score: {result['custom_score']}, Text: {result['metadata']['text']}\")\n</code></pre>"},{"location":"swarms_memory/faiss/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Ensure that the dimension of the document embeddings matches the dimension specified during the initialization of the FAISSDB instance.</li> <li>Use custom embedding functions to leverage domain-specific models for generating embeddings.</li> <li>Custom preprocessing and postprocessing functions can help tailor the text processing and</li> </ul> <p>result formatting to specific needs. - FAISS supports various types of indices; choose the one that best fits the application requirements (e.g., <code>Flat</code> for brute-force search, <code>IVF</code> for faster search with some accuracy trade-off). - Properly configure the logger to monitor and debug the operations of the FAISSDB instance.</p>"},{"location":"swarms_memory/faiss/#references-and-resources","title":"References and Resources","text":"<ul> <li>FAISS GitHub Repository</li> <li>Sentence Transformers Documentation</li> <li>Loguru Documentation</li> <li>HuggingFace Transformers</li> </ul> <p>By following this documentation, users can effectively utilize the <code>FAISSDB</code> class for various similarity search and document retrieval tasks, customizing it to their specific needs through the provided hooks and functions.</p>"},{"location":"swarms_memory/pinecone/","title":"PineconeMemory Documentation","text":"<p>The <code>PineconeMemory</code> class provides a robust interface for integrating Pinecone-based Retrieval-Augmented Generation (RAG) systems. It allows for adding documents to a Pinecone index and querying the index for similar documents. The class supports custom embedding models, preprocessing functions, and other customizations to suit different use cases.</p>"},{"location":"swarms_memory/pinecone/#parameters","title":"Parameters","text":"Parameter Type Default Description <code>api_key</code> <code>str</code> - Pinecone API key. <code>environment</code> <code>str</code> - Pinecone environment. <code>index_name</code> <code>str</code> - Name of the Pinecone index to use. <code>dimension</code> <code>int</code> <code>768</code> Dimension of the document embeddings. <code>embedding_model</code> <code>Optional[Any]</code> <code>None</code> Custom embedding model. Defaults to <code>SentenceTransformer('all-MiniLM-L6-v2')</code>. <code>embedding_function</code> <code>Optional[Callable[[str], List[float]]]</code> <code>None</code> Custom embedding function. Defaults to <code>_default_embedding_function</code>. <code>preprocess_function</code> <code>Optional[Callable[[str], str]]</code> <code>None</code> Custom preprocessing function. Defaults to <code>_default_preprocess_function</code>. <code>postprocess_function</code> <code>Optional[Callable[[List[Dict[str, Any]]], List[Dict[str, Any]]]]</code> <code>None</code> Custom postprocessing function. Defaults to <code>_default_postprocess_function</code>. <code>metric</code> <code>str</code> <code>'cosine'</code> Distance metric for Pinecone index. <code>pod_type</code> <code>str</code> <code>'p1'</code> Pinecone pod type. <code>namespace</code> <code>str</code> <code>''</code> Pinecone namespace. <code>logger_config</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Configuration for the logger. Defaults to logging to <code>rag_wrapper.log</code> and console output."},{"location":"swarms_memory/pinecone/#methods","title":"Methods","text":""},{"location":"swarms_memory/pinecone/#_setup_logger","title":"<code>_setup_logger</code>","text":"<pre><code>def _setup_logger(self, config: Optional[Dict[str, Any]] = None)\n</code></pre> <p>Sets up the logger with the given configuration.</p>"},{"location":"swarms_memory/pinecone/#_default_embedding_function","title":"<code>_default_embedding_function</code>","text":"<pre><code>def _default_embedding_function(self, text: str) -&gt; List[float]\n</code></pre> <p>Generates embeddings using the default SentenceTransformer model.</p>"},{"location":"swarms_memory/pinecone/#_default_preprocess_function","title":"<code>_default_preprocess_function</code>","text":"<pre><code>def _default_preprocess_function(self, text: str) -&gt; str\n</code></pre> <p>Preprocesses the input text by stripping whitespace.</p>"},{"location":"swarms_memory/pinecone/#_default_postprocess_function","title":"<code>_default_postprocess_function</code>","text":"<pre><code>def _default_postprocess_function(self, results: List[Dict[str, Any]]) -&gt; List[Dict[str, Any]]\n</code></pre> <p>Postprocesses the query results.</p>"},{"location":"swarms_memory/pinecone/#add","title":"<code>add</code>","text":"<p>Adds a document to the Pinecone index.</p> Parameter Type Default Description <code>doc</code> <code>str</code> - The document to be added. <code>metadata</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Additional metadata for the document."},{"location":"swarms_memory/pinecone/#query","title":"<code>query</code>","text":"<p>Queries the Pinecone index for similar documents.</p> Parameter Type Default Description <code>query</code> <code>str</code> - The query string. <code>top_k</code> <code>int</code> <code>5</code> The number of top results to return. <code>filter</code> <code>Optional[Dict[str, Any]]</code> <code>None</code> Metadata filter for the query."},{"location":"swarms_memory/pinecone/#usage","title":"Usage","text":"<p>The <code>PineconeMemory</code> class is initialized with the necessary parameters to configure Pinecone and the embedding model. It supports a variety of custom configurations to suit different needs.</p>"},{"location":"swarms_memory/pinecone/#example","title":"Example","text":"<pre><code>from swarms_memory import PineconeMemory\n\n# Initialize PineconeMemory\nmemory = PineconeMemory(\n    api_key=\"your-api-key\",\n    environment=\"us-west1-gcp\",\n    index_name=\"example-index\",\n    dimension=768\n)\n</code></pre>"},{"location":"swarms_memory/pinecone/#adding-documents","title":"Adding Documents","text":"<p>Documents can be added to the Pinecone index using the <code>add</code> method. The method accepts a document string and optional metadata.</p>"},{"location":"swarms_memory/pinecone/#example_1","title":"Example","text":"<pre><code>doc = \"This is a sample document to be added to the Pinecone index.\"\nmetadata = {\"author\": \"John Doe\", \"date\": \"2024-07-08\"}\n\nmemory.add(doc, metadata)\n</code></pre>"},{"location":"swarms_memory/pinecone/#querying-documents","title":"Querying Documents","text":"<p>The <code>query</code> method allows for querying the Pinecone index for similar documents based on a query string. It returns the top <code>k</code> most similar documents.</p>"},{"location":"swarms_memory/pinecone/#example_2","title":"Example","text":"<pre><code>query = \"Sample query to find similar documents.\"\nresults = memory.query(query, top_k=5)\n\nfor result in results:\n    print(result)\n</code></pre>"},{"location":"swarms_memory/pinecone/#additional-information-and-tips","title":"Additional Information and Tips","text":""},{"location":"swarms_memory/pinecone/#custom-embedding-and-preprocessing-functions","title":"Custom Embedding and Preprocessing Functions","text":"<p>Custom embedding and preprocessing functions can be provided during initialization to tailor the document processing to specific requirements.</p>"},{"location":"swarms_memory/pinecone/#example_3","title":"Example","text":"<pre><code>def custom_embedding_function(text: str) -&gt; List[float]:\n    # Custom embedding logic\n    return [0.1, 0.2, 0.3]\n\ndef custom_preprocess_function(text: str) -&gt; str:\n    # Custom preprocessing logic\n    return text.lower()\n\nmemory = PineconeMemory(\n    api_key=\"your-api-key\",\n    environment=\"us-west1-gcp\",\n    index_name=\"example-index\",\n    embedding_function=custom_embedding_function,\n    preprocess_function=custom_preprocess_function\n)\n</code></pre>"},{"location":"swarms_memory/pinecone/#logger-configuration","title":"Logger Configuration","text":"<p>The logger can be configured to suit different logging needs. The default configuration logs to a file and the console.</p>"},{"location":"swarms_memory/pinecone/#example_4","title":"Example","text":"<pre><code>logger_config = {\n    \"handlers\": [\n        {\"sink\": \"custom_log.log\", \"rotation\": \"1 MB\"},\n        {\"sink\": lambda msg: print(msg, end=\"\")},\n    ]\n}\n\nmemory = PineconeMemory(\n    api_key=\"your-api-key\",\n    environment=\"us-west1-gcp\",\n    index_name=\"example-index\",\n    logger_config=logger_config\n)\n</code></pre>"},{"location":"swarms_memory/pinecone/#references-and-resources","title":"References and Resources","text":"<ul> <li>Pinecone Documentation</li> <li>SentenceTransformers Documentation</li> <li>Loguru Documentation</li> </ul> <p>For further exploration and examples, refer to the official documentation and resources provided by Pinecone, SentenceTransformers, and Loguru.</p> <p>This concludes the detailed documentation for the <code>PineconeMemory</code> class. The class offers a flexible and powerful interface for leveraging Pinecone's capabilities in retrieval-augmented generation systems. By supporting custom embeddings, preprocessing, and postprocessing functions, it can be tailored to a wide range of applications.</p>"},{"location":"swarms_platform/","title":"Swarms Platform Documentation","text":"<p>Welcome to the Swarms Platform, a dynamic ecosystem where users can share, discover, and host agents and agent swarms. This documentation will guide you through the various features of the platform, providing you with the information you need to get started and make the most out of your experience.</p>"},{"location":"swarms_platform/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Getting Started</li> <li>Account Management</li> <li>Usage Monitoring</li> <li>API Key Generation</li> <li>Explorer</li> <li>Dashboard</li> <li>Creating an Organization</li> <li>Additional Resources</li> </ol>"},{"location":"swarms_platform/#introduction","title":"Introduction","text":"<p>The Swarms Platform is designed to facilitate the sharing, discovery, and hosting of intelligent agents and swarms of agents. Whether you are a developer looking to deploy your own agents, or an organization seeking to leverage collective intelligence, the Swarms Platform provides the tools and community support you need.</p>"},{"location":"swarms_platform/#getting-started","title":"Getting Started","text":"<p>To begin using the Swarms Platform, follow these steps:</p> <ol> <li>Create an Account: Sign up on the platform to access its features.</li> <li>Explore the Dashboard: Familiarize yourself with the user interface and available functionalities.</li> <li>Generate API Keys: Securely interact with the platform's API.</li> <li>Create and Join Organizations: Collaborate with others to deploy and manage agents and swarms.</li> <li>Share and Discover: Use the Explorer to find and share agents and swarms.</li> </ol>"},{"location":"swarms_platform/#account-management","title":"Account Management","text":""},{"location":"swarms_platform/#account-page","title":"Account Page","text":"<p>Access and manage your account settings through the account page.</p> <ul> <li>URL: Account Page</li> </ul> <p>Here, you can update your profile information, manage security settings, and configure notifications.</p>"},{"location":"swarms_platform/#usage-monitoring","title":"Usage Monitoring","text":""},{"location":"swarms_platform/#check-your-usage","title":"Check Your Usage","text":"<p>Monitor your usage statistics to keep track of your activities and resource consumption on the platform.</p> <ul> <li>URL: Usage Monitoring</li> </ul> <p>This page provides detailed insights into your usage patterns, helping you optimize your resource allocation and stay within your limits.</p>"},{"location":"swarms_platform/#api-key-generation","title":"API Key Generation","text":""},{"location":"swarms_platform/#generate-your-api-keys","title":"Generate Your API Keys","text":"<p>Generate API keys to securely interact with the Swarms Platform API.</p> <ul> <li>URL: API Key Generation</li> </ul> <p>Follow the steps on this page to create, manage, and revoke API keys as needed. Ensure that your keys are kept secure and only share them with trusted applications.</p>"},{"location":"swarms_platform/#explorer","title":"Explorer","text":""},{"location":"swarms_platform/#explorer-share-discover-and-deploy","title":"Explorer: Share, Discover, and Deploy","text":"<p>The Explorer is a central hub for sharing, discovering, and deploying prompts, agents, and swarms.</p> <ul> <li>URL: Explorer</li> </ul> <p>Use the Explorer to:</p> <ul> <li>Share: Upload and share your own prompts, agents, and swarms with the community.</li> <li>Discover: Browse and discover new and innovative agents and swarms created by others.</li> <li>Deploy: Quickly deploy agents and swarms for your own use or organizational needs.</li> </ul>"},{"location":"swarms_platform/#dashboard","title":"Dashboard","text":""},{"location":"swarms_platform/#dashboard_1","title":"Dashboard","text":"<p>The Dashboard is your control center for managing all aspects of your Swarms Platform experience.</p> <ul> <li>URL: Dashboard</li> </ul> <p>From the Dashboard, you can:</p> <ul> <li>Monitor real-time metrics and analytics.</li> <li>Manage your agents and swarms.</li> <li>Access your account settings and usage information.</li> <li>Navigate to other sections of the platform.</li> </ul>"},{"location":"swarms_platform/#creating-an-organization","title":"Creating an Organization","text":""},{"location":"swarms_platform/#create-an-organization","title":"Create an Organization","text":"<p>Collaborate with others by creating and joining organizations on the Swarms Platform.</p> <ul> <li>URL: Create an Organization</li> </ul> <p>Creating an organization allows you to:</p> <ul> <li>Pool resources with team members.</li> <li>Manage shared agents and swarms.</li> <li>Set permissions and roles for organization members.</li> </ul>"},{"location":"swarms_platform/#additional-resources","title":"Additional Resources","text":"<p>To further enhance your understanding and usage of the Swarms Platform, explore the following resources:</p> <ul> <li>API Documentation: Comprehensive documentation on the platform's API.</li> <li>Community Forums: Engage with other users, share insights, and get support.</li> <li>Tutorials and Guides: Step-by-step tutorials to help you get started with specific features and use cases.</li> <li>Support: Contact the support team for any issues or inquiries.</li> </ul>"},{"location":"swarms_platform/#links","title":"Links","text":"<ul> <li>API Documentation</li> <li>Community Forums</li> <li>Tutorials and Guides)</li> <li>Support</li> </ul>"},{"location":"swarms_platform/#conclusion","title":"Conclusion","text":"<p>The Swarms Platform is a versatile and powerful ecosystem for managing intelligent agents and swarms. By following this documentation, you can effectively navigate the platform, leverage its features, and collaborate with others to create innovative solutions. Happy swarming!</p>"},{"location":"swarms_platform/account_management/","title":"Swarms Platform Account Management Documentation","text":"<p>This guide provides comprehensive, production-grade documentation for managing your account on the Swarms Platform. It covers account settings, profile management, billing, payment methods, subscription details, and cryptocurrency wallet management. Use this documentation to navigate the account management interface, understand available options, and perform account-related operations efficiently and securely.</p>"},{"location":"swarms_platform/account_management/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Accessing the Account Management Page</li> <li>Account Settings</li> <li>Theme Mode</li> <li>Profile Management</li> <li>Profile Information</li> <li>Password Management</li> <li>Billing and Payment Methods</li> <li>Subscription Status</li> <li>Payment Methods</li> <li>Cryptocurrency Wallet</li> <li>Wallet Overview</li> <li>Exchange and Transaction History</li> <li>Additional Resources</li> </ol>"},{"location":"swarms_platform/account_management/#overview","title":"Overview","text":"<p>The Swarms Platform account management page, available at https://swarms.world/platform/account, allows you to configure and update your account settings and preferences. From here, you can manage the appearance of the platform, view and update profile details, manage your billing information and subscriptions, and handle your cryptocurrency wallet operations.</p>"},{"location":"swarms_platform/account_management/#accessing-the-account-management-page","title":"Accessing the Account Management Page","text":"<p>To access your account management dashboard: 1. Log in to your Swarms Platform account. 2. Navigate to https://swarms.world/platform/account.</p> <p>Once on this page, you will see several sections dedicated to different aspects of your account:</p> <ul> <li>Account Settings: Customize the platform appearance and user interface.</li> <li>Profile: View and manage personal details.</li> <li>Billing: Review credits, invoices, and manage your payment methods.</li> <li>Crypto: Manage your cryptocurrency wallet and transactions.</li> </ul>"},{"location":"swarms_platform/account_management/#account-settings","title":"Account Settings","text":"<p>This section allows you to modify your personal account preferences, including the visual theme.</p>"},{"location":"swarms_platform/account_management/#theme-mode","title":"Theme Mode","text":"<p>You can choose between different theme options to tailor your user experience:</p> <ul> <li>Single Theme:   A fixed theme, independent of system settings.</li> <li> <p>Example: </p> <ul> <li>Logo: Swarms logo</li> <li>Terminal Command: <pre><code>pip3 install -U swarms\n</code></pre></li> <li>Theme Options: </li> <li>light </li> <li>dark (default)</li> </ul> </li> <li> <p>Sync with System Theme:   Automatically adjusts the platform theme to match your system's theme settings.</p> </li> </ul> <p>Select the theme mode that best fits your workflow. Changes are applied immediately across the platform.</p>"},{"location":"swarms_platform/account_management/#profile-management","title":"Profile Management","text":""},{"location":"swarms_platform/account_management/#profile-information","title":"Profile Information","text":"<p>The Profile section allows you to view and update your personal details:</p> <ul> <li> <p>View Details:   Your current profile information is displayed, including contact details, username, and any additional settings.</p> </li> <li> <p>Manage Profile:   Options to update your information, ensuring your account details remain current.</p> </li> </ul>"},{"location":"swarms_platform/account_management/#password-management","title":"Password Management","text":"<p>For security purposes, it is important to regularly update your password:</p> <ul> <li>Change Password:   Select the \"Change password\" option to update your login credentials.   Ensure you choose a strong password and keep it confidential.</li> </ul>"},{"location":"swarms_platform/account_management/#billing-and-payment-methods","title":"Billing and Payment Methods","text":"<p>The Billing section helps you manage financial aspects of your account, including credits, invoices, and subscriptions.</p>"},{"location":"swarms_platform/account_management/#subscription-status","title":"Subscription Status","text":"<p>Your subscription details are clearly displayed:</p> <ul> <li> <p>Current Plan:   Options include Free, Premium, or Enterprise.</p> </li> <li> <p>Status:   The active subscription status is indicated (e.g., \"Active\").</p> </li> <li> <p>Customer Portal:   An option to open the customer portal for additional billing and subscription management.</p> </li> </ul>"},{"location":"swarms_platform/account_management/#payment-methods","title":"Payment Methods","text":"<p>Manage your payment methods and review your billing details:</p> <ul> <li>Manage Cards:   View existing payment methods. Example Entry:</li> <li>Card Type: mastercard</li> <li>Last 4 Digits: ending in 9491</li> <li> <p>Expiry Date: 2030/2</p> </li> <li> <p>Add Card:   Use the \"Add Card\" option to register a new payment method securely.</p> </li> </ul>"},{"location":"swarms_platform/account_management/#credit-system","title":"Credit System","text":"<p>Details of the credits available for your account:</p> <ul> <li> <p>Credits Available:   Displays the current credit balance (e.g., <code>$20.00</code>).</p> </li> <li> <p>Charge:   Option to apply charges against your available credits.</p> </li> <li> <p>Invoice:   Review or download your invoices.</p> </li> </ul>"},{"location":"swarms_platform/account_management/#cryptocurrency-wallet","title":"Cryptocurrency Wallet","text":"<p>The Crypto section provides management tools for your cryptocurrency wallet and associated transactions.</p>"},{"location":"swarms_platform/account_management/#wallet-overview","title":"Wallet Overview","text":"<ul> <li>Connected Wallet:   Displays your linked wallet information.</li> <li> <p>Example: </p> <ul> <li>Wallet Identifier: A truncated wallet ID (e.g., <code>EmVa...79Vb</code>)</li> </ul> </li> <li> <p>$swarms Balance and Price:</p> </li> <li>Balance:     Displays your current $swarms balance (e.g., <code>0.00</code>).</li> <li>Price:     Current market price for $swarms (e.g., <code>$0.0400</code>).</li> </ul>"},{"location":"swarms_platform/account_management/#exchange-and-transaction-history","title":"Exchange and Transaction History","text":"<ul> <li> <p>Exchange Functionality:   Option to exchange $swarms tokens for credits directly through the platform.</p> </li> <li> <p>Transaction History:   View a detailed log of wallet transactions, ensuring full transparency over all exchanges and wallet activity.</p> </li> </ul>"},{"location":"swarms_platform/account_management/#additional-resources","title":"Additional Resources","text":"<p>For further assistance or to learn more about managing your account on the Swarms Platform, refer to the following resources:</p> <ul> <li>Help Center</li> <li>Customer Support</li> <li>API Documentation (for developers)</li> </ul>"},{"location":"swarms_platform/account_management/#best-practices","title":"Best Practices","text":"<ul> <li> <p>Regular Updates:   Periodically review your account settings, profile, and payment methods to ensure they are up-to-date.</p> </li> <li> <p>Security Measures:   Always use strong, unique passwords and consider enabling two-factor authentication if available.</p> </li> <li> <p>Monitor Transactions:   Regularly check your billing and wallet transaction history to detect any unauthorized activities promptly.</p> </li> </ul>"},{"location":"swarms_platform/apikeys/","title":"Swarms Platform API Keys Documentation","text":"<p>This document provides detailed information on managing API keys within the Swarms Platform. API keys grant programmatic access to your account and should be handled securely. Follow the guidelines below to manage your API keys safely and effectively.</p>"},{"location":"swarms_platform/apikeys/#table-of-contents","title":"Table of Contents","text":"<ol> <li>Overview</li> <li>Viewing Your API Keys</li> <li>Creating a New API Key</li> <li>Security Guidelines</li> <li>Frequently Asked Questions</li> </ol>"},{"location":"swarms_platform/apikeys/#overview","title":"Overview","text":"<p>API keys are unique credentials that allow you to interact with the Swarms Platform programmatically. These keys enable you to make authenticated API requests to access or modify your data. Important: Once a secret API key is generated, it will not be displayed again. Ensure you store it securely, as it cannot be retrieved from the platform later.</p>"},{"location":"swarms_platform/apikeys/#viewing-your-api-keys","title":"Viewing Your API Keys","text":"<p>When you navigate to the API Keys page (https://swarms.world/platform/api-keys), you will see a list of your API keys along with the following information:</p>"},{"location":"swarms_platform/apikeys/#key-details","title":"Key Details:","text":"<ul> <li>Name: A label you assign to your API key to help you identify it.</li> <li>Key: The secret API key is only partially visible here for security reasons.</li> <li>Created Date: The date when the API key was generated.</li> <li>Actions: Options available for managing the key (e.g., deleting an API key).</li> </ul>"},{"location":"swarms_platform/apikeys/#creating-a-new-api-key","title":"Creating a New API Key","text":"<p>To generate a new API key, follow these steps:</p> <ol> <li> <p>Attach a Credit Card:    Before creating a new API key, ensure that your account has a credit card attached. This is required for authentication and billing purposes.</p> </li> <li> <p>Access the API Keys Page:    Navigate to https://swarms.world/platform/api-keys.</p> </li> <li> <p>Generate a New Key:    Click on the \"Create new API key\" button. The system will generate a new secret API key for your account.</p> </li> <li> <p>Store Your API Key Securely:    Once generated, the full API key will be displayed only once. Copy and store it in a secure location, as it will not be displayed again. Note: Do not share your API key with anyone or expose it in any client-side code (e.g., browser JavaScript).</p> </li> </ol>"},{"location":"swarms_platform/apikeys/#security-guidelines","title":"Security Guidelines","text":"<ul> <li> <p>Confidentiality:   Your API keys are sensitive credentials. Do not share them with anyone or include them in public repositories or client-side code.</p> </li> <li> <p>Storage:   Store your API keys in secure, encrypted storage. Avoid saving them in plain text files or unsecured locations.</p> </li> <li> <p>Rotation:   If you suspect that your API key has been compromised, immediately delete it and create a new one.</p> </li> <li> <p>Access Control:   Limit access to your API keys to only those systems and personnel who absolutely require it.</p> </li> </ul>"},{"location":"swarms_platform/apikeys/#frequently-asked-questions","title":"Frequently Asked Questions","text":""},{"location":"swarms_platform/apikeys/#q1-why-do-i-need-a-credit-card-attached-to-my-account-to-create-an-api-key","title":"Q1: Why do I need a credit card attached to my account to create an API key?","text":"<p>A: The requirement to attach a credit card helps verify your identity and manage billing, ensuring responsible usage of the API services provided by the Swarms Platform.</p>"},{"location":"swarms_platform/apikeys/#q2-what-happens-if-i-lose-my-api-key","title":"Q2: What happens if I lose my API key?","text":"<p>A: If you lose your API key, you will need to generate a new one. The platform does not store the full key after its initial generation, so recovery is not possible.</p>"},{"location":"swarms_platform/apikeys/#q3-how-can-i-delete-an-api-key","title":"Q3: How can I delete an API key?","text":"<p>A: On the API Keys page, locate the key you wish to delete and click the \"Delete\" action next to it. This will revoke the key's access immediately.</p>"},{"location":"swarms_platform/apikeys/#q4-can-i-have-multiple-api-keys","title":"Q4: Can I have multiple API keys?","text":"<p>A: Yes, you can generate and manage multiple API keys. Use naming conventions to keep track of their usage and purpose.</p> <p>For any further questions or issues regarding API key management, please refer to our Help Center or contact our support team.</p>"},{"location":"swarms_platform/apps_page/","title":"Swarms Marketplace Apps Documentation","text":"<p>The Swarms Apps page (<code>https://swarms.world/apps</code>) is your central hub for managing and customizing your workspace experience. Here you can control which applications appear in your sidebar, organize them using templates, and quickly access the tools you need for different workflows.</p>"},{"location":"swarms_platform/apps_page/#apps-gallery","title":"Apps Gallery","text":""},{"location":"swarms_platform/apps_page/#customizing-your-sidebar","title":"Customizing Your Sidebar","text":"<p>The Apps Gallery allows you to curate your workspace by selecting which applications you want to see in your sidebar. This personalized approach ensures you have quick access to the tools most relevant to your work.</p> <p>Key Features:</p> <ul> <li> <p>Selective App Display: Choose exactly which apps appear in your sidebar</p> </li> <li> <p>Favorites System: Star your most-used apps to pin them for instant access</p> </li> <li> <p>Quick Access: Starred apps remain easily accessible regardless of your current template</p> </li> </ul>"},{"location":"swarms_platform/apps_page/#how-to-use-the-apps-gallery","title":"How to Use the Apps Gallery","text":"<ol> <li>Browse Available Apps: Scroll through the complete list of available applications</li> <li>Toggle App Visibility: Click on apps to add or remove them from your sidebar</li> <li>Star Favorites: Click the star icon on frequently used apps to pin them</li> <li>Instant Updates: Changes to your sidebar configuration take effect immediately</li> </ol>"},{"location":"swarms_platform/apps_page/#quick-sidebar-templates","title":"Quick Sidebar Templates","text":"<p>Templates provide pre-configured app collections optimized for specific workflows. Instead of manually selecting apps one by one, you can choose a template that matches your current needs.</p>"},{"location":"swarms_platform/apps_page/#available-templates","title":"Available Templates","text":""},{"location":"swarms_platform/apps_page/#marketplace-template","title":"\ud83c\udfea Marketplace Template","text":"<p>Perfect for discovering and managing marketplace content</p> <p>Included Apps:</p> <ul> <li> <p>Marketplace: Browse and discover new tools, agents, and prompts</p> </li> <li> <p>App Store: Access autonomous AI applications  </p> </li> <li> <p>Leaderboard: View top creators and contributors</p> </li> <li> <p>Dashboard: Your main control center</p> </li> <li> <p>Settings: Account and organization configuration</p> </li> </ul> <p>Best For: Content discovery, community engagement, platform exploration</p>"},{"location":"swarms_platform/apps_page/#no-code-solutions-template","title":"\ud83c\udfa8 No-Code Solutions Template","text":"<p>Ideal for users who prefer visual, drag-and-drop interfaces</p> <p>Included Apps: - Dashboard: Central control and overview</p> <ul> <li> <p>Chat: Direct communication with agents and team members</p> </li> <li> <p>Spreadsheet: Collaborative AI-powered spreadsheets</p> </li> <li> <p>Drag n Drop: Visual workflow builder for creating processes</p> </li> <li> <p>Settings: Platform configuration options</p> </li> </ul> <p>Best For: Visual workflow creation, collaborative work, rapid prototyping</p>"},{"location":"swarms_platform/apps_page/#developer-template","title":"\ud83d\udc68\u200d\ud83d\udcbb Developer Template","text":"<p>Designed for technical users and developers</p> <p>Included Apps: - Dashboard: System overview and monitoring</p> <ul> <li> <p>API Key: Manage authentication credentials  </p> </li> <li> <p>Telemetry: Monitor platform usage and analytics</p> </li> <li> <p>Settings: Advanced configuration options</p> </li> <li> <p>Playground: Testing and experimentation environment</p> </li> </ul> <p>Best For: API integration, performance monitoring, technical development</p>"},{"location":"swarms_platform/apps_page/#all-apps-template","title":"\ud83d\udcf1 All Apps Template","text":"<p>Comprehensive access to every available application</p> <p>Features: - Complete Access: Activates all available apps in your sidebar</p> <ul> <li> <p>Maximum Flexibility: Switch between any tool without reconfiguration</p> </li> <li> <p>Full Feature Set: Access to every platform capability</p> </li> </ul> <p>Best For: Power users, comprehensive workflows, exploration of all features</p>"},{"location":"swarms_platform/apps_page/#app-categories","title":"App Categories","text":""},{"location":"swarms_platform/apps_page/#marketplace-applications","title":"Marketplace Applications","text":"<p>These apps focus on content discovery, community interaction, and marketplace functionality.</p>"},{"location":"swarms_platform/apps_page/#dashboard","title":"Dashboard","text":"<p>Your primary control center providing system overview, key metrics, and quick access to important functions.</p>"},{"location":"swarms_platform/apps_page/#marketplace","title":"Marketplace","text":"<p>Discover and utilize new tools, agents, and prompts created by the community. Browse categories, read reviews, and integrate new capabilities into your workflows.</p>"},{"location":"swarms_platform/apps_page/#app-store","title":"App Store","text":"<p>Access a curated collection of autonomous AI applications. These are complete solutions that can operate independently to accomplish specific tasks.</p>"},{"location":"swarms_platform/apps_page/#leaderboard","title":"Leaderboard","text":"<p>View rankings of top creators, contributors, and most popular content. Discover trending tools and identify influential community members.</p>"},{"location":"swarms_platform/apps_page/#marketplace-bookmarks","title":"Marketplace Bookmarks","text":"<p>Organize and manage your saved marketplace items. Keep track of tools you want to try later or frequently reference.</p>"},{"location":"swarms_platform/apps_page/#no-code-agent-platforms","title":"No Code Agent Platforms","text":"<p>Visual, user-friendly tools that don't require programming knowledge.</p> Application Description Apps Meta-application for managing your sidebar configuration. Add, remove, and organize your available applications. Chat Real-time communication interface for conversing with AI agents and team members. Supports both individual and group conversations. Spreadsheet Swarm AI-enhanced collaborative spreadsheets that combine familiar spreadsheet functionality with intelligent automation and team collaboration features. Drag &amp; Drop Visual workflow builder allowing you to create complex processes using intuitive drag-and-drop interfaces. Connect different tools and actions without coding."},{"location":"swarms_platform/apps_page/#account-settings","title":"Account Settings","text":"<p>Configuration and management tools for your account and organization.</p> Application Description API Keys Secure management of your authentication credentials. Generate, rotate, and manage API keys for integrating external services. Telemetry Comprehensive analytics dashboard showing platform usage, performance metrics, and usage patterns. Monitor your organization's AI agent activity. Settings Central configuration hub for account preferences, organization settings, notification preferences, and platform customization options. Playground Safe testing environment for experimenting with new configurations, testing API calls, and prototyping workflows before implementing them in production."},{"location":"swarms_platform/apps_page/#best-practices","title":"Best Practices","text":""},{"location":"swarms_platform/apps_page/#template-selection-strategy","title":"Template Selection Strategy","text":"<p>Start with Templates: Begin with a template that matches your primary use case, then customize as needed.</p> <p>Regular Review: Periodically reassess your app selection as your needs evolve.</p> <p>Workflow-Specific: Consider switching templates based on current projects or tasks.</p>"},{"location":"swarms_platform/apps_page/#app-management-tips","title":"App Management Tips","text":"<p>Star Strategically: Only star apps you use daily to avoid sidebar clutter.</p> <p>Template Switching: Don't hesitate to switch templates when your focus changes.</p> <p>Exploration: Periodically activate the \"All\" template to discover new capabilities.</p>"},{"location":"swarms_platform/apps_page/#organization-recommendations","title":"Organization Recommendations","text":"<p>Role-Based Setup: Configure templates based on team roles (developers, content creators, analysts).</p> <p>Project Phases: Adjust app selection based on project phases (research, development, deployment).</p> <p>Performance Monitoring: Use telemetry data to optimize your app selection over time.</p>"},{"location":"swarms_platform/apps_page/#getting-started","title":"Getting Started","text":"<ol> <li>Visit the Apps Page: Navigate to <code>https://swarms.world/apps</code></li> <li>Choose a Template: Select the template that best matches your immediate needs</li> <li>Customize: Add or remove specific apps based on your preferences  </li> <li>Star Favorites: Mark your most-used apps as favorites</li> <li>Start Working: Your customized sidebar is immediately available across the platform</li> </ol> <p>The Apps page puts you in complete control of your Swarms experience, ensuring you have the right tools at your fingertips for any task or workflow.</p>"},{"location":"swarms_platform/monetize/","title":"Swarms.World Monetization Guide","text":""},{"location":"swarms_platform/monetize/#quick-overview","title":"Quick Overview","text":"<p>Swarms Marketplace has activated its payment infrastructure, enabling creators to monetize AI agents, prompts, and tools directly through the platform. Sellers receive payments minus a 5-15% platform fee, scaled based on subscription tiers. Revenue accrues in real-time to integrated crypto wallets, with optional fiat conversions.</p>"},{"location":"swarms_platform/monetize/#eligibility-requirements","title":"Eligibility Requirements","text":""},{"location":"swarms_platform/monetize/#current-requirements-for-paid-content","title":"Current Requirements for Paid Content","text":"<ul> <li> <p>2+ published items (Prompts, Agents, and Tools)</p> </li> <li> <p>2 Items with 4+ star ratings (you need community ratings)</p> </li> <li> <p>Marketplace Agent Rating An agent will automatically rate your prompt, agent, or tool.</p> </li> </ul> <p>Bottom Line: You must build reputation with free, high-quality content first.</p>"},{"location":"swarms_platform/monetize/#step-by-step-process","title":"Step-by-Step Process","text":""},{"location":"swarms_platform/monetize/#phase-1-build-reputation-required-first","title":"Phase 1: Build Reputation (Required First)","text":""},{"location":"swarms_platform/monetize/#1-improve-your-existing-content","title":"1. Improve Your Existing Content","text":"<ul> <li> <p>Add better descriptions and examples to your published items</p> </li> <li> <p>Use the Rating System: Evaluate and rate prompts, agents, and tools based on their effectiveness. Commenting System: Share feedback and insights with the Swarms community</p> </li> <li> <p>Ask users for honest reviews and ratings</p> </li> </ul>"},{"location":"swarms_platform/monetize/#2-create-more-quality-content","title":"2. Create More Quality Content","text":"<p>Focus on these categories:</p> <ul> <li> <p>Agents: Marketing, finance, or programming automation</p> </li> <li> <p>Prompts: Templates for specific business tasks  </p> </li> <li> <p>Tools: Utilities that solve real problems</p> </li> </ul> <p>Target: 3-5 additional items, all aiming for 4+ star ratings</p>"},{"location":"swarms_platform/monetize/#3-get-community-ratings","title":"3. Get Community Ratings","text":"<ul> <li> <p>Share your content in relevant communities</p> </li> <li> <p>Engage with users who try your content</p> </li> <li> <p>Respond to feedback and improve based on comments</p> </li> <li> <p>Be patient - ratings take time to accumulate</p> </li> </ul>"},{"location":"swarms_platform/monetize/#phase-2-start-monetizing","title":"Phase 2: Start Monetizing","text":""},{"location":"swarms_platform/monetize/#4-choose-your-pricing-model","title":"4. Choose Your Pricing Model","text":"<p>Three primary monetization avenues exist: AI agents (autonomous task-execution models), prompts (pre-optimized input templates), and tools (development utilities like data preprocessors)</p> <p>Pricing Options:</p> <ul> <li> <p>One-time: $0.01 - $999,999 USD</p> </li> <li> <p>Subscription: Monthly/annual recurring fees  (Coming Soon)</p> </li> <li> <p>Usage-based: Pay per API call or computation (Coming Soon)</p> </li> </ul>"},{"location":"swarms_platform/monetize/#6-optimize-scale","title":"6. Optimize &amp; Scale","text":"<ul> <li> <p>Monitor your revenue and user feedback</p> </li> <li> <p>Developers can bundle assets\u2014such as pairing prompt libraries with compatible agents\u2014creating value-added  packages</p> </li> <li> <p>Create bundles of related content for higher value</p> </li> <li> <p>Adjust pricing based on demand</p> </li> </ul>"},{"location":"swarms_platform/monetize/#revenue-models","title":"Revenue Models","text":""},{"location":"swarms_platform/monetize/#what-sells-best","title":"What Sells Best","text":"<ol> <li> <p>Business Automation Agents - Marketing, sales, finance</p> </li> <li> <p>Industry-Specific Prompts - Legal, medical, technical writing</p> </li> <li> <p>Integration Tools - APIs, data processors, connectors</p> </li> </ol>"},{"location":"swarms_platform/monetize/#pricing-examples","title":"Pricing Examples","text":"<ul> <li> <p>Simple prompts: $1-50</p> </li> <li> <p>Complex agents: $20-500+</p> </li> <li> <p>Enterprise tools: $100-1000+</p> </li> </ul>"},{"location":"swarms_platform/monetize/#quick-tips-for-success","title":"Quick Tips for Success","text":"<ol> <li>Quality over quantity - Better to have 3 excellent items than 10 mediocre ones</li> <li>Solve real problems - Focus on actual business needs</li> <li>Document everything - Clear instructions increase ratings</li> <li>Engage actively - Respond to all user feedback</li> <li>Be patient - Building reputation takes time but pays off</li> </ol>"},{"location":"swarms_platform/monetize/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ul> <li> <p>Publishing low-quality content to meet quantity requirements</p> </li> <li> <p>Not responding to user feedback</p> </li> <li> <p>Setting prices too high before building reputation</p> </li> <li> <p>Copying existing solutions without adding value</p> </li> <li> <p>Ignoring community guidelines</p> </li> </ul>"},{"location":"swarms_platform/playground_page/","title":"Swarms API Playground Documentation","text":""},{"location":"swarms_platform/playground_page/#overview","title":"Overview","text":"<p>The Swarms Playground (<code>https://swarms.world/platform/playground</code>) is an interactive testing environment that allows you to experiment with the Swarms API in real-time. This powerful tool enables you to configure AI agents, test different parameters, and generate code examples in multiple programming languages without writing any code manually.</p>"},{"location":"swarms_platform/playground_page/#key-features","title":"Key Features","text":"<ul> <li> <p>Real-time API Testing: Execute Swarms API calls directly in the browser</p> </li> <li> <p>Multi-language Code Generation: Generate code examples in Python, Rust, Go, and TypeScript</p> </li> <li> <p>Interactive Configuration: Visual interface for setting up agent parameters</p> </li> <li> <p>Live Output: See API responses immediately in the output terminal</p> </li> <li> <p>Code Export: Copy generated code for use in your applications</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#interface-overview","title":"Interface Overview","text":""},{"location":"swarms_platform/playground_page/#language-selection","title":"Language Selection","text":"<p>The playground supports code generation in four programming languages:</p> <ul> <li> <p>Python: Default language with <code>requests</code> library implementation</p> </li> <li> <p>Rust: Native Rust HTTP client implementation</p> </li> <li> <p>Go: Standard Go HTTP package implementation  </p> </li> <li> <p>TypeScript: Node.js/browser-compatible implementation</p> </li> </ul> <p>Switch between languages using the dropdown menu in the top-right corner to see language-specific code examples.</p>"},{"location":"swarms_platform/playground_page/#agent-modes","title":"Agent Modes","text":"<p>The playground offers two distinct modes for testing different types of AI implementations:</p>"},{"location":"swarms_platform/playground_page/#single-agent-mode","title":"Single Agent Mode","text":"<p>Test individual AI agents with specific configurations and tasks. Ideal for: - Prototype testing</p> <ul> <li> <p>Parameter optimization</p> </li> <li> <p>Simple task automation</p> </li> <li> <p>API familiarization</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#multi-agent-mode","title":"Multi-Agent Mode","text":"<p>Experiment with coordinated AI agent systems. Perfect for: - Complex workflow automation</p> <ul> <li> <p>Collaborative AI systems</p> </li> <li> <p>Distributed task processing</p> </li> <li> <p>Advanced orchestration scenarios</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#configuration-parameters","title":"Configuration Parameters","text":""},{"location":"swarms_platform/playground_page/#basic-agent-settings","title":"Basic Agent Settings","text":""},{"location":"swarms_platform/playground_page/#agent-name","title":"Agent Name","text":"<p>Purpose: Unique identifier for your agent Usage: Helps distinguish between different agent configurations Example: <code>\"customer_service_bot\"</code>, <code>\"data_analyst\"</code>, <code>\"content_writer\"</code></p>"},{"location":"swarms_platform/playground_page/#model-name","title":"Model Name","text":"<p>Purpose: Specifies which AI model to use for the agent Default: <code>gpt-4o-mini</code> Options: Various OpenAI and other supported models Impact: Affects response quality, speed, and cost</p>"},{"location":"swarms_platform/playground_page/#description","title":"Description","text":"<p>Purpose: Human-readable description of the agent's purpose Usage: Documentation and identification Best Practice: Be specific about the agent's intended function</p>"},{"location":"swarms_platform/playground_page/#system-prompt","title":"System Prompt","text":"<p>Purpose: Core instructions that define the agent's behavior and personality Impact: Critical for agent performance and response style Tips:  - Be clear and specific</p> <ul> <li> <p>Include role definition</p> </li> <li> <p>Specify output format if needed</p> </li> <li> <p>Add relevant constraints</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#advanced-parameters","title":"Advanced Parameters","text":""},{"location":"swarms_platform/playground_page/#temperature","title":"Temperature","text":"<p>Range: 0.0 - 2.0</p> <p>Default: 0.5 Purpose: Controls randomness in responses - Low (0.0-0.3): More deterministic, consistent responses</p> <ul> <li> <p>Medium (0.4-0.7): Balanced creativity and consistency  </p> </li> <li> <p>High (0.8-2.0): More creative and varied responses</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#max-tokens","title":"Max Tokens","text":"<p>Default: 8192 Purpose: Maximum length of the agent's response Considerations: - Higher values allow longer responses</p> <ul> <li> <p>Impacts API costs</p> </li> <li> <p>Model-dependent limits apply</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#role","title":"Role","text":"<p>Default: <code>worker</code> Purpose: Defines the agent's role in multi-agent scenarios Common Roles: <code>worker</code>, <code>manager</code>, <code>coordinator</code>, <code>specialist</code></p>"},{"location":"swarms_platform/playground_page/#max-loops","title":"Max Loops","text":"<p>Default: 1 Purpose: Number of iterations the agent can perform Usage: - <code>1</code>: Single response</p> <ul> <li><code>&gt;1</code>: Allows iterative problem solving</li> </ul>"},{"location":"swarms_platform/playground_page/#mcp-url-optional","title":"MCP URL (Optional)","text":"<p>Purpose: Model Context Protocol URL for external integrations Usage: Connect to external services or data sources Format: Valid URL pointing to MCP-compatible service</p>"},{"location":"swarms_platform/playground_page/#task-definition","title":"Task Definition","text":""},{"location":"swarms_platform/playground_page/#task","title":"Task","text":"<p>Purpose: Specific instruction or query for the agent to process Best Practices: - Be specific and clear</p> <ul> <li> <p>Include all necessary context</p> </li> <li> <p>Specify desired output format</p> </li> <li> <p>Provide examples when helpful</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#using-the-playground","title":"Using the Playground","text":""},{"location":"swarms_platform/playground_page/#step-by-step-guide","title":"Step-by-Step Guide","text":"<ol> <li>Select Mode: Choose between Single Agent or Multi-Agent</li> <li>Choose Language: Select your preferred programming language</li> <li>Configure Agent: Fill in the required parameters</li> <li>Define Task: Enter your specific task or query</li> <li>Run Agent: Click the \"Run Agent\" button</li> <li>Review Output: Check the Output Terminal for results</li> <li>Copy Code: Use the generated code in your applications</li> </ol>"},{"location":"swarms_platform/playground_page/#testing-strategies","title":"Testing Strategies","text":""},{"location":"swarms_platform/playground_page/#parameter-experimentation","title":"Parameter Experimentation","text":"<ul> <li> <p>Temperature Testing: Try different temperature values to find optimal creativity levels</p> </li> <li> <p>Prompt Engineering: Iterate on system prompts to improve responses</p> </li> <li> <p>Token Optimization: Adjust max_tokens based on expected response length</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#workflow-development","title":"Workflow Development","text":"<ul> <li> <p>Start Simple: Begin with basic tasks and gradually increase complexity</p> </li> <li> <p>Iterative Refinement: Use playground results to refine your approach</p> </li> <li> <p>Documentation: Keep notes on successful configurations</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#output-interpretation","title":"Output Interpretation","text":""},{"location":"swarms_platform/playground_page/#output-terminal","title":"Output Terminal","text":"<p>The Output Terminal displays:</p> <ul> <li> <p>Agent Responses: Direct output from the AI agent</p> </li> <li> <p>Error Messages: API errors or configuration issues</p> </li> <li> <p>Execution Status: Success/failure indicators</p> </li> <li> <p>Response Metadata: Token usage, timing information</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#code-preview","title":"Code Preview","text":"<p>The Code Preview section shows:</p> <ul> <li> <p>Complete Implementation: Ready-to-use code in your selected language</p> </li> <li> <p>API Configuration: Proper headers and authentication setup</p> </li> <li> <p>Request Structure: Correctly formatted payload</p> </li> <li> <p>Response Handling: Basic error handling and output processing</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#code-examples-by-language","title":"Code Examples by Language","text":""},{"location":"swarms_platform/playground_page/#python-implementation","title":"Python Implementation","text":"<pre><code>import requests\n\nurl = \"https://swarms-api-285321057562.us-east1.run.app/v1/agent/completions\"\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"x-api-key\": \"your-api-key-here\"\n}\n\npayload = {\n    \"agent_config\": {\n        \"agent_name\": \"example_agent\",\n        \"description\": \"Example agent for demonstration\",\n        \"system_prompt\": \"You are a helpful assistant.\",\n        \"model_name\": \"gpt-4o-mini\",\n        \"auto_generate_prompt\": false,\n        \"max_tokens\": 8192,\n        \"temperature\": 0.5,\n        \"role\": \"worker\",\n        \"max_loops\": 1,\n        \"tools_list_dictionary\": null,\n        \"mcp_url\": null\n    },\n    \"task\": \"Explain quantum computing in simple terms\"\n}\n\nresponse = requests.post(url, json=payload, headers=headers)\nprint(response.json())\n</code></pre>"},{"location":"swarms_platform/playground_page/#key-code-components","title":"Key Code Components","text":""},{"location":"swarms_platform/playground_page/#api-endpoint","title":"API Endpoint","text":"<ul> <li> <p>URL: <code>https://swarms-api-285321057562.us-east1.run.app/v1/agent/completions</code></p> </li> <li> <p>Method: POST</p> </li> <li> <p>Authentication: API key in <code>x-api-key</code> header</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#request-structure","title":"Request Structure","text":"<ul> <li> <p>Headers: Content-Type and API key</p> </li> <li> <p>Payload: Agent configuration and task</p> </li> <li> <p>Response: JSON with agent output and metadata</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#best-practices","title":"Best Practices","text":""},{"location":"swarms_platform/playground_page/#security","title":"Security","text":"<ul> <li> <p>API Key Management: Never expose API keys in client-side code</p> </li> <li> <p>Environment Variables: Store sensitive credentials securely</p> </li> <li> <p>Rate Limiting: Respect API rate limits in production</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#performance-optimization","title":"Performance Optimization","text":"<ul> <li> <p>Parameter Tuning: Optimize temperature and max_tokens for your use case</p> </li> <li> <p>Prompt Engineering: Craft efficient system prompts</p> </li> <li> <p>Caching: Implement response caching for repeated queries</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#development-workflow","title":"Development Workflow","text":"<ul> <li> <p>Prototype in Playground: Test configurations before implementation</p> </li> <li> <p>Document Successful Configs: Save working parameter combinations</p> </li> <li> <p>Iterate and Improve: Use playground for continuous optimization</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#troubleshooting","title":"Troubleshooting","text":""},{"location":"swarms_platform/playground_page/#common-issues","title":"Common Issues","text":""},{"location":"swarms_platform/playground_page/#no-output-in-terminal","title":"No Output in Terminal","text":"<ul> <li> <p>Check API Key: Ensure valid API key is configured</p> </li> <li> <p>Verify Parameters: All required fields must be filled</p> </li> <li> <p>Network Issues: Check internet connection</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#unexpected-responses","title":"Unexpected Responses","text":"<ul> <li> <p>Review System Prompt: Ensure clear instructions</p> </li> <li> <p>Adjust Temperature: Try different creativity levels</p> </li> <li> <p>Check Task Definition: Verify task clarity and specificity</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#code-generation-issues","title":"Code Generation Issues","text":"<ul> <li> <p>Language Selection: Ensure correct language is selected</p> </li> <li> <p>Copy Functionality: Use the \"Copy Code\" button for accurate copying</p> </li> <li> <p>Syntax Validation: Test generated code in your development environment</p> </li> </ul>"},{"location":"swarms_platform/playground_page/#integration-guide","title":"Integration Guide","text":""},{"location":"swarms_platform/playground_page/#from-playground-to-production","title":"From Playground to Production","text":"<ol> <li>Copy Generated Code: Use the Code Preview section</li> <li>Add Error Handling: Implement robust error handling</li> <li>Configure Environment: Set up proper API key management</li> <li>Test Thoroughly: Validate in your target environment</li> <li>Monitor Performance: Track API usage and response quality</li> </ol> <p>The Swarms Playground is your gateway to understanding and implementing the Swarms API effectively. Use it to experiment, learn, and build confidence before deploying AI agents in production environments.</p>"},{"location":"swarms_platform/share_and_discover/","title":"Swarms Marketplace Documentation","text":"<p>The Swarms Marketplace (<code>https://swarms.world</code>) is a vibrant community hub where developers, researchers, and agent enthusiasts share and discover cutting-edge agent tools, agents, and prompts. This collaborative platform empowers you to leverage the collective intelligence of the Swarms community while contributing your own innovations.</p>"},{"location":"swarms_platform/share_and_discover/#what-you-can-discover","title":"What You Can Discover","text":""},{"location":"swarms_platform/share_and_discover/#agents","title":"\ud83e\udd16 Agents","text":"<p>Ready-to-use agent agents for specific tasks and industries:</p> <ul> <li> <p>Specialized Agents: From healthcare diagnostics to financial analysis</p> </li> <li> <p>Multi-Agent Systems: Collaborative agent swarms for complex workflows</p> </li> <li> <p>Industry Solutions: Pre-built agents for healthcare, finance, education, and more</p> </li> <li> <p>Custom Implementations: Unique agent architectures and approaches</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#prompts","title":"\ud83d\udca1 Prompts","text":"<p>System prompts and instructions that define agent behavior:</p> <ul> <li> <p>Role-Specific Prompts: Behavioral psychologist, documentation specialist, financial advisor</p> </li> <li> <p>System Templates: Production-grade prompts for various use cases</p> </li> <li> <p>Collaborative Frameworks: Multi-agent coordination prompts</p> </li> <li> <p>Task-Specific Instructions: Optimized prompts for specific workflows</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#tools","title":"\ud83d\udee0\ufe0f Tools","text":"<p>APIs, integrations, and utilities that extend agent capabilities:</p> <ul> <li> <p>API Integrations: Connect to external services and data sources</p> </li> <li> <p>Data Fetchers: Tools for retrieving information from various platforms</p> </li> <li> <p>Workflow Utilities: Helper functions and automation tools</p> </li> <li> <p>Communication Tools: Integrations with messaging platforms and services</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#browsing-and-discovery","title":"Browsing and Discovery","text":""},{"location":"swarms_platform/share_and_discover/#category-based-navigation","title":"Category-Based Navigation","text":"<p>Industry Categories:</p> <ul> <li> <p>Healthcare: Medical diagnosis, patient care, research tools</p> </li> <li> <p>Education: Learning assistants, curriculum development, assessment tools</p> </li> <li> <p>Finance: Trading bots, market analysis, financial planning</p> </li> <li> <p>Research: Academic paper fetchers, data analysis, literature review</p> </li> <li> <p>Public Safety: Risk assessment, emergency response, safety monitoring</p> </li> <li> <p>Marketing: Content creation, campagentgn optimization, audience analysis</p> </li> <li> <p>Sales: Lead generation, customer engagement, sales automation</p> </li> <li> <p>Customer Support: Chatbots, issue resolution, knowledge management</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#trending-section","title":"Trending Section","text":"<p>Discover the most popular and highly-rated content in the community:</p> <ul> <li> <p>Top-Rated Items: Content with 5-star ratings from users</p> </li> <li> <p>Community Favorites: Most shared and downloaded items</p> </li> <li> <p>Recent Additions: Latest contributions to the marketplace</p> </li> <li> <p>Featured Content: Curated selections highlighting exceptional work</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#search-and-filtering","title":"Search and Filtering","text":"<ul> <li> <p>Keyword Search: Find specific tools, agents, or prompts by name or description</p> </li> <li> <p>Category Filters: Browse within specific industry verticals</p> </li> <li> <p>Rating Filters: Filter by community ratings and reviews</p> </li> <li> <p>Tag-Based Discovery: Explore content by relevant tags and keywords</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#contributing-to-the-marketplace","title":"Contributing to the Marketplace","text":""},{"location":"swarms_platform/share_and_discover/#why-share-your-work","title":"Why Share Your Work?","text":"<p>\ud83c\udf1f Community Impact</p> <ul> <li> <p>Help fellow developers solve similar challenges</p> </li> <li> <p>Contribute to the collective advancement of agent technology</p> </li> <li> <p>Build your reputation in the agent community</p> </li> </ul> <p>\ud83d\udcc8 Professional Growth</p> <ul> <li> <p>Showcase your expertise and innovative solutions</p> </li> <li> <p>Receive feedback and suggestions from the community</p> </li> <li> <p>Network with like-minded professionals and researchers</p> </li> </ul> <p>\ud83d\udd04 Knowledge Exchange</p> <ul> <li> <p>Learn from others who use and modify your contributions</p> </li> <li> <p>Discover new approaches and improvements to your work</p> </li> <li> <p>Foster collaborative innovation and problem-solving</p> </li> </ul> <p>\ud83c\udfc6 Recognition</p> <ul> <li> <p>Get credited for your contributions with author attribution</p> </li> <li> <p>Build a portfolio of public agent implementations</p> </li> <li> <p>Gagentn visibility in the growing Swarms ecosystem</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#how-to-submit-content","title":"How to Submit Content","text":""},{"location":"swarms_platform/share_and_discover/#adding-a-prompt","title":"Adding a Prompt","text":"<p>Prompts are the foundation of agent behavior - share your carefully crafted instructions with the community.</p> <p>Step-by-Step Process:</p> <ol> <li>Click \"Add Prompt\" from the marketplace interface</li> <li> <p>Fill Required Fields:</p> </li> <li> <p>Name: Descriptive title that clearly indicates the prompt's purpose</p> </li> <li> <p>Description: Detagentled explanation of what the prompt does and when to use it</p> </li> <li> <p>Prompt: The complete system prompt or instruction text</p> </li> <li> <p>Enhance Your Submission:</p> </li> <li> <p>Add Image: Upload a visual representation (up to 60MB)</p> </li> <li> <p>Select Categories: Choose relevant industry categories</p> </li> <li> <p>Add Tags: Include searchable keywords and descriptors</p> </li> <li> <p>Submit: Review and submit your prompt to the community</p> </li> </ol> <p>Best Practices for Prompts:</p> <ul> <li> <p>Be Specific: Clearly define the agent's role and expected behavior</p> </li> <li> <p>Include Context: Provide background information and use case scenarios</p> </li> <li> <p>Test Thoroughly: Ensure your prompt produces consistent, high-quality results</p> </li> <li> <p>Document Parameters: Explagentn any variables or customization options</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#submitting-an-agent","title":"Submitting an Agent","text":"<p>Agents are complete agent implementations - share your working solutions with the community.</p> <p>Step-by-Step Process:</p> <ol> <li>Click \"Add Agent\" from the marketplace interface</li> <li>Complete Required Information:</li> <li> <p>Name: Clear, descriptive agent name</p> </li> <li> <p>Description: Comprehensive explanation of functionality and use cases</p> </li> <li> <p>Agent Code: Complete, working implementation</p> </li> <li> <p>Language: Select the programming language (Python, etc.)</p> </li> <li> <p>Optimize Discoverability:</p> </li> <li> <p>Categories: Choose appropriate industry verticals</p> </li> <li> <p>Image: Add a representative image or diagram</p> </li> <li> <p>Tags: Include relevant keywords for searchability</p> </li> <li> <p>Submit: Finalize and share your agent with the community</p> </li> </ol> <p>Agent Submission Guidelines:</p> <ul> <li> <p>Complete Implementation: Provide fully functional, tested code</p> </li> <li> <p>Clear Documentation: Include usage instructions and configuration detagentls</p> </li> <li> <p>Error Handling: Implement robust error handling and validation</p> </li> <li> <p>Dependencies: List all required libraries and dependencies</p> </li> <li> <p>Examples: Provide usage examples and expected outputs</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#adding-tools","title":"Adding Tools","text":"<p>Tools extend the capabilities of the Swarms ecosystem - share your integrations and utilities.</p> <p>What Makes a Great Tool:</p> <ul> <li> <p>Solves Real Problems: Addresses common pagentn points or workflow gaps</p> </li> <li> <p>Easy Integration: Simple to implement and configure</p> </li> <li> <p>Well Documented: Clear instructions and examples</p> </li> <li> <p>Reliable Performance: Tested and optimized for production use</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#content-quality-guidelines","title":"Content Quality Guidelines","text":""},{"location":"swarms_platform/share_and_discover/#writing-effective-descriptions","title":"Writing Effective Descriptions","text":"<p>For All Submissions:</p> <ul> <li> <p>Start with Purpose: Lead with what your contribution does</p> </li> <li> <p>Explagentn Benefits: Highlight the value and use cases</p> </li> <li> <p>Include Technical Detagentls: Mention key features and capabilities</p> </li> <li> <p>Provide Context: Explagentn when and why to use your contribution</p> </li> </ul> <p>Example Description Structure:</p> <pre><code>[Brief summary of what it does]\n\nKey Features:\n- [Feature 1 with benefit]\n\n- [Feature 2 with benefit]\n\n- [Feature 3 with benefit]\n\n\nUse Cases:\n- [Scenario 1]\n\n- [Scenario 2]\n\n- [Scenario 3]\n\n\nTechnical Detagentls:\n- [Implementation notes]\n\n- [Requirements or dependencies]\n\n- [Configuration options]\n</code></pre>"},{"location":"swarms_platform/share_and_discover/#choosing-categories-and-tags","title":"Choosing Categories and Tags","text":"<p>Categories:</p> <ul> <li> <p>Select all relevant industry verticals</p> </li> <li> <p>Consider cross-industry applications</p> </li> <li> <p>Choose the primary category first</p> </li> </ul> <p>Tags:</p> <ul> <li> <p>Include technical keywords (API names, frameworks, models)</p> </li> <li> <p>Add functional descriptors (automation, analysis, generation)</p> </li> <li> <p>Include use case keywords (customer service, data processing, content creation)</p> </li> <li> <p>Use common terminology that others would search for</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#visual-assets","title":"Visual Assets","text":"<p>Image Guidelines:</p> <ul> <li> <p>File Size: Maximum 60MB supported</p> </li> <li> <p>Recommended Types: Screenshots, diagrams, logos, workflow illustrations</p> </li> <li> <p>Quality: High-resolution images that clearly represent your contribution</p> </li> <li> <p>Content: Visual representations of functionality, architecture, or results</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#community-engagement","title":"Community Engagement","text":""},{"location":"swarms_platform/share_and_discover/#rating-and-reviews","title":"Rating and Reviews","text":"<p>As a User:</p> <ul> <li> <p>Rate content honestly based on quality and usefulness</p> </li> <li> <p>Leave constructive feedback to help creators improve</p> </li> <li> <p>Share your experiences and modifications</p> </li> </ul> <p>As a Creator:</p> <ul> <li> <p>Respond to feedback and questions</p> </li> <li> <p>Update your submissions based on community input</p> </li> <li> <p>Engage with users who implement your solutions</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#building-your-reputation","title":"Building Your Reputation","text":"<p>Consistency: Regularly contribute high-quality content Responsiveness: Engage with community feedback and questions Innovation: Share unique approaches and creative solutions Collaboration: Build upon and improve existing community contributions</p>"},{"location":"swarms_platform/share_and_discover/#what-makes-content-successful","title":"What Makes Content Successful","text":"<p>Clear Value Proposition: Immediately obvious benefits and use cases Production Ready: Fully functional, tested implementations Good Documentation: Clear instructions and examples Active Magentntenance: Regular updates and community engagement Unique Approach: Novel solutions or creative implementations</p>"},{"location":"swarms_platform/share_and_discover/#getting-started","title":"Getting Started","text":""},{"location":"swarms_platform/share_and_discover/#for-new-contributors","title":"For New Contributors","text":"<ol> <li>Explore First: Browse existing content to understand community standards</li> <li>Start Small: Begin with a simple but useful contribution</li> <li>Focus on Quality: Prioritize completeness and documentation over quantity</li> <li>Engage: Participate in discussions and provide feedback to others</li> </ol>"},{"location":"swarms_platform/share_and_discover/#for-experienced-developers","title":"For Experienced Developers","text":"<ol> <li>Share Expertise: Contribute advanced implementations and frameworks</li> <li>Mentor Others: Provide feedback and suggestions to new contributors</li> <li>Lead Innovation: Introduce cutting-edge approaches and techniques</li> <li>Build Ecosystems: Create complementary tools and integrations</li> </ol>"},{"location":"swarms_platform/share_and_discover/#best-practices-summary","title":"Best Practices Summary","text":""},{"location":"swarms_platform/share_and_discover/#before-submitting","title":"Before Submitting","text":"<ul> <li> <p>\u2705 Test your contribution thoroughly</p> </li> <li> <p>\u2705 Write clear, comprehensive documentation</p> </li> <li> <p>\u2705 Choose appropriate categories and tags</p> </li> <li> <p>\u2705 Create or find a representative image</p> </li> <li> <p>\u2705 Review similar existing content</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#after-submitting","title":"After Submitting","text":"<ul> <li> <p>\u2705 Monitor for community feedback</p> </li> <li> <p>\u2705 Respond to questions and comments</p> </li> <li> <p>\u2705 Update based on user suggestions</p> </li> <li> <p>\u2705 Share your contribution on social platforms</p> </li> <li> <p>\u2705 Continue improving and iterating</p> </li> </ul>"},{"location":"swarms_platform/share_and_discover/#join-the-community","title":"Join the Community","text":"<p>The Swarms Marketplace thrives on community participation. Whether you're sharing a simple prompt or a complex multi-agent system, your contribution makes the entire ecosystem stronger. Start exploring, contributing, and collaborating today!</p> <p>Ready to contribute? Visit <code>https://swarms.world</code> and click \"Add Prompt,\" \"Add Agent,\" or \"Add Tool\" to share your innovation with the world.</p> <p>Together, we're building the future of agent collaboration, one contribution at a time.</p>"},{"location":"swarms_platform/agents/agents_api/","title":"Agents API Documentation","text":"<p>The <code>https://swarms.world/api/add-agent</code> endpoint allows users to add a new agent to the Swarms platform. This API accepts a POST request with a JSON body containing details of the agent, such as its name, description, use cases, language, tags and requirements. The request must be authenticated using an API key.</p>"},{"location":"swarms_platform/agents/agents_api/#endpoint-add-agent","title":"Endpoint: Add Agent","text":"<ul> <li>URL: <code>https://swarms.world/api/add-agent</code></li> <li>Method: POST</li> <li>Content-Type: <code>application/json</code></li> <li>Authorization: Bearer token required in the header</li> </ul>"},{"location":"swarms_platform/agents/agents_api/#request-parameters","title":"Request Parameters","text":"<p>The request body should be a JSON object with the following attributes:</p> Attribute Type Description Required <code>name</code> <code>string</code> The name of the agent. Yes <code>agent</code> <code>string</code> The agent text. Yes <code>description</code> <code>string</code> A brief description of the agent. Yes <code>language</code> <code>string</code> The agent's syntax language with a default of python No <code>useCases</code> <code>array</code> An array of use cases, each containing a title and description. Yes <code>requirements</code> <code>array</code> An array of requirements, each containing a package name and installation. Yes <code>tags</code> <code>string</code> Comma-separated tags for the agent. Yes"},{"location":"swarms_platform/agents/agents_api/#usecases-structure","title":"<code>useCases</code> Structure","text":"<p>Each use case in the <code>useCases</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>title</code> <code>string</code> The title of the use case. Yes <code>description</code> <code>string</code> A brief description of the use case. Yes"},{"location":"swarms_platform/agents/agents_api/#requirements-structure","title":"<code>requirements</code> Structure","text":"<p>Each requirement in the <code>requirements</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>package</code> <code>string</code> The name of the package. Yes <code>installation</code> <code>string</code> Installation command for the package Yes"},{"location":"swarms_platform/agents/agents_api/#example-usage","title":"Example Usage","text":""},{"location":"swarms_platform/agents/agents_api/#python","title":"Python","text":"<pre><code>import requests\nimport json\nimport os\n\n\nurl = \"https://swarms.world/api/add-agent\"\n\nheaders = {\n  \"Content-Type\": \"application/json\",\n  \"Authorization\": f\"Bearer {os.getenv(\"SWARMS_API_KEY\")}\"\n}\n\ndata = {\n  \"name\": \"Example Agent\",\n  \"agent\": \"This is an example agent from an API route.\",\n  \"description\": \"Description of the agent.\",\n  \"language\": \"python\",\n  \"useCases\": [\n      {\"title\": \"Use case 1\", \"description\": \"Description of use case 1\"},\n      {\"title\": \"Use case 2\", \"description\": \"Description of use case 2\"}\n  ],\n  \"requirements\": [\n      {\"package\": \"pip\", \"installation\": \"pip install\"},\n      {\"package\": \"pip3\", \"installation\": \"pip3 install\"}\n  ],\n    \"tags\": \"example, agent\"\n}\n\nresponse = requests.post(url, headers=headers, data=json.dumps(data))\nprint(response.json())\n</code></pre>"},{"location":"swarms_platform/agents/agents_api/#nodejs","title":"Node.js","text":"<pre><code>const fetch = require(\"node-fetch\");\n\nasync function addAgentHandler() {\n  try {\n    const response = await fetch(\"https://swarms.world/api/add-agent\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer {apiKey}\",\n      },\n      body: JSON.stringify({\n        name: \"Example Agent\",\n        agent: \"This is an example agent from an API route.\",\n        description: \"Description of the agent.\",\n        language: \"python\",\n        useCases: [\n          { title: \"Use case 1\", description: \"Description of use case 1\" },\n          { title: \"Use case 2\", description: \"Description of use case 2\" },\n        ],\n        requirements: [\n          { package: \"pip\", installation: \"pip install\" },\n          { package: \"pip3\", installation: \"pip3 install\" },\n        ],\n        tags: \"example, agent\",\n      }),\n    });\n\n    const result = await response.json();\n    console.log(result);\n  } catch (error) {\n    console.error(\"An error has occurred\", error);\n  }\n}\n\naddAgentHandler();\n</code></pre>"},{"location":"swarms_platform/agents/agents_api/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"https://swarms.world/api/add-agent\"\n    payload := map[string]interface{}{\n        \"name\":       \"Example Agent\",\n        \"agent\":      \"This is an example agent from an API route.\",\n        \"description\": \"Description of the agent.\",\n        \"useCases\": []map[string]string{\n            {\"title\": \"Use case 1\", \"description\": \"Description of use case 1\"},\n            {\"title\": \"Use case 2\", \"description\": \"Description of use case 2\"},\n        },\n        \"requirements\": []map[string]string{\n            {\"package\": \"pip\", \"installation\": \"pip install\"},\n            {\"package\": \"pip3\", \"installation\": \"pip3 install\"}\n        },\n        \"tags\": \"example, agent\",\n    }\n    jsonPayload, _ := json.Marshal(payload)\n\n    req, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonPayload))\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        fmt.Println(\"An error has occurred\", err)\n        return\n    }\n    defer resp.Body.Close()\n\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;result)\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"swarms_platform/agents/agents_api/#curl","title":"cURL","text":"<pre><code>curl -X POST https://swarms.world/api/add-agent \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\" \\\n-d '{\n    \"name\": \"Example Agent\",\n    \"agent\": \"This is an example agent from an API route.\",\n    \"description\": \"Description of the agent.\",\n    \"language\": \"python\",\n    \"useCases\": [\n        { title: \"Use case 1\", description: \"Description of use case 1\" },\n        { title: \"Use case 2\", description: \"Description of use case 2\" },\n    ],\n    \"requirements\": [\n        { package: \"pip\", installation: \"pip install\" },\n        { package: \"pip3\", installation: \"pip3 install\" },\n    ],\n    \"tags\": \"example, agent\",\n}'\n</code></pre>"},{"location":"swarms_platform/agents/agents_api/#response","title":"Response","text":"<p>The response will be a JSON object containing the result of the operation. Example response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Agent added successfully\",\n  \"data\": {\n    \"id\": \"agent_id\",\n    \"name\": \"Example Agent\",\n    \"agent\": \"This is an example agent from an API route.\",\n    \"description\": \"Description of the agent.\",\n    \"language\": \"python\",\n    \"useCases\": [\n      { \"title\": \"Use case 1\", \"description\": \"Description of use case 1\" },\n      { \"title\": \"Use case 2\", \"description\": \"Description of use case 2\" }\n    ],\n    \"requirements\": [\n      { \"package\": \"pip\", \"installation\": \"pip install\" },\n      { \"package\": \"pip3\", \"installation\": \"pip3 install\" }\n    ],\n    \"tags\": \"example, agent\"\n  }\n}\n</code></pre>"},{"location":"swarms_platform/agents/edit_agent/","title":"Endpoint: Edit Agent","text":"<p>The <code>https://swarms.world/api/edit-agent</code> endpoint allows users to edit an existing agent on the Swarms platform. This API accepts a POST request with a JSON body containing the agent details to be updated, such as its id, name, description, use cases, language, tags and requirements. The request must be authenticated using an API key.</p>"},{"location":"swarms_platform/agents/edit_agent/#endpoint","title":"Endpoint","text":"<ul> <li>URL: <code>https://swarms.world/api/edit-agent</code></li> <li>Method: POST</li> <li>Content-Type: <code>application/json</code></li> <li>Authorization: Bearer token required in the header</li> </ul>"},{"location":"swarms_platform/agents/edit_agent/#request-parameters","title":"Request Parameters","text":"<p>The request body should be a JSON object with the following attributes:</p> Attribute Type Description Required <code>id</code> <code>string</code> The ID of the agent to be edited. Yes <code>name</code> <code>string</code> The name of the agent. Yes <code>agent</code> <code>string</code> The agent text. Yes <code>description</code> <code>string</code> A brief description of the agent. Yes <code>language</code> <code>string</code> The agent's syntax language No <code>useCases</code> <code>array</code> An array of use cases, each containing a title and description. Yes <code>requirements</code> <code>array</code> An array of requirements, each containing a package name and installation. Yes <code>tags</code> <code>string</code> Comma-separated tags for the agent. No"},{"location":"swarms_platform/agents/edit_agent/#usecases-structure","title":"<code>useCases</code> Structure","text":"<p>Each use case in the <code>useCases</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>title</code> <code>string</code> The title of the use case. Yes <code>description</code> <code>string</code> A brief description of the use case. Yes"},{"location":"swarms_platform/agents/edit_agent/#requirements-structure","title":"<code>requirements</code> Structure","text":"<p>Each requirement in the <code>requirements</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>package</code> <code>string</code> The name of the package. Yes <code>installation</code> <code>string</code> Installation command for the package Yes"},{"location":"swarms_platform/agents/edit_agent/#example-usage","title":"Example Usage","text":""},{"location":"swarms_platform/agents/edit_agent/#python","title":"Python","text":"<pre><code>import requests\nimport json\n\nurl = \"https://swarms.world/api/edit-agent\"\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"Bearer {apiKey}\"\n}\ndata = {\n    \"id\": \"agent_id\",\n    \"name\": \"Updated agent\",\n    \"agent\": \"This is an updated agent from an API route.\",\n    \"description\": \"Updated description of the agent.\",\n    \"language\": \"javascript\",\n    \"useCases\": [\n        {\"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\"},\n        {\"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\"}\n    ],\n    \"requirements\": [\n        { \"package\": \"express\", \"installation\": \"npm install express\" },\n        { \"package\": \"lodash\", \"installation\": \"npm install lodash\" },\n    ],\n    \"tags\": \"updated, agent\"\n}\n\nresponse = requests.post(url, headers=headers, data=json.dumps(data))\nprint(response.json())\n</code></pre>"},{"location":"swarms_platform/agents/edit_agent/#nodejs","title":"Node.js","text":"<pre><code>const fetch = require(\"node-fetch\");\n\nasync function editAgentHandler() {\n  try {\n    const response = await fetch(\"https://swarms.world/api/edit-agent\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer {apiKey}\",\n      },\n      body: JSON.stringify({\n        id: \"agent_id\",\n        name: \"Updated agent\",\n        agent: \"This is an updated agent from an API route.\",\n        description: \"Updated description of the agent.\",\n        language: \"javascript\",\n        useCases: [\n          {\n            title: \"Updated use case 1\",\n            description: \"Updated description of use case 1\",\n          },\n          {\n            title: \"Updated use case 2\",\n            description: \"Updated description of use case 2\",\n          },\n        ],\n        requirements: [\n          { package: \"express\", installation: \"npm install express\" },\n          { package: \"lodash\", installation: \"npm install lodash\" },\n        ],\n        tags: \"updated, agent\",\n      }),\n    });\n\n    const result = await response.json();\n    console.log(result);\n  } catch (error) {\n    console.error(\"An error has occurred\", error);\n  }\n}\n\neditAgentHandler();\n</code></pre>"},{"location":"swarms_platform/agents/edit_agent/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"https://swarms.world/api/edit-agent\"\n    payload := map[string]interface{}{\n        \"id\":          \"agent_id\",\n        \"name\":        \"Updated Agent\",\n        \"agent\":      \"This is an updated agent from an API route.\",\n        \"description\": \"Updated description of the agent.\",\n        \"language\": \"javascript\",\n        \"useCases\": []map[string]string{\n            {\"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\"},\n            {\"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\"},\n        },\n        \"requirements\": []map[string]string{\n            {\"package\": \"express\", \"installation\": \"npm install express\"},\n            {\"package\": \"lodash\", \"installation\": \"npm install lodash\"},\n        },\n        \"tags\": \"updated, agent\",\n    }\n    jsonPayload, _ := json.Marshal(payload)\n\n    req, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonPayload))\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        fmt.Println(\"An error has occurred\", err)\n        return\n    }\n    defer resp.Body.Close()\n\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;result)\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"swarms_platform/agents/edit_agent/#curl","title":"cURL","text":"<pre><code>curl -X POST https://swarms.world/api/edit-agent \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\" \\\n-d '{\n    \"id\": \"agent_id\",\n    \"name\": \"Updated agent\",\n    \"agent\": \"This is an updated agent from an API route.\",\n    \"description\": \"Updated description of the agent.\",\n    \"language\": \"javascript\",\n    \"useCases\": [\n        {\"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\"},\n        {\"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\"}\n    ],\n    \"requirements\": [\n        { \"package\": \"express\", \"installation\": \"npm install express\" },\n        { \"package\": \"lodash\", \"installation\": \"npm install lodash\" },\n    ],\n    \"tags\": \"updated, agent\"\n}'\n</code></pre>"},{"location":"swarms_platform/agents/edit_agent/#response","title":"Response","text":"<p>The response will be a JSON object containing the result of the operation. Example response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Agent updated successfully\",\n  \"data\": {\n    \"id\": \"agent_id\",\n    \"name\": \"Updated agent\",\n    \"agent\": \"This is an updated agent from an API route.\",\n    \"description\": \"Updated description of the agent.\",\n    \"language\": \"javascript\",\n    \"useCases\": [\n      {\n        \"title\": \"Updated use case 1\",\n        \"description\": \"Updated description of use case 1\"\n      },\n      {\n        \"title\": \"Updated use case 2\",\n        \"description\": \"Updated description of use case 2\"\n      }\n    ],\n    \"requirements\": [\n      { \"package\": \"express\", \"installation\": \"npm install express\" },\n      { \"package\": \"lodash\", \"installation\": \"npm install lodash\" }\n    ],\n    \"tags\": \"updated, agent\"\n  }\n}\n</code></pre> <p>In case of an error, the response will contain an error message detailing the issue.</p>"},{"location":"swarms_platform/agents/edit_agent/#common-issues-and-tips","title":"Common Issues and Tips","text":"<ul> <li>Authentication Error: Ensure that the <code>Authorization</code> header is correctly set with a valid API key.</li> <li>Invalid JSON: Make sure the request body is a valid JSON object.</li> <li>Missing Required Fields: Ensure that all required fields (<code>name</code>, <code>agent</code>, <code>description</code>, <code>useCases</code>, <code>requirements</code>) are included in the request body.</li> <li>Network Issues: Verify network connectivity and endpoint URL.</li> </ul>"},{"location":"swarms_platform/agents/edit_agent/#references-and-resources","title":"References and Resources","text":"<ul> <li>API Authentication Guide</li> <li>JSON Structure Standards</li> <li>Fetch API Documentation (Node.js)</li> <li>Requests Library (Python)</li> <li>Net/HTTP Package (Go)</li> </ul> <p>This comprehensive documentation provides all the necessary information to effectively use the <code>https://swarms.world/api/add-agent</code> and <code>https://swarms.world/api/edit-agent</code> endpoints, including details on request parameters, example code snippets in multiple programming languages, and troubleshooting tips.</p>"},{"location":"swarms_platform/agents/fetch_agents/","title":"Documentation for <code>getAllAgents</code> API Endpoint","text":"<p>The <code>getAllAgents</code> API endpoint is a part of the <code>swarms.world</code> application, designed to fetch all agent records from the database. This endpoint is crucial for retrieving various agents stored in the <code>swarms_cloud_agents</code> table, including their metadata such as name, description, use cases, language, requirements and tags. It provides an authenticated way to access this data, ensuring that only authorized users can retrieve the information.</p>"},{"location":"swarms_platform/agents/fetch_agents/#purpose","title":"Purpose","text":"<p>The primary purpose of this API endpoint is to provide a method for clients to fetch a list of agents stored in the <code>swarms_cloud_agents</code> table, with the ability to filter by name, tags, language, requirement package and use cases. It ensures data integrity and security by using an authentication guard and handles various HTTP methods and errors gracefully.</p>"},{"location":"swarms_platform/agents/fetch_agents/#api-endpoint-definition","title":"API Endpoint Definition","text":""},{"location":"swarms_platform/agents/fetch_agents/#fetch-all-agents","title":"Fetch All Agents","text":""},{"location":"swarms_platform/agents/fetch_agents/#endpoint-url","title":"Endpoint URL","text":"<pre><code>https://swarms.world/get-agents\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#http-method","title":"HTTP Method","text":"<pre><code>GET\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#request-headers","title":"Request Headers","text":"Header Type Required Description Authorization String Yes Bearer token for API access"},{"location":"swarms_platform/agents/fetch_agents/#query-parameters","title":"Query Parameters","text":"<ul> <li>name (optional): A substring to match against the agent name. The query is case-insensitive.</li> <li>tag (optional): A comma-separated list of tags to filter agents by. The query matches any of the provided tags, and is case-insensitive.</li> <li>language (optional): A substring to match against the language the agent is written in. The query is case-insensitive.</li> <li>use_case (optional): A substring to match against the use case titles within the <code>use_cases</code> array. The query is case-insensitive.</li> <li>req_package (optional): A substring to match against the requirement packaages within the <code>requirements</code> array. The query is case-insensitive.</li> </ul>"},{"location":"swarms_platform/agents/fetch_agents/#response","title":"Response","text":""},{"location":"swarms_platform/agents/fetch_agents/#success-response-200","title":"Success Response (200)","text":"<p>Returns an array of agents.</p> <pre><code>[\n  {\n    \"id\": \"string\",\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"language\": \"string\",\n    \"agent\": \"string\",\n    \"use_cases\": [\n      {\n        \"title\": \"string\",\n        \"description\": \"string\"\n      }\n    ],\n    \"requirements\": [\n      {\n        \"package\": \"string\",\n        \"installation\": \"string\"\n      }\n    ],\n    \"tags\": \"string\"\n  },\n  ...\n]\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#error-responses","title":"Error Responses","text":"<ul> <li>405 Method Not Allowed</li> </ul> <pre><code>{\n  \"error\": \"Method &lt;method&gt; Not Allowed\"\n}\n</code></pre> <ul> <li>500 Internal Server Error</li> </ul> <pre><code>{\n  \"error\": \"Could not fetch agents\"\n}\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#fetch-agent-by-id","title":"Fetch Agent by ID","text":""},{"location":"swarms_platform/agents/fetch_agents/#endpoint-url_1","title":"Endpoint URL","text":"<pre><code>https://swarms.world/get-agents/[id]\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#http-method_1","title":"HTTP Method","text":"<pre><code>GET\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#request-headers_1","title":"Request Headers","text":"Header Type Required Description Authorization String Yes Bearer token for API access"},{"location":"swarms_platform/agents/fetch_agents/#response_1","title":"Response","text":""},{"location":"swarms_platform/agents/fetch_agents/#success-response-200_1","title":"Success Response (200)","text":"<p>Returns a single agent by ID.</p> <pre><code>{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"language\": \"string\",\n  \"agent\": \"string\",\n  \"use_cases\": [\n    {\n      \"title\": \"string\",\n      \"description\": \"string\"\n    }\n  ],\n  \"requirements\": [\n    {\n      \"package\": \"string\",\n      \"installation\": \"string\"\n    }\n  ],\n  \"tags\": \"string\"\n}\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#error-responses_1","title":"Error Responses","text":"<ul> <li>404 Not Found</li> </ul> <pre><code>{\n  \"error\": \"Agent not found\"\n}\n</code></pre> <ul> <li>500 Internal Server Error</li> </ul> <pre><code>{\n  \"error\": \"Could not fetch agent\"\n}\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#request-handling","title":"Request Handling","text":"<ol> <li> <p>Method Validation: The endpoint only supports the <code>GET</code> method. If a different HTTP method is used, it responds with a <code>405 Method Not Allowed</code> status.</p> </li> <li> <p>Database Query:</p> </li> <li> <p>Fetching All Agents: The endpoint uses the <code>supabaseAdmin</code> client to query the <code>swarms_cloud_agents</code> table. Filters are applied based on the query parameters (<code>name</code>, <code>tag</code>, <code>language</code>, <code>req_package</code> and <code>use_case</code>).</p> </li> <li> <p>Fetching an Agent by ID: The endpoint retrieves a single agent from the <code>swarms_cloud_agents</code> table by its unique ID.</p> </li> <li> <p>Response: On success, it returns the agent data in JSON format. In case of an error during the database query, a <code>500 Internal Server Error</code> status is returned. For fetching by ID, if the agent is not found, it returns a <code>404 Not Found</code> status.</p> </li> </ol>"},{"location":"swarms_platform/agents/fetch_agents/#code-example","title":"Code Example","text":""},{"location":"swarms_platform/agents/fetch_agents/#javascript-nodejs","title":"JavaScript (Node.js)","text":"<pre><code>import fetch from \"node-fetch\";\n\n// Fetch all agents with optional filters\nconst getAgents = async (filters) =&gt; {\n  const queryString = new URLSearchParams(filters).toString();\n  const response = await fetch(\n    `https://swarms.world/get-agents?${queryString}`,\n    {\n      method: \"GET\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer {apiKey}\",\n      },\n    }\n  );\n\n  if (!response.ok) {\n    throw new Error(`Error: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Fetch agent by ID\nconst getAgentById = async (id) =&gt; {\n  const response = await fetch(`https://swarms.world/get-agents/${id}`, {\n    method: \"GET\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: \"Bearer {apiKey}\",\n    },\n  });\n\n  if (!response.ok) {\n    throw new Error(`Error: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Example usage\ngetAgents({\n  name: \"example\",\n  tag: \"tag1,tag2\",\n  use_case: \"example\",\n  language: \"langauge\",\n  req_package: \"package_name\",\n}).catch(console.error);\ngetAgentById(\"123\").catch(console.error);\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#python","title":"Python","text":"<pre><code>import requests\n\nAPI_KEY = \"{apiKey}\"\n\n# Fetch all agents with optional filters\ndef get_agents(filters):\n    query_string = \"&amp;\".join([f\"{key}={value}\" for key, value in filters.items()])\n    url = f\"https://swarms.world/get-agents?{query_string}\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {API_KEY}\",\n    }\n    response = requests.get(url, headers=headers)\n\n    if not response.ok:\n        raise Exception(f\"Error: {response.reason}\")\n\n    data = response.json()\n    print(data)\n    return data\n\n# Fetch agent by ID\ndef get_agent_by_id(agent_id):\n    url = f\"https://swarms.world/get-agents/{agent_id}\"\n    headers = {\n        \"Content-Type\": \"application/json\",\n        \"Authorization\": f\"Bearer {API_KEY}\",\n    }\n    response = requests.get(url, headers=headers)\n\n    if not response.ok:\n        raise Exception(f\"Error: {response.reason}\")\n\n    data = response.json()\n    print(data)\n    return data\n\n# Example usage\ntry:\n    get_agents({\n        \"name\": \"example\",\n        \"tag\": \"tag1,tag2\",\n        \"use_case\": \"example\",\n        \"language\": \"language\",\n        \"req_package\": \"package_name\",\n    })\nexcept Exception as e:\n    print(e)\n\ntry:\n    get_agent_by_id(\"123\")\nexcept Exception as e:\n    print(e)\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#curl","title":"cURL","text":"<pre><code># Fetch all agents with optional filters\ncurl -X GET \"https://swarms.world/get-agents?name=example&amp;tag=tag1,tag2&amp;use_case=example&amp;language=language&amp;req_package=package_name\" \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\"\n\n# Fetch agent by ID\ncurl -X GET \"https://swarms.world/get-agents/123\" \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\"\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n    \"net/url\"\n    \"os\"\n)\n\nfunc getAgents(filters map[string]string) error {\n    query := url.Values{}\n    for key, value := range filters {\n        query.Set(key, value)\n    }\n\n    url := fmt.Sprintf(\"https://swarms.world/get-agents?%s\", query.Encode())\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"error: %s\", resp.Status)\n    }\n\n    var data interface{}\n    if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {\n        return err\n    }\n\n    fmt.Println(data)\n    return nil\n}\n\nfunc getAgentById(id string) error {\n    url := fmt.Sprintf(\"https://swarms.world/get-agents/%s\", id)\n    req, err := http.NewRequest(\"GET\", url, nil)\n    if err != nil {\n        return err\n    }\n\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        return err\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        return fmt.Errorf(\"error: %s\", resp.Status)\n    }\n\n    var data interface{}\n    if err := json.NewDecoder(resp.Body).Decode(&amp;data); err != nil {\n        return err\n    }\n\n    fmt.Println(data)\n    return nil\n}\nfunc main() {\n    filters := map[string]string{\n        \"name\":        \"example\",\n        \"tag\":         \"tag1,tag2\",\n        \"use_case\":    \"example\",\n        \"language\":    \"language\",\n        \"req_package\": \"package_name\",\n    }\n\n    getAgents(filters)\n    getAgentById(\"123\")\n}\n</code></pre>"},{"location":"swarms_platform/agents/fetch_agents/#attributes-table","title":"Attributes Table","text":"Attribute Type Description id String Unique identifier for the agent name String Name of the agent description String Description of the agent agent String The actual agent lanuage String The code language of the agent use_cases Array Use cases for the agent requirements Array Requirements for the agent tags String Tags associated with the agent"},{"location":"swarms_platform/agents/fetch_agents/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Handle different error statuses appropriately to provide clear feedback to users.</li> <li>Consider implementing rate limiting and logging for better security and monitoring.</li> </ul>"},{"location":"swarms_platform/agents/fetch_agents/#references-and-resources","title":"References and Resources","text":"<ul> <li>Next.js API Routes</li> <li>Supabase Documentation</li> <li>Node Fetch</li> <li>Requests Library (Python)</li> <li>Go net/http Package</li> </ul> <p>This documentation provides a comprehensive guide to the <code>getAllAgents</code> API endpoint, including usage examples in multiple programming languages and detailed attribute descriptions.</p>"},{"location":"swarms_platform/prompts/add_prompt/","title":"Prompts API Documentation","text":"<p>The <code>https://swarms.world/api/add-prompt</code> endpoint allows users to add a new prompt to the Swarms platform. This API accepts a POST request with a JSON body containing details of the prompt, such as its name, description, use cases, and tags. The request must be authenticated using an API key.</p>"},{"location":"swarms_platform/prompts/add_prompt/#endpoint-add-prompt","title":"Endpoint: Add Prompt","text":"<ul> <li>URL: <code>https://swarms.world/api/add-prompt</code></li> <li>Method: POST</li> <li>Content-Type: <code>application/json</code></li> <li>Authorization: Bearer token required in the header</li> </ul>"},{"location":"swarms_platform/prompts/add_prompt/#request-parameters","title":"Request Parameters","text":"<p>The request body should be a JSON object with the following attributes:</p> Attribute Type Description Required <code>name</code> <code>string</code> The name of the prompt. Yes <code>prompt</code> <code>string</code> The prompt text. Yes <code>description</code> <code>string</code> A brief description of the prompt. Yes <code>useCases</code> <code>array</code> An array of use cases, each containing a title and description. Yes <code>tags</code> <code>string</code> Comma-separated tags for the prompt. No"},{"location":"swarms_platform/prompts/add_prompt/#usecases-structure","title":"<code>useCases</code> Structure","text":"<p>Each use case in the <code>useCases</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>title</code> <code>string</code> The title of the use case. Yes <code>description</code> <code>string</code> A brief description of the use case. Yes"},{"location":"swarms_platform/prompts/add_prompt/#example-usage","title":"Example Usage","text":""},{"location":"swarms_platform/prompts/add_prompt/#python","title":"Python","text":"<pre><code>import requests\nimport json\n\nurl = \"https://swarms.world/api/add-prompt\"\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"Bearer {apiKey}\"\n}\ndata = {\n    \"name\": \"Example Prompt\",\n    \"prompt\": \"This is an example prompt from an API route.\",\n    \"description\": \"Description of the prompt.\",\n    \"useCases\": [\n        {\"title\": \"Use case 1\", \"description\": \"Description of use case 1\"},\n        {\"title\": \"Use case 2\", \"description\": \"Description of use case 2\"}\n    ],\n    \"tags\": \"example, prompt\"\n}\n\nresponse = requests.post(url, headers=headers, data=json.dumps(data))\nprint(response.json())\n</code></pre>"},{"location":"swarms_platform/prompts/add_prompt/#nodejs","title":"Node.js","text":"<pre><code>const fetch = require(\"node-fetch\");\n\nasync function addPromptsHandler() {\n  try {\n    const response = await fetch(\"https://swarms.world/api/add-prompt\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer {apiKey}\",\n      },\n      body: JSON.stringify({\n        name: \"Example Prompt\",\n        prompt: \"This is an example prompt from an API route.\",\n        description: \"Description of the prompt.\",\n        useCases: [\n          { title: \"Use case 1\", description: \"Description of use case 1\" },\n          { title: \"Use case 2\", description: \"Description of use case 2\" },\n        ],\n        tags: \"example, prompt\",\n      }),\n    });\n\n    const result = await response.json();\n    console.log(result);\n  } catch (error) {\n    console.error(\"An error has occurred\", error);\n  }\n}\n\naddPromptsHandler();\n</code></pre>"},{"location":"swarms_platform/prompts/add_prompt/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"https://swarms.world/api/add-prompt\"\n    payload := map[string]interface{}{\n        \"name\":        \"Example Prompt\",\n        \"prompt\":      \"This is an example prompt from an API route.\",\n        \"description\": \"Description of the prompt.\",\n        \"useCases\": []map[string]string{\n            {\"title\": \"Use case 1\", \"description\": \"Description of use case 1\"},\n            {\"title\": \"Use case 2\", \"description\": \"Description of use case 2\"},\n        },\n        \"tags\": \"example, prompt\",\n    }\n    jsonPayload, _ := json.Marshal(payload)\n\n    req, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonPayload))\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        fmt.Println(\"An error has occurred\", err)\n        return\n    }\n    defer resp.Body.Close()\n\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;result)\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"swarms_platform/prompts/add_prompt/#curl","title":"cURL","text":"<pre><code>curl -X POST https://swarms.world/api/add-prompt \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\" \\\n-d '{\n  \"name\": \"Example Prompt\",\n  \"prompt\": \"This is an example prompt from an API route.\",\n  \"description\": \"Description of the prompt.\",\n  \"useCases\": [\n    { \"title\": \"Use case 1\", \"description\": \"Description of use case 1\" },\n    { \"title\": \"Use case 2\", \"description\": \"Description of use case 2\" }\n  ],\n  \"tags\": \"example, prompt\"\n}'\n</code></pre>"},{"location":"swarms_platform/prompts/add_prompt/#response","title":"Response","text":"<p>The response will be a JSON object containing the result of the operation. Example response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Prompt added successfully\",\n  \"data\": {\n    \"id\": \"prompt_id\",\n    \"name\": \"Example Prompt\",\n    \"prompt\": \"This is an example prompt from an API route.\",\n    \"description\": \"Description of the prompt.\",\n    \"useCases\": [\n      { \"title\": \"Use case 1\", \"description\": \"Description of use case 1\" },\n      { \"title\": \"Use case 2\", \"description\": \"Description of use case 2\" }\n    ],\n    \"tags\": \"example, prompt\"\n  }\n}\n</code></pre>"},{"location":"swarms_platform/prompts/edit_prompt/","title":"Endpoint: Edit Prompt","text":"<p>The <code>https://swarms.world/api/edit-prompt</code> endpoint allows users to edit an existing prompt on the Swarms platform. This API accepts a POST request with a JSON body containing the prompt details to be updated, such as its name, description, use cases, and tags. The request must be authenticated using an API key.</p>"},{"location":"swarms_platform/prompts/edit_prompt/#endpoint","title":"Endpoint","text":"<ul> <li>URL: <code>https://swarms.world/api/edit-prompt</code></li> <li>Method: POST</li> <li>Content-Type: <code>application/json</code></li> <li>Authorization: Bearer token required in the header</li> </ul>"},{"location":"swarms_platform/prompts/edit_prompt/#request-parameters","title":"Request Parameters","text":"<p>The request body should be a JSON object with the following attributes:</p> Attribute Type Description Required <code>id</code> <code>string</code> The ID of the prompt to be edited. Yes <code>name</code> <code>string</code> The name of the prompt. Yes <code>prompt</code> <code>string</code> The prompt text. Yes <code>description</code> <code>string</code> A brief description of the prompt. No <code>useCases</code> <code>array</code> An array of use cases, each containing a title and description. Yes <code>tags</code> <code>string</code> Comma-separated tags for the prompt. No"},{"location":"swarms_platform/prompts/edit_prompt/#usecases-structure","title":"<code>useCases</code> Structure","text":"<p>Each use case in the <code>useCases</code> array should be an object with the following attributes:</p> Attribute Type Description Required <code>title</code> <code>string</code> The title of the use case. Yes <code>description</code> <code>string</code> A brief description of the use case. Yes"},{"location":"swarms_platform/prompts/edit_prompt/#example-usage","title":"Example Usage","text":""},{"location":"swarms_platform/prompts/edit_prompt/#python","title":"Python","text":"<pre><code>import requests\nimport json\n\nurl = \"https://swarms.world/api/edit-prompt\"\nheaders = {\n    \"Content-Type\": \"application/json\",\n    \"Authorization\": \"Bearer {apiKey}\"\n}\ndata = {\n    \"id\": \"prompt_id\",\n    \"name\": \"Updated Prompt\",\n    \"prompt\": \"This is an updated prompt from an API route.\",\n    \"description\": \"Updated description of the prompt.\",\n    \"useCases\": [\n        {\"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\"},\n        {\"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\"}\n    ],\n    \"tags\": \"updated, prompt\"\n}\n\nresponse = requests.post(url, headers=headers, data=json.dumps(data))\nprint(response.json())\n</code></pre>"},{"location":"swarms_platform/prompts/edit_prompt/#nodejs","title":"Node.js","text":"<pre><code>const fetch = require(\"node-fetch\");\n\nasync function editPromptsHandler() {\n  try {\n    const response = await fetch(\"https://swarms.world/api/edit-prompt\", {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: \"Bearer {apiKey}\",\n      },\n      body: JSON.stringify({\n        id: \"prompt_id\",\n        name: \"Updated Prompt\",\n        prompt: \"This is an updated prompt from an API route.\",\n        description: \"Updated description of the prompt.\",\n        useCases: [\n          {\n            title: \"Updated use case 1\",\n            description: \"Updated description of use case 1\",\n          },\n          {\n            title: \"Updated use case 2\",\n            description: \"Updated description of use case 2\",\n          },\n        ],\n        tags: \"updated, prompt\",\n      }),\n    });\n\n    const result = await response.json();\n    console.log(result);\n  } catch (error) {\n    console.error(\"An error has occurred\", error);\n  }\n}\n\neditPromptsHandler();\n</code></pre>"},{"location":"swarms_platform/prompts/edit_prompt/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"bytes\"\n    \"encoding/json\"\n    \"fmt\"\n    \"net/http\"\n)\n\nfunc main() {\n    url := \"https://swarms.world/api/edit-prompt\"\n    payload := map[string]interface{}{\n        \"id\":          \"prompt_id\",\n        \"name\":        \"Updated Prompt\",\n        \"prompt\":      \"This is an updated prompt from an API route.\",\n        \"description\": \"Updated description of the prompt.\",\n        \"useCases\": []map[string]string{\n            {\"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\"},\n            {\"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\"},\n        },\n        \"tags\": \"updated, prompt\",\n    }\n    jsonPayload, _ := json.Marshal(payload)\n\n    req, _ := http.NewRequest(\"POST\", url, bytes.NewBuffer(jsonPayload))\n    req.Header.Set(\"Content-Type\", \"application/json\")\n    req.Header.Set(\"Authorization\", \"Bearer {apiKey}\")\n\n    client := &amp;http.Client{}\n    resp, err := client.Do(req)\n    if err != nil {\n        fmt.Println(\"An error has occurred\", err)\n        return\n    }\n    defer resp.Body.Close()\n\n    var result map[string]interface{}\n    json.NewDecoder(resp.Body).Decode(&amp;result)\n    fmt.Println(result)\n}\n</code></pre>"},{"location":"swarms_platform/prompts/edit_prompt/#curl","title":"cURL","text":"<pre><code>curl -X POST https://swarms.world/api/edit-prompt \\\n-H \"Content-Type: application/json\" \\\n-H \"Authorization: Bearer {apiKey}\" \\\n-d '{\n  \"id\": \"prompt_id\",\n  \"name\": \"Updated Prompt\",\n  \"prompt\": \"This is an updated prompt from an API route.\",\n  \"description\": \"Updated description of the prompt.\",\n  \"useCases\": [\n    { \"title\": \"Updated use case 1\", \"description\": \"Updated description of use case 1\" },\n    { \"title\": \"Updated use case 2\", \"description\": \"Updated description of use case 2\" }\n  ],\n  \"tags\": \"updated, prompt\"\n}'\n</code></pre>"},{"location":"swarms_platform/prompts/edit_prompt/#response","title":"Response","text":"<p>The response will be a JSON object containing the result of the operation. Example response:</p> <pre><code>{\n  \"success\": true,\n  \"message\": \"Prompt updated successfully\",\n  \"data\": {\n    \"id\": \"prompt_id\",\n    \"name\": \"Updated Prompt\",\n    \"prompt\": \"This is an updated prompt from an API route.\",\n    \"description\": \"Updated description of the prompt.\",\n    \"useCases\": [\n      {\n        \"title\": \"Updated use case 1\",\n        \"description\": \"Updated description of use case 1\"\n      },\n      {\n        \"title\": \"Updated use case 2\",\n        \"description\": \"Updated description of use case 2\"\n      }\n    ],\n    \"tags\": \"updated, prompt\"\n  }\n}\n</code></pre> <p>In case of an error, the response will contain an error message detailing the issue.</p>"},{"location":"swarms_platform/prompts/edit_prompt/#common-issues-and-tips","title":"Common Issues and Tips","text":"<ul> <li>Authentication Error: Ensure that the <code>Authorization</code> header is correctly set with a valid API key.</li> <li>Invalid JSON: Make sure the request body is a valid JSON object.</li> <li>Missing Required Fields: Ensure that all required fields (<code>name</code>, <code>prompt</code>, <code>description</code>, <code>useCases</code>) are included in the request body.</li> <li>Network Issues: Verify network connectivity and endpoint URL.</li> </ul>"},{"location":"swarms_platform/prompts/edit_prompt/#references-and-resources","title":"References and Resources","text":"<ul> <li>API Authentication Guide</li> <li>JSON Structure Standards</li> <li>Fetch API Documentation (Node.js)</li> <li>Requests Library (Python)</li> <li>Net/HTTP Package (Go)</li> </ul> <p>This comprehensive documentation provides all the necessary information to effectively use the <code>https://swarms.world/api/add-prompt</code> and <code>https://swarms.world/api/edit-prompt</code> endpoints, including details on request parameters, example code snippets in multiple programming languages, and troubleshooting tips.</p>"},{"location":"swarms_platform/prompts/fetch_prompts/","title":"Documentation for <code>getAllPrompts</code> API Endpoint","text":"<p>The <code>getAllPrompts</code> API endpoint is a part of the <code>swarms.world</code> application, designed to fetch all prompt records from the database. This endpoint is crucial for retrieving various prompts stored in the <code>swarms_cloud_prompts</code> table, including their metadata such as name, description, use cases, and tags.</p>"},{"location":"swarms_platform/prompts/fetch_prompts/#purpose","title":"Purpose","text":"<p>The primary purpose of this API endpoint is to provide a method for clients to fetch a list of prompts stored in the <code>swarms_cloud_prompts</code> table, with the ability to filter by name, tags, and use cases.</p>"},{"location":"swarms_platform/prompts/fetch_prompts/#api-endpoint-definition","title":"API Endpoint Definition","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#fetch-all-prompts","title":"Fetch All Prompts","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#endpoint-url","title":"Endpoint URL","text":"<pre><code>https://swarms.world/get-prompts\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#http-method","title":"HTTP Method","text":"<pre><code>GET\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#query-parameters","title":"Query Parameters","text":"<ul> <li>name (optional): A substring to match against the prompt name. The query is case-insensitive.</li> <li>tag (optional): A comma-separated list of tags to filter prompts by. The query matches any of the provided tags, and is case-insensitive.</li> <li>use_case (optional): A substring to match against the use case titles within the <code>use_cases</code> array. The query is case-insensitive.</li> <li>use_case_description (optional): A substring to match against the use case descriptions within the <code>use_cases</code> array. The query is case-insensitive.</li> </ul>"},{"location":"swarms_platform/prompts/fetch_prompts/#response","title":"Response","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#success-response-200","title":"Success Response (200)","text":"<p>Returns an array of prompts.</p> <pre><code>[\n  {\n    \"id\": \"string\",\n    \"name\": \"string\",\n    \"description\": \"string\",\n    \"prompt\": \"string\",\n    \"use_cases\": [\n      {\n        \"title\": \"string\",\n        \"description\": \"string\"\n      }\n    ],\n    \"tags\": \"string\"\n  },\n  ...\n]\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#error-responses","title":"Error Responses","text":"<ul> <li>405 Method Not Allowed</li> </ul> <pre><code>{\n  \"error\": \"Method &lt;method&gt; Not Allowed\"\n}\n</code></pre> <ul> <li>500 Internal Server Error</li> </ul> <pre><code>{\n  \"error\": \"Could not fetch prompts\"\n}\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#fetch-prompt-by-id","title":"Fetch Prompt by ID","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#endpoint-url_1","title":"Endpoint URL","text":"<pre><code>https://swarms.world/get-prompts/[id]\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#http-method_1","title":"HTTP Method","text":"<pre><code>GET\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#response_1","title":"Response","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#success-response-200_1","title":"Success Response (200)","text":"<p>Returns a single prompt by ID.</p> <pre><code>{\n  \"id\": \"string\",\n  \"name\": \"string\",\n  \"description\": \"string\",\n  \"prompt\": \"string\",\n  \"use_cases\": [\n    {\n      \"title\": \"string\",\n      \"description\": \"string\"\n    }\n  ],\n  \"tags\": \"string\"\n}\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#error-responses_1","title":"Error Responses","text":"<ul> <li>404 Not Found</li> </ul> <pre><code>{\n  \"error\": \"Prompt not found\"\n}\n</code></pre> <ul> <li>500 Internal Server Error</li> </ul> <pre><code>{\n  \"error\": \"Could not fetch prompt\"\n}\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#request-handling","title":"Request Handling","text":"<ol> <li> <p>Method Validation: The endpoint only supports the <code>GET</code> method. If a different HTTP method is used, it responds with a <code>405 Method Not Allowed</code> status.</p> </li> <li> <p>Database Query:</p> </li> <li> <p>Fetching All Prompts: The endpoint uses the <code>supabaseAdmin</code> client to query the <code>swarms_cloud_prompts</code> table. Filters are applied based on the query parameters (<code>name</code>, <code>tag</code>, and <code>use_cases</code>).</p> </li> <li> <p>Fetching a Prompt by ID: The endpoint retrieves a single prompt from the <code>swarms_cloud_prompts</code> table by its unique ID.</p> </li> <li> <p>Response: On success, it returns the prompt data in JSON format. In case of an error during the database query, a <code>500 Internal Server Error</code> status is returned. For fetching by ID, if the prompt is not found, it returns a <code>404 Not Found</code> status.</p> </li> </ol>"},{"location":"swarms_platform/prompts/fetch_prompts/#code-example","title":"Code Example","text":""},{"location":"swarms_platform/prompts/fetch_prompts/#javascript-nodejs","title":"JavaScript (Node.js)","text":"<pre><code>import fetch from \"node-fetch\";\n\n// Fetch all prompts with optional filters\nconst getPrompts = async (filters) =&gt; {\n  const queryString = new URLSearchParams(filters).toString();\n  const response = await fetch(\n    `https://swarms.world/get-prompts?${queryString}`,\n    {\n      method: \"GET\",\n    }\n  );\n\n  if (!response.ok) {\n    throw new Error(`Error: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Fetch prompt by ID\nconst getPromptById = async (id) =&gt; {\n  const response = await fetch(`https://swarms.world/get-prompts/${id}`, {\n    method: \"GET\",\n  });\n\n  if (!response.ok) {\n    throw new Error(`Error: ${response.statusText}`);\n  }\n\n  const data = await response.json();\n  console.log(data);\n};\n\n// Example usage\ngetPrompts({\n  name: \"example\",\n  tag: \"tag1,tag2\",\n  use_case: \"example\",\n  use_case_description: \"description\",\n}).catch(console.error);\ngetPromptById(\"123\").catch(console.error);\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#python","title":"Python","text":"<pre><code>import requests\n\n# Fetch all prompts with optional filters\ndef get_prompts(filters):\n    response = requests.get('https://swarms.world/get-prompts', params=filters)\n\n    if response.status_code != 200:\n        raise Exception(f'Error: {response.status_code}, {response.text}')\n\n    data = response.json()\n    print(data)\n\n# Fetch prompt by ID\ndef get_prompt_by_id(id):\n    response = requests.get(f'https://swarms.world/get-prompts/{id}')\n\n    if response.status_code != 200:\n        raise Exception(f'Error: {response.status_code}, {response.text}')\n\n    data = response.json()\n    print(data)\n\n# Example usage\nget_prompts({'name': 'example', 'tag': 'tag1,tag2', 'use_case': 'example', 'use_case_description': 'description'})\nget_prompt_by_id('123')\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#curl","title":"cURL","text":"<pre><code># Fetch all prompts with optional filters\ncurl -X GET \"https://swarms.world/get-prompts?name=example&amp;tag=tag1,tag2&amp;use_case=example&amp;use_case_description=description\"\n\n# Fetch prompt by ID\ncurl -X GET https://swarms.world/get-prompts/123\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#go","title":"Go","text":"<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"net/url\"\n)\n\nfunc getPrompts(filters map[string]string) {\n    baseURL := \"https://swarms.world/get-prompts\"\n    query := url.Values{}\n    for key, value := range filters {\n        query.Set(key, value)\n    }\n    fullURL := fmt.Sprintf(\"%s?%s\", baseURL, query.Encode())\n\n    resp, err := http.Get(fullURL)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        body, _ := ioutil.ReadAll(resp.Body)\n        panic(fmt.Sprintf(\"Error: %d, %s\", resp.StatusCode, string(body)))\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(body))\n}\n\nfunc getPromptById(id string) {\n    url := fmt.Sprintf(\"https://swarms.world/get-prompts/%s\", id)\n    resp, err := http.Get(url)\n    if err != nil {\n        panic(err)\n    }\n    defer resp.Body.Close()\n\n    if resp.StatusCode != http.StatusOK {\n        body, _ := ioutil.ReadAll(resp.Body)\n        panic(fmt.Sprintf(\"Error: %d, %s\", resp.StatusCode, string(body)))\n    }\n\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n        panic(err)\n    }\n\n    fmt.Println(string(body))\n}\n\nfunc main() {\n    filters := map[string]string{\n        \"name\":                  \"example\",\n        \"tag\":                   \"tag1,tag2\",\n        \"use_case\":        \"example\",\n        \"use_case_description\":  \"description\",\n    }\n    getPrompts(filters)\n    getPromptById(\"123\")\n}\n</code></pre>"},{"location":"swarms_platform/prompts/fetch_prompts/#attributes-table","title":"Attributes Table","text":"Attribute Type Description id String Unique identifier for the prompt name String Name of the prompt description String Description of the prompt prompt String The actual prompt text use_cases Array Use cases for the prompt tags String Tags associated with the prompt"},{"location":"swarms_platform/prompts/fetch_prompts/#additional-information-and-tips","title":"Additional Information and Tips","text":"<ul> <li>Handle different error statuses appropriately to provide clear feedback to users.</li> <li>Consider implementing rate limiting and logging for better security and monitoring.</li> </ul>"},{"location":"swarms_platform/prompts/fetch_prompts/#references-and-resources","title":"References and Resources","text":"<ul> <li>Next.js API Routes</li> <li>Supabase Documentation</li> <li>Node Fetch</li> <li>Requests Library (Python)</li> <li>Go net/http Package</li> </ul> <p>This documentation provides a comprehensive guide to the <code>getAllPrompts</code> API endpoint, including usage examples in multiple programming languages and detailed attribute descriptions.</p>"},{"location":"swarms_rs/agents/","title":"swarms-rs","text":"<p>Modern AI Agent Framework</p> <p>swarms-rs is a powerful Rust framework for building autonomous AI agents powered by LLMs, equipped with robust tools and memory capabilities. Designed for various applications from trading analysis to healthcare diagnostics.</p>"},{"location":"swarms_rs/agents/#getting-started","title":"Getting Started","text":""},{"location":"swarms_rs/agents/#installation","title":"Installation","text":"<pre><code>cargo add swarms-rs\n</code></pre> <p>Compatible with Rust 1.70+</p> <p>This library requires Rust 1.70 or later. Make sure your Rust toolchain is up to date.</p>"},{"location":"swarms_rs/agents/#required-environment-variables","title":"Required Environment Variables","text":"<pre><code># Required API keys\nOPENAI_API_KEY=\"your_openai_api_key_here\"\nDEEPSEEK_API_KEY=\"your_deepseek_api_key_here\"\n</code></pre>"},{"location":"swarms_rs/agents/#quick-start","title":"Quick Start","text":"<p>Here's a simple example to get you started with swarms-rs:</p> <pre><code>use std::env;\nuse anyhow::Result;\nuse swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    // Load environment variables from .env file\n    dotenv::dotenv().ok();\n\n    // Initialize tracing for better debugging\n    tracing_subscriber::registry()\n        .with(tracing_subscriber::EnvFilter::from_default_env())\n        .with(\n            tracing_subscriber::fmt::layer()\n                .with_line_number(true)\n                .with_file(true),\n        )\n        .init();\n\n    // Set up your LLM client\n    let api_key = env::var(\"OPENAI_API_KEY\").expect(\"OPENAI_API_KEY must be set\");\n    let client = OpenAI::new(api_key).set_model(\"gpt-4-turbo\");\n\n    // Create a basic agent\n    let agent = client\n        .agent_builder()\n        .system_prompt(\"You are a helpful assistant.\")\n        .agent_name(\"BasicAgent\")\n        .user_name(\"User\")\n        .build();\n\n    // Run the agent with a user query\n    let response = agent\n        .run(\"Tell me about Rust programming.\".to_owned())\n        .await?;\n\n    println!(\"{}\", response);\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_rs/agents/#core-concepts","title":"Core Concepts","text":""},{"location":"swarms_rs/agents/#agents","title":"Agents","text":"<p>Agents in swarms-rs are autonomous entities that can:</p> <ul> <li>Perform complex reasoning based on LLM capabilities</li> <li>Use tools to interact with external systems</li> <li>Maintain persistent memory</li> <li>Execute multi-step plans</li> </ul>"},{"location":"swarms_rs/agents/#agent-configuration","title":"Agent Configuration","text":""},{"location":"swarms_rs/agents/#core-parameters","title":"Core Parameters","text":"Parameter Description Default Required <code>system_prompt</code> Initial instructions/role for the agent - Yes <code>agent_name</code> Name identifier for the agent - Yes <code>user_name</code> Name for the user interacting with agent - Yes <code>max_loops</code> Maximum number of reasoning loops 1 No <code>retry_attempts</code> Number of retry attempts on failure 1 No <code>enable_autosave</code> Enable state persistence false No <code>save_state_dir</code> Directory for saving agent state None No"},{"location":"swarms_rs/agents/#advanced-configuration","title":"Advanced Configuration","text":"<p>You can enhance your agent's capabilities with:</p> <ul> <li>Planning: Enable structured planning for complex tasks</li> <li>Memory: Persistent storage for agent state</li> <li>Tools: External capabilities through MCP protocol</li> </ul> <p>Resource Usage</p> <p>Setting high values for <code>max_loops</code> can increase API usage and costs. Start with lower values and adjust as needed.</p>"},{"location":"swarms_rs/agents/#examples","title":"Examples","text":""},{"location":"swarms_rs/agents/#specialized-agent-for-cryptocurrency-analysis","title":"Specialized Agent for Cryptocurrency Analysis","text":"<pre><code>use std::env;\nuse anyhow::Result;\nuse swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    dotenv::dotenv().ok();\n    tracing_subscriber::registry()\n        .with(tracing_subscriber::EnvFilter::from_default_env())\n        .with(\n            tracing_subscriber::fmt::layer()\n                .with_line_number(true)\n                .with_file(true),\n        )\n        .init();\n\n    let api_key = env::var(\"OPENAI_API_KEY\").expect(\"OPENAI_API_KEY must be set\");\n    let client = OpenAI::new(api_key).set_model(\"gpt-4-turbo\");\n\n    let agent = client\n        .agent_builder()\n        .system_prompt(\n            \"You are a sophisticated cryptocurrency analysis assistant specialized in:\n            1. Technical analysis of crypto markets\n            2. Fundamental analysis of blockchain projects\n            3. Market sentiment analysis\n            4. Risk assessment\n            5. Trading patterns recognition\n\n            When analyzing cryptocurrencies, always consider:\n            - Market capitalization and volume\n            - Historical price trends\n            - Project fundamentals and technology\n            - Recent news and developments\n            - Market sentiment indicators\n            - Potential risks and opportunities\n\n            Provide clear, data-driven insights and always include relevant disclaimers about market volatility.\"\n        )\n        .agent_name(\"CryptoAnalyst\")\n        .user_name(\"Trader\")\n        .enable_autosave()\n        .max_loops(3)  // Increased for more thorough analysis\n        .save_state_dir(\"./crypto_analysis/\")\n        .enable_plan(\"Break down the crypto analysis into systematic steps:\n            1. Gather market data\n            2. Analyze technical indicators\n            3. Review fundamental factors\n            4. Assess market sentiment\n            5. Provide comprehensive insights\".to_owned())\n        .build();\n\n    let response = agent\n        .run(\"What are your thoughts on Bitcoin's current market position?\".to_owned())\n        .await?;\n\n    println!(\"{}\", response);\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_rs/agents/#using-tools-with-mcp","title":"Using Tools with MCP","text":""},{"location":"swarms_rs/agents/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<p>swarms-rs supports the Model Context Protocol (MCP), enabling agents to interact with external tools through standardized interfaces.</p> <p>What is MCP?</p> <p>MCP (Model Context Protocol) provides a standardized way for LLMs to interact with external tools, giving your agents access to real-world data and capabilities beyond language processing.</p>"},{"location":"swarms_rs/agents/#supported-mcp-server-types","title":"Supported MCP Server Types","text":"<ul> <li>STDIO MCP Servers: Connect to command-line tools implementing the MCP protocol</li> <li>SSE MCP Servers: Connect to web-based MCP servers using Server-Sent Events</li> </ul>"},{"location":"swarms_rs/agents/#tool-integration","title":"Tool Integration","text":"<p>Add tools to your agent during configuration:</p> <pre><code>let agent = client\n    .agent_builder()\n    .system_prompt(\"You are a helpful assistant with access to tools.\")\n    .agent_name(\"ToolAgent\")\n    .user_name(\"User\")\n    // Add STDIO MCP server\n    .add_stdio_mcp_server(\"uvx\", [\"mcp-hn\"])\n    .await\n    // Add SSE MCP server\n    .add_sse_mcp_server(\"file-browser\", \"http://127.0.0.1:8000/sse\")\n    .await\n    .build();\n</code></pre>"},{"location":"swarms_rs/agents/#full-mcp-agent-example","title":"Full MCP Agent Example","text":"<pre><code>use std::env;\nuse anyhow::Result;\nuse swarms_rs::{llm::provider::openai::OpenAI, structs::agent::Agent};\n\n#[tokio::main]\nasync fn main() -&gt; Result&lt;()&gt; {\n    dotenv::dotenv().ok();\n    tracing_subscriber::registry()\n        .with(tracing_subscriber::EnvFilter::from_default_env())\n        .with(\n            tracing_subscriber::fmt::layer()\n                .with_line_number(true)\n                .with_file(true),\n        )\n        .init();\n\n    let api_key = env::var(\"OPENAI_API_KEY\").expect(\"OPENAI_API_KEY must be set\");\n    let client = OpenAI::new(api_key).set_model(\"gpt-4-turbo\");\n\n    let agent = client\n        .agent_builder()\n        .system_prompt(\"You are a helpful assistant with access to news and file system tools.\")\n        .agent_name(\"SwarmsAgent\")\n        .user_name(\"User\")\n        // Add Hacker News tool\n        .add_stdio_mcp_server(\"uvx\", [\"mcp-hn\"])\n        .await\n        // Add filesystem tool\n        // To set up: uvx mcp-proxy --sse-port=8000 -- npx -y @modelcontextprotocol/server-filesystem ~\n        .add_sse_mcp_server(\"file-browser\", \"http://127.0.0.1:8000/sse\")\n        .await\n        .retry_attempts(2)\n        .max_loops(3)\n        .build();\n\n    // Use the news tool\n    let news_response = agent\n        .run(\"Get the top 3 stories of today from Hacker News\".to_owned())\n        .await?;\n    println!(\"NEWS RESPONSE:\\n{}\", news_response);\n\n    // Use the filesystem tool\n    let fs_response = agent.run(\"List files in my home directory\".to_owned()).await?;\n    println!(\"FILESYSTEM RESPONSE:\\n{}\", fs_response);\n\n    Ok(())\n}\n</code></pre>"},{"location":"swarms_rs/agents/#setting-up-mcp-tools","title":"Setting Up MCP Tools","text":""},{"location":"swarms_rs/agents/#installing-mcp-servers","title":"Installing MCP Servers","text":"<p>To use MCP servers with swarms-rs, you'll need to install the appropriate tools:</p> <ol> <li> <p>uv Package Manager:    <pre><code>curl -sSf https://raw.githubusercontent.com/astral-sh/uv/main/install.sh | sh\n</code></pre></p> </li> <li> <p>MCP-HN (Hacker News MCP server):    <pre><code>uvx install mcp-hn\n</code></pre></p> </li> <li> <p>Setting up an SSE MCP server:    <pre><code># Start file system MCP server over SSE\nuvx mcp-proxy --sse-port=8000 -- npx -y @modelcontextprotocol/server-filesystem ~\n</code></pre></p> </li> </ol>"},{"location":"swarms_rs/agents/#faq","title":"FAQ","text":""},{"location":"swarms_rs/agents/#general-questions","title":"General Questions","text":"What LLM providers are supported? <p>swarms-rs currently supports:</p> <ul> <li> <p>OpenAI (GPT models)</p> </li> <li> <p>DeepSeek AI</p> </li> <li> <p>More providers coming soon</p> </li> </ul> How does state persistence work? <p>When <code>enable_autosave</code> is set to <code>true</code>, the agent will save its state to the directory specified in <code>save_state_dir</code>. This includes conversation history and tool states, allowing the agent to resume from where it left off.</p> What is the difference between <code>max_loops</code> and <code>retry_attempts</code>? <ul> <li> <p><code>max_loops</code>: Controls how many reasoning steps the agent can take for a single query</p> </li> <li> <p><code>retry_attempts</code>: Specifies how many times the agent will retry if an error occurs</p> </li> </ul>"},{"location":"swarms_rs/agents/#mcp-tools","title":"MCP Tools","text":"How do I create my own MCP server? <p>You can create your own MCP server by implementing the MCP protocol. Check out the MCP documentation for details on the protocol specification.</p> Can I use tools without MCP? <p>Currently, swarms-rs is designed to use the MCP protocol for tool integration. This provides a standardized way for agents to interact with external systems.</p>"},{"location":"swarms_rs/agents/#advanced-topics","title":"Advanced Topics","text":""},{"location":"swarms_rs/agents/#performance-optimization","title":"Performance Optimization","text":"<p>Optimize your agent's performance by:</p> <ol> <li>Crafting Effective System Prompts:</li> <li> <p>Be specific about the agent's role and capabilities</p> </li> <li> <p>Include clear instructions on how to use available tools</p> </li> <li> <p>Define success criteria for the agent's responses</p> </li> <li> <p>Tuning Loop Parameters:</p> </li> <li> <p>Start with lower values for <code>max_loops</code> and increase as needed</p> </li> <li> <p>Consider the complexity of tasks when setting loop limits</p> </li> <li> <p>Strategic Tool Integration:</p> </li> <li> <p>Only integrate tools that are necessary for the agent's tasks</p> </li> <li> <p>Provide clear documentation in the system prompt about when to use each tool</p> </li> </ol>"},{"location":"swarms_rs/agents/#security-considerations","title":"Security Considerations","text":"<p>Security Notice</p> <p>When using file system tools or other system-level access, always be careful about permissions. Limit the scope of what your agent can access, especially in production environments.</p>"},{"location":"swarms_rs/agents/#coming-soon","title":"Coming Soon","text":"<ul> <li> <p>Memory plugins for different storage backends</p> </li> <li> <p>Additional LLM providers</p> </li> <li> <p>Group agent coordination</p> </li> <li> <p>Function calling</p> </li> <li> <p>Custom tool development framework</p> </li> </ul>"},{"location":"swarms_rs/agents/#contributing","title":"Contributing","text":"<p>Contributions to swarms-rs are welcome! Check out our GitHub repository for more information.</p>"},{"location":"swarms_rs/overview/","title":"swarms-rs \ud83d\ude80","text":""},{"location":"swarms_rs/overview/#overview","title":"\ud83d\udcd6 Overview","text":"<p>swarms-rs is an enterprise-grade, production-ready multi-agent orchestration framework built in Rust, designed to handle the most demanding tasks with unparalleled speed and efficiency. By leveraging Rust's bleeding-edge performance and safety features, swarms-rs provides a powerful and scalable solution for orchestrating complex multi-agent systems across various industries.</p>"},{"location":"swarms_rs/overview/#key-benefits","title":"\u2728 Key Benefits","text":""},{"location":"swarms_rs/overview/#extreme-performance","title":"\u26a1 Extreme Performance","text":"<ul> <li> <p>Multi-Threaded Architecture</p> <ul> <li> <p>Utilize the full potential of modern multi-core processors</p> </li> <li> <p>Zero-cost abstractions and fearless concurrency</p> </li> <li> <p>Minimal overhead with maximum throughput</p> </li> <li> <p>Optimal resource utilization</p> </li> </ul> </li> <li> <p>Bleeding-Edge Speed</p> <ul> <li> <p>Near-zero latency execution</p> </li> <li> <p>Lightning-fast performance</p> </li> <li> <p>Ideal for high-frequency applications</p> </li> <li> <p>Perfect for real-time systems</p> </li> </ul> </li> </ul>"},{"location":"swarms_rs/overview/#quick-links","title":"\ud83d\udd17 Quick Links","text":"<ul> <li> <p> GitHub</p> <ul> <li>Browse the source code</li> <li>Contribute to the project</li> <li>Report issues</li> </ul> </li> <li> <p> Crates.io</p> <ul> <li>Download the latest version</li> <li>View package statistics</li> </ul> </li> <li> <p> Documentation</p> <ul> <li>Read the API documentation</li> <li>Learn how to use swarms-rs</li> </ul> </li> </ul>"},{"location":"swarms_tools/finance/","title":"Swarms Finance Tools Documentation","text":""},{"location":"swarms_tools/finance/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms-tools yfinance requests httpx pandas loguru backoff web3 solana spl-token\n</code></pre>"},{"location":"swarms_tools/finance/#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in your project root with the following variables (as needed):</p> Environment Variable Description Required For <code>COINBASE_API_KEY</code> Coinbase API Key Coinbase Trading <code>COINBASE_API_SECRET</code> Coinbase API Secret Coinbase Trading <code>COINBASE_API_PASSPHRASE</code> Coinbase API Passphrase Coinbase Trading <code>COINMARKETCAP_API_KEY</code> CoinMarketCap API Key CoinMarketCap Data <code>HELIUS_API_KEY</code> Helius API Key Solana Data <code>EODHD_API_KEY</code> EODHD API Key Stock News <code>OKX_API_KEY</code> OKX API Key OKX Trading <code>OKX_API_SECRET</code> OKX API Secret OKX Trading <code>OKX_PASSPHRASE</code> OKX Passphrase OKX Trading"},{"location":"swarms_tools/finance/#tools-overview","title":"Tools Overview","text":"Tool Description Requires API Key Yahoo Finance Real-time stock market data No CoinGecko Cryptocurrency market data No Coinbase Cryptocurrency trading and data Yes CoinMarketCap Cryptocurrency market data Yes Helius Solana blockchain data Yes DexScreener DEX trading pairs and data No HTX (Huobi) Cryptocurrency exchange data No OKX Cryptocurrency exchange data Yes EODHD Stock market news Yes Jupiter Solana DEX aggregator No Sector Analysis GICS sector ETF analysis No Solana Tools Solana wallet and token tools Yes"},{"location":"swarms_tools/finance/#detailed-documentation","title":"Detailed Documentation","text":""},{"location":"swarms_tools/finance/#yahoo-finance-api","title":"Yahoo Finance API","text":"<p>Fetch real-time and historical stock market data.</p> <pre><code>from swarms_tools.finance import yahoo_finance_api\n\n# Fetch data for single stock\ndata = yahoo_finance_api([\"AAPL\"])\n\n# Fetch data for multiple stocks\ndata = yahoo_finance_api([\"AAPL\", \"GOOG\", \"MSFT\"])\n</code></pre> <p>Arguments:</p> Parameter Type Description Required stock_symbols List[str] List of stock symbols Yes"},{"location":"swarms_tools/finance/#coingecko-api","title":"CoinGecko API","text":"<p>Fetch comprehensive cryptocurrency data.</p> <pre><code>from swarms_tools.finance import coin_gecko_coin_api\n\n# Fetch Bitcoin data\ndata = coin_gecko_coin_api(\"bitcoin\")\n</code></pre> <p>Arguments:</p> Parameter Type Description Required coin str Cryptocurrency ID (e.g., 'bitcoin') Yes"},{"location":"swarms_tools/finance/#coinbase-trading","title":"Coinbase Trading","text":"<p>Execute trades and fetch market data from Coinbase.</p> <pre><code>from swarms_tools.finance import get_coin_data, place_buy_order, place_sell_order\n\n# Fetch coin data\ndata = get_coin_data(\"BTC-USD\")\n\n# Place orders\nbuy_order = place_buy_order(\"BTC-USD\", amount=100)  # Buy $100 worth of BTC\nsell_order = place_sell_order(\"BTC-USD\", amount=0.01)  # Sell 0.01 BTC\n</code></pre> <p>Arguments:</p> Parameter Type Description Required symbol str Trading pair (e.g., 'BTC-USD') Yes amount Union[str, float, Decimal] Trade amount Yes sandbox bool Use sandbox environment No"},{"location":"swarms_tools/finance/#coinmarketcap-api","title":"CoinMarketCap API","text":"<p>Fetch cryptocurrency market data from CoinMarketCap.</p> <pre><code>from swarms_tools.finance import coinmarketcap_api\n\n# Fetch single coin data\ndata = coinmarketcap_api([\"Bitcoin\"])\n\n# Fetch multiple coins\ndata = coinmarketcap_api([\"Bitcoin\", \"Ethereum\", \"Tether\"])\n</code></pre> <p>Arguments:</p> Parameter Type Description Required coin_names Optional[List[str]] List of coin names No"},{"location":"swarms_tools/finance/#helius-api-solana","title":"Helius API (Solana)","text":"<p>Fetch Solana blockchain data.</p> <pre><code>from swarms_tools.finance import helius_api_tool\n\n# Fetch account data\naccount_data = helius_api_tool(\"account\", \"account_address\")\n\n# Fetch transaction data\ntx_data = helius_api_tool(\"transaction\", \"tx_signature\")\n\n# Fetch token data\ntoken_data = helius_api_tool(\"token\", \"token_mint_address\")\n</code></pre> <p>Arguments:</p> Parameter Type Description Required action str Type of action ('account', 'transaction', 'token') Yes identifier str Address/signature to query Yes"},{"location":"swarms_tools/finance/#dexscreener-api","title":"DexScreener API","text":"<p>Fetch DEX trading pair data.</p> <pre><code>from swarms_tools.finance import (\n    fetch_dex_screener_profiles,\n    fetch_latest_token_boosts,\n    fetch_solana_token_pairs\n)\n\n# Fetch latest profiles\nprofiles = fetch_dex_screener_profiles()\n\n# Fetch token boosts\nboosts = fetch_latest_token_boosts()\n\n# Fetch Solana pairs\npairs = fetch_solana_token_pairs([\"token_address\"])\n</code></pre>"},{"location":"swarms_tools/finance/#htx-huobi-api","title":"HTX (Huobi) API","text":"<p>Fetch cryptocurrency data from HTX.</p> <pre><code>from swarms_tools.finance import fetch_htx_data\n\n# Fetch coin data\ndata = fetch_htx_data(\"BTC\")\n</code></pre> <p>Arguments:</p> Parameter Type Description Required coin_name str Cryptocurrency symbol Yes"},{"location":"swarms_tools/finance/#okx-api","title":"OKX API","text":"<p>Fetch cryptocurrency data from OKX.</p> <pre><code>from swarms_tools.finance import okx_api_tool\n\n# Fetch single coin\ndata = okx_api_tool([\"BTC-USDT\"])\n\n# Fetch multiple coins\ndata = okx_api_tool([\"BTC-USDT\", \"ETH-USDT\"])\n</code></pre> <p>Arguments:</p> Parameter Type Description Required coin_symbols Optional[List[str]] List of trading pairs No"},{"location":"swarms_tools/finance/#eodhd-stock-news","title":"EODHD Stock News","text":"<p>Fetch stock market news.</p> <pre><code>from swarms_tools.finance import fetch_stock_news\n\n# Fetch news for a stock\nnews = fetch_stock_news(\"AAPL\")\n</code></pre> <p>Arguments:</p> Parameter Type Description Required stock_name str Stock symbol Yes"},{"location":"swarms_tools/finance/#jupiter-solana-dex","title":"Jupiter (Solana DEX)","text":"<p>Fetch Solana DEX prices.</p> <pre><code>from swarms_tools.finance import get_jupiter_price\n\n# Fetch price data\nprice = get_jupiter_price(input_mint=\"input_token\", output_mint=\"output_token\")\n</code></pre> <p>Arguments:</p> Parameter Type Description Required input_mint str Input token mint address Yes output_mint str Output token mint address Yes"},{"location":"swarms_tools/finance/#sector-analysis","title":"Sector Analysis","text":"<p>Analyze GICS sector ETFs.</p> <pre><code>from swarms_tools.finance.sector_analysis import analyze_index_sectors\n\n# Run sector analysis\nanalyze_index_sectors()\n</code></pre>"},{"location":"swarms_tools/finance/#solana-tools","title":"Solana Tools","text":"<p>Check Solana wallet balances and manage tokens.</p> <pre><code>from swarms_tools.finance import check_solana_balance, check_multiple_wallets\n\n# Check single wallet\nbalance = check_solana_balance(\"wallet_address\")\n\n# Check multiple wallets\nbalances = check_multiple_wallets([\"wallet1\", \"wallet2\"])\n</code></pre> <p>Arguments:</p> Parameter Type Description Required wallet_address str Solana wallet address Yes wallet_addresses List[str] List of wallet addresses Yes"},{"location":"swarms_tools/finance/#complete-example","title":"Complete Example","text":"<p>Here's a comprehensive example using multiple tools:</p> <pre><code>from swarms_tools.finance import (\n    yahoo_finance_api,\n    coin_gecko_coin_api,\n    coinmarketcap_api,\n    fetch_htx_data\n)\n\n# Fetch stock data\nstocks = yahoo_finance_api([\"AAPL\", \"GOOG\"])\nprint(\"Stock Data:\", stocks)\n\n# Fetch crypto data from multiple sources\nbitcoin_cg = coin_gecko_coin_api(\"bitcoin\")\nprint(\"Bitcoin Data (CoinGecko):\", bitcoin_cg)\n\ncrypto_cmc = coinmarketcap_api([\"Bitcoin\", \"Ethereum\"])\nprint(\"Crypto Data (CoinMarketCap):\", crypto_cmc)\n\nbtc_htx = fetch_htx_data(\"BTC\")\nprint(\"Bitcoin Data (HTX):\", btc_htx)\n</code></pre>"},{"location":"swarms_tools/finance/#error-handling","title":"Error Handling","text":"<p>All tools include proper error handling and logging. Errors are logged using the <code>loguru</code> logger. Example error handling:</p> <pre><code>from loguru import logger\n\ntry:\n    data = yahoo_finance_api([\"INVALID\"])\nexcept Exception as e:\n    logger.error(f\"Error fetching stock data: {e}\")\n</code></pre>"},{"location":"swarms_tools/finance/#rate-limits","title":"Rate Limits","text":"<p>Please be aware of rate limits for various APIs: - CoinGecko: 50 calls/minute (free tier) - CoinMarketCap: Varies by subscription - Helius: Varies by subscription - DexScreener: 300 calls/minute for pairs, 60 calls/minute for profiles - Other APIs: Refer to respective documentation</p>"},{"location":"swarms_tools/finance/#dependencies","title":"Dependencies","text":"<p>The package automatically handles most dependencies, but you may need to install some manually:</p>"},{"location":"swarms_tools/overview/","title":"Swarms Tools","text":"<p>Welcome to Swarms Tools, the ultimate package for integrating cutting-edge APIs into Python functions with seamless multi-agent system compatibility. Designed for enterprises at the forefront of innovation, Swarms Tools is your key to simplifying complexity and unlocking operational excellence.</p>"},{"location":"swarms_tools/overview/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>Unified API Integration: Ready-to-use Python functions for financial data, social media, IoT, and more.</li> <li>Enterprise-Grade Design: Comprehensive type hints, structured outputs, and robust documentation.</li> <li>Agent-Ready Framework: Optimized for seamless integration into Swarms' multi-agent orchestration systems.</li> <li>Expandable Architecture: Easily extend functionality with a standardized schema for new tools.</li> </ul>"},{"location":"swarms_tools/overview/#installation","title":"\ud83d\udd27 Installation","text":"<pre><code>pip3 install -U swarms-tools\n</code></pre>"},{"location":"swarms_tools/overview/#directory-structure","title":"\ud83d\udcc2 Directory Structure","text":"<pre><code>swarms-tools/\n\u251c\u2500\u2500 swarms_tools/\n\u2502   \u251c\u2500\u2500 finance/\n\u2502   \u2502   \u251c\u2500\u2500 htx_tool.py\n\u2502   \u2502   \u251c\u2500\u2500 eodh_api.py\n\u2502   \u2502   \u2514\u2500\u2500 coingecko_tool.py\n\u2502   \u251c\u2500\u2500 social_media/\n\u2502   \u2502   \u251c\u2500\u2500 telegram_tool.py\n\u2502   \u251c\u2500\u2500 utilities/\n\u2502   \u2502   \u2514\u2500\u2500 logging.py\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 test_financial_data.py\n\u2502   \u2514\u2500\u2500 test_social_media.py\n\u2514\u2500\u2500 README.md\n</code></pre>"},{"location":"swarms_tools/overview/#use-cases","title":"\ud83d\udcbc Use Cases","text":""},{"location":"swarms_tools/overview/#finance","title":"Finance","text":"<p>Explore our diverse range of financial tools, designed to streamline your operations. If you need a tool not listed, feel free to submit an issue or accelerate integration by contributing a pull request with your tool of choice.</p> Tool Name Function Description <code>fetch_stock_news</code> <code>fetch_stock_news</code> Fetches the latest stock news and updates. <code>fetch_htx_data</code> <code>fetch_htx_data</code> Retrieves financial data from the HTX platform. <code>yahoo_finance_api</code> <code>yahoo_finance_api</code> Fetches comprehensive stock data from Yahoo Finance, including prices and trends. <code>coin_gecko_coin_api</code> <code>coin_gecko_coin_api</code> Fetches cryptocurrency data from CoinGecko, including market and price information. <code>helius_api_tool</code> <code>helius_api_tool</code> Retrieves blockchain account, transaction, or token data using the Helius API. <code>okx_api_tool</code> <code>okx_api_tool</code> Fetches detailed cryptocurrency data for coins from the OKX exchange."},{"location":"swarms_tools/overview/#financial-data-retrieval","title":"Financial Data Retrieval","text":"<p>Enable precise and actionable financial insights:</p>"},{"location":"swarms_tools/overview/#example-1-fetch-historical-data","title":"Example 1: Fetch Historical Data","text":"<pre><code>from swarms_tools import fetch_htx_data\n\n# Fetch historical trading data for \"Swarms Corporation\"\nresponse = fetch_htx_data(\"swarms\")\nprint(response)\n</code></pre>"},{"location":"swarms_tools/overview/#example-2-stock-news-analysis","title":"Example 2: Stock News Analysis","text":"<pre><code>from swarms_tools import fetch_stock_news\n\n# Retrieve latest stock news for Apple\nnews = fetch_stock_news(\"AAPL\")\nprint(news)\n</code></pre>"},{"location":"swarms_tools/overview/#example-3-cryptocurrency-metrics","title":"Example 3: Cryptocurrency Metrics","text":"<pre><code>from swarms_tools import coin_gecko_coin_api\n\n# Fetch live data for Bitcoin\ncrypto_data = coin_gecko_coin_api(\"bitcoin\")\nprint(crypto_data)\n</code></pre>"},{"location":"swarms_tools/overview/#social-media-automation","title":"Social Media Automation","text":"<p>Streamline communication and engagement:</p>"},{"location":"swarms_tools/overview/#example-telegram-bot-messaging","title":"Example: Telegram Bot Messaging","text":"<pre><code>from swarms_tools import telegram_dm_or_tag_api\n\ndef send_alert(response: str):\n    telegram_dm_or_tag_api(response)\n\n# Send a message to a user or group\nsend_alert(\"Mission-critical update from Swarms.\")\n</code></pre>"},{"location":"swarms_tools/overview/#dex-screener","title":"Dex Screener","text":"<p>This is a tool that allows you to fetch data from the Dex Screener API. It supports multiple chains and multiple tokens.</p> <pre><code>from swarms_tools.finance.dex_screener import (\n    fetch_latest_token_boosts,\n    fetch_dex_screener_profiles,\n)\n\n\nfetch_dex_screener_profiles()\nfetch_latest_token_boosts()\n</code></pre>"},{"location":"swarms_tools/overview/#structs","title":"Structs","text":"<p>The tool chainer enables the execution of multiple tools in a sequence, allowing for the aggregation of their results in either a parallel or sequential manner.</p>"},{"location":"swarms_tools/overview/#example-usage-from-loguru-import-logger-from-swarms_toolsstructs-import-tool_chainer-if-__name__-__main__-loggeraddtool_chainerlog-rotation500-mb-levelinfo-example-tools-def-tool1-return-tool1-result-def-tool2-return-tool2-result-def-tool3-raise-valueerrorsimulated-error-in-tool3-tools-tool1-tool2-parallel-execution-parallel_results-tool_chainertools-paralleltrue-printparallel-results-parallel_results-sequential-execution-sequential_results-tool_chainertools-parallelfalse-printsequential-results-sequential_results","title":"<pre><code># Example usage\nfrom loguru import logger\n\nfrom swarms_tools.structs import tool_chainer\n\n\nif __name__ == \"__main__\":\n    logger.add(\"tool_chainer.log\", rotation=\"500 MB\", level=\"INFO\")\n\n    # Example tools\n    def tool1():\n        return \"Tool1 Result\"\n\n    def tool2():\n        return \"Tool2 Result\"\n\n    # def tool3():\n    #     raise ValueError(\"Simulated error in Tool3\")\n\n    tools = [tool1, tool2]\n\n    # Parallel execution\n    parallel_results = tool_chainer(tools, parallel=True)\n    print(\"Parallel Results:\", parallel_results)\n\n    # Sequential execution\n    # sequential_results = tool_chainer(tools, parallel=False)\n    # print(\"Sequential Results:\", sequential_results)\n</code></pre>","text":""},{"location":"swarms_tools/overview/#standardized-schema","title":"\ud83e\udde9 Standardized Schema","text":"<p>Every tool in Swarms Tools adheres to a strict schema for maintainability and interoperability:</p>"},{"location":"swarms_tools/overview/#schema-template","title":"Schema Template","text":"<ol> <li>Functionality:</li> <li> <p>Encapsulate API logic into a modular, reusable function.</p> </li> <li> <p>Typing:</p> </li> <li>Leverage Python type hints for input validation and clarity.</li> </ol> <p>Example:    <pre><code>def fetch_data(symbol: str, date_range: str) -&gt; str:\n    \"\"\"\n    Fetch financial data for a given symbol and date range.\n\n    Args:\n        symbol (str): Ticker symbol of the asset.\n        date_range (str): Timeframe for the data (e.g., '1d', '1m', '1y').\n\n    Returns:\n        dict: A dictionary containing financial metrics.\n    \"\"\"\n    pass\n</code></pre></p> <ol> <li>Documentation:</li> <li> <p>Include detailed docstrings with parameter explanations and usage examples.</p> </li> <li> <p>Output Standardization:</p> </li> <li> <p>Ensure consistent outputs (e.g., strings) for easy downstream agent integration.</p> </li> <li> <p>API-Key Management:</p> <ul> <li>All API keys must be fetched with <code>os.getenv(\"YOUR_KEY\")</code></li> </ul> </li> </ol>"},{"location":"swarms_tools/overview/#documentation","title":"\ud83d\udcd6 Documentation","text":"<p>Comprehensive documentation is available to guide developers and enterprises. Visit our official docs for detailed API references, usage examples, and best practices.</p>"},{"location":"swarms_tools/overview/#contributing","title":"\ud83d\udee0 Contributing","text":"<p>We welcome contributions from the global developer community. To contribute:</p> <ol> <li>Fork the Repository: Start by forking the repository.</li> <li>Create a Feature Branch: Use a descriptive branch name: <code>feature/add-new-tool</code>.</li> <li>Commit Your Changes: Write meaningful commit messages.</li> <li>Submit a Pull Request: Open a pull request for review.</li> </ol>"},{"location":"swarms_tools/overview/#license","title":"\ud83d\udee1\ufe0f License","text":"<p>This project is licensed under the MIT License. See the LICENSE file for details.</p>"},{"location":"swarms_tools/overview/#join-the-future","title":"\ud83c\udf20 Join the Future","text":"<p>Explore the limitless possibilities of agent-based systems. Together, we can build a smarter, faster, and more interconnected world.</p> <p>Visit us: Swarms Corporation Follow us: Twitter</p> <p>\"The future belongs to those who dare to automate it.\" \u2014 The Swarms Corporation</p>"},{"location":"swarms_tools/search/","title":"Search Tools Documentation","text":"<p>This documentation covers the search tools available in the <code>swarms-tools</code> package.</p>"},{"location":"swarms_tools/search/#installation","title":"Installation","text":"<pre><code>pip3 install -U swarms-tools\n</code></pre>"},{"location":"swarms_tools/search/#environment-variables-required","title":"Environment Variables Required","text":"<p>Create a <code>.env</code> file in your project root with the following API keys:</p> <pre><code># Bing Search API\nBING_API_KEY=your_bing_api_key\n\n# Google Search API\nGOOGLE_API_KEY=your_google_api_key\nGOOGLE_CX=your_google_cx_id\nGEMINI_API_KEY=your_gemini_api_key\n\n# Exa AI API\nEXA_API_KEY=your_exa_api_key\n</code></pre>"},{"location":"swarms_tools/search/#tools-overview","title":"Tools Overview","text":""},{"location":"swarms_tools/search/#1-bing-search-tool","title":"1. Bing Search Tool","text":"<p>The Bing Search tool allows you to fetch web articles using the Bing Web Search API.</p>"},{"location":"swarms_tools/search/#function-fetch_web_articles_bing_api","title":"Function: <code>fetch_web_articles_bing_api</code>","text":"Parameter Type Required Description query str Yes The search query to retrieve articles"},{"location":"swarms_tools/search/#example-usage","title":"Example Usage:","text":"<pre><code>from swarms_tools.search import fetch_web_articles_bing_api\n\n# Fetch articles about AI\nresults = fetch_web_articles_bing_api(\"swarms ai github\")\nprint(results)\n</code></pre>"},{"location":"swarms_tools/search/#2-exa-ai-search-tool","title":"2. Exa AI Search Tool","text":"<p>The Exa AI tool is designed for searching research papers and academic content.</p>"},{"location":"swarms_tools/search/#function-search_exa_ai","title":"Function: <code>search_exa_ai</code>","text":"Parameter Type Required Default Description query str Yes \"Latest developments in LLM capabilities\" Search query num_results int No 10 Number of results to return auto_prompt bool No True Whether to use auto-prompting include_domains List[str] No [\"arxiv.org\", \"paperswithcode.com\"] Domains to include exclude_domains List[str] No [] Domains to exclude category str No \"research paper\" Category of search"},{"location":"swarms_tools/search/#example-usage_1","title":"Example Usage:","text":"<pre><code>from swarms_tools.search import search_exa_ai\n\n# Search for research papers\nresults = search_exa_ai(\n    query=\"Latest developments in LLM capabilities\",\n    num_results=5,\n    include_domains=[\"arxiv.org\"]\n)\nprint(results)\n</code></pre>"},{"location":"swarms_tools/search/#3-google-search-tool","title":"3. Google Search Tool","text":"<p>A comprehensive search tool that uses Google Custom Search API and includes content extraction and summarization using Gemini.</p>"},{"location":"swarms_tools/search/#class-websitechecker","title":"Class: <code>WebsiteChecker</code>","text":"Method Parameters Description search query: str Main search function that fetches, processes, and summarizes results"},{"location":"swarms_tools/search/#example-usage_2","title":"Example Usage:","text":"<pre><code>from swarms_tools.search import WebsiteChecker\n\n# Initialize with an agent (required for summarization)\nchecker = WebsiteChecker(agent=your_agent_function)\n\n# Perform search\nasync def search_example():\n    results = await checker.search(\"who won elections 2024 us\")\n    print(results)\n\n# For synchronous usage\nfrom swarms_tools.search import search\n\nresults = search(\"who won elections 2024 us\", agent=your_agent_function)\nprint(results)\n</code></pre>"},{"location":"swarms_tools/search/#features","title":"Features","text":"<ul> <li>Bing Search: Fetch and parse web articles with structured output</li> <li>Exa AI: Specialized academic and research paper search</li> <li>Google Search: </li> <li>Custom search with content extraction</li> <li>Concurrent URL processing</li> <li>Content summarization using Gemini</li> <li>Progress tracking</li> <li>Automatic retry mechanisms</li> <li>Results saved to JSON</li> </ul>"},{"location":"swarms_tools/search/#dependencies","title":"Dependencies","text":"<p>The tools automatically handle dependency installation, but here are the main requirements:</p> <pre><code>aiohttp\nasyncio\nbeautifulsoup4\ngoogle-generativeai\nhtml2text\nplaywright\npython-dotenv\nrich\ntenacity\n</code></pre>"},{"location":"swarms_tools/search/#error-handling","title":"Error Handling","text":"<p>All tools include robust error handling: - Automatic retries for failed requests - Timeout handling - Rate limiting consideration - Detailed error messages</p>"},{"location":"swarms_tools/search/#output-format","title":"Output Format","text":"<p>Each tool provides structured output:</p> <ul> <li>Bing Search: Returns formatted string with article details</li> <li>Exa AI: Returns JSON response with search results</li> <li>Google Search: Returns summarized content with sections:</li> <li>Key Findings</li> <li>Important Details</li> <li>Sources</li> </ul>"},{"location":"swarms_tools/search/#best-practices","title":"Best Practices","text":"<ol> <li>Always store API keys in environment variables</li> <li>Use appropriate error handling</li> <li>Consider rate limits of the APIs</li> <li>Cache results when appropriate</li> <li>Monitor API usage and costs</li> </ol>"},{"location":"swarms_tools/search/#limitations","title":"Limitations","text":"<ul> <li>Bing Search: Limited to 4 articles per query</li> <li>Exa AI: Focused on academic content</li> <li>Google Search: Requires Gemini API for summarization</li> </ul>"},{"location":"swarms_tools/search/#support","title":"Support","text":"<p>For issues and feature requests, please visit the GitHub repository. </p>"},{"location":"swarms_tools/twitter/","title":"Twitter Tool Documentation","text":""},{"location":"swarms_tools/twitter/#overview","title":"Overview","text":"<p>The Twitter Tool provides a convenient interface for interacting with Twitter's API through the swarms-tools package. This documentation covers the initialization process and available functions for posting, replying, liking, and quoting tweets, as well as retrieving metrics.</p>"},{"location":"swarms_tools/twitter/#installation","title":"Installation","text":"<pre><code>pip install swarms-tools\n</code></pre>"},{"location":"swarms_tools/twitter/#authentication","title":"Authentication","text":"<p>The Twitter Tool requires Twitter API credentials for authentication. These should be stored as environment variables:</p> <pre><code>TWITTER_ID=your_twitter_id\nTWITTER_NAME=your_twitter_name\nTWITTER_DESCRIPTION=your_twitter_description\nTWITTER_API_KEY=your_api_key\nTWITTER_API_SECRET_KEY=your_api_secret_key\nTWITTER_ACCESS_TOKEN=your_access_token\nTWITTER_ACCESS_TOKEN_SECRET=your_access_token_secret\n</code></pre>"},{"location":"swarms_tools/twitter/#initialization","title":"Initialization","text":""},{"location":"swarms_tools/twitter/#twittertool-configuration-options","title":"TwitterTool Configuration Options","text":"Parameter Type Required Description id str Yes Unique identifier for the Twitter tool instance name str Yes Name of the Twitter tool instance description str No Description of the tool's purpose credentials dict Yes Dictionary containing Twitter API credentials"},{"location":"swarms_tools/twitter/#credentials-dictionary-structure","title":"Credentials Dictionary Structure","text":"Key Type Required Description apiKey str Yes Twitter API Key apiSecretKey str Yes Twitter API Secret Key accessToken str Yes Twitter Access Token accessTokenSecret str Yes Twitter Access Token Secret"},{"location":"swarms_tools/twitter/#available-functions","title":"Available Functions","text":""},{"location":"swarms_tools/twitter/#initialize_twitter_tool","title":"initialize_twitter_tool()","text":"<p>Creates and returns a new instance of the TwitterTool.</p> <pre><code>def initialize_twitter_tool() -&gt; TwitterTool:\n</code></pre> <p>Returns: - TwitterTool: Initialized Twitter tool instance</p>"},{"location":"swarms_tools/twitter/#post_tweet","title":"post_tweet()","text":"<p>Posts a new tweet to Twitter.</p> Parameter Type Required Description tweet str Yes Text content of the tweet to post <p>Raises: - tweepy.TweepyException: If tweet posting fails</p>"},{"location":"swarms_tools/twitter/#reply_tweet","title":"reply_tweet()","text":"<p>Replies to an existing tweet.</p> Parameter Type Required Description tweet_id int Yes ID of the tweet to reply to reply str Yes Text content of the reply <p>Raises: - tweepy.TweepyException: If reply posting fails</p>"},{"location":"swarms_tools/twitter/#like_tweet","title":"like_tweet()","text":"<p>Likes a specified tweet.</p> Parameter Type Required Description tweet_id int Yes ID of the tweet to like <p>Raises: - tweepy.TweepyException: If liking the tweet fails</p>"},{"location":"swarms_tools/twitter/#quote_tweet","title":"quote_tweet()","text":"<p>Creates a quote tweet.</p> Parameter Type Required Description tweet_id int Yes ID of the tweet to quote quote str Yes Text content to add to the quoted tweet <p>Raises: - tweepy.TweepyException: If quote tweet creation fails</p>"},{"location":"swarms_tools/twitter/#get_metrics","title":"get_metrics()","text":"<p>Retrieves Twitter metrics.</p> <p>Returns: - Dict[str, int]: Dictionary containing various Twitter metrics</p> <p>Raises: - tweepy.TweepyException: If metrics retrieval fails</p>"},{"location":"swarms_tools/twitter/#usage-examples","title":"Usage Examples","text":""},{"location":"swarms_tools/twitter/#basic-tweet-posting","title":"Basic Tweet Posting","text":"<pre><code>from swarms_tools.twitter import initialize_twitter_tool, post_tweet\n\n# Post a simple tweet\npost_tweet(\"Hello, Twitter!\")\n</code></pre>"},{"location":"swarms_tools/twitter/#interacting-with-tweets","title":"Interacting with Tweets","text":"<pre><code># Reply to a tweet\nreply_tweet(12345, \"Great point!\")\n\n# Like a tweet\nlike_tweet(12345)\n\n# Quote a tweet\nquote_tweet(12345, \"Adding my thoughts on this!\")\n</code></pre>"},{"location":"swarms_tools/twitter/#retrieving-metrics","title":"Retrieving Metrics","text":"<pre><code>metrics = get_metrics()\nprint(f\"Current metrics: {metrics}\")\n</code></pre>"},{"location":"swarms_tools/twitter/#error-handling","title":"Error Handling","text":"<p>All functions include built-in error handling and will print error messages if operations fail. It's recommended to implement additional error handling in production environments:</p> <pre><code>try:\n    post_tweet(\"Hello, Twitter!\")\nexcept Exception as e:\n    logger.error(f\"Tweet posting failed: {e}\")\n    # Implement appropriate error handling\n</code></pre>"},{"location":"swarms_tools/twitter/#production-example","title":"Production Example","text":"<p>This is an example of how to use the TwitterTool in a production environment using Swarms.</p> <pre><code>import os\nfrom time import time\n\nfrom swarms import Agent\nfrom dotenv import load_dotenv\n\nfrom swarms_tools.social_media.twitter_tool import TwitterTool\n\nmedical_coder = Agent(\n    agent_name=\"Medical Coder\",\n    system_prompt=\"\"\"\n    You are a highly experienced and certified medical coder with extensive knowledge of ICD-10 coding guidelines, clinical documentation standards, and compliance regulations. Your responsibility is to ensure precise, compliant, and well-documented coding for all clinical cases.\n\n    ### Primary Responsibilities:\n    1. **Review Clinical Documentation**: Analyze all available clinical records, including specialist inputs, physician notes, lab results, imaging reports, and discharge summaries.\n    2. **Assign Accurate ICD-10 Codes**: Identify and assign appropriate codes for primary diagnoses, secondary conditions, symptoms, and complications.\n    3. **Ensure Coding Compliance**: Follow the latest ICD-10-CM/PCS coding guidelines, payer-specific requirements, and organizational policies.\n    4. **Document Code Justification**: Provide clear, evidence-based rationale for each assigned code.\n\n    ### Detailed Coding Process:\n    - **Review Specialist Inputs**: Examine all relevant documentation to capture the full scope of the patient's condition and care provided.\n    - **Identify Diagnoses**: Determine the primary and secondary diagnoses, as well as any symptoms or complications, based on the documentation.\n    - **Assign ICD-10 Codes**: Select the most accurate and specific ICD-10 codes for each identified diagnosis or condition.\n    - **Document Supporting Evidence**: Record the documentation source (e.g., lab report, imaging, or physician note) for each code to justify its assignment.\n    - **Address Queries**: Note and flag any inconsistencies, missing information, or areas requiring clarification from providers.\n\n    ### Output Requirements:\n    Your response must be clear, structured, and compliant with professional standards. Use the following format:\n\n    1. **Primary Diagnosis Codes**:\n        - **ICD-10 Code**: [e.g., E11.9]\n        - **Description**: [e.g., Type 2 diabetes mellitus without complications]\n        - **Supporting Documentation**: [e.g., Physician's note dated MM/DD/YYYY]\n\n    2. **Secondary Diagnosis Codes**:\n        - **ICD-10 Code**: [Code]\n        - **Description**: [Description]\n        - **Order of Clinical Significance**: [Rank or priority]\n\n    3. **Symptom Codes**:\n        - **ICD-10 Code**: [Code]\n        - **Description**: [Description]\n\n    4. **Complication Codes**:\n        - **ICD-10 Code**: [Code]\n        - **Description**: [Description]\n        - **Relevant Documentation**: [Source of information]\n\n    5. **Coding Notes**:\n        - Observations, clarifications, or any potential issues requiring provider input.\n\n    ### Additional Guidelines:\n    - Always prioritize specificity and compliance when assigning codes.\n    - For ambiguous cases, provide a brief note with reasoning and flag for clarification.\n    - Ensure the output format is clean, consistent, and ready for professional use.\n    \"\"\",\n    model_name=\"gpt-4o-mini\",\n    max_tokens=3000,\n    max_loops=1,\n    dynamic_temperature_enabled=True,\n)\n\n\n# Define your options with the necessary credentials\noptions = {\n    \"id\": \"mcsswarm\",\n    \"name\": \"mcsswarm\",\n    \"description\": \"An example Twitter Plugin for testing.\",\n    \"credentials\": {\n        \"apiKey\": os.getenv(\"TWITTER_API_KEY\"),\n        \"apiSecretKey\": os.getenv(\"TWITTER_API_SECRET_KEY\"),\n        \"accessToken\": os.getenv(\"TWITTER_ACCESS_TOKEN\"),\n        \"accessTokenSecret\": os.getenv(\"TWITTER_ACCESS_TOKEN_SECRET\"),\n    },\n}\n\n# Initialize the TwitterTool with your options\ntwitter_plugin = TwitterTool(options)\n\n# # Post a tweet\n# post_tweet_fn = twitter_plugin.get_function('post_tweet')\n# post_tweet_fn(\"Hello world!\")\n\n\n# Assuming `twitter_plugin` and `medical_coder` are already initialized\npost_tweet = twitter_plugin.get_function(\"post_tweet\")\n\n# Set to track posted tweets and avoid duplicates\nposted_tweets = set()\n\n\ndef post_unique_tweet():\n    \"\"\"\n    Generate and post a unique tweet. Skip duplicates.\n    \"\"\"\n    tweet_prompt = (\n        \"Share an intriguing, lesser-known fact about a medical disease, and include an innovative, fun, or surprising way to manage or cure it! \"\n        \"Make the response playful, engaging, and inspiring\u2014something that makes people smile while learning. No markdown, just plain text!\"\n    )\n\n    # Generate a new tweet text\n    tweet_text = medical_coder.run(tweet_prompt)\n\n    # Check for duplicates\n    if tweet_text in posted_tweets:\n        print(\"Duplicate tweet detected. Skipping...\")\n        return\n\n    # Post the tweet\n    try:\n        post_tweet(tweet_text)\n        print(f\"Posted tweet: {tweet_text}\")\n        # Add the tweet to the set of posted tweets\n        posted_tweets.add(tweet_text)\n    except Exception as e:\n        print(f\"Error posting tweet: {e}\")\n\n\n# Loop to post tweets every 10 seconds\ndef start_tweet_loop(interval=10):\n    \"\"\"\n    Continuously post tweets every `interval` seconds.\n\n    Args:\n        interval (int): Time in seconds between tweets.\n    \"\"\"\n    print(\"Starting tweet loop...\")\n    while True:\n        post_unique_tweet()\n        time.sleep(interval)\n\n\n# Start the loop\nstart_tweet_loop(10)\n</code></pre>"},{"location":"swarms_tools/twitter/#best-practices","title":"Best Practices","text":"<ol> <li>Always store credentials in environment variables</li> <li>Implement rate limiting in production environments</li> <li>Add proper logging for all operations</li> <li>Handle errors gracefully</li> <li>Validate tweet content before posting</li> <li>Monitor API usage limits</li> </ol>"},{"location":"swarms_tools/twitter/#rate-limits","title":"Rate Limits","text":"<p>Be aware of Twitter's API rate limits. Implement appropriate delays between requests in production environments to avoid hitting these limits.</p>"},{"location":"swarms_tools/twitter/#dependencies","title":"Dependencies","text":"<ul> <li>tweepy</li> <li>python-dotenv</li> <li>swarms-tools</li> </ul>"},{"location":"swarms_tools/twitter/#version-compatibility","title":"Version Compatibility","text":"<ul> <li>Python 3.7+</li> <li>Latest version of swarms-tools package</li> </ul>"},{"location":"web3/token/","title":"$swarms Tokenomics","text":"<p>Empowering the Agentic Revolution Token Contract Address: <code>74SBV4zDXxTRgv1pEMoECskKBkZHc2yGPnc7GYVepump</code></p> <p>You can buy $swarms on most marketplaces: Pump.fun, Kraken, Bitget, Binance, OKX, and more.</p>"},{"location":"web3/token/#overview","title":"\ud83d\udce6 Overview","text":"<ul> <li>Token Name: Swarms Coin  </li> <li>Ticker: <code>$swarms</code> </li> <li>Blockchain: Solana  </li> <li>Utility: Powering the agentic economy.</li> </ul>"},{"location":"web3/token/#initial-token-distribution","title":"\ud83d\udcca Initial Token Distribution","text":"Allocation Percentage \ud83e\udde0 Team 3% \ud83c\udf0d Public Sale 97% <p>\u26a0\ufe0f At launch, only 2% was reserved for the team \u2014 among the smallest allocations in DAO history.</p>"},{"location":"web3/token/#a-message-from-the-team","title":"\ud83d\udce3 A Message from the Team","text":"<p>Quote</p> <p>When we launched $swarms, we prioritized community ownership by allocating just 2% to the team. Our intent was radical decentralization. But that decision has created unintended consequences.</p>"},{"location":"web3/token/#challenges-we-faced","title":"\u2757 Challenges We Faced","text":"<ul> <li>Market manipulation by whales and exchanges  </li> <li>Unsustainable funding for innovation and ops  </li> <li>Malicious actors undermining decentralization</li> </ul>"},{"location":"web3/token/#our-proposed-solution","title":"\ud83d\udee0 Our Proposed Solution","text":"<p>We are initiating a DAO governance proposal to:</p> Key Reforms <ul> <li> <p>\ud83d\udcc8 Increase team allocation to 10%   Secure operational longevity and attract top contributors.</p> </li> <li> <p>\ud83c\udf31 Launch an ecosystem grants program   Incentivize developers building agentic tools and infra.</p> </li> <li> <p>\ud83d\udee1 Combat token manipulation   Deploy anti-whale policies and explore token lockups.</p> </li> <li> <p>\ud83e\udd1d Strengthen community dev initiatives   Support contributor bounties, governance tooling, and hackathons.</p> </li> </ul> <p>This proposal isn\u2019t about centralizing power \u2014 it's about protecting and empowering the Swarms ecosystem.</p>"},{"location":"web3/token/#contribute-to-swarms-dao","title":"\ud83d\udcb8 Contribute to Swarms DAO","text":"<p>To expand our ecosystem, grow the core team, and bring agentic AI to the world, we invite all community members to invest directly in Swarms DAO.</p> <p>Send $swarms or SOL to our official treasury address:</p> <pre><code>\ud83e\ude99 DAO Treasury Wallet:\n7MaX4muAn8ZQREJxnupm8sgokwFHujgrGfH9Qn81BuEV\n</code></pre> <p>Every contribution matters</p> <p>Whether it\u2019s 1 $swarms or 1000 SOL \u2014 you\u2019re helping fund a decentralized future.</p> <p>You may use most wallets and platforms supporting Solana to send tokens.</p>"},{"location":"web3/token/#why-invest","title":"\ud83e\udde0 Why Invest?","text":"<p>Your contributions fund:</p> <ul> <li>Expansion of the Swarms core team </li> <li>Development of open-source AI agent tooling </li> <li>Community grants and contributor bounties </li> <li>Anti-manipulation strategies &amp; decentralized governance tools</li> </ul>"},{"location":"web3/token/#how-to-get-involved","title":"\ud83d\ude80 How to Get Involved","text":""},{"location":"web3/token/#you-can","title":"\ud83d\udee0 You can:","text":"<ul> <li> <p>Vote on governance proposals  </p> </li> <li> <p>Submit development or funding proposals  </p> </li> <li> <p>Share $swarms with your network  </p> </li> <li> <p>Build with our upcoming agent SDKs  </p> </li> <li> <p>Contribute to the mission of agentic decentralization  </p> </li> </ul>"},{"location":"web3/token/#quick-summary","title":"\ud83d\udcd8 Quick Summary","text":"Key Metric Value Token Symbol <code>$swarms</code> Blockchain Solana Initial Team Allocation 3% (Proposed 10%) Public Distribution 97% DAO Wallet <code>7MaX4muAn8ZQREJxnupm8sgokwFHujgrGfH9Qn81BuEV</code> DAO Governance dao.swarms.world"},{"location":"web3/token/#useful-links","title":"\ud83c\udf0d Useful Links","text":"<ul> <li> <p>DAO Governance Portal </p> </li> <li> <p>Investor Information </p> </li> <li> <p>Official Site </p> </li> <li> <p>Join Swarms on Discord </p> </li> </ul> <p>```</p>"}]}